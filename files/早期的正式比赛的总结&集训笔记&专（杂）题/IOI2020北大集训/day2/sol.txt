## A - 循环数列

### 题意

有一个无限长的下标从$1$开始的序列，初始的时候所有在模$n$意义下等于$m$的位置的数为$1$，其余位置的数为$0$。

每一次操作会使得操作后的序列$F'_i=F_i+F_{i+1}$。

现在给出$n,m,k,pos,P$。你需要求出$k$次操作之后，$F_{pos}\pmod P$的值。

数据组数$T\le 500$，$k\le 10^9, P\le 10^7, \sum n\le 10^6, 1\le m< n, 1\le pos< n$，数据保证$P$为质数且$n\mid p-1$。

### Sol

假设某个初始序列中的$1$的下标为$x$，那么它将对$F_{pos}$产生的贡献等价于：每一次可以让$x$不变或减一，操作$k$次后恰好$x=pos$的方案数。也就是${k \choose x-pos}$。

故而答案为
$$
\sum_{i=0}^{\infty} {k\choose i\cdot n+m-pos }
$$


令$t=m-pos$，进行单位根反演：
$$
Ans=\sum_{i=0}^{\infty} {k\choose i\cdot n+t}\\
=\sum_{i=0}^{\infty}{k\choose i} [n\mid (i-t)]\\
=\sum_{i=0}^{\infty}{k\choose i} {1\over n} \sum_{j=0}^{n-1} \omega_n^{j(i-t)}\\
={1\over n}\sum_{j=0}^{n-1} \omega_n^{-jt} \sum_{i=0}^{\infty}{k\choose i}\omega_n^{ij}\\
={1\over n}\sum_{j=0}^{n-1} \omega_n^{-jt} (1+\omega_n^j)^k
$$

暴力枚举$j$计算，复杂度$O(n\log k)$。

---

## B - Matrix

### 题意

给出一个$n\times n$的整数矩阵$A$。

问能否求出一组置换矩阵$\{B_1,B_2\cdots B_m\}$，使得**唯一**存在一组非负整系数$\alpha_1,\alpha_2\cdots \alpha_m$，满足$A=\alpha_1\cdot B_1 + \alpha_2\cdot B_2+\cdots +\alpha_m\cdot B_m$。

求出一组$m\le n^2$的解或判定无解。

$n\le 50,T\le 10,A_{i,j}\le 2\times 10^7$

### Sol

参考Birkhoff–von Neumann theorem。

一个$A$能够被表示出来的充分必要条件是$A$中的每一行元素的和、每一列元素的和都相同。

充分性证明：设$C$为某一行的所有元素的和。构造一个二分图，左侧有$n$个点表示每一行，右侧有$n$个点表示每一列。$(i,j)$这条边存在当且仅当$A_{i,j}>0$。用Hall定理证明这张图存在完备匹配：任选一个左边的点构成的集合$X$，考虑与他们相邻的列集合$Y$，由于$|X|\cdot C = \sum_{x\in X,y\in Y} A_{x,y} \le |Y|\cdot C$，所以有$|X|\le |Y|$，证毕。所以这张二分图一定存在完备匹配，将完备匹配对应的置换矩阵从$A$中减掉（$\alpha$取匹配中的最小边权），就转化成了规模更小的问题。

上述的证明过程也描述了算法的过程。显然这样最多会用$n\times n$个置换矩阵。由于每一次都会让一个位置变成$0$，所以这一步拿出来的置换矩阵与之后拿出来的置换矩阵必然线性无关。

---

## C - 杀蚂蚁简单版

### 题意

有一棵包含$n$个节点的树，每个点有一个权值$v_i$。有一只蚂蚁，如果它当前在的节点为$x$，与它相邻的点集为$\{y_1,y_2\cdots y_m\}$，则它下一秒将以${v_{y_i}\over \sum v_{y_j}}$的概率走到$y_i$这个点。蚂蚁一旦走到$1$节点就会消失。

有$q$次询问，每次询问给出$s,x,y$，你需要回答：如果蚂蚁的初始位置是在$s$，它期望有多少秒停留在$x$到$y$的最短路径上。

$n,q\le 10^5$，答案对$998244353$取模。

### Sol

设$P_{x,y}$表示从$x$走到$y$的概率。

下面考虑部分分$v=u+1,s=2$的情况怎么做。设$f_i$表示$i$期望被经过多少次，那么显然有$f_2=P_{2,3}\cdot f_2+1={1\over 1-P_{2,3}}$，$f_3 = P_{2,3}f_2 + P_{4,3}\cdot f_4 $，由于出发点是$2$，终点是$1$，所以必然有$f_4P_{4,3} = f_3P_{3,4}$，所以$f_3={1\over 1-P_{3,4}}P_{2,3}f_2$。后面的可以类似的方法推导。概括一下就是，设$g_i = {1\over 1-P_{i,i+1}},h_i=P_{i-1,i}$，则$f_2 = g_2, f_i = h_ig_if_{i-1}(i>2)$。

考虑$v=u+1,s\not = 2$的情况：此时的答案等价于蚂蚁第一次走到$s-1$之前经过每个点的次数的期望 加上 以$s-1$作为出发点的时候的答案。如果限制了不能够经过$s-1$这个点，等价于让$s-1$做根，故而此时$f_s = g_s, f_i = h_ig_if_{i-1}(i>s)$。所以这种情况的答案为$\sum_{i\in [x,y]} \sum_{j=2}^s g_j\prod_{k=j+1}^i h_ig_i$。考虑如何快速计算答案：令$F_i$表示当以$2$作为起点的时候期望经过$i$的次数，那么$F_i$对答案的贡献相当于$F_i(1 + {1\over g_2h_3}+{1\over g_2g_3h_3h_4}+\cdots {1\over g_2g-_3\cdots g_{s-1}h_3h_4\cdots h_s})$。按照从小到大依次枚举$s$，当从$s-1$变成$s$的时候，相当于对于所有大于了$s$的$x$，它的贡献都增加了$F_x\cdot {1\over g_2g-_3\cdots g_{s-1}h_3h_4\cdots h_s}$，可以用线段树维护区间内的贡献和。

上面的结论推广到树仍然成立。对整棵树进行dfs遍历，进入一个点$s$的时候，就使它的子树内的点$x$都加上贡献$F_x \cdot {1\over h_sg_{fa_s}h_{fa_s}g_{fa_{fa_s}}\cdots }$，用树链剖分维护链的贡献和即可。时间复杂度$O(n\log ^2 n)$。