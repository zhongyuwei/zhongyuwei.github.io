 ## A - 投影对称

### 题意

给定$n$个点，求有多少过$(0,0)$的直线，满足这$n$个点在直线上的投影为中心对称图形。

$n\le 2000$，$|x_i|,|y_i|\le 10^6$，可能会有重合的点。

### Sol

假设对称中心为$P$，考虑过$P$且与$OP$垂直的直线$l$，对于一对其投影关于$P$对称的点$A,B$，它们到$l$的距离相等。故线段$AB$的中点也一定经过了$l$。枚举$1,2$这两个点匹配的另一个点是什么就可以确定$l$，然后再$O(n\log n)$检查，这样总复杂度是$O(n^3\log n)$的。

考虑由于$l$过所有点对的中点，所以$l$一定过这$n$个点的重心。因此只需要枚举$1$号点匹配的点，再考虑上重心，就可以确定$l$了。时间复杂度$O(n^2\log n)$。

有一种写法是，先对这$n$个点求一次凸包，由于凸包上的点只能和凸包上的点配对，（再加上出题人没有考虑到凸包，因此数据中凸包上的点数很少），可以将总复杂度优化到$O(Cn\log n)$，其中$C$为凸包上的点数。

---

## B - 数圈

### 题意

有$n$个整数排成一个圈，初始它们为$A_1,A_2\cdots A_n$。

定义一次操作为，选择一个数$a$，将与它相邻的数加上$a$，将它变成$-a$。

问至少进行多少次操作，可以使得所有的数非负。如果办不到输出$-1$。

$n\le 10^5, -1000\le A_i \le 1000$

### Sol

考虑如果是序列怎么做：观察发现，一次操作等价于交换了前缀和数组中的两个元素，所以答案就是前缀和数组的逆序对数。

而对于圈，我们定义它的广义前缀和是一个双向无限的序列$S_i(i\in \mathbb {Z})$，如1,2,-3,4的一个可能的广义前缀和是……-8,-4,-3,-1,-4,0,1,3,0,4,5,7,4,8,9,……定义它的一次交换操作为：选定一个$i$，对于所有在模$n$意义下与$i$同余的位置$x$，交换$S_x$与$S_{x-1}$。

设$sum=\sum_{i=1}^nA_i$，如果$sum< 0$显然无解，如果$sum=0$则当且仅当序列中所有元素都是$0$的时候有解，否则无解。下面只讨论$sum>0$的情况。

定义$R_i = \sum_{j>i} [ S_j< S_i]$，定义逆序对数为$R_1+R_2+\cdots R_n$。由于$sum>0$，所以$R_i$是有限的。由于$S_{x+n}=S_x+sum$，所以$R_i = R_{i+n}$。一次操作会交换所有的$S_{i+kn}$与$S_{i-1+kn}(k\in \mathbb Z)$，对于某一个$k'$，$R_{i+k'n}$只会受到交换$S_{i+k'n},S_{i-1+k'n}$的影响，所以一次操作我们恰好可以让某一个$R_i(i\in [1,n])$减掉一。所以答案就是这个逆序对数。

枚举$j-i$在模$n$意义下的取值。由于$S_{i+n}=S_i + sum$，所以$R_i = \sum_{j=1,S_{i+j}< S_i}^{n-1} \lceil{S_i-S_{i+j}	\over sum}\rceil$。利用这个式子可以在$O(n^2)$的时间内解决问题。

考虑将$S_i$分解为$S_i = u_i \cdot sum +v_i(0 \le v_i < sum)$，则前面的式子转化为$\sum_{j=1,S_{i+j}< S_i}^{n-1} u_i - u_{i+j} + [v_i > v_{i+j}]$。从小到大枚举$i$并动态维护二维点集$(S_{i+j},v_{i+j})$以及点权$u_{i+j}$，可以做到$O(n\log ^ 2 n)$的复杂度。进一步观察，这个动态维护的过程中，我们每一次删除的是$((S_x,v_x),u_x)$，而加入的是$((S_{x+n},v_{x+n}) ,u_{x+n}) = (( S_x +sum, v_x), u_x +1)$。如果我们不去做这个修改，造成的影响是：对于所有的$i>x,S_i > S_x$，$R_i$会多算上$1$的贡献，这是一个二维偏序问题。不做修改的原问题也是个二维偏序问题。这样就做到了$O(n\log n)$的复杂度。

---

## C - search

### 题意

交互题。有一个$n\times n$的单调矩阵（同一行的元素右边的比左边的大，同一列的元素下面的比上面的大），此外还有一个数$x$。保证矩阵内的元素以及$x$两两互不相同。有两种询问：

- 询问矩形内的某两个格子，返回它们的大小关系。
- 询问矩形内的某一个格子，返回这个格子与$x$的大小关系。

你需要回答，矩形内比$x$小的位置的个数。

$n\le 2000$，时限2s，限制询问1的次数不超过$64n$，询问2的次数不超过$34$。

### Sol

#### 一个随机算法

随机一个格子$(i,j)$，然后抠出如下图的这个轮廓线：

![网格.PNG](https://i.loli.net/2019/12/25/wJTPcaYkMhtdEgb.png)

有颜色的格子是用过询问1的，橘色表示问出来比$x$小，蓝色表示问出来比$x$大。

这样抠一次，$i$行之前的，橘色格子每列至多有一个，蓝色格子每行至多有一个；$i$行之后的，橘色格子每行至多有一个，蓝色格子每列至多有一个。所以这一步会用掉至多$2n$次询问1。

比较$(i,j)$与$x$的大小关系。若$(i,j) < x$，则轮廓线上方的全部都$< x$，可以记入贡献之后删掉；否则，$(i,j) > x$，则轮廓线下方的也全部$> x$，可以删掉。

期望只需要进行$O(\log n)$次上述操作，就可以结束程序。