# 20180219考试总结（十连附加八）

标签（空格分隔）： 总结

---

### T1 move

有$n$条形如$y=a_ix+b_i$的直线。将直线$y=a_ix+b_i$修改为$y=a_i'x+b_i'$的代价为$|a_i-a_i'|+|b_i-b_i'|$。问最少花费多少代价使得所有的直线都交在一个点。$n\le 10^5$

Solution：首先，设交点坐标为$(x_0,y_0)$，则$(a_i+\Delta a_i)x_0 + (b_i+\Delta b_i) = a_i x_0 + b_i + (\Delta a_0x_0 + \Delta b_0 ) = y_0$。一个显然的结论是，我们一定只会改变$a_i,b_i$中的一个，并且改哪一个取决于$|x_0|$与$1$的大小关系。当$|x_0|\le 1$的时候我们的花费是$\sum |a_ix_0 + b_i - y_0 | $，否则就是这个值除以$|x_0|$。

并且绝对值符号打开过后是个一次函数，所以函数的极值一定只会在端点上取到。那么$x_0$一定是某两条线段的交点的横坐标，可以$O(n^3)$暴力求解。

正解是三分$x_0$。当$x\in [-1,1]$时，直接三分$x$；当$x<-1 $或者$x>1$时，三分${1\over x}$（一定在$[-1,1]$），这个时候我们可以把式子写成${y\over x} = a_i + b_i{1\over x}$。不会证明单峰性质。

---

### T2 robot

题意：有一个$n\times m$的方格，每一列有且仅有一个蛋糕。对于每一列，在第$i$行有蛋糕的概率是$p_i$。保证$p_1+p_2+p_3+\cdots p_n=1$。每一列是独立的，且每一列的$(p_1,p_2,\cdots p_n)$是相同的。输入将给出$n$和$p_i$。

有一个机器人将在这个方格里行走。如果机器人现在的位置是$(x,y)$，那么下一步它将可以走到$(x,y+1)$或者$(x-1,y+1)$或者$(x+1,y+1)$，但是必须保证这个机器人时时刻刻都是在网格中的。你在得知整个方格中蛋糕的位置过后，可以确定机器人的起始位置和路线，此时你的得分是机器人路径上的蛋糕数量。

设$f(m)$为当网格的列数为$m$时，你得知蛋糕分布后，采取最优策略的得分期望。请计算：
$$
\lim _{m\to \infty} {f(m)\over m}
$$

答案对$10^9+7$取模。$1\le n\le 6$

Solution：~~我真的真的真的不会DP啊~~

我们考虑$dp$套$dp$。内层的那个$dp$就是我们在知道蛋糕分布过后，确定机器人的路线的那部分，即$f[i][j]=max(f[i-1][j],f[i-1][j-1],f[i-1][j+1])+score[i][j]$。按照套路，我们的外层$dp$就应该是：$dp[i][j]$表示，到第$i$列，这一列上，$f$数组的状态为$j$的概率——但是这样第二维是无限大的，没有办法做。

于是就有了一个非常骚的操作：我们让第二维里面，$f$数组的值，全部减去这个数组里面最小的那个值。这样的状态就是有限的了。爆搜发现，第二维的状态数只有$478$种，而可能的转移有$2868$种。

考虑这样的一种建图：每个第二维状态作为一个点，每种转移作为边。对于状态$u$而言（注意这个状态中$f$数组里面，我们已经把最小值减掉了），我们要枚举下一列的的蛋糕分布情况，然后计算$f$数组转移的结果$f'$，取$f'$中的最小值$x$，把$f'$中的每一个值都减去$x$，设减去$x$后的$f'$对应的状态为$v$，我们在$u$和转移到的状态$v$之间连一条边，边权是一个二元组，表示这条边（这种转移）出现的概率（也就是我们现在枚举的这种蛋糕分布情况出现的概率，设为$p_{u,v}$）以及这次转移中$f'$的最小值$x$（设为$w_{u,v}$）。这样问题就转化成了在一个有向图上随机游走问题。而我们在这条路上走过的一条长度为$m$的路径，唯一地映射到了一种有$m$列的蛋糕布局上，这种布局中，我们最优策略下的收益是路径上的边的$w_{u,v}$的和加上结束状态的$f$数组里的最大值，而这种布局出现的概率是路径上所有边的$p_{u,v}$的乘积。

由于我们行走的距离是无限长，所以可以认为最终每条边被经过的次数是无限多，收益中经过的边的$w_{u,v}$的贡献是无限大，结束状态中的$f$数组的贡献可以忽略不计。我们考虑计算每条边对$f(m)\over m$的贡献（这个东西本质就是当总步数趋近于无限大时，经过的边的$w_{u,v}$的平均值），也就是计算出每条边在这无限多步行走中，被经过的次数在行走总步数中占的比例$r_{u,v}$，答案就是$\sum r_{u,v} \cdot w_{u,v}$。~~按照套路~~我们把问题转化成，无限多步行走中，每个点的被经过次数占总经过点数的比例$r_u$。那么我们可以列出方程：$r_v = \sum p_{u,v} r_u$，以及$r_1+r_2+r_3\cdots =1$。高斯消元解出这个方程即可。然后我们可以得到，$r_{u,v} = r_u \cdot p_{u,v}$，这样就可以算出答案了。

``` cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <map>
#define ll long long
using namespace std;
template <class T>
inline void read(T &x)
{
    x=0; char c=getchar();  int f=1;
    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}
    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;
}
const int mod=1e9+7;
int Pow(int x,int y){int res=1; while(y){if(y&1) res=(ll)res*x%mod; x=x*(ll)x%mod,y>>=1;} return res;}
int n,m,p[7];
const int base=6;
int get_hash(int d[])
{
	ll ans=0; for(int i=0;i<n;++i) ans=ans*base+d[i];
	return ans;
}
map<int,int> mp;
struct ed{int u,v,w,p;}e[3010];
int ecnt;
int dfs(int d[],int h)
{
	if(mp.count(h)) return mp[h];
	int g[6],u=++m; mp[h]=m;
	for(int i=0;i<n;++i)
	{
		int mi=233;
		for(int j=0;j<n;++j)
		{
			g[j]=d[j]; if(j) g[j]=max(g[j],d[j-1]); if(j<n-1) g[j]=max(g[j],d[j+1]);
			if(i==j) g[j]++;
			mi=min(g[j],mi);
		}
		for(int j=0;j<n;++j) g[j]-=mi;
		int hv=get_hash(g),v=dfs(g,hv);
		e[++ecnt]=(ed){u,v,mi,p[i]};
	}
	return u;
}
// 478 2868
int a[510][510];
void Gauss(int n,int m)
{
	for(int i=1;i<=n;++i)
	{
		for(int j=i;j<=n;++j) if(a[j][i]){if(i!=j) swap(a[i],a[j]); break;}
		for(int j=1;j<=n;++j) if(j!=i)
		{
			int t=a[j][i]*(ll)Pow(a[i][i],mod-2)%mod;
			for(int k=1;k<=m+1;++k)
			a[j][k]=(a[j][k]-a[i][k]*(ll)t%mod+mod)%mod;
		}
	}
	for(int i=1;i<=n;++i) a[i][m+1]=a[i][m+1]*(ll)Pow(a[i][i],mod-2)%mod;
}
int main()
{
	read(n); int inv10=Pow(10,mod-2);
	double x;
	for(int i=0;i<n;++i) scanf("%lf",&x),p[i]=((int)(x*10))*(ll)inv10%mod;
	int d[6]; memset(d,0,sizeof(d));
	dfs(d,0);
//	cout<<m<<' '<<ecnt<<endl;
	for(int i=1;i<=m;++i) a[i][i]=mod-1;
	for(int i=1;i<=ecnt;++i) (a[e[i].v][e[i].u]+=e[i].p)%=mod;
	for(int i=1;i<=m+1;++i) a[m+1][i]=1;
	Gauss(m+1,m);
	int ans=0;
	for(int i=1;i<=ecnt;++i) ans=(ans+e[i].w*(ll)a[e[i].u][m+1]%mod*e[i].p%mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```

---

### T3 scc

一张有向图的scc数组定义如下：$C_i$表示加入前$i$条边后图中scc的数量。注意由于加边的顺序不同，所以可能同一张图会有不同的scc数组。问一张包含$n$个点$m$条边的图可能的不同的scc数组的数量。$n\le 50,m\le n(n-1)$

Solution：首先，从数据范围中的$m\le n(n-1)$，我们可以得到，这张图中是不能存在自环和重边的。但是我考场上真的以为可以连自环，结果就自闭了……

可以考虑一个问题：如何判断一个强连通数组是否合法。我们可以考虑一种构造：当强连通数组的值没有改变的时候，优先加边让所有点连成一条链；强连通数组的值改变时，我们合并**最前面**的几个强连通分量，使得大小大于$1$的强连通分量的数量始终不超过$1$。当所有的点都连成一条链的时候，我们就连与我们连链的边的方向相同的边（比如说，原来是1->2->3，现在我们还可以连1->3），保证不成环。最前面的那个强连通分量的内部也可以连边，强连通分量的数量不会增加。当无法再连不会增加强连通分量的边，而scc数组的值仍然没有改变的时候，该数组就是不合法的。

我们直接把这个东西改成$dp$的状态。设$dp[i][j][k]$表示连了$i$条边过后，前$j$个点形成了强连通分量，前$k$个点连成了一条链的不同的scc数组的数量。我们枚举scc数组中下一个数是多少进行转移就可以了。

