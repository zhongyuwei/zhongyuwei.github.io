# 20181209考试总结（十连二）

标签（空格分隔）： 总结

---

### T1 图

给出一个$n$个顶点、$m$条边的无向图，边有边权$z(x,y)$，点也有权值$p$，并且对于每条边$(x,y)$都满足$p_x+p_y\ge z(x,y)$。现在要将顶点$i$的权值$c_i$，其中$0\leq c_i\leq p_i$。设修改后的权值为$p_i'=p_i-c_i$，对于每条边$(x,y)$都满足$p_x'+p_y'=z(x,y)$，求$\sum c_i$的最大值和最小值。

考虑一种暴力：对于每一个连通块来说，如果有一个点的权值确定，那么其他所有点的权值就确定了。那么可以直接从这个连通块的某个点出发bfs，将每个点的权值表示为关于出发点的一次函数，注意判断可以联立成方程求出唯一解或者有矛盾方程的情况，还要判断方程的解是否满足$0\leq c_i\leq p_i$。根据每个点的$c_i$的取值范围推出出发点的$c$取值的上限和下限，就可以求出极值。

考场上我忘记了在方程解出来的时候判断这个解是否满足所有的点的$0\leq c_i\leq p_i$，结果只过了形态为树的点，丢了80分。总结起来，丢分的原因有二：

1.，我的程序写得太啰嗦，不简洁明白，容易出错。当方程有唯一解的时候，直接将出发点的上限下限记为解即可；如果无解，可以将下限设置的比上限更大。
2.考试的时候，出于懒没有对拍，然后就凉了……

---

### T2 车站

有$n+2$个车站，编号为$0$到$n+1$。每个车站有上行站台、下行站台、位于这两个站台之间的邮戳台。

你可以：
1.从车站$i$的上行站台乘坐电车到达车站$i+1$的上行站台。
2.从车站$i$的下行站台乘坐电车到达车站$i-1$的下行站台。注意，等车时间不计，电车上行和下行一站的时间都是$T$。你在$0$号车站不能乘坐下行列车，在$n+1$号车站不能乘坐上行列车。
3.从某个车站$i$的上行站台花费$U_i$的时间到达这个车站的邮戳台；
从某个车站$i$的邮戳台花费$V_i$的时间到上行站台；
从某个车站$i$的下行站台花费$D_i$的时间到达邮戳台；
从某个车站$i$的邮戳台花费$E_i$的时间到达下行站台。

你从$0$号车站出发，在$n+1$号车站结束，期间你只能访问$0$号车站和$n+1$号车站各一次，但是你可以访问$1\cdots n$号车站任意多次。你必须访问$1\cdots n$号车站的邮戳台各至少一次。

求出完成任务最少需要花费的时间。$n\le 3000$

DP的状态非常奇妙。整个过程一定是一条从$0$号车站的上行站台到$n+1$号车站的一条直线 + 若干个穿过了邮戳台的环。环可以看成括号，无论这些左右括号如何配对，它们的本质是一样的。因此可以用括号序列的套路定义$dp[i][j]$表示到第$i$个车站前面还有$j$个左括号（前面的所有邮戳台当然已经都被访问了至少依次），然后转移的时候还需要考虑每一个站台可能是多个环的端点，需要完全背包一下。

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define ll long long
using namespace std;
const int N=3010;
ll dp[N][N],U[N][2],D[N][2];
int n,T; 
int main()
{
	memset(dp,0x3f,sizeof(dp));
	scanf("%d%d",&n,&T);
	for(int i=1;i<=n;i++) scanf("%lld%lld%lld%lld",&U[i][0],&U[i][1],&D[i][0],&D[i][1]);
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=n;j++)
		{
			if(!j) dp[i][j]=min(dp[i-1][j]+U[i][0]+U[i][1],dp[i-1][j+1]+2*(j+1)*T+U[i][0]+D[i][1]);
			else
			{
				dp[i][j]=min(dp[i-1][j-1]+2*(j-1)*T+U[i][1]+D[i][0],dp[i-1][j+1]+2*(j+1)*T+U[i][0]+D[i][1]);
				dp[i][j]=min(dp[i][j],dp[i-1][j]+2*T*j+min(U[i][0]+U[i][1],D[i][0]+D[i][1]));
			}
		}
		for(int j=1;j<=n;j++) dp[i][j]=min(dp[i][j],dp[i][j-1]+U[i][1]+D[i][0]);
		for(int j=n-1;j>=0;--j) dp[i][j]=min(dp[i][j],dp[i][j+1]+2*T+U[i][0]+D[i][1]);
	}
//	for(int i=1;i<=n;i++)
//	{
//		for(int j=0;j<=n;j++) printf("%lld ",dp[i][j]);
//		puts("");
//	}
	printf("%lld\n",dp[n][0]+T*(n+1));
	return 0;
}			
```