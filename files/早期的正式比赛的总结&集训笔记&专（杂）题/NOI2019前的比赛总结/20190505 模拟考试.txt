# 20190505 模拟考试

标签（空格分隔）： 总结

---

### T1 rank

给一棵树。树上的每一条边都有$1\over 2$的概率消失，边消失的概率互相独立。问最终得到的图的邻接矩阵的秩的期望乘以$2^{n-1}$的值。答案对$998244353$取模。$n\le 5\times 10^5$

Solution：

结论：一个森林的邻接矩阵的秩是这张图的最大匹配数+1。

然后可以直接树形$dp$解决。

---

### T2 route

有一棵包含$n$个节点的完全二叉树，其中$i(i>1)$节点的父亲是$\lfloor {i\over 2}\rfloor $。树上面加了$m$额外的边。问图中经过的边的序列不同的简单路径的数量。其中，简单路径定义为不经过重复的点的路径。单独的一个点也计算在内。答案对$10^9+7$取模。$n\le 10^9,m\le 6$

Solution：

lsj说这是一道[原题][1]。

这道题的思想和 爆搜题 比较类似。经过这$m$的序列的数量很少，如果枚举完这个序列再枚举路径的起点和终点，整个路径就可以确定了。

考虑优化枚举起点和终点的过程。我们令所有的额外边的端点和这些端点到根的路径上的点都为关键点，关键点的数量只有$O(m\log n)$个，非常小。然后我们枚举路径上的第一个和最后一个关键点，这样就可以快速算出合法的起点和终点的数量。

然后**直接搜索**，这样的效率和先在外面枚举经过$m$条边的序列是相同的并且不至把人劝退。

---

### T3 railway

给一棵树，树上点有点权$w_u$，边有边权。定义$dis(u,v)$为$u\to v$的路径上所有边的边权的和。定义$f(u,v)=dis^{3\over 2}(u,v)$，定义$g(u)=\sum_{v\in [1,n]} w_vf(u,v)$。你需要求出$g(u)$最小值，以及达到这个最小值的点。$n\le 2\times 10^5,1\le w_u\le 10^8$

Solution：

这道题的$g$是一个凸函数，换句话说就是这道题是可以通过爬山的方法解决的。

首先对于任意一个确定的$p$，以及一条路径上的点$u_1,u_2\cdots u_k$，$h(x) = f(u_x,p)$是一个凸函数。然后又因为$w>0$，所以$h$的按照$w$加权的组合，也就是$g$也是一个凸函数。放到树上来看，对于树上某一个点，至多存在一个子树，我们把答案从这个点调整到那个子树内后会更优秀。用 邮递员 的方法点分治做就可以了。

问题在于如何在$O(n)$而不是$O(n\cdot degree)$的时间求从$u$往哪个子树走会更优。假设当前的点为$u$，我们对$u$的某一个子树$sub_x$内的所有点$v$，求出$h(sub_x) = \sum f(u,v)w_v$这个函数的导数$h'(sub_x)$。我们把决策点从$u$移往$sub_x$这棵子树的时候，答案的变化量就是$\sum _{y!=x} h'(sub_y) - h'(sub_x)$。至多只有一个$x$满足这个变化量是负的，把答案往这棵子树内走就可以了。

---

### T4 random

有一个离散随机变量$x$，初始的时候这个变量取值为$i(0\le i \le n)$的概率是$p_i$。一次操作过后，$x$值会被随机赋为$[0,x]$中的任意一个整数。问$m$次操作过后，对于$[0,n]$中的每一个$i$，$x$取值为$i$的概率。$n\le 2.5\times 10^5,m\le 10^{18}$

Solution：

设变换前的生成函数是$f(x)$，变换后是$f^*(x)$：
$$
f^*(x) = \sum_{i=0}^n x^i \sum_{j=i}^n{ [x^j] f(x) \over j+1}\\
=\sum_{j=0}^n {[x^j]f(x) \over j+1} \sum_{i=0}^j x^i\\
=\sum_{j=0}^n {[x^j]f(x) \over j+1} {x^{j+1}-1\over x-1}\\
\because \int _1^x t^j dt = {x^{j+1}-1\over j+1}\\
\therefore f^*(x) = \sum_{j=0}^n {[x^j]f(x) \over x-1} \int_1^x t^j dt \\
=\sum_{j=0}^n {1\over x-1}\int _1 ^x [x^j ]f(x) t^jdt
$$
这一步是因为$[x^j]f(x)$是一个常量，而积分是线性的，所以可以把常量拿进去。

$$
f^*(x) = {1\over x-1} \int_1^x \sum_{j=0}^n [x^j]f(x)t^jdt\\
={1\over x-1} \int_1^x f(t)dt
$$

但是这样不是很好看。我们令$g(x) = f(x+1)$，则
$$
g^*(x) = f^*(x+1) \\
={1\over x} \int_1^{x+1} f(t)dt\\
={1\over x} \int_0^x g(t)dt
$$

然后观察系数我们发现
$$
[x^i] g^*(x) = {1\over i+1}[x^i]g(x)
$$
因此$m$变换后的多项式就是$[x^i] g^*(x) = {1\over (i+1)^m}[x^i]g(x)$。

剩下的问题就是如何从$f$变到$g$以及如何从$g$变到$f$。这一步是一个比较套路的二项式展开，然后NTT优化。


  [1]: http://codeforces.com/contest/869/problem/D