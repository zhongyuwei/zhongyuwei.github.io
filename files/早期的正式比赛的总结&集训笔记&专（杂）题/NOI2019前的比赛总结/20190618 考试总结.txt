# 20190618 考试总结

标签（空格分隔）： 总结

---

### T1 正方形

有一个$n\times m$的棋盘，有一些位置有障碍。有$q$次询问，每一次询问给出$(x_1,y_1,x_2,y_2,w)$，询问对于一个右下角为$(x_1,y_1)$边长为$w$（左上角是$(x_1-w+1,y_1-w+1)$）的正方形能否通过平移使得它的右下角位于$(x_2,y_2)$，平移的过程中任意时刻正方形内都不能有障碍。如果开始平移之前正方形内有障碍也不行。$n,m\le 10^3,q\le 10^5$

Solution：

处理出每个点以它为右下角的、边长最大的且不包含障碍的正方形的边长，记为$dis_{x,y}$。

将询问离线下来排好序，然后从大到小枚举$w$。当两个相邻的格子$dis$都大于等于当前枚举的$w$的时候，就把它们在并查集中合并。询问相当于问两个点在并查集中是否属于同一个集合。

问题在于如何求出$dis$。考场上我脑抽了以为$dis$ = min（这个点左上角的障碍和它横坐标之差的最小值，这个点左上角的障碍和它纵坐标之差的最小值，这个点的横/下标的最小值），由于写不来暴力所以没有对拍，所以差不多爆零了。

一种做法是直接二分 + 二维前缀和检查。另一种是直接递推：如果$(x,y)$有障碍那么$dis_{x,y} = 0$，否则$dis_{x,y} = min\{ dis_{x,y-1},dis_{x-1,y},dis_{x-1,y-1} \} + 1$。

总结：不知道可以怎么总结了……考试的时候不要打瞌睡发昏？画一两个比较形象的图是不是就可以避免这种错误？

---

### T2 计数

有一个长度为$n$的$01$串$s$。定义函数$f(s)$：
$$
f(s) = \sum_{i=0}^{\lfloor {|S|\over 2}\rfloor -1} [ s_i = s_{n-1-i} ]
$$

给出一个$01$串$s$，求$s$的所有的非空子序列的$f$的和对$998244353$取模的值。

Solution：

答案等于：
$$
\sum_{i<j,s_i = s_j} \sum_{k=0}^{\min(i-1,n-j)} {i-1\choose k}{n-j\choose k } \cdot 2^{j-i-1} 
$$

中间的那个$g(a,b) = \sum_{k=0}^{\min(a,b)} \begin{pmatrix} a\\ k \end{pmatrix}\begin{pmatrix} b\\ k \end{pmatrix}$太难算了。

通过一番玄学乱推（这个东西可以看做在一个网格中走，每一步走到的坐标两维都必须严格大于上一步走到的点的坐标。把用前缀和优化后的式子写出来可以发现$g(a,b) = g(a-1,b) + g(a,b-1)$）可以得到它等于${a+b\choose a}$。

SC的一个感觉要好得多的方法（首先假设$a<b$）：

$$
\sum_{k=0}^{a} {a\choose k} {b\choose k} \\
=\sum_{k=0}^a {a\choose a-k} {b\choose k } \\
$$

观察到$(a-k) + k = a$，而$k$则是枚举了在$b$中选择了多少个。所以它等价于${a+b\choose a}$。

所以
$$
Ans = \sum_{i<j,s_i = s_j } {(i-1)+(n-j)\choose i-1} 2^{j-1} \cdot 2^{-i}
$$

分别枚举$s_i=s_j=0$或者$s_i=s_j=1$吗，直接用FFT优化就好。直接做一遍卷积，然后我们只取指数小于等于$n-2$的部分，自然会满足$i<j$。

然而我脑抽写了分治FFT，差几十毫秒就T掉了（运气真好）。总结：跟上一道题差不多，不知道自己在干什么。。。

zlx还有一个分治FFT的方法：如果选一个在$i$左边的数，我们就让指数+1；选一个在$j$右边的数，就让指数-1。最后指数为$0$的项就是答案。分治FFT的时候，对于每一个区间，维护只考虑了这个区间内的数选或者不选、得到的生成函数：1）$i$在这个区间，$j$不在这个区间，得到的生成函数；2）$i$不在这个区间，$j$在这个区间的生成函数。3）$i,j$都在这个区间，得到的生成函数。合并两个区间的时候1）考虑$i$在左区间还是右区间，如果在右区间则需要做一次多项式乘法，计算左区间的贡献。2）考虑$j$在左区间还是右区间。3）$i,j$都在左区间，$i,j$都在右区间，$i$在左区间、$j$在右区间，分三种情况讨论。

---

### T3 纳什平衡

![题面][1]

数据范围：$n\le 5000,k\le 20$

Solution：

下面是linli的$O(n^2)$做法。

考虑对于一个$(f,g)$，我们求出$f$不变，$g$任意改变，可以走到的叶子的个数$x$，求出$f$任意改变$g$不变，可以走到的叶子个数$y$。设$cnt_x= \sum_{j=1}^k j^{x-1} $那么$(f,g)$对答案的贡献是$cnt_x k^{|L|-x} \cdot cnt_y k^{|L|-y}$。$x$的取值与$g$无关，并且$y$的取值与$f$无关。故而，只需要求出当$g$随意变动的时候走到的叶子等于$x$的$f$的个数$a$以及当$f$随意变动的时候走到的叶子的个数为$y$的$g$的个数$b$，那么答案就是$\sum_x \sum_y a\cdot b\cdot cnt_x k^{|L|-x} \cdot cnt_y k^{|L|-y}$。

设$h_{i,j}$表示以$i$为根的子树内，任意改变$g$可以到达的点的数量为$j$的$f$的数量。设$v_0,v_1$分别为$i$的两个儿子。如果当前这一层决定的是$f$，那么$h_{i,j} = h_{v_0,j} \cdot (\sum_k f_{v_1,k} ) + h_{v_1,j} \cdot (\sum_k f_{v_0,k} )$；否则，$f_{i,j} = \sum_{k} f_{v_0,k} \cdot f_{v_1,j-k} $。

另一个做法：$f_{u,a,b,c,d}$表示以$u$为根的子树内，按照$(f,g)$走到的点的$c_i$的值是$a$，$d_i$的值是$d_i$是$c$，任意改变$g$得到的最大的$c_i$是$b$，任意改变$f$得到的最大的$d_i$是$d$的$(f,g)$的方案数。

直接转移是$O(k^8)$的。
``` cpp
for(int a0=1;a0<=m;++a0)
for(int b0=1;b0<=m;++b0)
for(int c0=1;c0<=m;++c0)
for(int d0=1;d0<=m;++d0)
if(f[v0][a0][b0][c0][d0]) {
	for(int a1=1;a1<=m;++a1)
	for(int b1=1;b1<=m;++b1)
	for(int c1=1;c1<=m;++c1)
	for(int d1=1;d1<=m;++d1) if(f[v1][a1][b1][c1][d1]) {
		int t=f[v0][a0][b0][c0][d0]*(ll)f[v1][a1][b1][c1][d1]%mod;
		if(dep[u]) {
			Add(f[u][a0][b0][c0][max(d0,d1)],t);
			Add(f[u][a1][b1][c1][max(d0,d1)],t);
		}
		else {
			Add(f[u][a0][max(b0,b1)][c0][d0],t);
			Add(f[u][a1][max(b0,b1)][c1][d1],t);
		}
	}
}
```

发现其实只需要记录，任意改变$g$得到的最大的$c_i$以及这个$c_i$和当前$(f,g)$走到的点的$c_i$是否一样，以及任意改变$f$得到的最大的$d_i$以及这个$d_i$和当前的$(f,g)$走到的点的$d_i$是否一样，就可以完成转移了。转移复杂度$O(k^4)$

``` cpp
for(int a0=1;a0<=m;++a0)
for(int b0=0;b0<2;++b0)
for(int c0=1;c0<=m;++c0)
for(int d0=0;d0<2;++d0)
if(f[v0][a0][b0][c0][d0]) {
	for(int a1=1;a1<=m;++a1)
	for(int b1=0;b1<2;++b1)
	for(int c1=1;c1<=m;++c1)
	for(int d1=0;d1<2;++d1) if(f[v1][a1][b1][c1][d1]) {
		int t=f[v0][a0][b0][c0][d0]*(ll)f[v1][a1][b1][c1][d1]%mod;
		if(dep[u]) {
			Add(f[u][a0][b0][max(c0,c1)][c0==max(c0,c1)&&d0],t);
			Add(f[u][a1][b1][max(c0,c1)][c1==max(c0,c1)&&d1],t);
		}
		else {
			Add(f[u][max(a0,a1)][a0==max(a0,a1)&&b0][c0][d0],t);
			Add(f[u][max(a0,a1)][a1==max(a0,a1)&&b1][c1][d1],t);
		}
	}
}
```

转移还可以优化到$O(k^2)$。lkf的方法是，在最外层枚举最终到达的节点的$c_i,d_i$，然后$dp$的状态里面只需要记录改变$g$能够到达的点的$c_i$是否大于了枚举的，改变$f$能够到达的点的$d_i$是否大于了枚举的，以及最终到达的点是否等于枚举的。

czm的方法是，直接计算出子树内$f$改变后$c$最大取到$x$的方案数和子树内$g$改变后子树内最大取到$x$的方案数。那么枚举完这一层的状态，转移就是$O(1)$的了。




  [1]: https://i.loli.net/2019/06/19/5d09f70632a7934888.png