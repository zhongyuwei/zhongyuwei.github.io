# 20190602 模拟考试（补题）

标签（空格分隔）： 总结

---

### T1 Lemon

有一棵包含$n$个节点的有根树，每一个节点有一个坚固值$d_i$。同时，有$n$颗柠檬，第$i$颗柠檬的重量是$w_i$。将柠檬挂在节点上后（每个节点必须恰好挂一个柠檬），我们定义这个柠檬树是稳定的，当且仅当每个点的坚固值都大于等于它子树内的柠檬的重量的最大值。你可以选择某一个节点，将它的坚固值增加$k$。问$k$最小可以取多少，使得存在一种挂柠檬的方案，使得这个柠檬树是稳定的。无解输出$-1$，不需要加固输出$0$。$n\le 5\times 10^5,d_i,w_i\le 10^9 $

Solution：

确定每个点的$d_i$的情况下，一种显然正确的贪心，是用一个堆维护可以放柠檬的点，初始堆中只有$1$。将$w_i$按照从大到小的顺序填入，每一次选择堆中$d_i$最大的点，然后把这个点的儿子加入堆。如果某个点的$d_i$小于要放在它上面的柠檬的$w_i$，那么无解。

于是就有了一个$O(n^2 \log V)$的做法，枚举修改的点，然后二分修改的量。

考虑对原来输入的$d$进行前面贪心的过程，当进行到某一步$d_i < w_i$的时候，我们应该修改的点一定在此时的队列中。

考虑另外一种判断柠檬树是否合法的方法：记$s_i$为$i$到根的路径上$d_i$的最小值，记$s_i$大于等于$w_i$（第$i$重的柠檬）的点的数量为$cnt_i$，那么只要$\min \{ cnt_i - i \}\ge 9=0$成立，树就合法。

修改一个点的$d_i$会影响到子树内的点的$s_i$。不过之前堆里面每一个点的子树互不相交，所以直接枚举每一个点然后暴力就可以了。可以用线段树维护$cnt_i - i$，修改相当于区间加，查询相当于查询全局最小值。时间复杂度$O(n\log n)$。

---

### T2 Invert

有一个游戏，在一个$n\times n $的方格纸上进行。每一个格子可以是白色或者黑色。玩家可以选择一个黑色格子，然后选择一个边长不超过$k$、以选择的格子为右下角、且没有超出方格纸的正方形，然后翻转正方形里面每个格子的颜色。不能操作者输。

给出初始局面，问游戏结果。

其中，初始局面给出的方式是，给出若干个矩形，局面中为黑色的格子的集合等于这些矩形覆盖区域的并。

$n\le 10^9,m\le 5\times 10^5$

Solution：

考虑一个类似的游戏：每个格子上有**若干**的石头，每一次你可以拿走一个石头（任意一个都可以，没有限制），然后选择一个边长不超过$k$、以选择的石头所在的格子为右下角、且没有超出方格纸的正方形区域，在区域内的其他格子里面都放入一个石头。显然我们会发现在这个游戏里面每一个石头（每个格子里面有很多个石头）是独立的，因为你对一个石头的操作并不会影响到你对其他的石头的操作。并且，考虑如果某一个格子里面石头的个数是偶数，一个人在操作的时候从这个格子里面拿了石头，那么另一个人就可以模仿他的走法，直到游戏结束。故而，玩家一定只会拿走石子数量为奇数的格子的石头。

这个游戏的结果是所有的石头的sg函数的异或的结果。由于异或的性质，要计算这个结果只需要关心每个格子的石头数量的奇偶性（因为同一个格子里的石头sg值显然相同）。

这和原来的问题是等价的：每一次翻转一个右下角为黑色、边长不超过$k$的正方形（相当于改变了奇偶性），不能操作者输。故而，原问题中，一个局面的sg函数，就是这个局面中所有的黑格子的sg函数值的异或和。

结论：$(i,j)$这个格子的sg函数值
$$
sg(i,j) = \min\{ lowbit(i),lowbit(j),lim \}
$$
其中$lim$是不超过$k$且为$2$的整数次幂的最大整数。

然后可以线段树+扫描线。具体地，考虑对于每一个$j$，求lowbit(x)大于等于$j$的$x$的数量，矩形内的满足条件的点的数量 = 满足条件的横坐标的数量 * 满足条件的纵坐标的数量，在模$2$的意义下相当于与运算。可以把每个$j$的结果压在一个int里面。最后再考虑对lim取min。

---

### T3 Triplet

交互题。

有一个长度为$n$的序列$A$，满足序列中的元素两两不同。每一次询问你给出三个不同的位置$x,y,z$，交互库会返回$\min \{ A_x,A_y,A_z\} + \max \{ A_x,A_y,A_z \}$。你需要在$\min \{ n+35,2n\}$次询问中得到序列中每个元素的值并输出。$n\le 10^4,A_i\le 10^9$，部分分$n=5$。

Solution：

考虑$n=5$的时候怎么做。我们直接进行${5\choose 3} = 10$次询问。

假设这五个数从小到大依次是$x_1,x_2,x_3,x_4,x_5$，那么$x_1+x_3,x_2+x_4,x_3+x_5$会出现一次，$x_1+x_4,x_2+x_5$会出现两次，$x_1+x_5$会出现三次。这其中，$x_1+x_5$和$x_2+x_4$可能相等，此时会有一个数出现$4$次，判断一下就可以了。

列出方程后可以用高斯消元解出$x_1,x_2,x_3,x_4,x_5$，再暴力枚举排列、判断是否与询问结果相符就可以得到这五个数。

对于$n>5$，先问出前五个数。然后选择前五个位置中的三个位置$l,r,x$满足$A_l<A_r < A_x$，对于之后的每个位置$i$，询问$i,l,r$，如果得到的结果不是$A_l+A_r$，我们就可以知道$i$；否则就说明$A_l <A_i < A_r$，我们再询问$r,x,i$，就一定可以得到$A_i$。这样的询问次数是$2n$。

考虑减小$[A_l,A_r]$的大小，每一次遇到一个$A_l < A_i <A_r$的$A_i$，就看$[A_l,A_i]$和$[A_i,A_r]$两个区间哪一个更小，用更小的区间代替$[A_l,A_r]$，这样至多会进行$n+5+\log V$次询问。

