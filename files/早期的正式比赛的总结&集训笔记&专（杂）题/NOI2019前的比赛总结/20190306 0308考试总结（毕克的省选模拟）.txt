# 20190306 0308考试总结（毕克的省选模拟）

标签（空格分隔）： 总结

---

## day1

考了两道比较简单的数据结构，以及一道比较变态的递推。前两道题总共写了1个小时，第三题想了很久很久都没有想出递推式，最后写了$O(k^n) $和$O(k^k \log n)$的暴力，骗了15分。感觉自己在做递推式的时候，思路还是没有打开（wzbl）。

### T1 B君的曼哈顿

一个$n\times n$的矩阵。有$m$次操作，每次单点修改，或者查询到某个点曼哈顿距离不超过$k$的所有点的权值和。$n\le 1000,m\le 100000$

Solution：转成切比雪夫距离之后，询问的就是一个子矩阵内数的和。二维树状数组维护即可。

### T2 B君的矩形异或

有$n$个边界与坐标抽平行 的矩形。问被覆盖了奇数次的区域的面积。$n\le 10000$

~~Solution：扫描线模板。~~

### T3 B君的冬至

字符集大小为$k$。一个串合法的条件是，这个串中不存在一个长度为$k$的子串，子串包含了所有的$k$个字符。$n\le 1000 000 000,k\le 30000$

Solution：考试后zlx给我讲了他的$O(k^3\log n)$暴力，即，设$dp[i][j]$表示长度为$i$的字符串，最后$j$位形成了一个排列，并且最后$j+1$位不是排列的方案数，那么答案为$\sum_{j=1}^{n-1} dp[n][j]$，而转移方程是$dp[i][j] = dp[i-1][j-1](k-(j-1)) +\sum_{l=j}^{k} dp[i-1][l] $，可以矩阵乘法优化。

题解说，设$t_n$为长度为$n$的合法的字符串的数量，$s_n$为长度为$n$且前$n-1$个字符是合法的，并且最后$k$个字符恰好形成某种给定的排列的方案数，那么：
$$
kt_{n-1}=t_n + k!s_n \\
\Rightarrow s_n = {1\over k!}(kt_{n-1} - t_n)\\
t_n=\sum_{i=1}^k (k-i)!s_{n+i}\\
=\sum_{i=1}^k (k-i)! {1\over k!}(kt_{n+i-1} -t_{n+i}) \\
=t_n + \sum_{i=1}^{k-1}((k-i-1)!{1\over k!}kt_{n+i} - (k-i)!{1\over k!}t_{n+i} ) - {1\over k!}t_{n+k}\\
\Rightarrow t_{n+k} = \sum_{i=1}^{k-1} ((k-i-1)!kt_{n+i}-(k-i)!t_{n+i})\\
=\sum_{i=1}^{k-1} (k-i-1)!\cdot i \cdot t_{n+i}
$$

然后就是线性递推的板子了。


## day2

看完T1直接放弃。T2很板，但是我考试的时候已经把上个学期刷过的动态点分忘完了，而且改错的时候还调了很久。T3有点意思。

### T1 概率题

有$n$个变量$x_1,x_2\cdots x_n$，它们是独立的，并且它们的取值在$0$到$1$之间均匀随机。设$y_k= \sum_{i=1}^k x_i$。给一个数组$a_i$，问对于所有的$k\in [1,n]$，$y_k\le a_k$都成立的概率$A$。输出概率对$998244353$取模的结果。$n\le 50$


### T2 斐波那契树

一棵树，所有点的初始权值为$0$，所有边的边权都是$1$。两种操作：1.给出$u,m,a,b$，设斐波那契数列的第$0$项为$a$，第$1$项为$b$，对于所有距离$u$不超过$m$的点$v$，$v$的点权加上$F[dis(u,v)]$。2.查询某个点的点权对$1000 000 007$取模的结果。$n,q\le 200000$

Solution：首先把转化一下，考虑对于每一个询问，查询对它有影响的修改。直接用类似烁烁的游戏的动态点分治套路维护。

现在我们需要找到一种数据结构，支持：1.单点查询。2.给一段前缀加上一个斐波那契数列。注意到对于第$x$个位置，它在所有的修改操作中，加上的都是斐波那契数列的第$x$项，所以我们只需要关心那些覆盖到了这个点的修改操作，斐波那契数列的前两项的和分别是多少。这个直接用树状数组维护就可以了。


### T3 奇怪的树

一棵树，所有点的初始权值为$0$。每个点有黑白两种状态。支持两种操作：1.修改一个点的状态。2.选择一个点$u$，对于所有的黑点$v$，让$lca(u,v)$的点权加上$v$。在所有操作结束后，输出所有点的点权。$n,q\le 300000$

Solution：设$f[u]$为$u$的子树内黑点的数量，那么每一次2操作，影响到的点是1到$u$这条链，并且如果这条链上点$x$的儿子是$son[x]$，那么对$x$的贡献就是$f[x] - f[son[x]]$。

自然就想到了重链剖分，维护一下每一个点的$g[x] = f[x] - f[heavy\_son[x]]$，2操作的时候除了重链的顶端上方的点需要特殊考虑（这样的点只有$\log n$个），其他的点可以直接打标记。

而$1$操作涉及到了$g[x]$的修改。但是考虑到修改的点只有$\log n$个，我们不妨把这些点上方的区间的标记全部推下去，然后直接修改。

复杂度$O(q\log^2 n )$。

