# 20190428 模拟考试

标签（空格分隔）： 总结

---

### T1 旧词

给一棵包含$n$个节点的树，并且有一个给定的常量$k$。有$q$次询问，每一次给出$x,y$，你需要回答$\sum_{i\le x} depth(lca(i,y))^k$。答案对$998244353$取模。$n,q\le 5\times 10^4,k\le 10^9$

Solution：

首先肯定是把询问离线下来扫描线。

设$sz(u)$表示$u$子树内关键点的个数。考虑枚举$lca$，则它的贡献是$depth(lca)\times (sz(lca)-sz(son[lca]))$，其中$son$表示的是$lca$在$y$到根的路径上、深度大于它的最浅的点。这个东西可以直接用树剖+树状数组维护。

zlx的做法要更妙一些。考虑$d^k = (1^k + 2^k + 3^k \cdots d^k) - (1^k + 2^k + 3^k \cdots (d-1)^k )$，也就是（路径上所有的点的深度的$k$次方和 - 路径上所有点的深度减一的$k$次方和）= 路径上最深的点的深度的$k$次方。这个可以用树剖+线段树方便地维护。

---

### T2 盗梦空间

有一棵包含$n$个节点的树。有$q$次询问，每次询问给出一个点集$\{ a_1,a_2\cdots a_K \}$，你需要回答树上离这个点集中的最近点的距离最远的点，到这个点集中的最近点的距离。$n\le 10^5,\sum K \le 10^5$

Solution：

我们把这$K$个点的虚树建出来，则根据最近点是谁，可以比较方便地把整棵树分成$O(K)$个部分。

有一些部分是某个虚树上的点下面挂着的、不在虚树上的子树。这可以通过预处理出每个点所有子树中的最深点的深度，并用multiset来维护解决。

还有一些部分，是虚树上两个点之间的链上挂着的子树。这个可以通过树剖维护虚子树信息来解决。由于不带修区间查最大值可以用st表，查询的复杂度少一个$\log n$。要注意从轻链链顶向上跳的时候，为了避免父亲的最深点来自这棵子树，我们需要在预处理的同时记下每一个点向下走的次深的点。

处理出虚树上的每个点到关键点的最近距离就可以得到虚树上链的划分情况。注意特判某些要计算的区间不存在的情况。注意数组清空问题。

---

### T3 爱乐之城

定义
$$
f(n) = \sum_{i=1}^n \sum_{j=1}^n \mu(ij)\\
g(n) = \sum_{i=1}^n \sum_{j=1}^n [i\bot j]ij\\
F(S) = \sum_{T\subset S}  f( gcd(a\in T)) \prod_{a\in T}g(a)
$$

输入第一行给出$n,m,op$，其中$m=\max \{a_1,a_2\cdots a_n\}$。当$op=0$的时候，你需要输出$F(a_1,a_2\cdots a_n)$；当$op=1$的时候，你需要对于每一个$i\in[1,n]$，输出$F(a_1,a_2,a_3\cdots a_i)$，并且你必须输出$i$的答案之后才能得到$a_{i+1}$的输入，此时保证$a_i$随机生成。$n,m\le 4\times 10^5$

Solution：

感觉这道题trick蛮多的。

首先考虑怎么求$g(n),f(n)$。

$$
g(n) = \sum_{i=1}^n \sum_{j=1}^n [i\bot j] ij\\
=2(\sum_{i=2}^n i \sum_{j=1}^i [i\bot j]j) + 1
$$

这一步的正确性基于$[i\bot i]$对于$i>1$不成立。

$$
g(n) = 2(\sum_{i=2}^n i \sum_{j=1}^i [i\bot j]j) + 1\\
= 2(\sum_{i=2}^n i \sum_{j=1}^i \varphi(i) {i\over 2}) + 1
$$

这一步则是基于对于某个$j<i$，$i\bot j \Rightarrow i \bot i-j$。这是因为$gcd(i-j,j) = gcd(i,j)$。

所以$g(n) = \sum_{i=1}^n \varphi(i)i^2$，这个可以在$O(n)$的时间全部预处理出来。

考虑求$f(n)$。
$$
f(n) = \sum_{i=1}^n \sum_{j=1}^n \mu(ij)\\
=\sum_{i=1}^n \sum_{j=1}^n [i\bot j] \mu(i)\mu(j)
$$

这一步的正确性是基于，如果$gcd(i,j)>1$，那么$\mu(ij)=0$。

由莫比乌斯反演可得：
$$
f(n) = \sum_{d=1}^n \mu(d) (\sum_{d|i} \mu(i))^2
$$
我们设$S(d) = \sum_{d|i,i\le n} \mu(i)$。我们需要求的是$f(1),f(2),\cdots f(m)$，这个过程中$S$是在不断变化的。我们从小到大枚举，每加入加入一个数的时候，暴力枚举它的约束更新$S$，并更新$S$对答案的贡献。复杂度等于调和级数。

然后考虑怎么求答案：

$$
F(S) = \sum_{T\subset S}  f( gcd(a\in T)) \prod_{a\in T}g(a)\\
=\sum_{d=1}^n f(d) \sum_{d|k} \mu({k\over d})(\prod_{k|a_i }(g(a_i)+1) - 1)
$$

当$op=0$，我们对每一个$k$预处理出$h(k)\prod_{k|a_i}(g(a_i)+1)$，然后对于每个$d$暴力枚举$k$。复杂度调和级数。

当$op=1$，考虑新加进来一个$a_i$的时候，所有的$a_i$的约数$k$的$h(k)$都会改变。我们对于每一个$k$，预处理出它的贡献系数$\sum_{d|k} f(d)\mu({k\over d})$，然后暴力更新。由于$a_i$随机生成，复杂度还是调和级数。


---

### T4 星际穿越

有一个$r\times n $的矩阵。这个矩阵的每一行是$1$到$n$的一个排列。给定一个常数$K$。对于这个矩阵的某一列$j\in [1,n)$，这一列是稳定的，当且仅当$\forall i\in [1,r],A_{i,j}< A_{i,j+1}$。这个矩阵满足，对于任意的$j$，如果$j$是$K$的倍数，则第$j$列是不稳定的；否则第$j$列是稳定的。给出$n,r,K$，你需要求出有多少个这样的矩阵。答案对$998244353$取模。$n\le 10^6,r\le 19891989$

Solution：

我菜炸了只会做$n\le 17$qwq

一种对于$r=1,n\le 2000$的暴力：设$f_{i,j}$表示前$i$个位置，第$i$个位置填了前$i$个数中的第几大。转移的时候前缀和/后缀和优化。

对于更大的数据范围，我们考虑容斥。发现最终的方案一定是由若干个上升序列拼起来。考虑用容斥解决拼接的位置不合法的情况。

设$m=\lfloor{n-1\over K}\rfloor $。

假设上升序列的长度从左到右依次为$a_1,a_2\cdots a_j$，则方案数是$n!\over a_1!a_2!\cdots a_j!$。设$f_{i,j}$为前$i\cdot K$个位置分了$j$段的系数，则
$$
f_{i,j} = \sum_{x=0}^{i-1} f_{x,j-1}{1\over ((i-x)K)!}\\
Ans = \sum_{i=0}^m \sum_{j=0}^i f_{i,j}(-1)^{i-j+m-i}{n!\over (n-(i\cdot K))!}
$$

观察到$j$只与容斥系数有关，那么我们把这个东西放进去一起$dp$：
$$
f_i = - \sum_{x=0}^{i-1} f_x \cdot {1\over ((i-x)K)!}\\
Ans = \sum_{i=0}^m \sum_{j=0}^i f_{i}(-1)^m {n!\over (n-(i\cdot K))!}
$$

求$f$的过程可以用多项式求逆优化到$O(n\log n)$。

对于$r>1$的情况，直接把式子里面的阶乘和阶乘的逆元换成阶乘和阶乘逆元的$r$次方就可以了。
