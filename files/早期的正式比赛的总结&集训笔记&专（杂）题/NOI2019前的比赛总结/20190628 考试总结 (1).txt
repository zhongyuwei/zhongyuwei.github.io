# 20190628 考试总结

标签（空格分隔）： 总结

---

### T1 智慧树

有一棵树，树上第$i$个点的点权是$a_i$。问对于所有的$i \in [0,m)$，有多少个树上连通块满足连通块内所有点的点权和在模$m$的意义下为$i$。答案对$950009857$取模。

时间限制5s，**空间限制32MB**。

![数据范围][1]

Solution：

观察发现，模数是一个可以NTT的质数，并且$m$总是$\varphi(mod) $的约数，并且对于前面的数据$m$都是$2$的整数次幂。

考虑直接暴力$dp$，发现转移可以NTT优化，并且是循环卷积的形式。那么取数组的长度为$m$，直接算点值相乘就可以了。这一部分的时间复杂度是$O(nm)$，空间复杂度可以做到$O(m)$，对每一位的点值单独计算即可；也可以做到$O(m\log n)$，就是先重链剖分，每个节点直接继承重儿子的信息，当一条链算到链顶之后就把数组清空。

最后我们面临一个问题，就是当数组长度不是$2$的整数次幂的时候，如何计算IDFT。

我们实际上要算的是：

$$
A_i = {1\over m} \sum_{j=0}^{m-1}  F(\omega^j)\cdot \omega ^{-ij}
$$

考虑用卷积优化，我们需要把$-ij$表示成和$i,j,i+j$有关的式子的和。

构造：
$$
-ij = -{i+j\choose 2} + {i\choose 2 } + {j\choose 2 } 
$$

这样就有：
$$
{A_i \over \omega ^ i } = {1\over m} \sum_{j=0}^{m-1} F(w^j) w^{j\choose 2} \cdot \omega^{-{i+j\choose 2}}
$$

这个可以用一次卷积计算。时间复杂度$O(nm + m\log m)$。

这道题非常非常非常卡常。以下是一些优化：

- 首先要预处理出$\omega_m^0,\omega_m^1 \cdots \omega_m^{m-1}$。
- 首先dfs一遍处理处dfs序列，这样每一次就可以直接在序列上做，避免了递归。
- 对于每一个点处理出它的父亲，然后用它去更新父亲，而不是让每个点去访问儿子，因为vector比较慢。
- 当我们计算第$j$位的时候，我们需要算$a_i \times j \mod m$，我们可以从小到大依次枚举$j$，每一次把$a_i \times j$的值加等于$a_i$就可以了。
- 不要单独用一个循环去处理$a_i \times j \mod m$和重置每个点的点值，在每一次算完$i$对父亲对贡献之后就可以做了，这样可以少一遍for循环。


---

### T2 组合数

求$\sum_{i_1 = l_1}^{r_1} \sum_{i_2=l_2} ^{r_2} \cdots \sum_{i_n=l_n} ^ {r_n} {m\choose i_1 + i_2 + \cdots i_n} \bmod p$。

$l_i,r_i \le 10^{17}, m\le 10^{18},n\le 7,p \le 10 $且保证$p$为质数。


Solution：

设$x = \sum_{j=1}^n i_j $。

先不考虑$r$的限制，只要求满足$\sum l_i \le x \le \sum r_i$，此时$x$对答案对贡献应该是${m\choose x} \cdot {x - \sum l_i  + n-1 \choose n-1}$。然后，对上界进行容斥，枚举一个集合，让集合内对所有数点下界变成$r_i + 1$，并统计贡献。

现在的问题就是${m\choose x}\cdot {x - \sum l_i + n-1 \choose n-1}$怎么求。

由lucas定理我们知道，$x$在$p$进制下的每一位对${m\choose x} \bmod p$的贡献是独立的，所以可以考虑数位dp。对于$x - \sum l_i + n-1 \choose n-1$，发现$n-1$非常小，所以我们取一个$p^k > n-1$，然后记录$x \mod p^k$的值就可以计算了。

还有一些做法，是在数位$dp$的过程中直接加一维$2^n$的状态表示每个数是否卡到了上界，并且还需要考虑进位——不过进的位数一定不会超过$n$。

这道题我考场上只得了$55$分，原因是预处理组合数得时候本应该处理到$\max \{ p,p^k \} $，但是我写到是直接预处理到$p^k$，当$k=0$（也就是$n=1$）的时候就出错了。总结：应该谨慎考虑需要预处理的范围！

---

### T3 字符串

对于一个字符串$S$，定义$F(S)$为$S$中任意两个后缀的$lcp$的最大值。

给出一个长度为$n$的字符串$S$以及一个长度为$n$的数组$a$。定义$S$的一个子串$S[l\cdots r]$的价值为，$a_l,a_{l+1},\cdots a_r$的最大值。

给出一个长度为$n$的字符串以及$q$次询问，每次询问给出$l,r,x$，你需要求出对于$S[l\cdots r]$，它的价值最小的子串$t$满足$F(t) \ge x$，并输出$t$的价值。$n,m\le 3\times 10^4$，时间限制2s，空间限制1GB。

Solution：

如何计算一个子串的$F$？

对串建后缀自动机，考虑其中一个点的endpos集合。当我们合并两个子树的endpos集合的时候，枚举其中较小的集合中的每一个元素，在另一个集合中查询它的前驱和后继——它一定只需要和前驱或者后继作为$t$中的那两个$lcp$最大的后缀，这是因为当$lcp$不变的时候两个点一定是越靠近越优秀。这样，我们就得到了$2n\log n$个有用的三元组$(l,r,len)$，其中$S[l-len \cdots l] = S[r-len \cdots r]$，并且$l<r$。

从小到大枚举$r$建主席树。在第$r$棵线段树上，我们在$l-len$上打第一种标记，值为$len$；在$l-len$上打第二种标记，值为$l$。查询$F(S[l\cdots r])$的时候，只需要在第$r$棵线段树上，查出$[l,r-1]$中第一种标记的最大值，以及$[1,l]$中第二种标记的最大值用它减去$l-1$，两者取$max$就是$F(S[l\cdots r]) $的。这一部分预处理的时间复杂度是$O(n\log ^ 2 n)$，查询的时间复杂度是$O(\log n)$。

然后考虑如何计算答案。从小到大枚举$a_i$建主席树，并维护区间内已经插入了的点的数量以及标记最大值。插入一个点之后，找出这个点向左走走到的第一个没有插入的点，向右走走到的第一个没有插入的点，计算这两个点之间的区间的$F$，把这个值作为标记打在加入的点上面。计算答案的时候，先二分答案，然后在对应的线段树上，找出查询前左端点右侧的第一个没有插入的点$l'$，右端点左侧的第一个没有被插入的点$r'$，查询这两个点之间区间的标记最大值，这个值对左端点$S[l\cdots l'],S[r'\cdots r]$的$F$取$max$就是此时区间内最大的$F$。时间复杂度$O(m\log ^ 2 n)$

有一个跑不过的做法，是用类似线段树维护最大子段和的方法，合并两个线段的时候需要查询$F$，时间复杂度$O(n\log^3 n )$。

  [1]: https://i.loli.net/2019/07/01/5d19fae65864258392.png