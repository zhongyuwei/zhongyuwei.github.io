# 20190329 模拟考试

标签（空格分隔）： 总结

---

### T1 循环流

有一个流网络，上面有一个循环流。已知它是一个弱连通图，可能有重边但是没有自环。已知图中所有边的流量一定是$1$或者$2$。给出点数$n$，流量为$1$和$2$的边的边数$a$和$b$，问是否存在一张符合题目描述的图。$2\le n\le 50,0\le a,b\le 50,T\le 127449$

Solution：

特判掉只有一条边的流量是$1$的情况，此时肯定不行。

特判掉$n=2$的情况。如果$1$的边有奇数个肯定不行；如果$2$的边有奇数个，并且没有$1$的边，肯定也不行。其他情况可以。

对于只有一种流量的边的情况，构造的方法是，先连一个大小为$n$的环，然后对于剩下的边，我们单独分离出去一个点，如下面第一个图那样连环；如果剩下的边数是奇数的话，可以像下面第二个图那样子转化。因此，只要边数大于等于$n$就一定有合法解。

![图示][1]


对于两种流量的都有的情况，我们分别构造两个环，然后在某一个点把两个环拼在一起。因此只要边数的总和大于等于$n+1$就一定有解。

---

### T3 森林

对一棵树定义一次操作：以$1$号点为根，交换两个不互相为祖先的子树。一棵树的权值定义为，进行至多一次操作后，这棵树的直径的最大值。每一次往原来的树上加入一个点，给出加的点在树上的父亲。你需要在每一次加点之后，回答这棵树的权值。强制在线。$n\le 20000$

Solution：容易想到答案是直径 + 与直径不相交的一条最长链。首先这肯定是答案的上界，并且由于这条链一定有一个端点和直径相邻（否则可以更长），所以这个东西长得像个“三叉戟”，把$lca$最低的那个分叉接到不属于这个分叉的那一个端点的下面就可以了。

（终于跟着zlx哥哥学了lct维护虚子树信息，好激动！）用lct来维护这个东西。首先我们需要维护直径，我们只需要计算新加入的点到加入前直径的端点的距离，看这个距离是不是比直径更长就可以了。然后我们需要维护子树内的最长链。定义$lv[u]$为splay上，$u$这个点的子树内的点或者这些点的虚子树到$u$子树内深度最小的点的最大距离，$len[u]$为$u$的虚子树中的点到$u$点的最大距离——这个由于有access的虚实链切换，所以需要用multiset维护；定义$sz[u]$为splay上$u$子树内点的数量。那么$lv[u]=max(lv[ls[u]],sz[ls[u]]+1+max(len[u],lv[rs[u]]))$。由于我们还需要支持区间翻转，我们需要同时维护$rv[u]$，定义类似。最终，我们还需要维护对于一条实链，实链上所有点的虚子树内（不经过实链）的最长链，这样我们把直径split出来后就可以直接查询答案了。

``` cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <set>
#define ll long long
using namespace std;
template <class T>
inline void rd(T &x)
{
	x=0; char c=getchar(); int f=1;
	while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}
	while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;
}
const int N=2e5+10;
multiset<int> len[N];
int fa[N],sz[N],rev[N],ch[N][2],n;
int lv[N],rv[N],vmx[N];
inline int get(int x) { return ch[fa[x]][1]==x; }
inline bool isroot(int x) { return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x; }
inline void Swap(int x) { swap(ch[x][0],ch[x][1]),swap(lv[x],rv[x]); rev[x]^=1; }
inline void push_down(int x) { if(rev[x]) Swap(ch[x][0]),Swap(ch[x][1]),rev[x]=0; }
void push_up(int x) {
	sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;
	int tmp=len[x].empty()?0:(*len[x].rbegin());
	lv[x]=max(lv[ch[x][0]],sz[ch[x][0]]+1+max(lv[ch[x][1]],tmp));
	rv[x]=max(rv[ch[x][1]],sz[ch[x][1]]+1+max(rv[ch[x][0]],tmp));
	vmx[x]=max(max(vmx[ch[x][0]],vmx[ch[x][1]]),tmp);
}
void PD(int x) {
	static int stk[N],top;
	stk[top=1]=x; while(!isroot(x)) stk[++top]=x=fa[x];
	while(top) push_down(stk[top--]);
}
void rotate(int x) {
	int f=fa[x],ff=fa[f],d=get(x);
	fa[x]=ff; if(!isroot(f)) ch[ff][ch[ff][1]==f]=x;
	fa[ch[x][d^1]]=f,ch[f][d]=ch[x][d^1];
	fa[f]=x,ch[x][d^1]=f; push_up(f),push_up(x);
}
void splay(int x) {
	PD(x);
	for(int f=fa[x];!isroot(x);rotate(x),f=fa[x]) 
		if(!isroot(f)) rotate(get(x)==get(f)?f:x);
}
void access(int x) {
	for(int y=0;x;y=x,x=fa[x]) {
		splay(x);
		if(y) len[x].erase(len[x].find(lv[y]));
		if(ch[x][1]) len[x].insert(lv[ch[x][1]]);
		ch[x][1]=y; push_up(x);
	}
}
inline void makeroot(int x) {
	access(x),splay(x),Swap(x);
}
int u1=1,v1=1,Ans=1,dia=1;
int qlen(int x,int y) {
	makeroot(x),access(y),splay(y);
	return sz[y];
}
int getans(int x,int y) {
	makeroot(x),access(y),splay(y);
	if(vmx[y]) return vmx[y]-1; else return 0;
}
void update(int f,int x) {
	makeroot(f); fa[f]=x;
	len[x].insert(lv[f]),push_up(x);
	int l1=qlen(x,u1),l2=qlen(x,v1),flg=0;
//	cout<<u1<<' '<<v1<<' '<<l1<<' '<<l2<<endl;
	if(l1<l2) {
		if(l2>dia) u1=x,dia=l2,flg=1;
	}
	else if(l1>dia) v1=x,dia=l1,flg=1;
	Ans=dia+getans(u1,v1)-1;
}
int main () {
	freopen("forest.in","r",stdin);
	freopen("forest.out","w",stdout);
//	freopen("out.txt","w",stdout);
	int ty,lastans=0,x; rd(ty),rd(n);
	for(int i=2;i<=n;++i) {
		rd(x); x^=lastans;
		update(x,i);
		printf("%d\n",lastans=Ans);
	}
	return 0;
}
```


  [1]: https://s2.ax1x.com/2019/03/30/ADB5G9.png