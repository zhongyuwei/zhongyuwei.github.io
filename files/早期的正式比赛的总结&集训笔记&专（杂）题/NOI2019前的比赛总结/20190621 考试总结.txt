# 20190621 考试总结

标签（空格分隔）： 总结

---

### T1 ichi

给出一个包含$n$个节点点带权边也带权的树。有$m$次操作，操作有两种：1）询问一个节点的权值。2）给一个节点子树内、到这个节点的路径上的最小边权大于等于$d$的点的权值全部加上$v$。强制在线。$n,m\le 10^5$

Solution：

由于数据出锅我写的离线算法居然得了100分。。。

$d$的限制相当于在Kruskal重构树上的一个子树，可以转化成dfs序的一个区间；在点的子树内这个限制相当于在原树dfs序中的一个区间。于是这道题就是一个矩形加1、单点查询。直接树套树就可以了。

发现其实树套树没有想象的那么慢，我的cdq分治422ms，树套树431ms。

另外一个跑得很快的做法：对原树重链剖分，用线段树维护dfs序，对线段树上的每一个区间开一个$splay$。2）操作的时候，在修改的点所属于的重链上操作：遍历线段树上所有包含了修改了的点的区间（总共有$\log n$个），然后在区间的splay中，加入一个键值为这个区间的右端点到修改的点的路径上边权的最小值、权值为这次修改的增加量的点。查询的时候暴力向上跳重链，查重链上对应的区间。每一个修改一定会被查到并且只会被查到一次，因为任意一个包含了这个修改的区间，在线段树上我们都加入了这个修改的信息；并且，在线段树区间查询的时候，我们一定会依次遍历$\log n$个**互不相交**的区间，所以不会重复。

---

### T2 ni

对于一个序列$a_1,a_2,a_3\cdots a_n$，你有一个初始为$0$的变量$E$，这个变量将依次受$a_1,a_2,\cdots a_n$影响，最终得到一个值$E'$。具体地，当$E$受$X$影响的时候：

- 如果$E>X$，那么$E$会$-1$。
- 如果$E<X$，那么$E$会$+1$。
- 否则$E$不变。

对于任意$i\in [1,n]$，你需要确定$a_1,a_2,\cdots a_i$的排列的顺序，使得$E$（初始为$0$）依次受到这些数影响过后得到的$E'$最大，并输出这个最大值。$n\le 5\times 10^5 , - 5\times 10^5\le a_i \le 5\times 10^5$

Solution：

~~容易猜出~~对于一个序列，最优的方案一定是将这个序列升序排列。

现在的问题是怎么维护答案。

我的方法比较清奇：设$x_i$是受前$i$个数影响之后得到的$E'$，那么$x_i$显然是先下降再上升，在线段树上二分找到这个断点。断点后面的部分满足：
$$
x_i = \min \{ x_{i-1} +1, a_i \}
$$

两边同时减下标，得到
$$
x_i - i = \min \{ x_{i-1} - (i-1),a_i - i \}
$$

归纳一下得到：
$$
x_n - n  = \min_i \{ a_i - i \}
$$

用线段树维护，插入一个数的时候相当于后缀-1，询问的则是区间min。

端点前面的部分也可以用类似的方法维护，不过实际上这一部分一定是每一步$x$都会$-1$，所以直接可以得到答案。

另外一种思考的方法，是考虑如果在$i$这个点$x_i = a_i $，我们找出点$i$后面的第一个$j$满足$a_i + j - i = a_j  $且对于$(i,j)$中的任意一个数都有$a_i + k - i < a_k $。基于这个思路可以有各种方法去维护答案。

ljz的神奇方法：对正数和负数分别维护。对于正数集合，加入$x$的时候，找到小于等于$x$、且还没有出现过的数中的最大的数，如果存在就把那个数加入集合；否则就令$cnt++$，这个$cnt$可以用来去抵消负数的影响。对于负数，也是加入$x$的时候，找到小于等于它的、且还没有出现过的数中的最大的数，然后加入集合。计算出负数集合中得到的结果$a$，答案就是$\min \{ 0, a+cnt \} $再加上正数集合的大小。

---

### T3 san

有一张DAG，第$i$个点的权值是$a_i$。你需要求出原图的一个拓扑序的一个连续区间，使得这个区间内的点的权值和最大，并且输出这个最大权值。$n\le 50,m\le {n(n-1)\over 2},|a_i| \le 200$

Solution：

一些水法：1）枚举选择的权值为正数的点的集合，然后$O(n^2)$求出必须选上的权值为负数的集合。扩展集合的时候只保留最优秀的$10^5$个存下来。2）直接状态压缩$dp$ + 记忆化搜索，由于跑不满可以得到很多分。

正解：最小割，类似最大权闭合子图。建两排点，每一排都有$n$个点。对于原图中的边$(u,v)$，在左右两排点中分别连从$u$到$v$、容量为$\infty$的边。对于点权大于$0$的点，从源点向左边一排的那个点连容量为它的权值的边，从右边一排的那个点向汇点连容量为它的权值的边；对于点权小于$0$的点，从左边的那个点向右边的那个点连容量为这个点的点权的相反数的边。答案就是所有点权大于$0$的点的点权和 - 最小割。

正确性证明：考虑如果同时保留了两个边权为正的点$u,v$，并且它们之间有一条路径经过了$x$，其中$x$的边权为负，那么就必须割掉$x$从左边到右边的那一条边，否则就必须放弃$u,v$中的一个。

总结：对最大权闭合子图，以及最小割的模型不熟悉，考试的时候根本没有往这个方面去想qwq。