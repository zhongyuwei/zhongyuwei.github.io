# 20190429 模拟考试

标签（空格分隔）： 总结

---

### T1 Endless

有一个长度为$n$的序列$a$。通过它我们得到一个包含$n$个点的无向图：对于这个序列中的任意一个长度为偶数的子串$a_{l,l+1\cdots l+2k-1}$，如果它满足$\forall i\in [1,k]$，有$a_{l+i-1}= a_{l+i+k-1}$，那么我们就对于每一个$i\in [1,k]$，连一条从$l+i-1$到$l+i+k-1$、边权为$w_k$的边。输入给出$a$和$w$（$w$是一个长度为$\lfloor {n\over 2 } \rfloor $）。问最终的图的最小生成树。$n\le 3\times 10^5$

Solution：

考虑从小到大枚举$w_k$。问题转化成给定一个$k$，如何快速找出对应的段并合并。

显然所有有$i\to i+k$这条边的$i$组成若干个连续段，并且每一段的长度大于等于$k$。那么我们在原来的序列中每隔$k-1$个位置设置一个关键点，并且求出每一个关键点和下一个关键点的最长公共前缀和最长公共后缀。这样我们就可以找出所有的需要合并的段了。

维护这个合并的话，我们考虑开$\log n$层并查集，第$i$层中的$x$和$y$属于同一个集合则代表$a_{x\cdots x+2^i-1}$和$a_{y\cdots y+2^i-1}$完全相同。我们从上往下暴力合并，合并到$i=0$的时候统计对答案的贡献。当合并到某一层，要合并的两个元素已经属于同一个集合之后，直接返回即可。

这样的复杂度乍一看是$qn\log n\alpha(n)$的，其实不然。对于每一层而言我们只会合并$O(n)$次，所以合并的总复杂度$n\log n \alpha(n)$。

---

### T2 tree

输入一个包含$n$个节点的树，满足每个点的度数小于等于$16$。

任务一：将这棵树的所有的边都覆盖恰好一次，至少需要多少条路径。

任务二：在满足任务一的条件下，这些路径中最长的一条最短是多长。

任务三：在满足前两个任务的条件下，有多少种路径划分方案。答案与$998244353$。

$n\le 10^5$

Solution：

第一个任务：答案等于度数为奇数的点数除以二。显然任意一张图中度数为奇数的点的数量是偶数。

第二个任务：二分答案，然后贪心check。

第三个任务：首先考虑度数$\le 10,n\le 1000$怎么做。

我们考虑我们任务二中的贪心策略。对于每一个点，它必定会传一条链上去给父亲。因此，当一个点的儿子的数量为偶数的时候，它可能是把所有的儿子传上来的链都配对完，也可能是剩下一条链挂在它的下面，另一条链传上去，剩下的链两两配对。当一个点的儿子的数量是奇数的时候，它一定是把某一条来自于儿子的链传上去，而把剩下的链两两配对。

设$f[i][j]$表示$i$点向上传的那条链的长度为$j$，且$i$的子树内的决策满足任务一的方案数。

首先我们求出$i$的任意两个儿子配对成一条长度不超过任务二的答案的链的方案数。单独求一次是$O(n)$的。

考虑到点的度数很小，所以我们对这些儿子进行状压$dp$。最后再枚举单独挂着的或者传上去的点。

对于$n\le 10^5,D\le 16$的数据范围，状态压缩$dp$的时候有很多状态是无用的，可以压掉；$dp$的过程用长链剖分优化。但是我不会qwq。




