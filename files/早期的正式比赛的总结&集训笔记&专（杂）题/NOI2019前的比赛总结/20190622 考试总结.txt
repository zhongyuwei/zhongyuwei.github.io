# 20190622 考试总结

标签（空格分隔）： 总结

---

### T1 小蛋糕

有$n$个物品，每个物品有两个属性$v,c$，第$i$个物品表示为$(v_i,c_i)$。你需要从中选出恰好$m$个物品然后按照任意顺序排列，假设排列得到的第$i$个是$k_i$，你需要最大化（令$k_{m+1} = k_1$）：
$$
\sum_i v_{k_i} - \sum_i |c_{k_i} - c_{k_{i+1}}|
$$

并输出这个最大化的结果。

$n\le 2\times 10^5 ,v_i,c_i \le 10^9$

Solution：

如果确定了要选哪些元素，那么显然是把这些元素按照$c$从小到大排列最优，此时$\sum_i |c_{k_i} - c_{k_{i+1}}| = 2(c_{k_m} - c_{k_1})$。

枚举左右两个端点的元素$l$和$r$，其余的$m-2$个元素就直接选取$c$在它们之间的、$v$最大的$m-2$个元素就可以了。记这样得到的答案是$f(l,r)$。

对于某一个$l$，记$f(l,r)$取到最大值的$r$为$r'$，那么$r'$一定随着$l$的增大而增大。因为对于$l_1< l_2,x<y$，如果$l_2$的最优的$r'$是$x$，那么对于$l_1$而言，$x$一定会比$y$优秀，因为$x$可以选取到的元素$y$都可以选到。

对于决策点利用它的单调性分治即可。可以用主席树求区间前$m$大的元素的和，也可以利用类似莫队的方法移动指针，然后用两个multiset维护。具体地，用一个multiset一个维护前$m$大的元素，并另外用一个变量存它们的和；另一个维护其他的元素。移动指针的时候，把将要移动的区间的左右端点传进去，然后先扩再减，以免从set里面删除不存在的元素。也即是：

``` cpp

void get(int L,int R) {
//	cout<<get<<':'</<L<<' '<<R<<endl;
	L++,R--;
	while(pl>L) Insert(s[--pl].v);
	while(pr<R) Insert(s[++pr].v);
	while(pl<L) Erase(s[pl++].v);
	while(pr>R) Erase(s[pr--].v);
}	

```

---

### T2 小圆

有一棵包含$n$个节点的树。总共有$m$个集合，树上的第$i$个点属于第$S_i$个集合。一次操作可以把两个集合合并。问至少需要多少次操作，使得这棵树不存在同时满足以下所有条件的两个集合$X,Y$：

- $X\cap Y = \emptyset,X\cup Y = \{1,2,\cdots n\}$。
- 不存在两个点$a,b$，$a\in X,b\in Y$，且$S_a = S_b$。

$n\le 500000,m\le n$

Solution：

如果两个集合的虚树存在交，那么就先把他们缩起来。最后缩点完成过后将会得到一棵树，问题转化成在这棵树上加边，使得树上不存在桥。答案就是树上的叶子个数除以$2$下上取整。

合并虚树内部的点，可以转化成合并若干条路径上的点，这个可以直接树上并查集做（儿子 -> 父亲）。复杂度$O(n\log n + n\alpha (n))$

---

### T3 小宝石

交互题。有$2n$个宝石，这些宝石两两分成一对，总共有$n$种。现在这些宝石被全部打乱了。有一个装置可以报出这个状态中装的宝石的种类数，初始的时候装置为空。你可以进行两种操作：1）将一个宝石放入装置，并且得知此时装置内的宝石的种类数。2）将一个宝石从装置内拿出来，并得知此时装置内的宝石的种类数。你需要在不超过$1000000$次操作内，计算出这些宝石是如何两两分成一对的。$n\le 43000$

Solution：

首先可以通过$n$次询问将$2n$个宝石分成两个大小为$n$的集合，每一对的两个宝石分属于两个集合。具体地，从第一个宝石开始依次把宝石加入，如果加入之后种类数增多，那么这种宝石是第一次出现，放在第一个集合；否则放在第二个集合。

然后考虑分治：假设是第一个集合中的$[l,r]$中的宝石与第二个集合中的$[ql,qr]$中的宝石匹配。

对于第一个集合，把$[l,mid]$全部放入，其它的全部拿出。然后把第二个集合里面的先全部拿出来，然后依次询问$[ql,qr]$。如果加入第二个集合里的$i$的时候，总种类数没有变化，说明$i$与$[l,mid]$里面的匹配；否则$i$与$[mid+1,r]$里面的匹配。

这样的复杂度是$O(n\log_2 n )$的，但是常数较大。

我们对$[l,r]$区间以外的、第一个集合中的元素并没有要求，只是要求$[l,mid]$中的点处于一个状态，$[mid+1,r]$的点处于另一个状态就可以了。如果是$[l,mid]$在装置内，那么加入之后种类数没有变化的元素属于$[l,mid]$；如果是$[mid+1,r]$的在装置内，那么加入后种类数没有变化的元素就属于$[mid+1,r]$。并且，对于第二个集合内的点的状态，其实也并没有要求，我们只需要知道，把它从装置内拿出或者放入装置之后，种类数是否改变就可以了，并不需要知道具体是拿入还是拿出。

于是可以在分治下去的时候，记一个$op$表示这个区间第一个集合的所有的点的状态是全部都放入还是全部都拿出了，然后将$[l,mid]$的状态反转，然后依次查询。当第二个点分到$[l,mid]$的个数等于了$mid-l+1$，或者分到$[mid+1,r]$的点的个数等于$[r-mid]$，那么直接break出去就好了。

考虑到我们对左区间的操作会多一些，所以从$1\over 2$处断开并不是最优秀的。设断开的位置是$p$，计算一个长度为$N$的区间的答案的复杂度是$f(N) = t\cdot N\log N$，那么：

$$
f(N) = f(pN) + f((1-p)N) + (1+p)N \\
t\cdot N\log N  = t \cdot pN \log {(pN)} + t\cdot (1-p) N \log ((1-p)N) + (1+p)N \\
t\cdot N\log N = t\cdot pN (\log p + \log N) + t\cdot (1-p)N (\log (1-p) + \log N) + (1+p)N \\
t \cdot \log N = t \cdot p\log N + t\cdot (1-p) \log N + t\cdot pN \log p + t\cdot (1-p)\log (1-p)  +(1+p) \\
t = {-1-p \over p\log p + (1-p) \log (1-p)}
$$

考虑对上式求导：
$$
t' = -(p\log p + (1-p) \log (1-p)) + ( 1+p) ((p\log p+(1-p)\log(1-p))')
$$

考虑：
$$
(\log x)' = {1\over x}\\
(x \log x)' = 1\cdot \log x + x\cdot {1\over x} = \log x + 1\\
((1-x)\log(1-x)) = (\log(1-x) + 1) \cdot (-1) = -\log(1-x) - 1
$$

所以：
$$
t' = -(p\log p + (1-p)\log (1-p))\\
+ (1+p) ( \log p + 1 - \log(1-p) - 1 \\
= -p\log p + p \log (1-p) + p \log p - p \log (1-p) \\
- \log (1-p) + \log p - \log (1-p) \\
= \log p - 2 \cdot \log (1-p)
$$

所以当$\log p = 2\cdot \log (1-p)$的时候，$t$最小。

也就是：
$$
(1-p)^2 = p\\
p^2 - 3p + 1 =0 \\
\Rightarrow p = {3\pm \sqrt 5 \over 2}
$$

又因为$p<1$，所以$p = {3- \sqrt 5 \over 2 }$。

这样就可以通过了。