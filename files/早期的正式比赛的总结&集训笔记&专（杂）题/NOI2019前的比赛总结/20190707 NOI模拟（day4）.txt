# 20190707 NOI模拟（day4）

标签（空格分隔）：总结

---

### T1

有$n$堆果子依次排成一排，初始的时候第$i$堆有$a_i$个果子。

你可以在初始的时候选择一堆果子。每一轮，你可以把**你选择的这一堆果子**与它左边或者右边的一堆果子合并。合并的代价是合并后这一堆里面果子的数量。

对于每一个$i\in [1,n]$，你都需要求出将第$i$堆果子作为第一堆，操作完$n-1$轮后付出的代价的最小值。

$n\le 2\times 10^5 $

Solution：

考虑loj2509的模型。对于这道题来讲就是两条链，画一些图可以发现连通块可以用单调栈维护：从左往右扫，如果栈顶的连通块的平均权值小于新加入的点的权值就把栈顶弹出并和新加入的点合并，扫到$i-1$的时候，得到的单调栈中的连通块，就是我们把$i$作为根的时候需要考虑的连通块。右边也是同理。

单调栈中元素的总变化是$O(n)$的。可以用平衡树去维护所有的连通块，从而得到将连通块按照平均权值排序后合并得到的结果。

``` cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#define PB push_back
#define fir first
#define sec second
#define ll long long
#define db long double
#define uint unsigned 
using namespace std;
template <class T>
inline void rd(T &x) {
	x=0; char c=getchar(); int f=1;
	while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }
	while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;
}
const int N=4e5+10;
const db eps=1e-10;
db fabs(db x) { return x>0?x:-x; }
int dcmp(db x) { return fabs(x)<eps?0:(x>0?1:-1); }
struct item {
	ll w,c; int s;
	item(ll w=0,int s=0): w(w),s(s),c(0) {}
	friend bool operator <=(item A,item B) {
		return A.w*B.s==B.w*A.s?A.c<=B.c:A.w*B.s<=B.w*A.s;
//		return dcmp(A.w/(db)A.s-B.w/(db)B.s)<=0;
		
	}
	friend item operator +(item A,item B) {
		item C;
		C.c=A.c+B.c+B.w*(ll)A.s;
		C.w=A.w+B.w;
		C.s=A.s+B.s;
		return C;
	}
}s1[N],s2[N],a[N];
vector<item> v[N];
ll an[N];
int t1,t2,n;
namespace RNG {
	uint seed='z'+'l'+'x';
	uint Rnd() {
		seed^=seed<<13,seed^=seed>>17,seed^=seed<<5;
		return seed;
	}
}
using RNG::Rnd;
uint key[N<<1];
int ch[N<<1][2],ncnt,rt;
item val[N<<1],sum[N<<1];
void push_up(int c) { sum[c]=sum[ch[c][1]]+val[c]+sum[ch[c][0]]; }
void merge(int a,int b,int &x) {
	if(!a||!b) return (void)(x=a+b);
	if(key[a]<key[b]) merge(ch[a][1],b,ch[x=a][1]);
	else merge(a,ch[b][0],ch[x=b][0]);
	push_up(x);
}	
void split2(int x,int &a,int &b) {
	if(!x) return (void)(a=b=0);
	if(ch[x][1]) split2(ch[x][1],ch[a=x][1],b);
	else b=x,a=ch[x][0];
	push_up(a),push_up(b);
}
void split(int x,int &a,int &b,item k) {
	if(!x) return (void)(a=b=0);
	if(val[x]<=k) split(ch[x][1],ch[a=x][1],b,k),push_up(a);
	else split(ch[x][0],a,ch[b=x][0],k),push_up(b);
}
void Debug(int x) {
	if(!x) return;
	Debug(ch[x][0]);
	printf("%d: %lld %d %lld\n",x,val[x].w,val[x].s,val[x].c);
	Debug(ch[x][1]);
}
void ins(item v) {
//	cout<<"Ins:"<<v.w<<' '<<v.s<<' '<<v.c<<endl;
	int u=++ncnt;
	val[u]=v,key[u]=Rnd(); push_up(u);
	int x,y; split(rt,x,y,v);
	merge(x,u,rt);
	merge(rt,y,rt);
}
void del(item v) {
//	cout<<"Del:"<<v.w<<' '<<v.s<<' '<<v.c<<endl;
	int x,y,z;
	split(rt,x,y,v);
	split2(x,x,z);
	merge(x,y,rt);
}
int main() {
	rd(n);
	ll tot=0;
	for(int i=1,x;i<=n;++i)
		rd(x),a[i]=item(x,1),tot+=x;
	for(int i=1;i<=n;++i) {
		item tmp=a[i];
		while(t1&&s1[t1]<=tmp) {
			v[i].PB(s1[t1]);
			tmp=s1[t1]+tmp;
			t1--;
		}
		s1[++t1]=tmp;
	}
	for(int i=1;i<=t1;++i) ins(s1[i]);
	for(int i=n;i>=1;--i) {
		del(s1[t1]); t1--;
		for(int j=(int)v[i].size()-1;j>=0;--j) {
			s1[++t1]=v[i][j];
			ins(v[i][j]);
		}
//		cout<<"calc:"<<i<<endl;
//		Debug(rt);
		an[i]=sum[rt].c;
//		cout<<"an[i]="<<an[i]<<endl;
		item tmp=a[i];
		while(t2&&s2[t2]<=tmp) {
			del(s2[t2]);
			tmp=s2[t2]+tmp;
			t2--;
		}
		s2[++t2]=tmp; ins(tmp);
	}
	for(int i=1;i<=n;++i) printf("%lld\n",an[i]+a[i].w*(ll)(n-2)+tot);
	return 0;
}
/*
10
7 10 8 6 4 16 17 10 14 13 
*/
```