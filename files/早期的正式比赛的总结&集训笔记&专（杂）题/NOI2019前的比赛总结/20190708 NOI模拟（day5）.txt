# 20190708 NOI模拟（day5）

标签（空格分隔）： 总结

---

### T1 登山


![题面][1]

$n\le 5\times 10^6,-10^9 \le h_i \le 10^9$

对于10%的数据，$0\le h_i$

Solution：

对于$h_i\ge 0$的部分分，可以证明答案一定是yes。

通过讨论可以发现，图中（每一个点是一个pair，表示两个人分别在什么位置）除了$(0,n+1)$和$(n+1,0)$之外，所有点的度数都是偶数，所以这两个点必然连通。

对于其它数据，可以证明不存在解当且仅当存在一对$i,j$，满足$i<j$且$h_i \not\in [\min \{ h_{j+1},h_{j+2} \cdots h_n \},\max \{ h_{j+1},h_{j+2},\cdots h_n\} ] $且$h_j \not \in [\min \{ h_{i-1},h_{i-2} \cdots h_1\} , \max \{ h_{i-1},h_{i-2} \cdots h_1 \} $。

``` cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#define PII pair<int,int>
#define MP make_pair
#define fir first
#define sec second
#define PB push_back
#define db long double
#define ll long long
using namespace std;
template <class T>
inline void rd(T &x) {
	x=0; char c=getchar(); int f=1;
	while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }
	while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;
}
const int N=5e6+10,inf=2e9;
int h[N],n;
int main() {
	rd(n);
	for(int i=1;i<=n;++i) rd(h[i]);
	int lmi=min(0,h[1]),lmx=max(0,h[1]);
	int rmi=min(0,h[n]),rmx=max(0,h[n]);
	int L=0,R=n+1;
	while(R-L>1) {
		if(rmi<=h[L+1]&&rmx>=h[L+1]) {
			++L;
			lmi=min(lmi,h[L+1]);
			lmx=max(lmx,h[L+1]);
		}
		else if(lmi<=h[R-1]&&lmx>=h[R-1]) {
			--R;
			rmi=min(rmi,h[R-1]);
			rmx=max(rmx,h[R-1]);
		}
		else {
			printf("No");
			return 0;
		}
	}
	printf("Yes");
	return 0;
}
```

---

### T2 数数

![题面][2]

阿贝尔群计数。

$0 \le m\le 10^6,1\le p_i\le 10^9,1\le q_i \le 10^6$

Solution：

结论1：$n$阶阿贝尔群的数量$f(n)$是一个积性函数。可以考虑模意义下的加法，模不同质数的加法可以通过中国剩余定理合并。

结论2：对于$n=p^k$其中$p$是一个素数，$n$阶阿贝尔群的数量是$k$的划分数。

那么只要快速求出划分数就可以了。用五边形数定理可以做到$O(n\log n)$。

  [1]: https://i.loli.net/2019/07/09/5d23cccca394c16950.png
  [2]: https://i.loli.net/2019/07/09/5d23cfad0963920124.png