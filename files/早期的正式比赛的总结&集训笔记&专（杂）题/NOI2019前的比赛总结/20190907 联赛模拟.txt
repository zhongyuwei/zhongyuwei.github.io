# 20190907 联赛模拟 

标签（空格分隔）： 总结

---

## T2 匹配最大异或

有$n$个变量$x_1,x_2,\cdots x_n$，它们都在$[0,2^m)$。定义$p_i$为满足满足$x_k \text{xor} i$最大的$k$。

现在给出$p_0,p_1,\cdots p_{2^m - 1}$，问有多少满足条件的$\{x_1,x_2\cdots x_n\}$。

答案对$10^9+7$取模。

### Sol

考虑$i$最高位为$0$的所有$p_i$和$i$最高位为$1$的所有$p_i$。

如果$x_i$的所有数的最高位相同，那么这两部分是完全相同的。

否则，这两部分应该不相交。如果不是上述两种情况，则答案就是$0$。

递归下去求解即可。

``` cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#define PB push_back
#define ll long long
using namespace std;
template <class T>
inline void rd(T &x)
{
	x=0; char c=getchar(); int f=1;
	while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}
	while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;
}
const int N=(1<<16)+232;
const int mod=1e9+7;
int p[N],n,m,ans=1;
vector<int> x,y;
void solve(int l,int r) {
	if(l==r-1) return;
	int mid=l+r>>1,flg=0;
	for(int i=mid;i<r;++i) if(p[i]==p[l]) { flg=1; break; }
	x.clear(),y.clear();
	for(int i=l;i<mid;++i) x.PB(p[i]);
	for(int i=mid;i<r;++i) y.PB(p[i]);
	if(flg) {
		if(x!=y) ans=0;
		ans=ans*2ll%mod;
		solve(l,mid);
	}
    else {
    	sort(x.begin(),x.end());
    	sort(y.begin(),y.end());
		for(int i=0;i<x.size();++i) {
			int pos=lower_bound(y.begin(),y.end(),x[i])-y.begin();
			if(pos<y.size()&&y[pos]==x[i]) ans=0;
		}
		solve(l,mid),solve(mid,r);
	}
	if(!ans) return;
}
int main() {
	rd(m),rd(n);
	for(int i=0;i<(1<<m);++i) rd(p[i]);
	solve(0,1<<m);
	printf("%d\n",ans);
	return 0;
}
```

## T3 染色相邻的边

有一棵树，初始所有边都是黑色。

有两种操作：

1. 将一条路径上所有的边都变成黑色，将与这条路径相邻的边全部变成白色。
2. 询问一条路径上有多少条白色的边。

$n\le 200000, q\le 300000$

### Sol

一条边的颜色是白色，等价于边的两个端点的修改时间不同。

用树剖维护颜色就可以了。