## 热身小练习

考虑 Kruskal，按照 $w_L$ 从小到大枚举 $L$，然后找出所有的长度为 $L$ 的平方串（每隔 $L$ 个设置一个哨兵结点）、连边（倍增 + 并查集）。

具体的连边过程：

```
void unite(int k,int x,int y) {
	if( 在 k 这层的并查集中，x,y 属于同一集合 )
		return;
	if( k==0 ) ans++;
	else unite(k-1,x,y), unite(k-1, x+(1<<k-1), y+(1<<k-1));
	在 k 这层的并查集中合并 x,y ;
	return;
}
```

## LOJ2472 [九省联考2018] IIIDX

$i\to \lfloor \frac{i}{k} \rfloor$ 实际上是个树形结构。按照位置从前往后依次确定每个数。

考虑如何判断是否合法：如果确定了 $i$ 填 $x$，那么它的子树内的元素都不能小于 $x$，也就是说小于 $x$ 的元素中我们要预留 $size_i$ 个。记 $f_j$ 表示前 $j$ 大的元素除掉预留的之后还剩下多少个，则 $i$ 填 $x$ 带来的影响相当于 $f_x, f_{x+1}, \dots f_n$ 均减去 $size_i$，而存在合法方法等价于所有的 $j$ 均满足 $f_j \ge 0$。

## 另一道例题

出自 HNOI2018 省队集训。

由 Hall 定理得，答案为
$$
\min_{S} \frac{1}{|S|} \cdot (S集合中的人的到 LCA 的路径上的颜色数)
$$
数颜色：树剖 + bitset。总复杂度 $O(qc\log n \frac{m}{w} + q2^c \frac{m}{w})$。

## 另一道例题

题面的意思是 $\min_{c_u = c_v} \{ dis(u,v) \} \in [L,R]$。

容斥掉区间一端的限制，只考虑 $R$。

按照 BFS 序依次确定颜色。发现确定 $u$ 的颜色的时候，已经确定了颜色的不能与它同色的点，这些点两两之间也是不能同色的。点分治数出这些点的个数即可。

性质的证明：考虑现在要颜色的点是 $a$，而两个与它不能同色的点为 $b_1, b_2$，设 $dep(lca(a, b_1)) \le dep(lca(a, b_2))$，则 $lca(a, b_1)$ 为 $lca(a, b_2)$ 的祖先而 $dep(b_2) \le dep(a)$，所以 $dis(b_1, b_2) = dis(a, b_1) - dep(a) + dep(b_2) \le dis(a,b_1)$。

## HDU6368 Varience-MST

方差的表达式：
$$
\sum(w_i-\overline{w})^2
$$

在选的边确定的情况下，把方差考虑成一个关于 $\overline{w}$ 的函数，则它的导数为 $\sum -2(w_i - \overline w) = 2[ (n-1)\cdot \overline{w} - \sum w_i]$，零点为 $\frac{\sum w_i}{n-1}$。这也就意味着，如果 $\overline w$ 不等于 $\frac{\sum w_i}{n-1}$，代价会变大。

一个暴力的做法是，枚举 $A = \overline{w}$，然后把边权当成 $(w_i - A)^2$ 跑 Kruskal。

考虑对于两个边 $w_i < w_j$ 来说，$w_i$ 比 $w_j$ 优秀意味着 $A < \frac{w_i + w_j}{2}$。对 $A$ 做扫描线，从 $-\infty$ 枚举到 $\infty$，枚举到 $\frac{w_i + w_j}{2}$ 的时候就尝试用 $w_j$ 去替换掉 $w_i$。这样的复杂度是 $O(n^2\log n)$。

显然真正有效的替换事件不超过 $2m$ 个，如果能把找出来我们就 win 了。把所有的边从小到大依次加入生成森林，设当前加入的边为 $j$，如果加入 $j$ 之后成环了，那么 $j$ 在之前的过程中替换掉的就是环上 $w$ 最小的边，然后把那条边从森林中删掉、把 $j$ 加入。尽管这样处理出来的事件并不满足发生时间升序，但是对于特定的一条边来说，枚举到的、可能与它有关的事件的时间是升序的。严谨的证明？？？	

## 双一道例题

先从右到左做一个扫描线，求出最终的图形是什么样子的，并且求出在这个最终的图形中每个人能直接看到的点数。

第 $n$ 个人实际能看到的点数就是最终的点数。将第 $n$ 个人删掉，把它的区域中的点数加入到它的右上角第一个包含了它的点，剩下的是一个规模更小的子问题。

对每个点求出（不考虑时间）右上角第一个包含它的点，这是个类似树形结构的东西，用并查集维护即可支持查询一个点的最近的未被删掉的祖先。

## 叒一道例题

首先将 $l_i, r_i$ 离散化。由期望的线性性，考虑求出每个元素在 $w(L,R)$ 中的概率：设这个元素在 $a_1, a_2,\cdots a_k$ 这些位置出现，则相当于是求
$$
\sum_{i=1}^k P(a_i \in [L,R]) - \sum_{i=1}^{k-1} P(a_i \in [L,R] \wedge a_{i+1} \in [L,R])
$$
可以转化成形式
$$
 [ L'\le a_i \le R'] (a_i -L+1)(R-a_i+1) \cdot val\\
= [ L'\le a_i \le R'] ((a_i+1)^2 - L(a_i+1) + R(a_i+1) - LR) \cdot val
$$
如果能搞出 $a_i$，这就是个二维数点。

按照元素从小到大的顺序进行扫描线，每个位置只会进入 $\{ a_i\}$ 一次，出 $\{ a_i \}$ 一次，顺便维护一下就能得到每个 $a_i$ 出现的时间段、对应的 $val$。

时间复杂度 $O(n\log n)$。

---

## 叕一道例题

设 $f(u)$ 只考虑 $u$ 这个点的子树，子同构变换的方案数。则 $f(u) =\prod_i l_i! \cdot  \prod_{v\in sub_u} f(v)$，$l_i$ 表示 $u$ 有多少个孩子为第 $i$ 种形状。

考虑这样一种 hash：

1. 对树进行重链剖分，$x$ 的重儿子为**大小严格大于 $\frac{size_x}{2}$ 的儿子**（一个点可能只有轻儿子）
2. 定义一个点的 hash 值为它轻儿子的 hash，一条重链的 hash 为链上每个点的 hash，整棵树的 hash 为根所在重链的 hash

注意到，根据这里的定义，一个点的重儿子不可能与其它儿子的子树同构。

用类似 LCT 的东西维护 hash，只有轻儿子的 hash 改过的点其对答案的贡献会改变，暴力即可。

## LOJ2722 [NOI2018] 情报中心

![](1.jpg)

## UOJ418 [集训队作业2018]  三角形

考虑根节点的答案怎么求：把过程倒序，相当于每次可以在一个点的儿子上放上石头、然后把这个点的石头拿走。即经典的打怪兽问题。

> 设 $a_i$ 为打第 $i$ 个怪兽会掉的血，$b_i$ 为打完第 $i$ 个怪兽（扣除掉的血之后）能回的血（可能为负）。
>
> 优先打可以回血的，然后打会掉血的。
>
> 回血的部分优先打掉血掉得少的。证明可以考虑，交换相邻两个前面比后面掉血多的，答案不会变劣。
>
> 掉血的部分，则是优先打回血多的。证明可以考虑，这相当于是回血部分问题的逆序。

放在树上，则每次选出优先级最高的点，把它和父亲合并，表示选完父亲立刻选它。

对于本题，一个做法是合并 $u,v$ 的时候，只有 $u,v$ 之间的 $i$ 我们会把 $u$ 的子树里的玩意直接加入答案（而不是和父亲合并），树链剖分更新答案即可。另一个做法是维护出先后顺序、在原树上线段树合并（[参考](https://www.cnblogs.com/ZH-comld/p/11000039.html)）。

## CERC2017 I Intrinsic Interval

有两个比较传统的做法：[1](https://www.luogu.com.cn/blog/ywycasm/solution-p4747) [2](https://www.cnblogs.com/yqgAKIOI/p/10087038.html)

## time map

参考这个人的 blog：https://blog.csdn.net/mys_c_k/article/details/88086839

## 世界是个动物园

结论：联盟等价于 scc。

维护当前的点集的拓扑序，考虑当前点应该加入到拓扑序中的位置：找出有走向它的边的最靠后的点 $r$，从它能直接到达的边 $l$，则 $r \ge l-1$（否则区间 $(l,r)$ 中的边既要连向它，又要从它可以直接到达，这显然不可能）。分情况讨论：

1. $r = l-1$：新加入的点单独为一个强连通分量，插入到 $r,l$ 之间即可
2. $l < r$：新加入的点把 $[l,r]$ 全部合并成一个强连通分量

维护点 rank 的技巧：选择重量平衡树，每个点的大小关系用 $[0,1]$ 中的实数表达，重构的时候重新赋值即可。其中 treap 的实现：将旋转改成重构，期望每次要重构的子树是 $O(\log n)$ 的，这是因为设修改的点为 $x$ 则 $y$ 在需要重构的子树中的概率为 $\frac{1}{|y-x|}$。



