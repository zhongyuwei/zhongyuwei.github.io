## CF802C Heidi and Library

如果所有的 $c_i = 1$，可以直接贪心：当需要有书被扔掉的时候，扔掉下一次出现时间最晚的书。证明可以考虑这个策略不劣于其它策略。（？）

对于本题，先认为每一天将当天的书买来并扔掉，然后考虑利用书架保存书可以获得的“额外收益”：设 $a_i$ 之后第一个与 $a_i$ 相同的天为 $a_j$，则我们可以在第 $i$ 天到第 $j$ 天的书架上都占用一个位置，以获得 $c_{a_i}$ 的收益。而条件是每天占用书架的书的数量不超过 $k$。这是个经典的费用流问题。

## Colored Graph

考虑外围的一层边，如果所有边颜色都相同则我们得到了一组解，否则一定存在一个点，它和左右相邻的点之间的边颜色不一样，只要算出去掉这个点之后的一组解即可（因为无论解是用的什么颜色的边，我们都可以用这种颜色把它和相邻的边连起来）。

## Gardening Lesson

一种 Hash 方式：
$$
Hash(x) = ax^2 + bx + c\\
h(u) = \sum_{v\in son_u} Hash(h(v))
$$
（这也是个判断集合是否相同的 hash）

方法 1：把直径的中点作为根进行树哈希，并讨论删掉某个叶子后根的改变情况。

方法 2：利用前面给的 hash 方式，分别算出每种情况下，以每个点为根的 hash 值。这样可以快速得到第一棵树中“以叶子的父亲为根，删去叶子以后整棵树的 hash 值”，统计这个 hash 值在第二棵树中出现了几次即可。

## Dev, please add this

将格子划分成如下图的若干区域。

![](1.jpg)

建图，每个区域为一个点，$i$ 到 $j$ 的有向边表示从 $i$ 可以到 $j$。相当于要求起点为经过了球初始位置的两个点中的一个，经过了奖励的两个点至少有一个要被经过。此外还有两个必要条件：

1. 如果 $S_1$ 不能到 $v$ 且 $S_2$ 不能到 $v$ 则一定不选 $v$
2. 如果 $v_1$ 不能到 $v_2$ 并且 $v_2$ 不能到 $v_1$，那么 $v_1, v_2$ 不能同时被经过

可以发现以上这些也是能够对要经过的点找出哈密尔顿路径的充分条件，因为条件 $2$ 意味着两个点之间必然有边，而竞赛图必然存在哈密尔顿路径。

用 2-sat 求出一个“每个点是否被经过”的情况即可。

## 染色

考虑如何统计 Eulerian 的点集数量：钦定一个生成树，剩下的边可以任意选或者不选，最后通过生成树上的边来调整每个点的度数的奇偶性。

则 $|S|^2$ 相当于钦定两条边必选的方案数。

![image-20200725100633195](C:\Users\钟雨薇\AppData\Roaming\Typora\typora-user-images\image-20200725100633195.png)

搞个生成树的 dfs 树，选一条树边和非树边或者选两条树边（覆盖它的非树边集合相同，方法是UOJ207）。

## Airlines (Bytedance Camp 2020)

存在解的充要条件：

1. 图连通且 Eulerian
2. $\forall v$，不存在一种颜色，$v$ 的这种颜色的出边的数量 $> \frac{deg(v)}{2}$

必要性显然；充分性：首先可以得到若干个分别合法的环，而又公共点的环是可以合并的。设第一个环中的两条边为 $c_1,c_2$，第二个环中的两条边为 $d_1,d_2$，则 $c_1 \neq c_2, d_1 \neq d_2$，因此 $\begin{cases}c_1\neq d_1\\ c_2\neq d_2\end{cases}$ 和 $\begin{cases}c_1\neq d_2\\ c_2\neq d_1\end{cases}$ 中至少有一个成立。

## Cipher (SGU 307)

经典的结论是，只需要第一行和第一列的元素就可以表示出其它所有的元素。

找规律发现 $a_{i,j} = c_{i,j} + (-1)^{i+1}a_{i,1} + (-1)^{j+1}a_{1,j}$，其中 $c_{i,j}$ 为一个常数。

那么枚举 $a_{i,1}$ 和 $a_{1,j}$ 的取值，看这样是否会让 $a_{i,j}$ 的取值不合法，最后跑个 2-sat 即可。

## Dynamic Shortest Path (Codeforces 843D)

[Johnson 算法](https://www.cnblogs.com/gaochundong/p/johnson_algorithm.html)

用类似 Johnson 算法的方法，求出原图的最短路之后，重新建图，令 $w'(u,v) = w(u,v) + dis(u)-dis(v)$，则新图中 $u$ 到 $v$ 的最短路等于它们在原图中的最短路加上 $dis(u) - dis(v)$。注意到在新图上进行了修改以后，新的最短路长度也不会超过 $10^6$，可以用桶优化掉 Dijkstra 的 $\log m$。

## Roundtrip (GYM 100218I)

可以先网络流找出那三条点不相交路径，然后找出一条 $a\to c \to b$，调整一下使得 $a\to c, c\to b$ 分别只与三条点不相交路径中的一条重复，用剩下的那一条来构成环。

也可以枚举三条点不相交路径中的哪一条是保留下来的，然后再去求 $a\to c\to b$。

## Legacy of the Void (UVaLive 7506)

算出单次操作价值的概率分布就可以得到答案。

点分以后，我们实际上要算的就是一堆一次多项式的乘积。因为乘入一个多项式的辅助仅为 $O(W)$，所以可以直接 dfs 计算。这个做法不需要用到 FFT。

``` cpp
void dfs(int u, vector<int> &f) {
	vector<int> tmp_f = Mul(f, g[u]);
    for(int v : son[u]) dfs(v, tmp_f);
    f = Add(f, tmp_f);
}
```

## From G to H and back again

做法 1：搜索，每一次加入原图的一个点或者连接已有的两个点，可以证明复杂度是多项式级别的（？）

做法 2：如果能够确定一个团，剩下的部分都可以依次找下去、确定下来。考虑如何找出一个**可能**的团：找一个度数超过 $2$ 的点，然后枚举它的两条边、当作它们都在同一个团内，找与这几个点都相邻的点加入这个团，然后 check。（？？）

## 绝目编诗 (LOJ 3077)

暴力：直接 $O(n^2(n+m))$ 地找出 $n$ 个简单环，这其中必然有长度相同的。

观察：

1. 加几条边使图连通，不影响答案
2. $m\le 2n$，否则一定有解，因为非树边至少对应一个环

一个更强的结论是：当 $m \ge n+O(\sqrt n)$ 的时候必然有解。而对于 $m \le n + O(\sqrt n)$ 的图，缩掉一度和二度点，可以得到一个大小为 $O(\sqrt n)$ 的图，前面的爆搜算法的复杂度优化到 $O(n^2)$。

结论的证明（probablistic method）：考虑一个无解的图，以 $\frac{1}{\sqrt n}$ 的概率删去每条边之后，期望剩下的环数不超过 $\sum_{i=1}^n (\frac{\sqrt n -1}{\sqrt n})^i \le \sqrt n$，这时再删去 $\sqrt n$ 条边就可以破坏所有的环，得到一张无环图。也就是说，期望下我们只要删除 $m \cdot \frac{1}{\sqrt n} + \sqrt n$ 条边就能得到一张边数不超过 $n$ 的图（而期望的性质意味着至少存在一个方案使我们达到这个期望），也就是 $m - (m \cdot \frac{1}{\sqrt n} + \sqrt n) \le n$，而 $m$ 是 $O(n)$ 的，所以左边的式子是 $m - O(\sqrt n)$。

## James and the Chase (CF1361E)

随机几个点 check，以找出一个好点。

以这个好点为根，搞出一个 dfs 树。考虑树上的每一个点：如果这个点子树内有唯一一条向上的边，则它“是否是好点”与这条边向上到达的点一样；而如果它的子树内有两条或更多向上的边，则这个点一定不合法。

## TreePuzzle (TCO 2014 2A)

由于操作是可逆的，我们只需要考虑将标记的石头向目标位置移动一步：

1. 如果目标方向的子树不是满的，那么挪过去即可
2. 如果标记的石头有至少两个子树不是满的，利用它们挪过去即可
3. 在标记的石头唯一的不满的子树里，找出一个深度最浅且度数不为 $2$ 的位置，利用这个位置挪过去，如果不够则一定无解

## KazHackStan (IZhO 2020 Day2)

对于一次查询：对重心找出 $[l,r]$ 中它感染时间最晚的病毒 $v$，那么除了那个病毒所在的子树之外的部分的贡献都可以容易地计算（因为它们感染时间最晚的病毒一定是 $v$）；把最晚的且不在 $v$ 的子树的病毒挂在 $v$ 的子树上，然后递归到 $v$ 的子树内处理

## Breadboard Capacity (Codeforces 1368H1)

把蓝色的连向源点，红色的连向汇点，则相当于是求一个最大流。

考虑求最小割，也就是把图中的点划分成红蓝两个集合使得割边最少。

结论：划分方案要么是划成若干个整行，要么是划分成若干个整列。

证明：如下图，这样调整以后不会变劣。

![](2.jpg)

动态 dp 即可。

## Shoot the Turrets (GCJ 2017 R2 D)

一种奇妙的证明方法：考虑将问题规模减小。选择一个点 $u$，如果 $u$ 的路径上没有其它机关枪可以直接把它和它匹配的机关枪删掉；如果有，考虑它遇到的第一个机关枪所匹配的点，如果那个点可以直接打这个机关枪就把它们一起删了，否则考虑那个点遇到的第一个机关枪；如此必然会形成环，让环中的点打它们第一个遇到的机关枪就可以了。

## THUWC 19 Day1T3

下面的点为 bfs 序编号，$id(v)$ 表示 bfs 序为 $v$ 的点的真实编号。

性质：对于某个满足 $l \le id(v) \le r$ 的$v$，$v$ 为它所在连通块的 bfs 序最小的点当且仅当不存在 $v' < v$ 满足 $l \le id(v') \le r$ 且 $dis(v,v') \le X$。证明：假设 $v',v$ 在同一连通块中，它们之间存在一条路径 $v = v_1, v_2, \cdots v_k = v'$，我们只要不断找到 $v_i > \max\{ v_{i-1}, v_{i+1}\}$，推出 $v_{i-1}, v_{i+1}$ 之间有边并把 $v_i$ 删掉，最后一定会推出 $v, v'$ 之间有边。

则询问相当于是统计“不存在 $v' < v$ 满足 $l \le id(v') \le r, dis(v,v') \le X$ ”的 $v$ 的数量。点分治对每个 $v$ 求出 $[L_v,R_v]$ 使得 $L_v, R_v$ 中不存在 $dis(v,bfs\_id(v'))\le X$ 的 $v'$，而询问相当于是统计 $L_v \le l, R_v \ge r, l\le v \le r$ 的点数，三维数点即可。

更加优秀的做法：把条件拆分成 $l\le L_v \wedge l\le v \le r, R_v \le r \wedge l \le v \le r, l\le L_v \wedge R_v \le r \wedge l\le v \le r$，而满足 $l \le L_v \wedge R_v \le r$ 的 $v$ 必然满足 $l\le v \le r$，这样就拆分成了三个二维数点问题。