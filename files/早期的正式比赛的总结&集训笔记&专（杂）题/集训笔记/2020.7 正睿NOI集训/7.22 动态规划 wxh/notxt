## Alll Kill

[link to the problem](https://open.kattis.com/problems/allkill)

在最后加一个空的分钟，然后首尾接起来成一个环。

环上总共有 $t+1 - \sum a_i$ 分钟是空的。考虑把题目按照编号从小到大的顺序往这个空的环里插入，则现在的题目必然是在以前插入过的题目中间或者空的分钟之间想出来的。

这样算出来的东西除以环长就是环的数量。

最后要乘上断环为链的方案数，即空的分钟数量。

为什么直接在链上不行？

``` cpp
const int mod=998244353;
inline int Pow(int x,int y) { int res=1; for(;y;y>>=1,x=1ll*x*x%mod) if(y&1) res=1ll*res*x%mod; return res; }
int n,t,a[100010];
int main() {
	rd(n),rd(t);
	int e=t+1;
	for(int i=1;i<=n;++i) rd(a[i]),e-=a[i];
	// e 是空时间段的数量 
	int cur=e+n,res=1;
	for(int i=1;i<=n;++i) {
		res=1ll*res*cur%mod;
		cur+=a[i]-1;
//		cout<<i<<':'<<res<<endl;
	}
	res=1ll*res*Pow(e+n,mod-2)%mod*e%mod;
	printf("%d",res);
	return 0;
}
```

## Amidakuji

$n$ 是奇数的情况：$p_{i,j} = (j+2^i) \bmod n$。这样第 $i$ 个排列中，可以认为 $x$ 先减掉 $2^i$，然后选择是否加上 $2^{i+1}$。由于 $n$ 是奇数，所以跨过 $n$ 就可以改变 $x$ 的奇偶性。

$n\bmod 4 = 0$：在第一个排列中造 $\frac{n}{4}$ 个形如 $(2,0,3,1)$ 的环，后面的同 $n$ 为奇数。

$n \bmod 4 = 2$：在第一个排列中扔掉前两个元素造 $\frac{n-2}{4}$ 个环，在第二个排列中扔掉最后两个元素造 $\frac{n-2}{4}$ 个环，后面的同 $n$ 为奇数。

## Arcs on a Circle

枚举圆弧所放位置的小数部分的大小关系。

## Classic Towers

考虑策略是什么：从最终的状态开始，先把最大的圆盘归位（如果它位置已经是对的了就不需要花费代价；否则花费 $2^{n}$ 的代价把它放到正确的位置，此时其它的圆盘都在第三根柱子上），然后递归考虑更小的圆盘。

那么我们可以依次从大到小确定每个圆盘初始的位置，在状态中记录下初始的状态中三根柱子上分别有多少个圆盘，以及把已经确定初始位置的圆盘放到以后更小的圆盘所在的柱子的编号。

## Clique

枚举选了的最短的圆弧是谁。

![](1.png)

黑色为钦定的最短的圆弧，则红色和蓝色是一定会选的，紫色的可能选也可能不选。

紫色的可以用两个参数来描述：$x$ 表示它在黑色这段上的端点的位置，$y$ 表示它在黑色以外这段上的位置。则一个选法合法当且仅当不存在左边的 $(x_0,y_0)$，右边的 $(x_1,y_1)$，满足 $x_0 < x_1, y_0 < y_1$（即它们没有交）。

设 $dp_{x,y}$ 表示考虑了横坐标小于等于 $x$ 的点，选过的点中左边的最大的 $y_0$ 为 $y$，最多能选的点数。线段树优化一下转移，总复杂度 $O(n^2 \log n)$。

## DFS Count

设现在已经走了的点集为 $S$，停在点 $u$。

枚举下一步的点 $v$，则 $v$ 的子树一定是 $V\setminus S$ 中 $v$ 所在的连通块，子树内的走法是子问题。这样整个子树地转移，可以避免考虑 dfs 的回溯。

## Evacuation

来源：Gym GP of Tokyo

首先 $f(l,r,x)$ 只于 $l,r$ 中的一个（$l,r$ 中离 $x$ 较近的那个）有关。设我们现在要求 $\max_{L\le x \le U}g(r,x)$。

发现 $g$ 满足四边形不等式。把询问用线段树放到 $[L,U]$ 上，用决策单调性优化。

复杂度 $O(n\log^2 n)$。

## Games on DAG

依次考虑 $SG = 0, 1, 2, ...$ 的点集。设 $SG = 0$ 的点集为 $T$，$SG > 0$ 的点集为 $U$，则 $T$ 内部不能连边，$U$ 内部是子问题，每个 $U$ 中的点至少有一条到 $T$ 的出边。状压 DP 即可。

## Graph Coloring

来源：GP of Moscow

每个点选七种颜色当出边，七种颜色当入边。注意到 $\binom{14}{7} > 3000$。

## Horrible Cycles

？

20十连day9 [my submission](http://zhengruioi.com/submission/214341)

## Inversions

做法 1：多项式；对每个 $k$ 都可以算出来。

做法 2：相当于求方程 $0 \le x_i < i, \sum x_i = k$ 的解数。容斥，枚举一些位置超过限制然后搞。相当于是从 $[0,n-1]$ 中选出一些数使得它们的和为 $[0,k]$ 中的某数。想象我们有一个数集，每次给数集中的数整体加上一个 $1$，然后选择是否要再加入一个 $1$。数的数量这一维最多到根号，所以 dp 算方案数的复杂度为 $O(n\sqrt n)$。还要去掉最大的数大于了 $n-1$ 的方案。

```cpp
   rep(i, 1, m) {
      rep(j, 1, k) {
         if(j >= i) f[i][j] = f[i - 1][j - i];
         if(j >= i) (f[i][j] += f[i][j - i]) %= mod;
         if(j >= n + 1) (f[i][j] += mod - f[i - 1][j - n - 1]) %= mod;
      }
   }
```

## Jealous Split

考虑怎么证明 $k=2$ 时一定有解。反证，设序列的最大值为 $M$，且存在 $i$，满足
$$
\left. {
(a_1 + a_2 + \cdots a_{i-1}) - (a_i + a_{i+1} + \cdots a_n) < -M \\
(a_1 + a_2 + \cdots a_i) - (a_{i+1} + a_{i+2} + \cdots a_n) > M
} \right\} \\
\Rightarrow a_i > M
$$
与 $M$ 的定义矛盾。

对于相邻的某两段 $s_i, s_{i+1}$ 来说，如果我们调整它们使得 $|s_i - s_{i+1}|$ 变小了，那么 $s_i^2 + s_{i+1}^2$ 一定变小了。

因此，$\sum_i s_i^2$ 最小的划分一定是合法的。因为如果存在 $|s_i - s_{i-1}| > \max\{ m_i, m_{i-1} \}$，我们可以在不影响其它段的 $s_i$ 的情况下得到更小的 $s_i^2 + s_{i-1}^2$。

用 wqs 二分搞掉 $k$ 这一维然后求解即可。复杂度为 $O(n \log V)$。

---

## LIS vs. LDS

注意到 LIS 和 LDS 的交的大小不超过 1。

设 $f_i$ 为经过了 $i$ 的 LDS 数量。一个 LIS 不合法当且仅当 $f_{i_1} + f_{i_2} + \cdots f_{i_k}$ 为 LDS 的总数量。

在求 LIS 的时候，保留 $\sum f_{i_j}$ 的两个不同的取值，就能保证只要有解一定可以找到。

## Match

称一个字符串合法当且仅当存在一个合法的括号序列和它对应。

做法 1：

> 结论 1：如果 $S[l,r]$ 合法且 $S[l,y]$ 合法则 $S[y+1,r]$ 合法。
>
> 结论 2：设 $p$ 为最大的 $S[p] = S[1]$ 且 $[1,p]$ 合法的位置，则 $1$ 一定与 $p$ 配对，剩下的部分是子问题。另一方面，$p$ 也是最大的满足 $S[1] = S[p]$ 且 $S[p+1,n]$ 合法的位置。
>
> 设 $f(i,c)$ 表示 $i$ 左侧最大的 $j$ 满足 $S_j = c$ 且 $S[j+1,i]$ 合法（注意不要求 $S[i] = c$）。则 $f(i,c) = f(f(i-1,S[i]),c)$。

做法 2：

wxh 说利用九老师那个题的结论，可以推得一个线性做法，留作思考。

## Policeman and a Tree

暴力 dp，状态记录上一步走了哪条边，子树内有多少个小偷，子树外有多少个小偷。转移的时候背包。

## RPS Robots

[link to the problem](https://community.topcoder.com/stat?c=problem_statement&pm=14379)

[link to the problem on vjudge](https://vjudge.net/problem/TopCoder-14379)

令第一个人 $R_1 = 1, S_1 = \omega, P_1 = \omega^2$；第二个人 $R_2 = 1, S_2 = \omega^2, P_2 = \omega$，则相乘起来为 $1$ 的是平手，相乘起来是 $\omega$ 是第一个人输，相乘起来是 $\omega^2$ 是第一个人赢。注意到 $R_1 = \frac{1}{R_2}, S_1 = \frac{1}{S_2}, P_1 = \frac{1}{P_2}$。

用多项式表示字符串，每一项表示字符串中的一个字符，如 $R_1S_1S_1 = 1 + \omega x + \omega x^2$。

则两个人之间有边，当且仅当它们的字符串的循环卷积（$A_i(x) \cdot B_j^R(x)$）处处相等。因为对于这个循环卷积中的系数 $a\omega^2 + b \omega + c$，$a+b+c$ 是确定的，并且我们还分别知道实部和虚部，所以 $a,b,c$ 是可以被解出来的。

IDFT 之后处处相等，等价于 IDFT 之前整个函数除了常数项之外都是 $0$。（因为 IDFT 可以看作是求 $\omega_n^k$ 处的点值）

设 dp 状态为 $S$，表示在 $S$ 中的位置上存在已经选了的人的多项式在这个位置不为 $0$。

![](2.png)

这样做是 $O(3^{k})$ 的，可以接受。

DFT 时的优化：注意到 $\overline{\omega_3^k} = \omega_3^{3-k}$。

## Search Engine

加字符相当于 SAM 上走 parent 树或者走转移边。

注意到无论怎么走，$f$ 不会变大，所以肯定会优先走 $f$ 不变的 parent 树边。这样可以得到一个状态数为 SAM 结点数的 DP。

## Simple Counting Problems

https://blog.csdn.net/wxh010910/article/details/79110440

## The Karting

线头DP。

$t>0$ 的时候反复横跳应该是对的。

## Tree Nesting

状压已经匹配好的子树是哪些。最后除掉 $T$ 子同构的方案数。

## Unicyclic Graph Counting

直接对着一个基环树求 prufer 序列，则环上的点出现 $d_i - 2$ 次，不在环上的点出现 $d_i - 1$ 次，并且最后一个点要在环上。

要特判整个图是一个大环的情况。

## Wise Man

不考虑取模的时候就类似于我高一上学期的时候的某场比赛的那个题。状态设为 $\overline{000\cdots 000x}$，状态数是 $\log^2 n$ 级别的，然后直接 dp。

考虑取模的话，由于取模后的数一定是 $[0,10)$ 的，所以可以建出一个点为 $[0,10)$ 中的整数的图，然后找出循环节，最后再暴力即可。

## Xor Rank

[link to the problem](https://community.topcoder.com/stat?c=problem_statement&pm=14436&rd=16841)

[wxh's blog](https://blog.csdn.net/wxh010910/article/details/72510375)

下面考虑的是消得只剩下对角线的线性基。

第一个限制：第 $r_i$ 大的数就是 $r_i$ 的二进制表示中的1 对应的基的异或。由此可以得到一个形如 $\bigoplus_{i \in r} x_i = v$ 的方程。

第二个限制：假设让第 $i$ 个基对应的第 $j$ 位，则必须有：如果 $r$ 的第 $i$ 位是 $1$，那么 $v$ 的第 $j$ 位必须是 $1$。

第三个限制：如果 $r$ 的最高位是 $i$，那么第 $i$ 个基对应的位必须是 $v$ 的最高位。

如何满足第一个限制：不妨让不为最高位的基随便取，让最高位的基调整使得条件成立。

注意特判无解和无数多组解的情况。

## Contest Strategy

按照这种方式来算罚时：假设现在确定了写题的顺序，第 $i$ 个写的题耗时 $a_i$，则总耗时为 $\sum_i a_i(n-i+1)$。下面说的第 $i$ 个问题的贡献就是指 $a_i(n-i+1)$。

从大到小依次加入题，考虑答案的变化量的期望。首先是这个题本身的贡献，按照它加在前 $k$ 个中、它没有加在前 $k$ 个中分别讨论一下。然后考虑它给别的题的贡献的增加量，对于排第 $i$ 位的题目，它造成增加量的方案数是 $n - i +1 - (k-1)$，则增加量的期望为 $a_i (n-i+1-(k-1)) = a_i(n-i+1) - (k-1)a_i$，前者可以通过在加入这个题之前的答案得到，后者可以直接算得。