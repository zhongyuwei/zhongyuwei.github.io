## KMP的一个有用结论

```cpp
int p=nxt[0]=-1;
for(int i=1;i<=n;i++) {
    while(~p&&str[p+1]!=str[i]) p=nxt[p];
    nxt[i]=++p;
}
```

上面这份代码的复杂度是$O(n)$的，并且，**$p$的变化量的总和也是$O(n)$的**（可以考虑$p$每一次只会增加1，减少若干，因为只会增加到$n$，而减少不会让$p$小于$-1$，所以复杂度是线性的）。

## RANK-KMP

### 问题 (CEOI2011 Matching)

定义两个长度为$N$的序列$A$和$B$相似，当且仅当对于任意$i,j$，有$[ A_i < A_j ] = [ B_i < B_j ]$。给定序列$X,Y$，求$X$中有几个长度为$|Y|$的连续子序列和$Y$相似。$|X|,|Y|\le 10^6$。

### Sol 1

类似地定义border为最长的相似的前缀和后缀。套用kmp算法，则瓶颈在于判断如何判断两个字符串在加入末尾的元素之后仍然相似。

仔细观察发现，只要末尾元素在所有元素中的排名相同，这两个串就相似。

一种简单粗暴的方法是直接可持久化线段树。

巧妙的树状数组做法：利用kmp中$p$的变化量线性的性质，暴力用树状数组维护$X[1\cdots p],X[i-p+1\cdots i]$的元素。

### Sol 2

定义一个序列的hash值为：$\sum rank_i \cdot q^i$，其中$rank_i$为第$i$个元素在整个序列中出现过的元素中的排名。用树状数组可以求出$X$所有长度为$|Y|$的子串的hash值。

## NOI2014 动物园

一种有趣的方法：观察发现，如果最长border的长度小于这个串长度的一半，那么这个串一定是形如$AB^k$的循环串，并且$\forall k > 1$，都满足$AB^k$的最长border是$AB^{k-1}$。这样可以直接跳到$AB$。这是一个常数较小的带$\log n$的做法。

## 树上kmp

给定一棵Trie，求每个点到根的路径表示的字符串的最长Border。$N\le 10^6$，字符集还蛮大的。

做法：

1. 用类似AC自动机的方法，维护$ch_{x,c}$表示$x$代表的串后面加上$c$后的fail。因为字符集比较大所以要用数据结构维护，会带上一个$\log n$。
2. 对跳父亲fail的这一步做一些优化，我们令每次从$AB^k$跳到$AB$，这样每次只会跳$O(\log n)$次，且常数较小。

## CF1286E

利用$p$的变化量线性的性质，维护每个前缀的所有border的权值和。

## 缺位匹配

给定串$S,T$，求$S$有几个子串满足改动不超过$k$个字符就可以和$T$相等
|S|, |T| ≤ 105，k ≤ 2

枚举$S$的每个长度为$|T|$的子串，每次贪心地往后匹配（匹配补上再用缺位）。

## bzoj3277

一个$O(\log n\cdot \sum |S_i|)$处理出每个子串在多少个字符串中出现过的方法：对于每个$S_i$，拿出它所有前缀的结束节点，把它们按照dfs序排序之后，在关键点上打+1标记，在相邻关键点的lca上打-1标记。

## 查询第$K$小子串

强行要用SAM做的方法：设$dp_{x,k}$表示从$x$出发字典序第$k$小的子串的信息，转移的时候直接用可持久化treap合并，就能够做到单$\log_n$的复杂度。

## 例题 6

给定字符串$S$。对于每个$k$，求把$S_k$变成`#`后，$S$的本质不同的子串个数。$1\le |S|\le 10^5$

SOL：包含`#`的串必然两两不同，所以只需要考虑求不包含`#`的子串的贡献。而对于某个$k$，我们需要求出$k-1$前缀中的本质不同的子串数 + $n-k$的后缀中的本质不同的子串数 - 在前缀和后缀中都出现了的子串数。前两者很好算。对于SAM上的每个节点，我们只需要考虑它的endpos最靠左的和最靠右的出现位置，然后贡献可以用二次差分统计。