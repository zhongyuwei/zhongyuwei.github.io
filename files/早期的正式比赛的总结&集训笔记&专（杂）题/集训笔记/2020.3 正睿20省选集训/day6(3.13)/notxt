## 动态规划

### 小题题

- $n\times m$ 的网格，$(1,x)$ 和 $(x,1)$ 上标记着走到了这个点的人赢或者输
- 有一个棋子初始在 $(a,b)$ ，两个人轮流移动，每次可以从 $(x,y)$ 走到 $(x-1,y)$ 或者 $(x,y-1)$ 。
- 问谁会赢
- $n,m\le 10^5$

朴素的 dp 是在一个 $n\times m$ 的方格上递推：`f[i][j]=!(f[i-1][j]&f[i][j-1])` 。

可以证明第二层开始，对角线上的数相等。（打表程序：[p1.cpp](p1.cpp)）

（0表示会输，1表示会赢）

![1.jpg](https://i.loli.net/2020/03/15/tHTJ4wvUlO6aKmh.jpg)

![2.jpg](https://i.loli.net/2020/03/16/7MndURA46ZDjtHl.jpg)

口胡的略证：

- 第一层不存在连续的 2 个 0
- 第二层不存在连续的 3 个 1
- 只要上一层没有连续的 3 个 1 且没有连续的 2 个 0，就会始终有 $f_{i,j} = f_{i-1,j-1}$ 。这个我证不来，就穷举了所有可能的情况（框里面的是已知的 dp 值；倒数第二个是因为，通过已知的可以推出三个连续的 1 ）：

![3.jpg](https://i.loli.net/2020/03/15/kJSxRB56GUQmnqo.jpg)

### AGC002E

简单转化之后，变成了：网格中有个阶梯形状的轮廓线，棋子从 $(0,0)$ 开始走，每次可以往左走或者往上走，走到边界的那一步的操作者输（边界上的点是必胜态）。

可以证明，如果 $(x+1,y+1)$ 不在边界上，那么 $(x,y)$ 的胜负状态和 $(x+1,y+1)$ 的胜负状态相同。

证明：

1）可以从 $(x+1,y+1)$ 为必败态推出 $(x,y)$ 为必败态：如果 $(x+1,y+1)$ 必败，那么 $(x,y+1), (x+1,y)$ 是必胜态，那么 $(x,y)$ 就必败。

2）可以从 $(x+1,y+1), (x+2,y+2)$ 是必胜态推出 $(x,y)$ 是必胜态：$(x+3,y+2)$ 和 $(x+2,y+3)$ 中至少有一个是必败态，我们假设 $(x+3,y+2)$ 是必败态，可以推出：

\ |x | x+1 | x+2 | x+3 |
-|-|-|-|-|
y+2 | * | * | *1* | *0* |
y+1 | * | *1* | 0 (b) | 1 (a) |
y | 1 (e) | 0 (d) | 1 (c) | * |

其中，* 表示不确定，斜体表示已知的条件，(a) ~ (e) 代表推理的顺序。

对于 $(x+2,y+3)$ 的情况可以同理证明。

代码实现上，从 $(0,0)$ 出发往右上走直到下一步会碰到边界，然后算出上方和右边的格子的状态。

``` cpp
int main() {
	rd(n);
	for(int i=0;i<n;++i) rd(a[i]);
	sort(a,a+n,greater<int>());
	int x=0,y=0;
	while(y+1<a[x+1]) x++,y++;
	
	int t1=!((a[x]-(y+1))&1);
	int r=x; while(y<a[r+1]) r++;
	int t2=!((r+1-(x+1))&1);
	
	if(!(t1&t2)) printf("First");
	else printf("Second");
	return 0;
}
```

### 某个题

给定两个字符串 $s,t$ ，Alice 和 Bob 每次可以删掉 $s$ 最前面或者最后面的一个字符。若一个人操作后 $s$ 变成了 $t$ 的子串（如果删成了空串也算是 $t$ 的子串），那么这个人就输了。问谁会赢。$|s|,|t|\le 10^6$

对每个 $l$ 找出最长的 $r$ 使得 $s_{l\cdots r}$ 是 $t$ 的子串。这样以后，问题就转化成：有一个阶梯形的轮廓，每次从 $(1,n)$ 往右或者往下走，碰到边界的人输，问最后谁会输。做法和上一道题 AGC022E 是一样的。

## 平等博弈（SG）

### 0

Nim 游戏，每次可以取 $1$ 到 $k$ 个。

~~打表~~合理推导发现 $sg(n)=n\bmod {(k+1)}$

### 1

Nim 游戏，每次可以取 $l$ 到 $r$ 个。

手玩发现 $n\bmod (l+r)$ 小于等于 $l-1$ 的时候必败，否则必胜；对应的 $sg(n)=\lfloor\frac{n\bmod {(l+r)}}{l}\rfloor$

### 2

有 $n$ 堆石子，每次可以从某一堆里取走任意多个石头，或者把一堆石头分裂成两堆。不能操作者输。

 打表发现（[p2.cpp](p2.cpp)）：
$$
\begin{aligned}
sg(n) = \begin{cases}
n & n\equiv 1\pmod 4\\
n & n\equiv 2\pmod 4\\
n+1 & n\equiv 3\pmod 4\\
n-1 & n\equiv 0\pmod 4\\
\end{cases}
\end{aligned}
$$

### 3

Nim 游戏，每次能拿掉 $d$ 个石头，其中 $d$ 是当前石头数量的任意一个因子。

[p3.cpp](p3.cpp) 找规律发现是 $sg(n)=lowbit(n)+1$ ，$sg(1)=1,sg(4)=3,sg(5)=1$

### 4

Nim 游戏，每次能拿掉 $d$ 个石头，其中 $d$ 与当前石头数量互质。

[p4.cpp](p4.cpp) 找规律发现：设 $p_1<p_2<\cdots$ 为质数，则：
$$
\begin{aligned}
sg(n) = \begin{cases}
1 & n=1\\
0 & n \text{ is even}\\
k & p_k \text{ is the smallest prime that divides } n
\end{cases}
\end{aligned}
$$

### PE306

有个 $1\times n$ 的长条格子，一次操作可以拿走连续的两个格子（格子的位置不变），不能操作者输。问谁会输。

$sg(n) = mex\{sg(i),sg(n-2-i)\}$ ，打出来的表是循环的：

```txt
1 1 2 0 3 1 1 0 3 3 2 2 4 0 5 2 2 3 3 0 1 1 3 0 2 1 1 0 4 5 2 7 4 0 
1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 2 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4 8 
1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4 8 
1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4 8 
1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4 8 
1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4
```

如何知道循环节长度：拿一个支持自动换行的记事本，拖动窗口的宽度。windows 的 notepad 可以在 `格式-自动换行` 中打开自动换行。

### CF102341G

有 $n$ 层积木，每一层有三块积木并排放。一堆积木稳定的条件是：

- 每层至少有一块
- 如果一层只有一块，那么一定在中间
- 不存在相邻的两层都只有一块

两个人轮流拿走一块积木，要求拿走之后积木不会倒，不能拿的人输。问谁会赢。$n\le 20$

Sol：

- 如果有一层是 010 或者 101 ，那么这一层就再也不能动了。我们只需要考虑这些不能动的层之间的子游戏的组合即可。
- 这样以后可能的状态只有 `111` `110` `011` 这三种，而考虑到 `110` 和 `011` 能够转移到的状态是一样的，所以每层本质不同的状态只有两种，直接状压 dp 即可。

### SPOJ COT3

有一棵有根树，每次可以选择一个白点，把它到根的路径上的所有点都染黑。初始所有点都是白色。不能操作者输，问谁会赢。$n\le 10^5$

Sol：

- 设 $sg(u)$ 为以 $u$ 为根的子树的子游戏的 $sg$ 值，可以暴力枚举下一个被删掉的、子树内的点。这样可以得到一个多项式算法。
- 记 $p_{u,v}$ 表示 $u$ 子树去掉 $v$ 到 $u$ 的路径之后的局面的 $sg$ 值，考虑从 $p_{u,v}$ 与 $p_{fa_u,v}$ 的区别，实际上就是异或上了 $fa_u$ 的其它儿子的 $sg$ 值。
- 用 Trie 树合并（类似线段树合并的技巧）来维护，区间异或可以用交换左右儿子的标记维护，查询第一个没有出现的数只需要维护区间内是不是所有数都出现过即可。

### CF1091H

右移左边的两个棋子等价于左移最右边的棋子；左移右边的两个棋子同理。所以这是一个公平游戏。原问题等价于是两个 Nim 游戏的组合。

因为打表发现这个 Nim 的 sg 值很小，所以可以对每个 $x$ 维护一个 01 串 $p_{x,u}$ 表示 $u$ 的后继中是否有 $sg = x$ 的点，查询的时候从小到大枚举 $x$ 查询即可。实现上：用 bitset 维护 $p_x$；设 $s$ 为所有可能的步数的集合，让 `p[sg[i]] |= (s<<i)` 即可。复杂度是 $O(\sum sg_i + \frac{n^2}{w})$ 。

### N 阶 Nim （Nim-K游戏）

### CCPC Harbin 2019 G / CF102394G

设 $c_i(0\le c_i \le 2)$ 表示石头数量为 $a_i$ 的石头堆被 Bob 选了多少个，则 Bob 会赢当且仅当 $\sum c_ia_i$ 在三进制不进位的加法中等于 0 。

所以在 Bob 选集合之前，Alice 赢的条件就是所有的 $a_i$ 线性无关。

那么问题就转化成了一个权值最大的线性基。维护线性基里面每一个基的权值；插入新元素的时候，如果某一位上，它和某个基在这一位都不是 0 ，就保留权值较大的那个在这一位，而把另一个数的这一位消成零并继续尝试插入这个数。

优化计算的过程：用 bitset / long long 分别记录哪些位是 0 ，哪些位是 1 （剩下的位都是 2），然后可以用位运算优化两个向量的减法。

### Apia Du 的猛男题

![prob_0.jpg](prob_0.jpg)

看上去很合理的结论：一个包的 $sg$ 值是它最多能分出多少个不交的子集，满足每个子集的数字的和都是 4 的倍数（显然 $sg(G)=x$ 的局面一定能够转移到 sg 值为 $y\in [0,x)$ 的局面）。这个玩意直接贪心算：首先 4 单独一组；1 和 3 配；2 和 2 配；1，1，2 配；1，1，1，1 配。

算出每个包的 sg 值之后，用线性基算有多少个子集满足包的 sg 值的异或和为 0 。

### 阶梯 Nim

### zroj628

- 你有一个 $1\times n$ 的棋盘，你要在上面放上 $k$ 个普通棋子和一个特殊棋子，要求每个格子至多只能放上一个棋子
- Alice 和 Bob 轮流进行游戏，每次可以选择将一个棋子往左移若干格，当然不能跳过其他的棋子或者占用其他棋子的格子，也可以移除当前棋盘上相对位置最左边的一个棋子。移除了特殊棋子的玩家为胜者。
- 求有多少种初始状态，先手可以必胜，由于答案很大,输岀对 $10^9+7$ 取模的值。
- $n\le 10^{18}, k\le 8000$

由于这个规则看起来很像阶梯 Nim ，所以往那个方向猜结论。结论是：特判掉特殊棋子在最左边的位置的情况之后，当 $k$ 为偶数的时候，也就是第一个需要考虑的段的右端点是第一个棋子的时候，如果第二个棋子不是特殊棋子则要让第一段的长度 ++ 表示可以把棋子拿掉，否则不变；然后此时的游戏的阶梯 Nim 的结果就是答案。

注意到：1）尽管会有移除棋子的操作，但是需要考虑的段是始终不变的；~~）手玩一下找不出这个结论的反例；~~

接下来的问题是怎么数。一通讨论之后，问题转化成，有 $m$ 个非负整数变量 $c_1,c_2\cdots c_m$ ，要求 $\sum c_i = n-m$ 并且 $c_1 \bigoplus c_3 \bigoplus c_5 \cdots =0$ ，求方案数。

设 $S=n-m$ 。

设 $f_{i,j}$ 表示到 $2^i$ 这一位，$S$ 减去填入的数是 $j \cdot 2^i + (S\bmod {2^{i}})$ 。发现如果 $j > c$ 那么这个状态一定没用，因为在剩下的 $i$ 位每个数最大就只能取到 $2^i-1$ ，而 $c(2^i-1)$ 必然小于 $j \cdot 2^i + (S\bmod {2^{i}})$ 。这样就能有个 $k^3\log n$ 的做法，用 FFT 优化一下就能做到 $k\log k \log n$ 。

### 翻硬币

### CF494E

### 树上翻硬币

- 有一棵有根树，每个节点上有一个硬币。
- 每次可以选择一个正面的硬币，然后在他的所有后代中选择一个子集翻转。
- 谁不能动算输。

一个点的 sg 值是 2 的（到叶子的最远距离）次幂。可以归纳证明。

### 砍树游戏

- 给定一棵有根树，两个人轮流操作，每次可以选择一条边删掉它，然后扔掉根不在的那个连通块，无法操
  作的输

一棵有根树在根的位置往上再长出一条边之后，sg 值会 + 1。可以考虑原本 sg 是 0 的状态在上面多长一条边之后 sg 值会变成 1 ， sg 大于 0 的也是同理，归纳即可。**长出一条边这个操作，本质上是每个状态都多了一个到 0 的转移。**

所以一个子树的 sg 值是所有（儿子的子树的 sg 值+1）的异或和。

### 砍树游戏ex

- 给定一棵有根树，每条边可能是重边
- 两个人轮流操作，每次可以选择一条边删掉它，然后扔掉根不在的那个连通块，无法操作的输

Fusion Principle，参考[Winning Ways for Your Mathematical Plays(chapter7, P189-P176).pdf](Winning Ways for Your Mathematical Plays(chapter7, P189-P176).pdf)

来源：Bytedance 网络赛

### CCPC qhd 2019 I

- 有一棵有根树，每次选择可以选择一个叶子集合删掉。
- 问先手能不能删完。

找规律发现一个状态必败，当且仅当所有的叶子到第一个儿子数量大于 1 的祖先的路径长度都是偶数。

### Anti-SG

- 如果每堆石头都是 1 个，那么就看石头的堆数。
- 否则，先手必胜当且仅当整个游戏的 SG 值大于 0 。

### Nim 积

学不会的。。。

### Welter Game

有 $n$ 堆石子，你要玩 Nim ，要求任何时候不能有两个堆的石头个数一样。

source: [kupc2015 L](https://atcoder.jp/contests/kupc2015/tasks/kupc2015_l)

> - [a | b | c] 表示石头数量为 a,b,c 的游戏的组合
> - 很遗憾这是个结论题。
> - [a | b]=(a xor b) - 1
> - 每次删除最匹配的数对，也就是模2^k同余，其中k最大的
数对
> - [a | b | c | ...] = [a | b] xor [c | d] xor ...
> - 三堆石子必败的充要条件是 (a+1) xor (b+1) xor (c+1) == 0

### infinite Nimber

一个二维的例题 [link](http://acm.hdu.edu.cn/showproblem.php?pid=6173)

- You are given an infinity board with $d$ dimensions and $n$ tokens on the board. You can regard the coordinate of each token as a $d$-dimension vector. The coordinate of $i$-th token is $(x_1,x_2,\cdots x_d)$.
- Alice and Bob take turns playing, starting with Alice. In each turn, the player chooses a token with coordinate $(x_1,x_2,\cdots x_d)$ and move to a valid cell $(y_1,y_2,\cdots y_d)$. The cell is valid if $y_1,y_2,\cdots y_d > 0$ and $x>y$ in the lexicographic order. For example, you can move from $(2, 2, 2)$ to $(2, 1, 100)$ or $(1, 100, 1)$.
- A player loses if he cannot make a move on his turn. Determine the winner if both players play optimally.

定义为 $w$ 为无穷大，则一个状态的 Nimber 可以用 $\sum (x_i-1) w^{i-1}$ 表示。两个数的异或定义为每一维异或起来。

所以先手必胜当且仅当每一维的数 - 1 的异或和都是 0 。

### CF1149E

- 有一个DAG，每次你可以选择一个点权大于 0 的点，减小这个点的点权，然后修改它的所有后继的权值。
- 问先手必胜策略。

叶子节点的 sg 值为（点权 * $w^0$）。而 $mex\{ (0,x \cdot w^0), (1,x\cdot w^0), \cdots (A-1,x \cdot w^0)\} = Aw^1$ ，其中 $x$ 表示任意的数。以此类推。得出结论：记点 $u$ 的深度 $D(u) = mex_{v} \{ D(v)\}$ ，则 $sg(u) = val_u \cdot w^{D(u)}$ 。

先手必胜当且仅当所有点的 sg 值的异或和不为 0 。证明就直接拿着 Nim 的证明方法上就可以了。

## 杂题

### Moscow Region 2019 I

- 你有一个 $n$ 段的分段线性函数$(0,x_0),(1,x_1),(2,x_2) \cdots$
- Alice 和 Bob 玩游戏，他们会选择两个参数 $A$ 和 $eps$，一开始 $T=A$ ，Alice 选择一个 $0$ 到 $n$ 之间的实数 $x$ 。
- 两个人轮流操作，一次操作的时候会选择一个 $x'$ 满足 $|x'-x|\le T$ ，令 $x=x', T=T-eps$
- 当 $T\le 0$ 时游戏结束
- Alice 想让 $x$ 的函数值尽量小，Bob 想让函数值尽量大。
- 问 $eps$ 趋向于 $0$ 的时候，最后数字是多大。
- $n\le 10^5$

首先二分一下答案，转化成判断最后会停留在 0/1 的位置。

考虑一个坐标系：横坐标表示 $x$ ，纵坐标表示 $T$ 。则坐标系内每个点表示了一个状态。

![4.png](4.png)


蓝色区域（三角形的边的斜率的绝对值是 2 ）：无论是谁先操作，最后都会走到 0 或者 1。以最左边的三角形为例， 如果是 Alice 操作肯定会让 $x'=x$；而如果是 Bob 操作，他往右移 $T$ 之后，Alice 可以往左移 $T-eps$ ，这样一轮以后，$T$ 减少了 $2eps$ 而 $x$ 往右了 $eps$ 。所以，对于蓝色区域中的一个点，它能到达的区域就是以它为最高点的、两条边斜率为 2 和 -2 的三角形。

绿色区域：如果操作的人想要 0 ，那么可以一步移到 0/0 的区域，如此得到 0 ；如果操作的人想要 1 ，那么可以一步移到 1/1 的区域，如此得到 1 。

红色区域：无论是谁操作，最终都会得到 1 。如果是想得到 0 的人操作，他无论是走到 1/1 还是走到 0/1 都会导致最终得到 0 ；而对于想得到 1 的人来说，他只需要等到状态在绿色的区域上方一点点的时候，一步走进 1/1 的区域中。

以此类推，我们可以依次合并所有的三角形，最后根据这些三角形和 $y=A$ 这条直线相交的区域来判断最终的结果。

