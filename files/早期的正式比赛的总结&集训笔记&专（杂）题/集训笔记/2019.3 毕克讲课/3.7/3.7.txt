## 数据结构杂题

### [CF102028J  Carpets Removal](https://codeforces.com/gym/102028/problem/J)

有一个$m\times m$的方格图，有$n$张地毯，每张地毯覆盖了一个矩形区域，矩形的四个角都在格点上。你可以取走恰好2个地毯，最小化方格图中被至少一张地毯覆盖过的区域的面积。$m\le 1500,n\le 3\times 10^5$

Solution：首先处理出图中每一个格点，被多少个地毯覆盖过，覆盖它的地毯的编号的和以及覆盖它的地毯的编号的平方和。

两个地毯不相交的情况：处理出每张地毯上没有被其它的地毯覆盖的部分的面积，然后选这个面积最大的两个地毯。

两个地毯有交的情况：枚举交的格点，可以通过之前处理的信息解出覆盖这个格点的两张地毯是哪两张，然后更新答案。

如果我们需要解出来的数比较大，即维护平方和会炸long long，则可以考虑取一个模数。而如果模数$p$是形如$4k+3$的质数（30007或者1000 000 007），对于任意一个$a$，倘若$a$是$p$的二次剩余，那么有$x\equiv \pm a^{(p+1)\over 4}\mod p$。具体介绍见[wikipedia: prime or prime power modulus](https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus)。另一种办法是预处理指标（也就是$1$到$n$分别是原根的多少次幂），然后把乘法转化为指标的加法，把平方和改为维护所有编号的乘积。



### Dynamic GCD

给一个长度为$n$的序列，支持两种操作：1.区间加一个数。2.查询一个区间中所有数的gcd。$n,q\le 100000$

Solution：显然$gcd(a_1,a_2,a_3\cdots a_n)= gcd(a_1,a_2-a_1,a_3-a_2,\cdots )$，但是要注意$gcd(a_1,a_2,a_3\cdots a_n) \not = gcd(a_2-a_1,a_3-a_2,\cdots a_n-a_{n-1} )$。

维护一下差分数组的区间gcd就可以了。



### bzoj2877 魔幻棋盘

一个$n\times m$的二维矩阵，支持如下操作：1.给某一个子矩阵中的所有位置都加上一个数。2.查询某个子矩阵内所有的数的$gcd$。保证所有的二操作都会包含点$(x_0,y_0)$。$nm\le 500000,q\le 100000$

Solution：考虑二维差分数组$d_{i,j} = a_{i,j} - a{i-1,j}- a{i,j-1} + a{i-1,j-1} $。2询问的答案实际上就是询问的矩阵内的差分数组和其中的某一个位置的真实值的$gcd$。



### 上帝造题的七分钟

如果一定要用线段树做的话，标记永久化应该可以保证复杂度。



### [Codechef SEGSUMQ](https://www.codechef.com/problems/SEGSUMQ)

有两个长度为$N$的序列$A$和$B$。给$m$个询问，每次给出$L,R,C,D$，你需要回答$\sum_{L\le i\le R} max\{ 0,A_i\times C - B_i\times D\}$。强制在线。$n,m\le 10^4$

Solution：容易看出$i$是否产生贡献只与$A_i\over B_i$和$C\over D$的大小有关。

方法1：建归并树，树上每一个节点是这个区间内的所有位置按照$A_i\over B_i$的结果。

方法2：主席树，外层权值内层区间，先找出询问对应的权值区间，然后再进行查询。

方法3：用动态开点的BIT实现可持久化数组。具体地，树状数组的每一个位置开一个vector，修改某个位置的时候，就在这个位置的vector中加入一个元素，存下修改后的值和修改的时间。查询的时候就在对应位置中的vector里面二分查找需要的版本。

### [SPOJ XXXXXXXX](https://www.spoj.com/problems/XXXXXXXX/)

维护一个序列，支持查询区间内所有不同的数字的和，单点修改某个位置的值。$n\le 50000$

Solution：一种有趣的矩阵构造（假设原序列是1，2，2，1）

![](D:\钟雨薇\2018-2019下\3.7\数颜色，矩阵构造.png)

对角线上是对应位置的数。对于每一列，假设这个位置的数上一次出现是在位置$pre_i$，那么就在这一列的$pre_i$行减去这个数。

区间$[l,r]$对应的答案就是$(l,l)$到$(r,r)$这个子矩阵中所有位置的数的和。

可以用动态开点的树状数组来实现（反正可以离线），处理出所有需要用到的位置，给它们编号。这些位置的数量大概是$O((n+q)\log ^2 n $的。



## Atcoder选讲



### [Akashic Records](https://atcoder.jp/contests/cf17-relay-open/tasks/relay2_h)

有一个无尽长的数组。初始所有的位置都是$0$。有$q$次操作，每一次操作对数组中，所有下标为$m_i$的倍数的位置，权值加上一个数$x_i$。问所有操作后数组中最大的数的权值。$-10^6\le x_i\le 10^5,2\le m_i\le 300,q\le 299$

Solution：考虑到答案的位置至多包含一个大于$\sqrt 300 $的质因子，那么我们可以直接暴力枚举小于$\sqrt 300$的质因子的选择情况，最后再枚举大于$\sqrt 300$的质因子选哪一个。



### [Largest Smallest Cyclic Shift](https://code-festival-2017-qualb.contest.atcoder.jp/tasks/code_festival_2017_qualb_f)

有$3$种字符，给出每个字符的出现次数，问最小表示法最大的字符串。

Solution：用优先队列维护当前已经拼出来的串，每一次取出队列中字典序最小的串和字典序最大的串，把字典序最小的和最大的拼起来，然后再放会优先队列，知道队列中只剩下一个串。



### [Nice to meet you](https://atcoder.jp/contests/cf17-relay-open/tasks/relay2_i)

给一张无向图中的所有边定向，问从$1$号点出发能到达的点的集合和从$2$号点出发的点的集合有交的方案数。$n\le 15$

Solution：考虑计算这两个集合没有交的方案数。设$f[S]$为从$1$出发恰好能够到达$S$集合中的连边方案数，则$S$内的边、$S$外的边都随意连，$S$与$S$的补集之间的边一定是从$S$外连向$S$内，最后减掉$S$内部的点不连通的情况，即枚举$S$的真子集，减掉只有这个子集内的点连通的情况。最后枚举从$1$，$2$出发可以到达的集合即可。

需要注意，最终枚举的、从$1$、$2$出发可以到达的集合之间，在原图中一定没有边，否则一定存在一个节点$1,2$都可以到达。直接枚举从两个城市从两个城市出发可以到达的集合、令这两个集合有交，会非常难考虑两个集合之间的边。



### [Indifferent](https://atcoder.jp/contests/cf17-relay-open/tasks/relay2_j)

有$2N$个数，每一轮以如下形式进行：$B$拿走其中最大的，然后$A$从中随机拿走一个。问$B$拿走的数的和的期望值。$N\le 10^5$

Solution：设$f_{i,n}$表示有$n$个数时，第$i$大的数最终被$B$拿走的概率，则对于$i\not = n$，有$f_{i,n} = {i-1\over 2n-1} f_{i-2,n-2} + {2n-i\over 2n-1}f_{i-1,n-2}$。可以发现$f_{i,2n} = {2n-i\over 2n-1}$。



###  [Increment and Swap](https://atcoder.jp/contests/cf17-exhibition-open/tasks/cf17_exhibition_b)

一个长度为$n$的序列，有两种操作：1.交换两个相邻的元素。2.将某个元素的值+1。问最少进行多少次操作，这个序列中的元素可以变得单调不降。$n\le 200000$

Solution：[官方题解讲得很清楚](https://img.atcoder.jp/cf17-exhibition-open/editorial.pdf)

我们逐位确定序列中的每一个元素最终的取值。第$i$个位置最终取$v$的代价，是$v-A_i$再加上前$i-1$个数中，最终取值大于$v$的数的数量。

可以证明，如果我们每一次直接选择花费最小的$v$，最终的答案就是最优解。

考虑某一个位置，我们的策略让它最终取了$w$，而最优策略是让它最终取$w'$。首先，如果$w'>w$，那么把$w'$改成$w$一定不会更差，这是因为，改了过后，我们当前的这一步的花费变小了，并且对之后的操作的贡献也会变少（即对于后面的某个位置，它前面的、比它大的数变少了） 。对于$w'<w$的情况，由于此时，所有小于$w$的权值的花费已经都比$w$的花费大，无论后面的数取什么权值，所有小于$w$的权值的花费一定不会变得小于$w$的花费，所以在这一步以更大的花费取$w'$也是没有意义的。



### [Ancient Tree Record](https://atcoder.jp/contests/cf17-tournament-round1-open/tasks/asaporo2_d)

给出树的形态，以及树上所有的点到某一个点的距离之和$s_i$，构造树的边权使得所有的信息被满足。$n\le 100000$

Solution：考虑某条边的连接的两个端点$u,v$以及这条边两边的子树的大小$sz_u$与$sz_v$，有$s_u =  s_v - e\cdot sz_u + e\cdot sz_v$，当$sz_u\not = sz_v$的时候可以直接解出边权。$sz_u=sz_v$的边至多只有一条，可以通过其他边的边权推出。



### [Distribute Numbers](https://atcoder.jp/contests/cf17-final-open/tasks/cf17_final_f)

有$n$张纸，你需要在每一张纸上写$k$个$[1,n]$的数字，要求一张纸上一个数字不能出现两次，并且每个数字必须恰好被写$k$次，并且任意两张纸的交集大小为$1$。输出$n\in [1000,2000],k\ge 1​$的任意一种方案。

[题解](https://img.atcoder.jp/cf17-final/editorial.pdf)



### [Four coloring](https://atcoder.jp/contests/code-festival-2017-quala/tasks/code_festival_2017_quala_d)

对一个$n\times m$的方格图用四种颜色染色，使得所有曼哈顿距离为$k$的点颜色不相同。

Solution：首先转化成切比雪夫距离，那么两个有一维坐标相差正好为$k$的点，颜色一定不能相同。按照坐标除以$k$向下取整得到的数的奇偶性染色即可。



### [Squeezing Slimes](https://atcoder.jp/contests/code-festival-2017-quala/tasks/code_festival_2017_quala_f)

给一个长度为$n$的序列$a_1,a_2\cdots a_n$。有另一个长度为$\sum a_i$的序列$B$，初始所有的元素都是$1$。每一次操作你可以选择$B$中长度为偶数的一个区间，然后把区间中的相邻的两个数（第一个和第二个，第三个和第四个……）合并，合并后的数等于合并前两个数的和。问至少经过多少次操作可以把$B$变成$A$。$n\le 10^5$

Solution：首先，可以划定$B$序列中的每一个$1$最终会成为$A$序列中的哪一个数。如果一个数不是$2$的整数次幂，那么至少有一次操作会由它开始或者结束。并且，$a_i$被操作的次数至多是$\lg a_i$。



### [AGC022E Median Replace](https://agc022.contest.atcoder.jp/tasks/agc022_e)

对于一个长度为$n$的01序列（保证$n$为奇数），每一次操作可以选择一个长度为$3$的区间，将这个区间替换为这三个数的中位数。输入一个长度为$n$的字符串，其中有‘0’，‘1’，‘？’三种字符，问有多少种把‘？’替换为‘0’或者‘1’的方案，使得这个字符串在经过$n-1\over 2$次操作之后，剩下的数是$1$。$n\le 300000$

Solution：先看一道思想比较类似的题。

> #### [poj3208 Apocalypse Someday](http://poj.org/problem?id=3208)
>
> 求第$n$小的数位中含有666的数。$n\le 5\times 10^7,T\le 1000$
>
> Solution：比较容易构建自动机。然后求出从每一个节点开始，每一个长度的串的数量。询问的时候，先算出答案串的长度（检查某一个长度的合法串的总数量），然后直接在自动机上走就可以了。

（我弃疗了）

毕克的代码：[打表](https://agc022.contest.atcoder.jp/submissions/2289029) [代码构建自动机](https://agc022.contest.atcoder.jp/submissions/2412905)

[官方题解](https://img.atcoder.jp/agc022/editorial.pdf)

这是从别人博客里面扒的一张自动机示意图：

![](D:\钟雨薇\2018-2019下\3.7\自动机.png)





### [ARC070D No Need](https://arc070.contest.atcoder.jp/tasks/arc070_b)

有一个包含$N$个数的集合，以及一个限制$K$。称一个数是必要的，当且仅当存在一个包含了这个数且权值大于等于$K$的子集，在去掉这个数之后权值小于了$K$。问这$N$个数中有多少个数是必要的。$N,K\le 5000$

Solution：显然，一个数$x$是必要的条件是用其他的数可以凑出$[K-x,K)$。（当然就可以直接分治背包）

这道题的答案是单调的，可以二分最大的、不必要的数。证明：对于两个数$x,y$，其中$x<y$，如果$y$是必要的，那么$x$一定是必要的。如果用不包含$x,y$的数就可以凑出$[K-y,K)$，那么由于$[K-x,K)\in [K-y,K)$，$x$一定是必要的；否则，如果在凑出$[K-y,K)$的时候用了$x$，那么我们只需要把$x$换成$y$就可以凑出$[K-x,K)$中的数了。



### [Snuke's Subway Trip](https://atcoder.jp/contests/arc061/tasks/arc061_c)

解决边权只有0,1的图上的最短路：可以直接用双端队列bfs，由于当前队列中只有两种距离，所以每发现一个点的时候，判断应该把它放到队列的前段还是后端。



### [一些有趣的数学题](https://arxiv.org/pdf/1110.1556.pdf)



## wqs二分

### bzoj1150 数据备份

要求选的数两两不相邻，问恰好选$k$个数，这些数的和小是多少。$n\le 100000 $

Solution：正常的贪心做法：选择第$i$个数的时候，同时加入$a_{i-1}+a_{i+1}-a_i$这个数，每一次直接选最小的就可以了。



### 51nod1380 夹克老爷逢三抽一



### 林克卡特树

