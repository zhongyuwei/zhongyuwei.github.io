## CF1017G The Tree

有一棵有根树。初始树上所有的节点都是白色的。有三种操作：

1）选择一个点$v$。如果$v$的颜色是白色的，那么我们就把$v$点染黑；否则，对$v$的每一个儿子都进行1）操作。

2）选择一个点$v$，并把$v$子树内的所有的点都变成白色。

3）查询某个点的颜色。

$n,q\le 10^5$

Solution：

做法1：对询问分块，对于每一块中的询问或者修改涉及到的点，我们拖出来建虚树，并记录下虚树的每一条边上，在原来的图上有多少个点是白色的。

对于第一种操作，直接暴力遍历要修改的点。在每个点记录下这个点下传了多少次操作。一个点的操作可以传到它在虚树上的儿子的条件是，它下传的操作次数大于等于它到儿子的边上白色的点的数量。

对于第二种操作，把对应的虚树子树中的点的颜色、下传操作次数都重置，把子树内边上白色点的数量置为边上点的数量，并打上标记，表示在这一块的询问之前的这些点的颜色信息都失效。

在完成块内的操作后，我们将整棵树暴力重新遍历，利用我们记录下的每个点下传操作次数和子树清空的标记，重新统计出树上每一个点的颜色。时间复杂度$O(n\sqrt n )$。



做法2：先不考虑操作2。设$a_i$为$i$号点被进行1）的次数，设$f_i$为有多少次1）操作“经过了”$i$号节点，那么$f_i = max(f_{i-1}-1+a_i,a_i)$。由于$max$对加法满足分配率，所以这个东西是可以区间合并的。

对于第$i$个位置，我们记$(c_i,d_i)$表示$f_i = max(f_{i-1}+c_i,d_i)$。

对于操作2），我们先查出$f_{fa_v}$，那么父亲对$v$的影响就是$x = max(f_{fa_v}-1,0)$，我们令$c_v = -x-1 , d_v = 0$，并令$v$子树中的其他点的$c$都取$-1$，$d$都取$0$。注意到一段长度为$len$且所有的元素都是$(-1,0)$的区间合并起来得到的是$(-len,0)​$，因此对于后者我们直接打一个区间标记就可以了。



## CF887E  Little Brother

平面内有$2$个点以及$n$个圆。你需要再画一个过给的两个点的圆，使得这个圆与给出的$n$个圆不相交（可以相切或者包含）。在此基础上你要最小化你画的圆的半径。输出这个最小化过后的半径。$n\le 10^5$，保证答案不超过$10^{12}$。要求精度误差不超过$10^{-4}$。

Solution：背题解ing.

考虑我们画的圆的圆心，一定是在给出的两个点的中垂线上。考虑两个点连的线段的中点到圆心的有向线段，我们只需要最小化这条线段的长度的绝对值即可。对每一个圆考虑，这个圆将会使得一段连续的长度取值不合法。可以二分求出这个区间的边界，然后扫描线求解。

二分的时候，用一个变量记二分这个循环执行的次数，当次数达到一定值的时候直接退出。



## [APIO2016] Fireworks

有一棵有根树，边带权，权值为正整数。修改一条边的权值的代价是修改前后权值的差的绝对值。要求修改后所有边的权值必须非负。问使得所有的叶子到根的距离全部相等，所需要的最小代价。$n\le 3\times 10^5$，$i$连向$fa_i$的边的边权为$w_i$，满足$w_i\le 10^9$。

Solution：

设$f_v(i)$为让$v$子树内所有点到$v$的距离都为$i$，所需要的最小代价。设$g_v(i)$为让$v$的子树内的所有点到$fa_v$的距离都为$i$，所需要的最小代价。

只需要考虑怎么通过$f_v(i)$求到$g_v(i)$：
$$
g_v(i) = \min_{k\in (-\infty,i] } \{f_v(k)+|(i-k)-w_v|\}
$$
实际上，$f_v(i)$是一个下凸的函数（这个可以从最后推导出来的转移过程看出），后面那个我们可以看做函数$h(x) = |x-w_v|$在$i-k$这个点的取值。整个式子是两个凸函数——其中一个斜率为+1/-1——的min卷积。

两个一次函数的min卷积有如下的性质：

1）一个斜率小于等于$-1$的函数$f$和一个斜率为$+1$的函数$g$进行min卷积，得到的$(f*g)(x) = f(x)+g(0)$。

2）一个斜率大于等于$1$的函数$f$和一个斜率为$+1$的函数$g$进行$min$卷积，得到的$(f*g)(x) = f(0)+g(x)$。

然后我们考虑，若$f_v(i)$在$i\in [L,R]$时斜率为$0$，根据前面的性质，我们可以推出这样的结论：
$$
g_v(i) = \begin{cases}
f_v(i)+w_v && i<L\\ 
f_v(L)+w_v-(i-L) && L\le i <L+w_v\\
f_v(i-w_v) = f_v(L) && L+w_v\le i < R+w_v\\
f_v(R)+(i-R)-w_v && R+w_v\le i
\end{cases}
$$
$i<L$：考虑此时，如果决策点向左移动$1$，那么$f_v(k)$的值增大的值将会大于等于$1$，而$|i-k-w_v|$的值将会增加$1$或者减少$1$。因此最优的决策点就是$i$。

$L\le i<L+w_v$：$L$是$f_v(i)$的最低点，并且当$i-k$逼近$w_v$的时候，$|(i-k)-w_v|$的取值最小。如果要不选$L$从而使得$i-k$更逼近$w_v$，由于$L$左侧的斜率小于等于$1$，所以这样不可能更优。

$L+w_v\le i<R+w_v$：此时$f_v(k)$和$|(i-k)-w_v|$都取到了最小值。

$R+w_i\le i$：与第一段的情况类似，$R$一定是最优的决策点。

从这个转移我们可以很显然地看出这是个下凸的函数。考虑维护这个函数的拐点：对于一个点$u$，我们将要进行的操作，相当于把它所有儿子的拐点合并起来，然后弹掉最右边的（儿子个数 - 1）个拐点，并且把最右边的两个拐点横坐标加上$w_v$的值。用可并堆就可以维护了。



## [十二省联考2019] 字符串问题

有一个字符串$S$。$S$的$na$个子串构成了集合$A$。$S$的$nb$个子串构成了集合$B​$。

有$m$个支配关系，第$i$个支配关系用$x_i,y_i$描述，表示$A$的第$x_i  $个串支配$B$的第$y_i$个串。

定义一个串$T$是合法的，当且仅当$T$存在一个划分$t_1,t_2,\cdots t_k$，满足：

1）$\forall i\in [1,k] ,t_i\in A$

2）$\forall i\in [1,k)$，$B$中存在一个串$b$，满足$t_i$支配$b$，并且$b$是$t_{i+1}$的前缀。

问最长的合法的串的长度。如果是正无穷，输出$-1$。

$|S|,na,nb,|A|,|B|\le 2\times 10^5$

Solution：

考虑SAM。比较显然的建图思路是，$A$中的串连向它支配的$B$，$B$中的串连向以它作为前缀的$A$的串。

对于后者，我们把整个字符串反过来建SAM。对于子串$[l,r]$，我们找到$endpos$集合包含$l$、$len$大于等于$r-l+1$且$len$最小的节点，把这个子串挂在那里。对于$B$中的某一个串，以它作为串，要么被挂在它在$fail$树上的子树内，要么和它被挂在同一个节点上并且长度大于它。对同一个节点上挂的串按照长度排序依次连过去，树上父亲连儿子就可以了。

要考虑，从一个$A$集合中的字符串转移出去，必须经过一个$B$集合中的字符串、到达另一个$A$集合中的字符串，才能统计贡献。即，$A\to A$是不合法的转移。这个我是通过把$A$集合中的点单独拆出来解决的。具体就是，只有单独拆出来的$|A|$个点，点权为对应的字符串的长度，其他的点全部为$0$；这些点向树上它们支配的$B$中的串，树上它们对应的串连向它们。

图建出来之后就是个最长路问题。答案为正无穷的条件是存在正环（这道题不存在$0$环，但是我一时脑抽还是写了个缩点）。拓扑排序+DP就可以了。

我的写法建图的时候需要用到这个点的$fail$在建图过程中的信息，所以需要把节点先按照$len$排序再依次做。*不能直接按照节点的编号做过去！！！*存挂的子串，我开始用了map，结果T飞了。改成vector能够卡过。注意答案的上界是$|A|\cdot |S|$，会爆int。



## Tachibana Kanade Loves Probability

<https://ac.nowcoder.com/acm/contest/548/B>

求出$m\over n$的小数点后第$K_1$至$K_2$位。$n,m\le 10^9,K_1,K_2\le 10^9,K_2-K_1\le 10^5$

Solution：

考虑一位一位地求。第$x$位上的值是$\lfloor {m\cdot 10^x \over n}\rfloor $的个位。

设$ m \cdot 10^{x-1} = pn+q$，其中$0\le q<n$，则$m\cdot 10^x = 10pn+10q$。

因此，$\lfloor {m\cdot 10^x \over n}\rfloor = 10p+\lfloor {10q\over n}\rfloor $

我们只需要求出$q$即可算出个位。$q=m\cdot 10^{x-1}\mod n$，直接快速幂即可。

或者可以这样考虑，对于这个式子$\lfloor {m\cdot 10^x \over n} \rfloor $，让分母减去$10n$对我们要的东西没有影响。因此算出分母模$10n$意义下的取值就可以了。





## jzoj4424 道路

一张图的代价是，图中边的数量的平方。问所有包含$n$个点的无自环无重边的**联通图**的代价的和。$n\le 2000$

Solution：

如果所有图的代价都是$1$，那么这个题就和$bzoj$城市规划一样了。

记$f_{i,j}$表示包含$i$个点的所有联通图，图中边的数量的$j$次方的和。记$g_{i,j}$表示所有包含$i$个点的图，图中边的数量的$j$次方的和。

那么由于$(x+y)^k = \sum_{I=0}^k {k\choose i} x^ky^{k-i} $，可以得到
$$
f_{i,j}=g_{i,j}- \sum_{k=0}^j {j\choose k} \sum_{x=1}^{i-1}{i-1\choose x}f_{x,k}g_{i-x,j-k}
$$
还有一个问题是$g_{i,j}$怎么求。我们考虑$k$的实际意义是从$k$条边中选一个，$k^2$的实际意义是从$k$条边中选两次，每一次选一个，枚举被选出来的边可以得到：
$$
设T={i(i-1)\over 2 }\\
g_{i,0} = 2^T\\
g_{i,1} = T2^{T-1}\\
g_{i,2} = T2^{T-1} + T(T-1)2^{T-2}
$$
总复杂度$O(n^2\cdot 2^2)$。



## jzoj5702 滑稽子图

给一棵树$T$，以及常数$k$。定义$f(S)$为$S$这个点集的导出子图的边数。一条边会在$S$的导出子图中，当且仅当这条边的两个端点都在$S$中。求$\sum_{S\subset V} f(S)^k $的值。$n\le 10^5,k\le 10$

Solution：

一种暴力就是：$f_{u,0/1,j}$表示$u$这个点选或者不选，$u$的子树内包含的点数为$j$的导出子图的数量。在树上做背包可以得到
$$
f_{u,0,j} = \sum f_{u,0,j-x} \cdot (f_{v,0,x}+f_{v,1,x})\\
f_{u,1,j} = \sum f_{u,1,j-x} \cdot f_{v,0,x} \\
+\sum f_{u,1,j-x-1} \cdot f_{v,1,x}
$$
考虑设$f_{u,0/1,i}$表示$u$这个点选或者不选，$u$这个点的子树内的所有点的导出子图的边数的$k$次方的和。
$$
(x+y+1)^k \\
=\sum_{i=0}^k {k\choose i}x^i(y+1)^{k-i} \\
=\sum_{i=0}^k {k\choose i}x^i \sum_{j=0}^{k-i}{k-i\choose j} y^j\\
$$
设$h_{v,i}= \sum_{j=0}^i {i\choose j} f_{v,1,j}$，我们可以得到：
$$
f_{u,0,k_1+k_2} = \sum f_{u,0,k_1} \cdot (f_{V,0,k_2}+f_{v,1,k_2}) {k_1+k_2\choose k_1}\\
f_{u,1,k_1+k_2} = \sum f_{u,1,k_1} \cdot f_{v,0,k_2} {k_1+k_2\choose k_1}\\
+\sum f_{u,1,k_1}\cdot h_v,k_2 {k_1+k_2\choose k_1}
$$
总复杂度$O(nk^2)$。



## [NOI2014]购票

有一棵有根树。每条边有一个长度$s_i$，每个点有权值$l_i,p_i,q_i$。当你的位置处于点$u$的时候，你可以选择$u$的一个与$u$的距离不超过$l_u$的祖先$v$，设他们之间的距离为$d$，你可以花费$d\cdot p_u+q_u$的代价到达$v$。输出每一个点走到根节点需要的最小代价。$n\le 2\times 10^5$

Solution：

~~给出的距离那个式子一脸斜率优化~~

考虑点分治。对于一个分治中心，先分治它靠近根的那个子树，然后通过那个子树的东西更新分治中心，然后再通过那个子树和分治中心去更新分治中心的其他子树内的点。具体实现的时候，$l_i$相当于限制某个点下一步走到的点的深度大于等于某个值，把靠近根的子树内的点按照深度排序，把其他点按照对下一步走的点的深度限制排序，然后按照深度依次把点加入凸壳，或者在凸壳上二分找到查询的点斜率对应的切点。

注意以下问题：1）对于靠近根的那个子树，有用的仅仅只是向上走的一条链而不是子树中的所有点。2）注意分治完靠近根的那个子树后，那个子树中的点将会全部被标记为分治过。所以应该在分治下去之前，把那个子树内向上走的那条链拿出来。3）注意分治中心自己就是分治区域内最靠近根的点的情况。

还有一些其他的做法。可以用线段树维护区间（下标是节点的深度）内的凸壳（这是为了考虑$l_i$对一个点的决策点的限制）。加入一个点会影响到$\log n$个凸壳。我们记录下加入这个点对每一个凸壳的影响，实际上这只会改变一下单调栈栈顶的位置，并用这个点替换掉栈中的一个点。在树上$dfs$，退出一个点的时候，我们就把它对线段树上的凸壳的影响全部撤销掉。查询的时候在$\log n$个凸壳上分别查询就可以了。



## [SCOI2012]Blinker的噩梦

平面内有$n$个图形，每个图形要么是点，要么是凸多边形。保证这些图形互相不会相交或者相切。每一个图形有一个权值。

有两种操作：1）修改某个图形的权值。2）给出平面内的两点，查询从一个点走到另一个点的路径上，经过的所有的图形的边界对应的图形，其权值的异或和。这个权值与选择的路径显然无关，因为同一个图形被经过两遍对答案的贡献是$0​$。

图形数、操作数小于等于$10^5$。

Solution：

类似圆的异或面积并的方法，把凸的图形拆成上下两个壳，然后做扫描线，找出每个图形在树上的父亲，以及每个点被哪一个图形包含。

数据中有图形的左右边界重合的情况，所以排序的时候，要注意把加入排在前面，删除排在后面。

~~当然以上都不是这道题的难点。请自行体会代码难度hhh~~



## [十二省联考2019] 春节十二响

有一棵有根树，树上的每一个节点有一个权值。你需要把这些节点划分成若干个集合，满足对于任意节点$u,v$，若$v$是$u$的祖先，则$u,v$一定不能被分在同一个集合。一个集合的权值是这个集合中的点的权值的最大值，一个划分方案的权值是所有集合的权值的和。求权值最小的划分方案的权值。$n\le 2\times 10^5 $

Solution：

直接贪心。~~根据信仰~~我们的策略一定是尽量减少划分的集合的数量。假如对于某个点$u$已经递归完成了子树的方案的计算，我们一定是把它的每一个子树内最大的集合拼在一起，次大的集合拼在一起……最后把$u$单独作为一个集合。

这个过程用启发式合并实现就可以了。





## spoj CIRU

求平面内$n$个圆的面积的并。$n\le 1000$

Solution：

~~按照套路~~考虑到我们要的区域一定是若干个弓形+多边形。

对于每一个圆，把其他的圆和它的交点拿出来，把被其他的圆覆盖了的那一段弧度打上差分标记。这个圆没有被其他圆覆盖的部分，就是最终要的区域的一个弓形，那个弓形对应的弦就是多边形的一条边。

要特殊考虑一段弧穿过了扫描线的起点的情况。代码应该长这样：

``` cpp
if(A1<-Pi) ss.PB(itm(A1+2*Pi,1)),now++;
else ss.PB(itm(A1,1));
if(A2>Pi) ss.PB(itm(A2-2*Pi,-1)),now++;
else ss.PB(itm(A2,-1));
```

之所以两种情况都需要考虑，是因为他们分别对应到，当前圆的圆心到另一个圆的圆心的向量的极角，在起点的左侧和在起点的右侧的情况。



## spoj CIRU2

给出平面内$n$个圆，保证不存在两个圆重合。对于所有的$k\in [1,n]$，求出平面内被覆盖了$k$次的区域的面积。$n\le 1000 $

Solution：首先把答案后缀和，考虑对于$k\in [1,n] $，求出被覆盖的次数大于等于$k$的区域的面积。

观察发现此时，我们要求的区域仍然是若干个弓形+一个多边形。有贡献的弧，满足的是这个弧恰好被其他的圆覆盖了$k-1$次。套用上一道题的套路即可。



## [SCOI2015]小凸想跑步

有一个凸$n$边形，多边形的顶点逆时针依次为$A_0,A_1,\cdots A_{n-1}$。一个点是合法的，当且仅当这个点处在多边形的内部，并且这个点与多边形的所有的顶点的连线划分出的$n$个三角形中，这个点与$A_0,A_1$组成的三角形的面积是最小的。求所有合法点组成的区域的面积。$n\le 10^5 $

Solution：

考虑一个点$p(x,y)$，我们需要让它对于所有的$i$，满足$S_{\triangle PA_iA_{i+1}}>S_{\triangle PA_0A_1}$。稍加推导可以得到
$$
(A_1-A_0)\times (P-A_0)< (A_{i+1} - A_i)\times (P-A_i)\\
$$
设$d_i = A_{i+1}-A_i$，可以得到
$$
d_0 \times (P-A_0) < d_i \times (P-A_i)\\
x_{d_0}(y_P - y_{A_0}) - (x_P-x_{A_0})y_{d_0} < x_{d_i}(y_P - y_{A_i}) - (x_P-x_{A_i})y_{d_i} \\
(y_{d_i} - y_{d_0}) x_P + (x_{d_0}-x_{d_i})y_P -x_{d_0}y_{A_0} + x_{A_0}y_{d_0} +x_{d_i}y_{A_i} - x_{A_i} y_{d_i} <0
$$


就是一个半平面交。

对$Ax+By+C<0$这样的直线做半平面交的方法：

当$B\not = 0$的时候，我们就取$(0,-{C\over B})$到$(-B,A-{C\over B})$的有向直线逆时针方向的部分。否则，就取$(-{C\over A},0)$到$(-{C\over A},A)$的有向线段的逆时针方向的区域。



## bzoj4538 网络

给一棵包含$n$个节点的树。有一个初始为空的路径集合$S$。有三种操作：1）往$S$中加入一条重要度为$x$的路径。2）从$S$中删除一条路径。3）查询对于某一个点$x$，当前集合中，不经过$x​$的重要度最大的路径的重要度。

Solution：

考虑二分答案，那么这个答案合法的条件，就是所有重要度大于这个答案的路径都包含了点$x$。问题转化成求重要度大于等于某个值的路径的交，并判断这个交是否包含了点$x$。

先把询问离线下来，按照重要度排序之后建线段树，在线段树上维护区间内的路径的交。

``` cpp
struct Road {
	int u,v,t;
	Road(int u=0,int v=0,int t=-1): u(u),v(v),t(t){};
};
bool cmp_dep(int x,int y) { return dep[x]>dep[y]; }
Road Inter(Road A,Road B) {
	if(A.t==0||B.t==0) return Road(0,0,0);
	if(A.t==-1) return B;
	if(B.t==-1) return A;
	int tmp[4]={LCA(A.v,B.v),LCA(A.u,B.u),LCA(A.v,B.u),LCA(A.u,B.v)};
	sort(tmp,tmp+4,cmp_dep);
	if(tmp[0]==tmp[1]&&(dep[tmp[0]]<dep[LCA(A.u,A.v)]||dep[tmp[0]]<dep[LCA(B.u,B.v)]))
		return Road(0,0,0);
	return Road(tmp[0],tmp[1],1);
}
bool Onchain(Road A,int x) {
	if(A.t==0) return 0;
	if(A.t==-1) return 1;
	if(A.t==-1) return 1;
	int tmp[2]={LCA(A.u,x),LCA(A.v,x)};
	if(dep[tmp[0]]<dep[tmp[1]]) swap(tmp[0],tmp[1]);
	if(tmp[0]==x&&tmp[1]==LCA(A.u,A.v)) return 1;
	return 0;
}	
```



## bzoj 3533 向量集

有一个初始为空的点集$S$。有两种操作：1）加入一个点。2）给出一个点，询问这个点与第$l$次到第$r$次加入操作之间加入的点的点积的最大值。强制在线。操作数小于等于$4\times 10 ^5 $。

Solution：先建一个维护的叶子节点的数量等于操作数量的线段树。依次加入点，当线段树上某个节点代表的区间里面所有的点都已经加入的时候，我们就把这个节点上的点拿出来排序、分别算出上凸壳和下凸壳。询问的时候直接在对应的$O(\log n)$个区间的凸壳上二分就可以了。这样的正确性是基于，一个区间如果它内部还有点没有加入，那么它一定不会再询问的时候被查询。

注意在求凸包的时候，对于$x​$相同的点，我们需要保证他们的$y​$是**有序**的，这样才能够保证不需要的点被顺利弹掉。


