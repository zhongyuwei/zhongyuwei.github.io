<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>密码配置测试</title>
    <url>/2022/06/25/%E5%AF%86%E7%A0%81%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>title: 密码配置测试<br>mathjax: true<br>comments: false<br>date: 2022-06-25 20:44:24<br>tags: 杂记<br>password: password<br>abstract: Here’s something encrypted, password is required to continue reading.<br>message: Password is required. You can ask the author for access. See at the About page.<br>wrong_pass_message: Oh, this is an invalid password. Check and try again, please.<br>wrong_hash_message: Oh, these decrypted content cannot be verified, but you can still have a look.</p>
]]></content>
  </entry>
  <entry>
    <title>拉格朗日插值</title>
    <url>/2022/06/25/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<p>有$n$个点$(x_1,y_1),(x_2,y_2)\cdots (x_n,y_n)$，满足$\forall i\not =j,x_i\not =x_j$。你需要求出一个次数小于等于$n-1$的多项式$f(x)$，使得$\forall i\in [1,n],f(x_i) = y_i$。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>考虑对于每一个$i$，构造出一个在$x_i$处取值为$1$、在另外$n-1$个点取值为$0$的多项式$\ell _i (x)$：</p>
<script type="math/tex; mode=display">
\ell_i(x) = {\prod_{j\not =i} (x-x_j)\over \prod _{j\not= i} (x_i-x_j)}</script><p>这个多项式显然是满足上面的条件的。</p>
<p>由此我们可以构造出一个多项式$L(x) = \sum_{i=1}^n y_i\ell _i(x)$。这个多项式显然满足在$x_i$点取值为$y_i$。</p>
<h2 id="唯一性证明"><a href="#唯一性证明" class="headerlink" title="唯一性证明"></a>唯一性证明</h2><p>假设存在两个次数小于等于$n-1$的满足条件的多项式$P_1$和$P_2$，那么$P_1-P_2$在$x_1,x_2\cdots x_n$的取值一定都是$0$，也就是说这个多项式是$(x-x_1)(x-x_2)\cdots (x-x_n)$的倍数。考虑到$P_1-P_2$的次数不可能超过$n-1$，而$(x-x_1)(x-x_2)\cdots (x-x_n)$是一个$n$次多项式，所以$P_1-P_2$一定是这个多项式的$0$倍，也就是说$P_1-P_2=0$，也就是$P_1=P_2$。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一般我们是需要求出将某个值带入这个多项式得到的值。这个时候我们就没有必要求多项式的表达式了，直接把值带入式子里面算，时间复杂度$O(n^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rd(n),rd(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(x[i]),rd(y[i]);</span><br><span class="line">    <span class="keyword">int</span> Ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> d=<span class="number">1</span>,f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span>(i!=j) &#123;</span><br><span class="line">                d=d*(ll)(k-x[j])%mod;</span><br><span class="line">                f=f*(ll)(x[i]-x[j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        f=Pow(f,mod<span class="number">-2</span>);</span><br><span class="line">        Ans=(Ans+y[i]*(ll)f%mod*d)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(Ans+mod)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取值连续时的优化"><a href="#取值连续时的优化" class="headerlink" title="取值连续时的优化"></a>取值连续时的优化</h2><p>当$x$的取值是连续的一段自然数的时候，我们可以算出$(x-x_i)$的前缀积和后缀积，就可以在$O(1)$的时间内得到分子。观察发现$\ell_i$分母的绝对值是${1\over (i-1)!(n-i)!}$，它的符号与$n-i$的奇偶性相关。预处理出阶乘的逆元也就可以$O(1) $算了。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>泰勒展开</title>
    <url>/2022/06/25/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://blog.csdn.net/qq_42452134/article/details/83095736" target="_blank" rel="noopener">一个比较详细的介绍</a><br><a href="https://blog.csdn.net/qq_36330643/article/details/77288486" target="_blank" rel="noopener">一个微积分的推导</a><br><a href="https://blog.csdn.net/weixin_40100502/article/details/80531027" target="_blank" rel="noopener">一个我没有看懂的推导</a><br><a href="https://www.zhihu.com/question/21149770/answer/111173412" target="_blank" rel="noopener">知乎上一个提了拉格朗日中值定理的回答</a><br><a href="https://zhuanlan.zhihu.com/p/25413823" target="_blank" rel="noopener">知乎上一个使用了柯西中值定理的证明</a></p>
<hr>
<h2 id="泰勒公式推导"><a href="#泰勒公式推导" class="headerlink" title="泰勒公式推导"></a>泰勒公式推导</h2><p>简单来说，如果我们知道某一个函数在某一个点的取值，以及在这个点的各阶导数的取值，我们就可以通过泰勒公式构造出一个多项式，从而近似地得到这个点附近的点的这个函数取值。</p>
<p>对于函数$f(x)$，我们已经知道$f(x_0)$以及$f$在$x_0$处的$1,2,3\cdots n$阶导数。我们需要构造一个关于$x$的多项式$P$，使得$P(x)$的取值尽可能地接近$f(x)$。</p>
<p>考虑$P(x)$满足什么条件它才能够和$f(x)$比较接近：</p>
<ul>
<li>$P(x_0)$应该等于$f(x_0)$</li>
<li>在$x_0$这个点，两个函数的切线的斜率应该相等，也就是他们的一阶导数相等。</li>
<li>在$x_0$这个点，两个函数的曲率也应该相等，也就是他们的二阶导数也应该相等。</li>
<li>$\cdots $</li>
<li>在$x_0$这个点，两个函数的$1,2,3\cdots n$阶导数都应该相等。</li>
</ul>
<p>我们设$P(x)= \sum_{i=0}^n A_i(x-x_0)^i + R_n(x)$，最后的$R_n(x)$是余项，也就是误差。那么根据前面的推导我们可以知道：</p>
<ul>
<li>$P(x_0) = A_0 =f(x_0)$</li>
<li>$P’(x_0) = 1\cdot A_1 = f’(x_0) $（次数高于$1$的项此时因为$x-x_0=0$所以取值都是$0$；取值低于$1$的项因为求导已经没有了）</li>
<li>$P’’(x_0) = 1\cdot 2\cdot A_2 = f’’(x_0)$</li>
<li>$P’’’(x_0) = 1\cdot 2\cdot 3 \cdot A_3 = f’’’(x_0)$</li>
<li>$\cdots $</li>
<li>$P^{(n)}(x_0)= n!A_n = f^{(n)}(x_0)$</li>
</ul>
<p>于是我们得到了$A_i = {f^{(n)}(x_0)\over n!}$。</p>
<p>因此我们有了泰勒公式：</p>
<script type="math/tex; mode=display">
f(x) = f(x_0) +\sum_{i=1}^n {f^{(i)}(x_0)\over i!} (x-x_0)^i + R_n(x)</script><p>当$x_0 = 0$的时候这就是麦克劳林公式：</p>
<script type="math/tex; mode=display">
f(x) = f(0) + \sum_{i=1}^n {f^{(i)}(0) \over i!} x^i + R_n(x)</script><hr>
<h3 id="一些常用函数的泰勒展开"><a href="#一些常用函数的泰勒展开" class="headerlink" title="一些常用函数的泰勒展开"></a>一些常用函数的泰勒展开</h3><script type="math/tex; mode=display">
e^x = \sum_{i=0}^{\infty } {x^i \over i!}\\
\ln (1+x) = \sum_{i=1}^{\infty } {(-1)^{i+1} (i-1)!\over i!}x^i = \sum_{i=1}^{\infty }{(-1)^{i+1}\over i}x^i\\
\sin(x) = {\cos(0)\over 1!}x^1 - {\sin(0) \over 2!}x^2 - {
\cos(0)\over 3!}x^3 + {\sin(0)\over 4!}x^4\cdots \\
={x^1\over 1!} - {x^3\over 3!} + {x^5\over 5!} - {x^7\over 7!}\cdots \\
\cos(x) = 1-{x^2\over 2!} +{x^4\over 4!} - {x^6\over 6!}\\
{1\over 1-x} = 1 + x + x^2 + x^3\cdots</script><hr>
<p>upd 2020.1.15</p>
<h3 id="余项的估计"><a href="#余项的估计" class="headerlink" title="余项的估计"></a>余项的估计</h3><ol>
<li>函数$c \cdot {x^n \over n!}$的$n$阶导数是$c$。</li>
<li>对于连续且可以求$n+1$阶导的函数$f(x)$，以及某两个点$a,b$，令$y=cx^{n+1}$过$(a,f(a)),(b,f(b))$，则至少存在一个点$\theta \in (a,b)$，满足${f^{(n+1)}(\theta)\over (n+1)!} = c$。（拉格朗日中值定理的推广？我不会证）</li>
<li>$R_n(x) = f(x) - \sum_{i=0}^n {f^{(i)}(a)\over i!}(x-a)^i$，如果把$R_n(x)$看做一个关于$x$的函数，将$f(x)$泰勒展开为$f(x) = \sum_{i=0}^\infty {f^{(i)}(a)\over i!}(x-a)^i$，就可以得到$R_n^{(n+1)} (x)= f^{(n+1)}(x)$。</li>
<li>必然存在一个点$\theta \in (a,x)$，满足$R_n(x) - R_n(a) = {R_n^{(n+1)}(\theta)\over (n+1)!} (x-a)^{n+1}$，也就是$R_n(x) = {f^{(n+1)}(\theta)\over (n+1)!}(x-a)^{n+1}$。</li>
<li>所以，如果某个$M$满足$M\ge |R_n^{(n+1)}(\theta)|, \theta \in (a,x)$，那么就可以得到$|R_n(x)| \le {M\over (n+1)!}(x-a)^{n+1}$</li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>20220625 多项式与生成函数 讲课资料</title>
    <url>/2022/06/25/20220625-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E8%AE%B2%E8%AF%BE%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<h2 id="多项式与组合数学-ppt："><a href="#多项式与组合数学-ppt：" class="headerlink" title="多项式与组合数学 ppt："></a>多项式与组合数学 ppt：</h2><div class="pdf" target="/files/多项式与组合数学20220623.pdf" height=""></div>
<h2 id="FFT-NTT-FWT-ppt："><a href="#FFT-NTT-FWT-ppt：" class="headerlink" title="FFT NTT FWT ppt："></a>FFT NTT FWT ppt：</h2><div class="pdf" target="/files/FFT,NTT,FWT.pdf" height=""></div>
<h2 id="jzoj6058-false-false-true题解"><a href="#jzoj6058-false-false-true题解" class="headerlink" title="jzoj6058 false-false-true题解"></a>jzoj6058 false-false-true题解</h2><p>（下面pdf里的T3）</p>
<div class="pdf" target="/files/3.13纪中集训（联考5）.pdf" height=""></div>
<h2 id="拉格朗日插值、泰勒展开、微积分"><a href="#拉格朗日插值、泰勒展开、微积分" class="headerlink" title="拉格朗日插值、泰勒展开、微积分"></a>拉格朗日插值、泰勒展开、微积分</h2><p>在博客内搜索就能找到。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>我感谢一切相遇——退役录</title>
    <url>/2020/09/12/%E6%88%91%E6%84%9F%E8%B0%A2%E4%B8%80%E5%88%87%E7%9B%B8%E9%81%87%E2%80%94%E2%80%94%E9%80%80%E5%BD%B9%E5%BD%95/</url>
    <content><![CDATA[<p>并不想记叙那些太多细节，也没有那么多心力和时间去仔细地回忆。随手写几句这些年学习竞赛的感想，也算是认真地跟 OI 道个别吧。</p>
<p>也许这就是为什么学竞赛的女生很少吧？让一个多愁善感的人在这个多愁善感的年纪只是安安静静地做学问，简直是无法想象。学 OI 的这几年里我所追寻的不过是一种感觉而已：称其为“虐”也罢，称其为“追求挑战和刺激”也罢。那时候我还不懂得人间其实有温情在，只有对精神的堕落与死亡的恐惧会刺激我、让我振奋；于是没有麻烦也要制造麻烦，没有困难也要制造困难，总之绝对不能停下来（尽管当时的我根本不可能意识到“我在给自己找麻烦”这一点）。这是我所以选择了竞赛。</p>
<p>这样做的结果是，我在消灭麻烦这件事情上变得越来越强大，我却愈发不能和平地与自己相处。我所取得的成绩越好，我就越是用别的方式惩罚自己，比如生病，比如失眠，比如抑郁。只是因为我内心深处从不承认自己应该得到这些而已。只是因为我相信折磨（区别于“为了某个目标而奋斗”）真的应该成为我的主旋律而已。</p>
<p>我很幸运，在这条路上我遇见的人们，先让我明白“他人”其实并不是什么会伤害我的大怪兽，然后告诉我每一个人其实都很善良，最后使我慢慢体会到“他人”的头脑中也存在着和我类似的“心理活动”，我和“他人”是能够彼此理解的。我感激他们的友善，他们对我的那些如对待幼儿一般的教诲，也感激那双在我极度困顿时向北四楼的窗台上犹豫的我伸出的手，那双把我往回拉的手。</p>
<p>如今，我知道了我曾经所选择的，它们不是我曾以为的“唯一的选择”。我知道了一种可以成为生活的动力、并且比恐惧更加强大的力量——“爱”，我还知道了自己也是可以成为这个词语的主体和对象的。曾经总是坐在角落、感觉自己比机房里的耗子还要卑微的我，现在却敢怀揣着对自己的爱站着从这里走出去。</p>
<p>此刻我听着窗外的雨声——我曾经万般眷恋、却从某一天开始无比惧怕、后来又重新为之感慨的，来自天空的乐音；倘若要谈什么理想，我希望我能为我曾经遇见的人们和即将遇见的人们，给这个世界增添一点“美好”，我希望能怀揣着这份“生命可贵”的心情，去珍惜自己的和他人的生命。</p>
<p>“当你真的决定了要认真生活下去以后，剩下的一切事情其实都很容易。”</p>
<p>雨声渐渐消停、远去，一切归于平静。一切归于空境。这不是结束，这只是开始而已。</p>
<p>“我感谢一切相遇。”</p>
]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值练习题</title>
    <url>/2020/05/28/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="luogu-P5437-【XR-2】约定"><a href="#luogu-P5437-【XR-2】约定" class="headerlink" title="luogu P5437 【XR-2】约定"></a>luogu P5437 【XR-2】约定</h2><p>考虑每条边的贡献。所有生成树的边数和为 $n^{n-2} \cdot (n-1)$，原图中的边数为 $\frac{n(n-1)}{2}$，因为原图中每条边在最终的树中出现的概率是相同的，所以某条边出现在生成树中的概率为 $\frac{\frac{n^{n-2} \cdot (n-1)}{\frac{n(n-1)}{2}}}{n^{n-2}} = \frac{2}{n}$。</p>
<p>所以</p>
<script type="math/tex; mode=display">
\begin{gathered}
Ans = \frac{2}{n} \sum_{i=1}^n \sum_{j=1}^{i-1} (i+j)^k\\
= \frac{1}{n}\left(\sum_{i=1}^n \sum_{j=1}^n (i+j)^k - \sum_{i=1}^n (i+i)^k\right)
\end{gathered}</script><p>$\sum_{i=1}^n (2i)^k = 2^k \sum_{i=1}^n i^k$ 可以一次拉格朗日插值求出来。</p>
<p>可以证明 $f(n) = \sum_{i=1}^n \sum_{j=1}^n (i+j)^k$ 是一个关于 $n$ 的 $k+2$ 次多项式。</p>
<p>方法 1：$\sum_{t=0}^k \binom{k}{t} \left(\sum_{i=1}^n i^t\right) \left( \sum_{j=1}^n j^{k-t}\right)$，一个 $t+1$ 次多项式和 $k-t+1$ 次多项式相乘后为 $k+2$ 次多项式，求和后仍为 $k+2$ 次多项式。</p>
<p>方法 2：做差，分析得知 $f(n) - f(n-1)$ 是个 $k+1$ 次多项式。</p>
<p>最后的问题是如何算出 $f(1),f(2),\cdots f(k+3)$。</p>
<p>枚举 $u = i+j$，则合法的 $i$ 必须满足 $1\le i\le n, 1\le u-i \le n$。讨论一下可知</p>
<script type="math/tex; mode=display">
f(n) = \sum_{u=1}^n u^k (u-1) + \sum_{u=n+1}^{2n} u^k (2n-u+1)</script><p>预处理 $i^k$ 的前缀和即可。</p>
<h2 id="BZOJ4559-luogu-P3270-JLOI2016-成绩比较"><a href="#BZOJ4559-luogu-P3270-JLOI2016-成绩比较" class="headerlink" title="BZOJ4559 / luogu P3270 [JLOI2016]成绩比较"></a>BZOJ4559 / luogu P3270 [JLOI2016]成绩比较</h2><p>考虑求出 $F(x)$ 表示钦定 $x$ 个同学被碾压，此时给所有人赋分使得 B 神的排名符合题意的方案数。</p>
<script type="math/tex; mode=display">
F(x) = \prod_{i=1}^M \left(\binom{N-x}{R_i - x} \cdot \sum_{j=1}^{U_i} j^{N-R_i}(U_i-j)^{R_i-1}\right)</script><p>则由二项式反演知答案为 $\sum_{x=K}^N \binom{x}{K}(-1)^{x-K} F(x)$。</p>
<p>可以看出 $\sum_{j=1}^{U_i} j^{N-R_i}(U_i-j)^{R_i-1}$ 是一个关于 $U_i$ 的 $N$ 次多项式，可以用拉格朗日插值算。</p>
<p>总时间复杂度 $O(MN^2)$。</p>
<h2 id="BZOJ2655-luogu-P4463-集训队互测2012-calc"><a href="#BZOJ2655-luogu-P4463-集训队互测2012-calc" class="headerlink" title="BZOJ2655 / luogu P4463 [集训队互测2012] calc"></a>BZOJ2655 / luogu P4463 [集训队互测2012] calc</h2><p>钦定 $a_1 &lt; a_2 &lt; \cdots &lt; a_n$ 算答案，最后乘上一个 $n!$ 即可。</p>
<p>设 $f_{i,j}$ 表示：考虑了前 $i$ 个数，最大的数为 $j$，所有方案的权值和。</p>
<p>则 $f_{i,j} = \sum_{k&lt;j} f_{i-1,k} \cdot j$。</p>
<p>注意到，如果 $f_{i,j}$ 是个关于 $j$ 的 $p$ 次多项式，则 $f_{i,j} \cdot j$ 是个关于 $j$ 的 $p+1$ 次多项式，$\sum_{k &lt; j} f_{i,k}$ 是个关于 $j$ 的 $p+1$ 次多项式。</p>
<p>所以 $f_{n,j}$ 是个关于 $j$ 的 $2n+1$ 次多项式。</p>
<p>直接 dp + 拉格朗日插值，可以做到 $O(n^2)$。</p>
<h2 id="luogu-P5850-calc加强版"><a href="#luogu-P5850-calc加强版" class="headerlink" title="luogu P5850 calc加强版"></a>luogu P5850 calc加强版</h2><p>考虑答案关于 $n$ 的生成函数</p>
<script type="math/tex; mode=display">
\begin{gathered}
F(x) = \prod_{i=1}^A (1+ix)\\
= \exp\left( \sum_{i=1}^A \ln\left(1+ix\right) \right)\\
= \exp\left( \sum_{i=1}^A \sum_{j=1}^\infty \frac{(ix)^j (-1)^{j+1}}{j} \right)\\
= \exp\left(\sum_{j=1}^\infty \frac{x^j(-1)^{j+1}}{j} \sum_{i=1}^A i^j\right)\\
\end{gathered}</script><p>剩下的问题就是对每个 $j$ 算 $\sum_{i=1}^A i^j$：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{i=0}^\infty \frac{x^i}{i!} \sum_{j=0}^A j^i\\
= \sum_{j=0}^A \frac{x^i j^i}{i!}\\
= \sum_{j=0}^A e^{jx}\\
= \frac{e^{(A+1)x} - 1}{e^x - 1}
\end{gathered}</script><p>复杂度 $O(n\log n)$，需要卡常。</p>
<p><del>所以拉格朗日插值有什么用呢？</del></p>
<h2 id="BZOJ3453-tyvj-1858-XLkxc"><a href="#BZOJ3453-tyvj-1858-XLkxc" class="headerlink" title="BZOJ3453 tyvj 1858 XLkxc"></a>BZOJ3453 tyvj 1858 XLkxc</h2><p>$f(n) = \sum_{i=1}^n i^k$ 是关于 $n$ 的 $k+1$ 次多项式；</p>
<p>所以 $g(n) = \sum_{i=1}^n f(i)$ 是关于 $n$ 的 $k+2$ 次多项式。</p>
<p>注意到 $h(n) = g(a+nd)$ 仍然是关于 $n$ 的 $k+2$ 次多项式。</p>
<p>所以 $p(n) = \sum_{i=0}^n h(n)$ 是关于 $n$ 的 $k+3$ 次多项式。</p>
<p>拉格朗日插值即可，复杂度大约 $O(k^2)$。</p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Social Infrastructure Information Systems Division, Hitachi Programming Contest 2020 D Manga Market</title>
    <url>/2020/05/19/Atcoder-Social-Infrastructure-Information-Systems-Division-Hitachi-Programming-Contest-2020-D-Manga-Market/</url>
    <content><![CDATA[<p>稍微转化一下题目：</p>
<ol>
<li>把在商店之间行走的时间加到 $b_i$ 里面（也就是让所有的 $b_i$ 自增 1）；由于最后一次购物之后不需要走到别的商店去，所以这样算出来的所需时间会多 1，所以让 $T$ 相应地加 1。</li>
<li>令 $t$ 为当前已经花费的时间，发现 $t’=t+ at + b =(a+1)t+b$，所以令 $a_i$ 自增 1；这样转化以后，已经用了 $t$ 时间后再在第 $i$ 家商店购物，结束的时间恰为 $a_it + b_i$。</li>
</ol>
<p>考虑如果我们已经知道了在要在哪些商店购物，如何确定购物所需的最小时间：假设最优的购物顺序是第 $i$ 次去商店 $p_i$，则</p>
<script type="math/tex; mode=display">
\begin{gathered}a_{p_{i+1}} ( a_{p_i} t + b_{p_i}) + b_{p_{i+1}} < a_{p_i} ( a_{p_{i+1}} t + b_{p_{i+1}}) + b_{p_i}\\\Rightarrow a_{p_{i+1}} b_{p_i} + b_{p_{i+1}} < a_{p_i} b_{p_{i+1}} + b_{p_i}\\\Rightarrow (a_{p_{i+1}} - 1)b_{p_i} < (a_{p_i}-1)b_{p_{i+1}}\\\Rightarrow \frac{a_{p_{i+1}} - 1}{b_{p_{i+1}}} < \frac{a_{p_i}-1}{b_{p_i}}\end{gathered}</script><p>所以最优的购物顺序一定是按照 $\frac{a_i - 1}{b_i}$ 降序。</p>
<p>不妨将所有的商店按照 $\frac{a_i - 1}{b_i}$ 排序，然后进行 dp。设 $f_{i,j}$ 表示考虑完前 $i$ 家店，在 $j$ 家店购物所需的最小时间，然后直接枚举第 $i+1$ 个商店选或者不选转移即可。时间复杂度 $O(N^2)$。</p>
<p>注意到如果所有的 $a_i$ 都大于 $1$，那么 $j$ 取值不超过 $\lfloor \log_2 T \rfloor$。所以可以对 $a_i &gt; 1$ 的商店单独 dp，对于 $a_i = 1$ 的商店直接贪心取 $b_i$ 最小的即可。</p>
<p>时间复杂度 $O(N\log T)$。</p>
<p><a href="https://atcoder.jp/contests/hitachi2020/submissions/13398909" target="_blank" rel="noopener">my submission</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Panasonic Programming Contest 2020 F Fractal Shortest Path</title>
    <url>/2020/05/18/Atcoder-Panasonic-Programming-Contest-2020-F-Fractal-Shortest-Path/</url>
    <content><![CDATA[<h2 id="observation"><a href="#observation" class="headerlink" title="observation"></a>observation</h2><p> 阶分形的第一列、最后一列、第一行、最后一行都是白色的格子。</p>
<h2 id="lemma"><a href="#lemma" class="headerlink" title="lemma"></a>lemma</h2><p>对于一个  阶分形，从其中的任意一个点走到这个分形的右下角的最短路长度为这两个点的曼哈顿距离。</p>
<p>证明：考虑归纳，对于  显然成立；当结论对于  成立时，构造  阶分形中的行走方案：先走到点所属的  阶分形的右下角，然后沿着其它  阶分形的边缘走过去即可。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>将当前的图分为八个部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A B C</span><br><span class="line">D x E</span><br><span class="line">F G H</span><br></pre></td></tr></table></figure>
<p>如果两个点不在同一行或者同一列，那么它们之间的最短路就是它们之间的曼哈顿距离（与 lemma 证明类似构造）。</p>
<p>如果两个点都在 <code>B x G</code> 这一列或者都在 <code>D x E</code> 这一行（以 <code>B x G</code> 为例）：最短路径要么是（起点 -&gt; B 的左下角 -&gt; G 的左上角 -&gt; 终点），要么是（起点 -&gt; B 的右下角 -&gt; G 的右上角 -&gt; 终点）。可以直接算出来。</p>
<p>否则两个点在同一行或者同一列，并且之间全部是  阶分形。递归下去做即可。</p>
<p>为了减少讨论量，可以在初始的时候令点的横坐标绝对值之差大于纵坐标绝对值之差。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://atcoder.jp/contests/panasonic2020/submissions/13379144" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF516E Drazil and His Happy Friends</title>
    <url>/2020/05/13/CF516E-Drazil-and-His-Happy-Friends/</url>
    <content><![CDATA[<p>如果 $n\not \perp m$，则只有编号 $\bmod \{\gcd(n,m)\}$ 同余的编号才会互相影响，对每组同余的编号单独求解（相当于转化成了 $n\perp m$ 的问题）取最大值即可。</p>
<p>以下只考虑 $n\perp m$ 的情况。</p>
<p>观察：</p>
<ul>
<li><p>如果在 $t$ 时刻，第 $i$ 个男生让第 $j$ 个女生变得快乐了，那么第 $t+n$ 时刻第 $i$ 个男生会让第 $j+n \bmod m$ 个女生变得快乐。不妨看作，如果 $j$ 这个女生在 $t$ 这个时刻变得快乐了，那么她会让第 $j+n\bmod m$ 个女生在 $t+n$ 时刻变得快乐。男生同理。</p>
</li>
<li><p>如果男生 $i$ 是被某个女生 $j$ 变快乐的，那么未来的时间里，被这个男生变快乐的女生都可以用前文的方法看作是被 $j$ 变快乐的女生。换而言之，初始的时候不快乐的男生，对于女生们来说是没有用的。初始时不快乐的女生同理。</p>
</li>
</ul>
<p>所以，计算每个人最早什么时候变快乐，只需要考虑以下两种情况：</p>
<ol>
<li>男生 / 女生 $i$ 在 $t$ 时刻变快乐了，那么男生 $i+m\bmod n$ / 女生 $i+n\bmod m$ 会在 $t+m$ / $t+n$ 时刻变快乐</li>
<li>男生 / 女生 $i$ 在初始时是快乐的，他 / 她会在时刻 $i$ 让女生 $i\bmod m$ / 男生 $i\bmod n$ 变得快乐</li>
</ol>
<p>第一种情况中，考虑女生，可以看出这样的“路径”会形成一个环（$i \to i+n\bmod m \to i+2n \bmod m \cdots$）。按照点在环上的出现位置重编号，令原来的 $0$ 重标号后的编号为 $0$，则原来的 $i$ 重编号后的编号为 $i \cdot n^{-1} \bmod m$。令环上第二种情况涉及到的点和初始时开心的点为关键点，发现每个关键点能贡献到的一定是重标号后的环上以它开头的一段区间。直接计算每个关键点能贡献到的区间中最晚的变开心的时间即可。注意如果关键点是第二种情况造成的，则关键点变开心的时间也要计入答案。男生同理。</p>
<p><a href="https://codeforces.com/contest/516/submission/79937328" target="_blank" rel="noopener">my submission on codeforces.com</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Burnside Lemma的证明</title>
    <url>/2020/05/06/%E5%85%B3%E4%BA%8EBurnside-Lemma%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://tgsteven.github.io/2018/07/10/2018-07-10-polya/" target="_blank" rel="noopener">TGSteven 的博客</a>（那篇博客现在已经被TGSteven删掉了）</li>
<li><a href="https://en.wikipedia.org/wiki/Burnside&#39;s_lemma" target="_blank" rel="noopener">wikipedia: Burside’s lemma</a></li>
</ul>
<h3 id="轨道-orbit"><a href="#轨道-orbit" class="headerlink" title="轨道 orbit"></a>轨道 orbit</h3><p>我们记$X$中的元素$x$在置换群$G$作用下的轨道为：</p>
<script type="math/tex; mode=display">
G\cdot x = \{ g\cdot x \mid g\in G\}</script><p>那么，$x$的轨道中的所有元素一定和$x$属于同一个等价类，并且不在$x$的轨道中的元素一定不与$x$属于同一个等价类。比如说，$2$种颜色的珠子串长度为$4$的项链，允许旋转，那么0101和1010都是0101的轨道中的元素。又比如给$2\times 2$的方格涂色，允许进行旋转，那么$\begin{matrix} 1&amp; 0 \ 0 &amp; 1\end{matrix}$的轨道中的元素有$\begin{matrix} 1&amp; 0 \ 0 &amp; 1\end{matrix}$和$\begin{matrix} 0&amp; 1 \ 1 &amp; 0\end{matrix}$。一个元素的轨道，就是它在$G$的作用下能够得到的元素组成的集合。</p>
<p>定义一个集合$X$的轨道是所有元素的轨道的集合，记为$X/G$。实际上，一个轨道就是我们之前提到的一个等价类。</p>
<hr>
<h3 id="不动点与稳定子集"><a href="#不动点与稳定子集" class="headerlink" title="不动点与稳定子集"></a>不动点与稳定子集</h3><p>定义一个置换$g$的不动点为：</p>
<script type="math/tex; mode=display">
X^g=\{ x\in X \mid g\cdot x=x\}</script><p>定义$X$中的一个元素$x$的稳定子集为：</p>
<script type="math/tex; mode=display">
G_x = \{g\in G\mid g\cdot x=x\}</script><hr>
<h3 id="证明orbit-stabilizer-theorem（口胡）"><a href="#证明orbit-stabilizer-theorem（口胡）" class="headerlink" title="证明orbit-stabilizer theorem（口胡）"></a>证明orbit-stabilizer theorem（口胡）</h3><blockquote>
<p>orbit-stabilizer theorem：一个元素的轨道中的元素数量与这个元素的稳定子集的大小的乘积等于置换群中置换的数量，即$\forall x\in X,| G\cdot x|\cdot |G_x| = |G|$</p>
</blockquote>
<p>限于本人的水平，以下内容是在阅读了若干资料之后用口水话胡的。</p>
<p>对于一个元素$x$，我们可以将$G$中的置换分为两类，一类是$G_x$中的，一类是不属于$G_x$的。那么对于$x$的轨道中的所有元素，这个“分类”的结果是一样的。即对于一个置换$g$，如果$g\cdot x=x$，那么$\forall x’\in G\cdot x,g\cdot x’=x’$；如果$g\cdot x\not= x$，那么$\forall x’\in G\cdot x,g\cdot x’\not =x’$。</p>
<p>一个置换作用在$x$上，得到的结果一定在$x$的轨道中。那么任意一个置换，它可以表达为：$x$的轨道中的一个元素在$G_x$中的一个置换下得到的结果。并且，“$x$的轨道中的一个元素在$G_x$中的一个置换下得到的结果”和“$G$中的一个置换”，这两者是一一对应的关系。因此，$|G\cdot x|\cdot |G_x|=|G|$。</p>
<p>这也就是为什么我们要求置换构成群：这个定理成立的前提是置换结合满足封闭性。如果从$x$到达“$x$的轨道中的一个元素在$G_x$中的一个置换下得到的结果”这个置换不在$G$中，那么在计数的时候就会出错。</p>
<hr>
<h3 id="证明Burnside-Lemma"><a href="#证明Burnside-Lemma" class="headerlink" title="证明Burnside Lemma"></a>证明Burnside Lemma</h3><blockquote>
<p>Burnside Lemma：一个集合$X$在置换群$G$作用下的等价类（轨道）的数量，等于$G$中每一个置换的不动点的数量的平均值。即$|X/G|={1\over |G|}\sum_{g\in G}|X^g|$</p>
</blockquote>
<p>首先，显然有</p>
<script type="math/tex; mode=display">
\sum_{g\in G}|X^g| = \sum_{x\in X} |G_x| \tag{1}</script><p>考虑某一个轨道$G\cdot x$，轨道中的每一个元素的轨道都是$G\cdot x$，每一个元素对$(1)$的贡献是$|G_x|$，所以每一个轨道对$(1)$的贡献就是$|G\cdot x|\cdot |G_x| = |G|$（轨道稳定定理）。也就是说每个轨道对$(1)$的贡献是一样的。</p>
<p>由于轨道的数量为 $|X/G|$，故而 $\sum_{g\in G}|X^g| = |G||X/G|$，即$\frac{1}{|G|} \sum_{g\in G} |X^g| = |X/G|$。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3047 「ZJOI2019」浙江省选</title>
    <url>/2020/05/04/LOJ3047-%E3%80%8CZJOI2019%E3%80%8D%E6%B5%99%E6%B1%9F%E7%9C%81%E9%80%89/</url>
    <content><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>能够排名第 $k$ 的一定满足：存在一个 $x$，使得分数比这个人高的人不超过 $k-1$ 个。可以枚举其它的每一个人，然后计算它比这个人优秀的 $x$ 区间，最后检查一下被覆盖次数最小的部分被覆盖了多少次即可。这样是 $O(n^2 \log n)$ 的。</p>
<p>由于 $m$ 很小，我们考虑对每个 $k\in [1,m]$ 分别求解。假设现在已经求出了排名为 $1$ 到 $k-1$ 的人，则排名为 $k$ 的人一定在剩下的人的半平面交上，并且让它能进队的 $x$ 也一定在半平面交中它贡献的线段上。对其它人求出：对于哪些 $x$，它会比半平面交上对应位置的直线优秀；由于半平面交的形状是个凸壳，所以这样的 $x$ 一定也会构成一个连续区间。而一个人的排名为 $k$ 的条件就是：半平面交中它贡献的线段上，存在整点 $x$，满足 $x$ 只被那些区间覆盖了不到 $k$ 次。时间复杂度 $O(nm\log n)$。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol>
<li><p>排名为“分数<strong>严格</strong>大于自己的人数+1”，所以：</p>
<ol>
<li>对每个人求出的可以覆盖的 $x$ 区间，其端点是不能取到的</li>
<li>半平面交中，如果三条直线交于一点，则三条直线都应该保留</li>
</ol>
</li>
<li><p>题目中要求 $x$ 为非负<strong>整数</strong>，所以要特殊判断半平面交中的某条线段上没有整点的情况</p>
</li>
<li><p>判断某个人是否排名为 $k$：事先求出所有的被覆盖次数不到 $k$ 的区间（称为好区间），然后检查这些好区间与这个人在半平面交上的区间是否有交，这个可以转化成判断与这个人在半平面交上的区间无交的好区间数量是否等于总数量。</p>
</li>
<li><p>（似乎）<code>long double</code> 会精度爆炸，所以用了两个 <code>__int128</code> 来表示一个分数。从 <a href="https://blog.csdn.net/qq_39972971/article/details/92386663" target="_blank" rel="noopener">cz_xuyixuan</a> 的代码中学到了一个很妙的判断直线和凸壳上的点的位置关系的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">frac</span> &#123;</span></span><br><span class="line">	__int128 a,b;</span><br><span class="line">	frac(__int128 a=<span class="number">0</span>,__int128 b=<span class="number">1</span>): a(a),b(b) &#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(frac A,frac B) &#123; <span class="keyword">return</span> A.a*B.b &lt; A.b*B.a; &#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(frac A,frac B) &#123; <span class="keyword">return</span> A.a*B.b &lt;= A.b*B.a; </span><br><span class="line">&#125;s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">	ll k,b;</span><br><span class="line">&#125;q[N],L[N];</span><br><span class="line"><span class="keyword">int</span> tl;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> frac <span class="title">INTER</span><span class="params">(Line A,Line B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(B.k&gt;A.k) <span class="keyword">return</span> frac(A.b-B.b,B.k-A.k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> frac(B.b-A.b,A.k-B.k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L[x].k!=L[y].k) <span class="keyword">return</span> L[x].k&lt;L[y].k;</span><br><span class="line">	<span class="keyword">return</span> L[x].b&gt;L[y].b;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p 为要求半平面交的直线的编号</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">HPI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">	sort(p.begin(),p.end(),cmp);</span><br><span class="line">	tl=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.size();++i) &#123;</span><br><span class="line">		Line c=L[p[i]];</span><br><span class="line">		<span class="keyword">if</span>(tl&amp;&amp;c.k==L[p[i<span class="number">-1</span>]].k) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span>(tl&gt;=<span class="number">2</span> &amp;&amp; INTER(q[tl],c)&lt;s[tl]) tl--;</span><br><span class="line">		<span class="keyword">while</span>(tl&gt;=<span class="number">1</span> &amp;&amp; q[tl].b&lt;c.b) tl--;</span><br><span class="line">		q[++tl]=c;</span><br><span class="line">		<span class="keyword">if</span>(tl==<span class="number">1</span>) s[tl]=frac(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> s[tl]=INTER(q[tl],q[tl<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	s[tl+<span class="number">1</span>]=frac(inf,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://loj.ac/submission/801213" target="_blank" rel="noopener">my submission on loj.ac</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>20200423 SCOI模拟2</title>
    <url>/2020/04/24/20200423-SCOI%E6%A8%A1%E6%8B%9F2/</url>
    <content><![CDATA[<h2 id="A-矩阵求和"><a href="#A-矩阵求和" class="headerlink" title="A - 矩阵求和"></a>A - 矩阵求和</h2><p>答案是</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{i=lx}^{rx} \sum_{j=ly}^{ry} (a_i (m-1) + b_j) \binom{rx-i+k}{k} \binom{ry-j+k}{k}
\end{gathered}</script><p>把组合数拆开，用树状数组维护区间的 $\sum a_i i^j (j\in [0,maxk])$。</p>
<p>时间复杂度 $O\left(q\left(k\log n + k^2\right)\right)$。</p>
<h2 id="B-西行寺无余涅槃"><a href="#B-西行寺无余涅槃" class="headerlink" title="B - 西行寺无余涅槃"></a>B - 西行寺无余涅槃</h2><p>可以参考一下CF1119H（<a href="https://www.luogu.com.cn/blog/command-block/solution-cf1119h" target="_blank" rel="noopener">点此传送到command_block的题解</a>）的做法。</p>
<p>下文中，把 $F$ 数组 FWT 之后的结果写为 $FWT(F)$，把其中第 $i$ 个元素写为 $FWT(F)[i]$。</p>
<p>设</p>
<script type="math/tex; mode=display">
F_t[x] = \sum_{p_{t,j} = x} a_j</script><p>只要对每个 $i\in [0,2^m)$，求出 $\prod_{t=1}^n \left(FWT(F_t)[i]\right)$，就能得到答案。</p>
<p>$FWT(F_t)$ 中的每一项一定都是 $(-1)^{x_1} a_1 + (-1)^{x_2}a_2 + \cdots + (-1)^{x_k}a_k$ 的形式，这只有 $2^k$ 种不同的取值。由于 $k$ 很小，考虑求出每种取值出现了多少次。</p>
<p>设</p>
<script type="math/tex; mode=display">
C_{i,S} = \sum_{t=1}^n \prod_{j=0}^{k-1}\left[{bitcount(i\& p_{t,j})\bmod {2}} = [j\in S]\right]</script><p>显然有</p>
<script type="math/tex; mode=display">
\begin{gathered}
\prod_{t=1}^n (FWT(F_t)[i])\\
= \prod_{S=0}^{2^k-1}\left( \sum_{j\notin S} a_j - \sum_{j\in S} a_j\right)^{C_{i,S}}
\end{gathered}</script><p>想办法构建方程解出 $C_{i,S}$。</p>
<p>选取一个 $\{0,1,\cdots k-1\}$ 的子集 $T$，令</p>
<script type="math/tex; mode=display">
\begin{gathered}
G_{T,t}[j] = \left[\bigoplus_{x\in T} p_{t,x} = j\right]\\
D_{i,T} = \sum_{t=1}^n \left(FWT(G_{T,t})[i]\right)
\end{gathered}</script><p>则</p>
<script type="math/tex; mode=display">
\begin{gathered}
FWT(G_{T,t})[i]=(-1)^{bitcount\left(i\& \left(\bigoplus_{x\in T} p_{t,x}\right)\right)}\\
= (-1)^{\sum_{x\in T} bitcount(i\& p_{t,x})}\\
D_{i,T}\\
= \sum_{t=1}^n \left(FWT\left(G_{T,t}\right)[i] \right)\\
= \sum_{t=1}^n (-1)^{\sum_{x\in T} bitcount(i\& p_{t,x})}\\
= \sum_{S\in [0,2^k)} (-1)^{bitcount(S\&T)} \cdot C_{i,S}
\end{gathered}</script><p>所以 $C_{i} = IFWT(D_i)$。</p>
<p>而 $\sum_t FWT(G_{T,t}) = FWT\left(\sum_t G_{T,t} \right)$，枚举完 $T$ 之后 $O(nk + 2^m m)$ 计算即可求出所有的 $D_{i,T}$ 。</p>
<p>总时间复杂度为 $O(2^k (nk+2^m m) + 2^m2^k k)$。</p>
<h2 id="C-鱼贯而入"><a href="#C-鱼贯而入" class="headerlink" title="C - 鱼贯而入"></a>C - 鱼贯而入</h2><h3 id="做法-0"><a href="#做法-0" class="headerlink" title="做法 0"></a>做法 0</h3><p>特判 $n=1,2,3$。对于 $a_i$ 随机的数据来说，最优的 $len$ 一定不会比 $n$ 大太多。</p>
<h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法 1"></a>做法 1</h3><p>显然只有当 $\exists i,j, len\mid (a_i - a_j)$ 的时候，$Ans &gt; 0$。如此直接枚举 $len$ 计算。</p>
<h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法 3"></a>做法 3</h3><p>根据模运算的一些性质，$kp$ 有的寻址时间 $p$ 一定也有。设 $mind(n)$ 为 $n$ 的最小质因子，那么我们只需要检查满足 $\frac{len}{mind(len)} &lt; n \le len$  的 $len$。</p>
<p>$a_i - a_j$ 的大于等于 $n$ 的质因子一定是可以的。可以的合数一定在 $[n,n^2]$ 内。分别枚举并检查即可。</p>
<h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法 4"></a>做法 4</h3><p>把 Pollard-rho 求 gcd 的那个 $O(\log n)$ 优化掉（可以参考<a href="https://www.cnblogs.com/812-xiao-wen/p/10544546.html" target="_blank" rel="noopener">wch的博客</a>）。这样可以得到 100 分。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3112 「SDOI2019」世界地图</title>
    <url>/2020/04/23/LOJ3112-%E3%80%8CSDOI2019%E3%80%8D%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<p>考虑这样一个问题：有两棵边带权的树，以及若干条两个端点分别在两棵树上、有边权的边。求最小生成树。多次询问，每次给出两棵树之间的边，要求回答询问的复杂度与给出的边数相关。</p>
<p>一个暴力做法是动态最小生成树，每次尝试用新加的边替换掉原来的树上的边。</p>
<p>我们称连接两棵树的那些边的端点为关键点。观察到，对于树上的某条路径，如果任意的一对关键点之间的路径都包含它或者与它无交，那么这条路径上至多有一条边被新加入的边替换掉。因为一旦这条路径的某条边被替换掉（也就意味着这条路径被断开了），那么它将不再与任何的关键点之间的路径有交。</p>
<p>这意味着我们可以对关键点建虚树，虚树上两点之间的边权为它们路径上边权的最大值，然后进行之前的动态最小生成树做法。也可以直接 Kruskal，因为虚树上的点数不超过关键点数量的二倍。</p>
<p>回到本题，可以用上面说的方法求出每个前缀、后缀的最小生成树，对于每个询问，把 $[1,l_i)$ 与 $(r_i,n]$ 合并起来即可。时间复杂度 $O((m+q)n\log n)$。</p>
<p>实现细节可以参考<a href="https://loj.ac/submission/793488" target="_blank" rel="noopener">代码</a>。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu P6151 [集训队作业2019] 青春猪头少年不会梦到兔女郎学姐</title>
    <url>/2020/04/22/luogu-P6151-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2019-%E9%9D%92%E6%98%A5%E7%8C%AA%E5%A4%B4%E5%B0%91%E5%B9%B4%E4%B8%8D%E4%BC%9A%E6%A2%A6%E5%88%B0%E5%85%94%E5%A5%B3%E9%83%8E%E5%AD%A6%E5%A7%90/</url>
    <content><![CDATA[<h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>定义一个序列是好的，当且仅当它以 $1$ 开始且不以 $1$ 结尾。</p>
<p>任意一个序列 $S$，假设它对应的圆排列中有 $c(S)$ 段 $1$，那么它的循环移位中有 $c(S)$ 个好的序列（这其中可能有相同的好序列）。也就是说，所有的好序列的、等于 $S$ 的循环移位的数量为 $c(S)$。</p>
<p>设 $val(S)$ 为序列 $S$ 的权值（与题目中的定义相同），那么</p>
<script type="math/tex; mode=display">
\begin{gathered}
Ans\\
= \sum_{\text{S为符合题意的序列}} val(S) \\
= \sum_{\text{S为符合题意的序列}} \frac{1}{c(S)}\sum_{\text{P是S的循环移位且P是好序列}} val(P)\\
= 
\sum_{\text{S为符合题意的序列}} \sum_{\text{P是S的循环移位且P是好序列}} \frac{1}{c(P)} val(P)\\
= \sum_{\text{P 是符合题意的好序列}} \frac{ val(P)}{c(P)} \sum_{\text{S 是 P 的循环移位}} 1\\
= \sum_{\text{P 是符合题意的好序列}} \frac{val(P)}{c(P)} |P|
\end{gathered}</script><p>因为序列的长度是固定的，我们只需要统计 $\sum_{\text{P是符合题意的好序列}} \frac{val(P)}{c(P)}$ 就能得到答案。</p>
<p>将 $a$ 个相同的数字划分成 $b$ 段的所有方案的权值和为</p>
<script type="math/tex; mode=display">
\sum_{x_i \ge 1, x_1+x_2+\cdots x_b = a} \prod_{i=1}^b x_i</script><p>考虑到 $\prod_i x_i$ 的组合意义相当于是从每段里面再选出一个球，把选的这个球当成板子，可以得到上式等价于</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{x_i \ge 0, x_1+x_2+\cdots x_{2b} = a-b} 1\\
= \binom{a+b-1}{2b-1}
\end{gathered}</script><p>先枚举每种数字在最终的序列中形成了多少段，然后由于要求同种数字的段不能相邻，所以再枚举同种数字的哪些段被粘在了一起（容斥）。不为 $1$ 的数字，它的 EGF 为（假设这种数字共有 $a$ 个）</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{b=1}^a \binom{a+b-1}{2b-1} \sum_{j=1}^b (-1)^{b-j} \binom{b-1}{j-1} \frac{x^j}{j!}\\
= \sum_{j=1}^a \frac{x^j}{j!(j-1)!} (-1)^j \sum_{b=j}^a \frac{(b-1)!}{(b-j)!} (-1)^b \binom{a+b-1}{2b-1}
\end{gathered}</script><p>可以一次 FFT 算出来。</p>
<p>而对于数字 $1$，容斥的时候除了可以把相邻的段粘在一起，还可以把最后一段和结尾粘在一起，并且第一段在序列中的位置是确定了的，不参与排列，所以它的 EGF 为（仍然设 $a=c_1$）</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{b=1}^a \frac{1}{b} \binom{a+b-1}{2b-1} \sum_{j=0}^{b-1} \binom{b}{b-1-j} (-1)^{b-1-j} \frac{x^j}{j!}\\
= \sum_{j=0}^{a-1} \frac{x^j}{j!(j+1)!} (-1)^j \sum_{b=j+1}^a \frac{b!}{(b-j-1)!}(-1)^{b-1} \frac{1}{b} \binom{a+b-1}{2b-1}
\end{gathered}</script><p>也可以一次 FFT 算出来。</p>
<p>最后我们需要算的是每个数字的 EGF 的乘积，分治 FFT 即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,<span class="keyword">int</span> y)</span> </span>&#123; ll res=<span class="number">1</span>; <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%mod; <span class="keyword">return</span> res; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> wn[<span class="number">2</span>][N],rev[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getwn</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;l);i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> w0=Pow(<span class="number">3</span>,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>)),w1=Pow(<span class="number">3</span>,mod<span class="number">-1</span>-(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">            wn[<span class="number">0</span>][i]=wn[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line">                wn[<span class="number">0</span>][i+j]=wn[<span class="number">0</span>][i+j<span class="number">-1</span>]*(ll)w0%mod,</span><br><span class="line">                wn[<span class="number">1</span>][i+j]=wn[<span class="number">1</span>][i+j<span class="number">-1</span>]*(ll)w1%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(len&gt;&gt;<span class="number">1</span>)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> len,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) <span class="keyword">if</span>(rev[i]&lt;i) swap(A[i],A[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=l&lt;&lt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;l;++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t0=A[i+j],t1=A[i+l+j]*(ll)wn[f][l+j]%mod;</span><br><span class="line">                    A[i+j]=(t0+t1)%mod,A[i+l+j]=(t0-t1)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> Inv=Pow(len,mod<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[i]=A[i]*(ll)Inv%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span> *C,<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> l3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a[N],b[N];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>; <span class="keyword">while</span>(len&lt;n+m<span class="number">-1</span>||len&lt;l3) len&lt;&lt;=<span class="number">1</span>; getr(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=b[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) a[i]=A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) b[i]=B[i];</span><br><span class="line">        FFT(a,len,<span class="number">0</span>),FFT(b,len,<span class="number">0</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=a[i]*(ll)b[i]%mod; FFT(a,len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l3;++i) C[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span> *C,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123; Mul(A,B,C,n,m,n+m<span class="number">-1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;C)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> a[N],b[N];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>; <span class="keyword">while</span>(len&lt;A.size()+B.size()<span class="number">-1</span>) len&lt;&lt;=<span class="number">1</span>; getr(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=b[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();++i) a[i]=A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B.size();++i) b[i]=B[i];</span><br><span class="line">        FFT(a,len,<span class="number">0</span>),FFT(b,len,<span class="number">0</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=a[i]*(ll)b[i]%mod; FFT(a,len,<span class="number">1</span>);</span><br><span class="line">        C.resize(A.size()+B.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;C.size();++i) C[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N],s[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="keyword">void</span>)(s[c]=g[l]);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	solve(l,mid,c&lt;&lt;<span class="number">1</span>),solve(mid+<span class="number">1</span>,r,c&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	Poly::Mul(s[c&lt;&lt;<span class="number">1</span>],s[c&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],s[c]);</span><br><span class="line">	s[c&lt;&lt;<span class="number">1</span>].clear();</span><br><span class="line">	s[c&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].clear();</span><br><span class="line">&#125;</span><br><span class="line">ll fac[N&lt;&lt;<span class="number">1</span>],inv[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">// ll A[N],B[N],C[N];</span></span><br><span class="line"><span class="keyword">int</span> A[N],B[N],C[N];</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="comment">//ll sum[N],tmp[N];</span></span><br><span class="line"><span class="comment">//int len;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getfac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=Pow(fac[n],mod<span class="number">-2</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;</span><br><span class="line"><span class="keyword">int</span> ra[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m; rd(m);</span><br><span class="line">	getfac(<span class="number">400000</span>);</span><br><span class="line">	Poly::getwn(<span class="number">18</span>);</span><br><span class="line"><span class="comment">//	sum[0]=1;</span></span><br><span class="line">	<span class="keyword">int</span> coe=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">1</span>,a;now&lt;=m;++now) &#123;</span><br><span class="line">		rd(a),coe+=a;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a;++i) A[i]=B[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(now==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) A[i]=binom(a+i<span class="number">-1</span>,<span class="number">2</span>*i<span class="number">-1</span>)*fac[i<span class="number">-1</span>]%mod*(i&amp;<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) B[a-i]=inv[i<span class="number">-1</span>];</span><br><span class="line">			Poly::Mul(A,B,C,a+<span class="number">1</span>,a+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;++i) f[i]=C[i+a]*inv[i]%mod*inv[i+<span class="number">1</span>]%mod*(i&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line"><span class="comment">//			for(int i=1;i&lt;=a;++i) B[i]=inv[i-1];</span></span><br><span class="line"><span class="comment">//			for(int i=1;i&lt;=a;++i) for(int j=1;j&lt;=i;++j) (C[i-j]+=A[i]*B[j]%mod)%=mod;</span></span><br><span class="line"><span class="comment">//			for(int i=0;i&lt;a;++i) f[i]=C[i]*inv[i]%mod*inv[i+1]%mod*(i&amp;1?-1:1),C[i]=0;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) A[i]=binom(a+i<span class="number">-1</span>,<span class="number">2</span>*i<span class="number">-1</span>)*fac[i<span class="number">-1</span>]%mod*(i&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;++i) B[a-i]=inv[i];</span><br><span class="line">			Poly::Mul(A,B,C,a+<span class="number">1</span>,a+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) f[i]=C[i+a]*inv[i]%mod*inv[i<span class="number">-1</span>]%mod*(i&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line"><span class="comment">//			for(int i=0;i&lt;a;++i) B[i]=inv[i];</span></span><br><span class="line"><span class="comment">//			for(int i=1;i&lt;=a;++i) for(int j=0;j&lt;i;++j) (C[i-j]+=A[i]*B[j]%mod)%=mod;</span></span><br><span class="line"><span class="comment">//			for(int i=1;i&lt;=a;++i) f[i]=C[i]*inv[i]%mod*inv[i-1]%mod*(i&amp;1?-1:1),C[i]=0;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a;++i) g[now].PB(f[i]),f[i]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;=a;++i)</span></span><br><span class="line"><span class="comment">//		for(int j=0;j&lt;=len;++j)</span></span><br><span class="line"><span class="comment">//			(tmp[i+j]+=f[i]*sum[j]%mod)%=mod;</span></span><br><span class="line"><span class="comment">//		len+=a;</span></span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;=len;++i) sum[i]=tmp[i],tmp[i]=0;</span></span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;=a;++i) f[i]=0;</span></span><br><span class="line">	&#125;</span><br><span class="line">	solve(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;=len;++i) (ans+=sum[i]*fac[i]%mod)%=mod;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s[<span class="number">1</span>].size();++i) (ans+=s[<span class="number">1</span>][i]*fac[i]%mod)%=mod;</span><br><span class="line">	ans=<span class="number">1l</span>l*ans*coe%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,(ans+mod)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3102 「JSOI2019」神经网络</title>
    <url>/2020/04/21/LOJ3102-%E3%80%8CJSOI2019%E3%80%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/792389" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<p>不难发现问题等价于：把每棵树划分成若干条链，把这些链拿来做圆排列，要求相邻的链不能来自同一棵树，求方案数。</p>
<p>假设我们已经把每棵树划分成了若干条链，并且确定好了链在圆排列中出现的方向（长度大于 $1$ 的链有两种可能的方向），求圆排列方案数。假设此时第 $i$ 棵树的点划分成了 $A_i$ 条链。</p>
<p>把环断开为序列，钦定序列的开头为第一棵树的 $1$ 号点所在的链。我们对序列的要求是：</p>
<ul>
<li>相邻的两条链不能来自同一棵树</li>
<li>结尾的链不能来自第一棵树</li>
</ul>
<p>首先我们确定每棵树内的点在序列中的相对顺序（也就是最终答案乘上 $(A_1 - 1)! \prod_{i=2}^m A_i!$）。</p>
<p>如果没有上面两个限制，方案数就是 $\frac{(\sum A_i -1)!}{(A_1 - 1)!\prod_{i=2}^m A_i!}$。</p>
<p>对于上面的两个限制，钦定一些同一棵树中相对顺序相邻的链粘在一起（或者钦定第一棵树中相对顺序在最右边的和序列的结尾粘在一起）进行容斥即可。</p>
<p>把方案数中的 $\frac{1}{(A_1 - 1)! \prod_{i=2}^m A_i! }$ 下放到每个 $A_i$ 头上（也就是在我们确定 $A_i$ 的时候就乘上相应的系数），那么计算总方案数就只需要知道 $\sum A_i$。把 $\sum A_i$ 作为状态进行 dp（或者把 $\sum A_i$ 作为生成函数的指数进行卷积）即可。</p>
<p>总时间复杂度 $O((\sum k_i)^2 )$。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3059 「HNOI2019」序列</title>
    <url>/2020/04/20/LOJ3059-%E3%80%8CHNOI2019%E3%80%8D%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>IOI2018 集训队论文 高睿泉 《浅谈保序回归问题》</li>
<li><a href="https://www.cnblogs.com/Paul-Guderian/p/10801584.html" target="_blank" rel="noopener">大米饼的博客</a></li>
</ul>
<h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><h3 id="部分分：-m-0"><a href="#部分分：-m-0" class="headerlink" title="部分分：$m=0$"></a>部分分：$m=0$</h3><p>考虑一个更加一般的形式：已知 $w_i, A_i \ge 0$，要求确定 $B_i$，使得 $B_i \le B_{i+1}$ 且 $\sum w_i(A_i - B_i)^2$ 最小。</p>
<p>定义一个点集 $U$ 的均值为：让 $\sum_{j\in U} w_j (A_j - k)^2$ 取到最小值的 $k$。对于这道题，$k = \frac{\sum_{j\in U} w_jA_j}{\sum_{j\in U} w_j}$（通过求导可得）</p>
<h4 id="引理-1"><a href="#引理-1" class="headerlink" title="引理 1"></a>引理 1</h4><p>能达到最优解的 $\{ B_i \}$ 是唯一的。</p>
<p>证明：将 $(A_1,A_2,\cdots A_n)$ 和 $(B_1, B_2, \cdots B_n)$ 看作两个 $n$ 维向量，权值函数可以看作两个点之间的距离。由于不等式组 $B_i \le B_{i+1}$ 的解空间是一个凸集，所以到 $A$ 的距离最短的 $B$ 是唯一的。</p>
<h4 id="引理-2"><a href="#引理-2" class="headerlink" title="引理 2"></a>引理 2</h4><p>如果 $A_i &gt; A_{i+1}$，那么最优解中一定有 $B_i = B_{i+1}$。</p>
<p>证明：参考 IOI2018 集训队论文《浅谈保序回归问题》</p>
<p>引理 2 启发我们可以考虑这样的一个过程：每一次找到一个满足 $A_i &gt; A_{i+1}$ 的 $i$，然后将 $i$ 和 $i+1$ 合并。具体地，应该把 $(w_i, A_i), (w_{i+1},A_{i+1})$ 替换为 $(w_i + w_{i+1}, \frac{w_iA_i + w_{i+1}A_{i+1}}{w_i + w_{i+1}})$，这样前后的权函数只相差一个常数，直接在合并的时候把这个常数加入答案即可。合并到无法合并的时候，直接令每个 $B_i$ 都取 $A_i$，这就是最优方案。最终的答案就是在合并的过程中产生的那些常数的和。</p>
<p>由引理 1 可知，无论以任何顺序合并，最终得到的 $\{ B_i \}$ 都是相同的，所以合并过程完成以后得到的那些同值的段（下文称为等值段）也一定是相同的。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>把询问离线下来依次处理。对于询问 $(x,y)$，先处理好只考虑 $[1,x-1]$ 和 $[x+1,n]$ 时，等值段的划分情况（可以用从左到右和从右到左的单调栈分别维护）。</p>
<p>最终的划分方案一定是：保留 $[1,x-1]$ 的等值段划分的一个前缀，保留 $[x+1,n]$ 的等值段划分的一个后缀，剩下的部分和 $x$ 合并为一段。设这个前缀包含了 $[1,x-1]$ 的前 $L_0$ 个等值段，这个后缀包含了 $[x+1,n]$ 的后 $R_0$ 个等值段。设 $L_0,R_0$ 之间（不含 $L_0,R_0$）的元素合并起来后的权值（也就是它们的平均值）为 $v(L_0,R_0)$。设 $[1,x-1]$ 中从左到右第 $x$ 段的 $A_i$ 为 $lv(x)$，设 $[x+1,n]$ 中从右到左第 $x$ 段的 $A_i$ 为 $rv(x)$。</p>
<p>考虑如何求出 $L_0,R_0$。我们对 $L_0,R_0$ 的要求是：</p>
<ul>
<li>$lv(L_0) &lt; v(L_0,R_0) &lt; rv(R_0)$</li>
<li>$L_0,R_0$ 之间的元素确实能合并成一段（即合并过程中不存在把 $A_i &lt; A_{i+1}$ 的两个元素合并了的情况）</li>
</ul>
<p>考虑这样一个算法：从大到小枚举 $R_0$，然后求出最大的 $L_0$，使得 $lv(L_0) &lt; v(L_0, R_0)$；如果 $v(L_0, R_0) &lt; v(R_0)$ 就退出，把此时的 $L_0, R_0$ 作为答案，否则继续枚举 $R_0$。</p>
<ul>
<li>对于某个固定的 $R_0$ 来说<ul>
<li>考虑某个比求出的 $L_0$ 更小的 $L_0’$：$v(L_0’,R_0)$ 一定合并了不能合并的段（即满足 $A_i &lt; A_{i+1}$ 的两个段）</li>
<li>考虑某个比求出的 $L_0$ 更大的 $L_0’$：$v(L_0’,R_0)$ 一定还能和左边的段合并，所以不可能和 $R_0$ 一起作为最终的等值段</li>
</ul>
</li>
<li>故而，对于固定的 $R_0$ 来说，最大的满足 $lv(L_0) &lt; v(L_0, R_0)$ 的 $L_0$ 是<strong>唯一可能使 $(L_0,R_0)$ 合法</strong>的 $L_0$</li>
</ul>
<p>假设 $r$ 为算法结束时的 $R_0$：任意一个大于 $r$ 的 $R_0$ 显然不可能成为最终的等值段的右端点（因为还可以和右边的段合并）；而任意一个小于 $r$ 的 $R_0$，$v(L_0,R_0)$ 一定合并了不能合并的段。</p>
<p>所以，算法结束时求出来的 $L_0,R_0$ 就是我们想求的答案。</p>
<p>算法的优化：</p>
<ul>
<li>在已知 $R_0$ 的情况下求最大的满足 $lv(L_0) &lt; v(L_0, R_0)$ 的 $L_0$<ul>
<li>可以证明，如果 $L_0$ 满足条件，那么 $L_0 - 1$ 也满足条件<ul>
<li>由于 $lv(L_0) &lt; v (L_0, R_0)$，又因为 $lv(L_0 - 1) &lt; lv(L_0)$，所以 $lv(L_0 - 1) &lt; v(L_0, R_0)$，那么 $lv(L_0 - 1)$ 一定小于 $lv(L_0), v(L_0,R_0)$ 中的元素的平均值（也就是 $v(L_0 - 1,R_0)$），所以 $L_0 - 1$ 一定也满足条件</li>
</ul>
</li>
<li>所以可以直接二分 $L_0$</li>
</ul>
</li>
<li>求最大的 $R_0$，使得满足 $lv(L_0) &lt; v(L_0, R_0)$ 的最大的 $L_0$ 也满足 $v(L_0, R_0) &lt; rv(R_0)$<ul>
<li>一个重要的观察是，对于某个固定的 $R_0$，满足 $lv(L_0) &lt; v(L_0, R_0)$ 的最大的 $L_0$，就是使 $v(L_0,R_0)$ 取到最大值的 $L_0$</li>
<li>可以证明，如果 $R_0$ 满足条件，那么$R_0-1$ 也满足条件<ul>
<li>设 $R_0$ 求出的 $L_0$ 为 $L$，$R_0 - 1$ 求出的 $L$ 为 $L’$，那么 $v(L’, R_0) \le v(L, R_0) &lt; rv(R_0) &lt; rv(R_0 - 1)$，$v(L’,R_0)$ 和 $rv(R_0)$ 都小于 $rv(R_0 - 1)$，所以 $v(L’, R_0 - 1)$ 小于 $rv(R_0 - 1)$</li>
</ul>
</li>
<li>所以可以直接二分 $R_0$</li>
</ul>
</li>
</ul>
<p>总时间复杂度为 $O(n \log^2 n)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://loj.ac/submission/791870" target="_blank" rel="noopener">my submission on loj.ac</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3056 「HNOI2019」多边形</title>
    <url>/2020/04/18/LOJ3056-%E3%80%8CHNOI2019%E3%80%8D%E5%A4%9A%E8%BE%B9%E5%BD%A2/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/790203" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<p>对于一个已经无法继续旋转的多边形，我们考虑它上面的一个四边形，其顶点依次为 $A,B,C,D$（$O$ 点表示多边形的 $1$ 号顶点）：</p>
<p><img src="https://i.loli.net/2020/04/18/rAujCUZgbMqxNYH.jpg" alt="0.jpg"></p>
<p>从 $C$ 到 $D$ 的这一段：</p>
<ul>
<li>假设以 $CD$ 为一边的另一个三角形为 $\triangle CDT_1$（显然 $T_1\in (C,D)$，$CD$ 无法再旋转）</li>
<li>不可能有以 $T_1C$ 为一边的异于 $\triangle CDT_1$ 的三角形（否则 $CT_1$ 将可以旋转）</li>
<li>可以有以 $T_1D$ 为一边的异于 $\triangle CDT_1$ 的三角形，设为 $\triangle DT_1T_2$</li>
<li>不可能有以 $T_2T_1$ 为一边的异于 $\triangle DT_1T_2$ 的三角形，但是可以有以 $DT_1$ 为一边的异于 $\triangle DT_1T_2$ 的三角形，设为 $\triangle DT_2T_3$</li>
<li>……</li>
</ul>
<p>从 $B$ 到 $D$ 这一段：不可能有以 $BC$ 为边且不同于 $\triangle BCD$ 的三角形，否则 $BC$ 将可以旋转。从 $A$ 到 $B$ 的这一段同理。</p>
<p>从 $D$ 到 $A$ 的这一段：</p>
<ul>
<li>如果有以 $AD$ 为一边的异于 $\triangle ABD$ 的三角形，设为 $\triangle ADP_1$：<ul>
<li>$P_1\in (D,n]$，那么 $AD$ 就可以旋转了</li>
<li>如果 $P_1\in [1, A-1)$ 则是合法的</li>
</ul>
</li>
<li>不可能有以 $P_1A$ 为一边异于 $\triangle AP_1D$ 的三角形，因为这样 $P_1A$ 就可以旋转了</li>
<li>可以有以 $P_1D$ 为一边的异于 $\triangle AP_1D$ 且另一顶点 $\in [1,P_1)$的三角形，设为 $\triangle DP_1P_2(P_2 \in [1,P_1))$</li>
<li>不可能有以 $P_1P_2$ 为一边的异于 $\triangle DP_1P_2$ 的三角形，但是可以有以 $DP_2$ 为一边的异于 $\triangle DP_1P_2$ 且另一顶点位于 $[1,P_2)$ 的三角形，设为 $\triangle DP_2P_3$</li>
<li>……</li>
</ul>
<p><img src="https://i.loli.net/2020/04/18/91LQVh7Tgq8PREG.jpg" alt="1.jpg"></p>
<p>综上所述，一个多边形如果无法继续旋转，那么除了 $n$ 号点以外的每个点必须直接和 $n$ 号点相连。</p>
<p>对于一个状态，发现它不直接连接 $n$ 和其它点的边会形成一个树形结构（实际上是个二叉树森林）：</p>
<p><img src="https://i.loli.net/2020/04/18/JPl9guIyODTzkfV.jpg" alt="2.jpg"></p>
<p><img src="https://i.loli.net/2020/04/18/1DrkNOBKEcub2Pp.jpg" alt="3.jpg"></p>
<p>最小的操作次数就是树上的点数（即多边形中不直接连接 $n$ 和其它点的边数）；操作的方案数也就是将树中的点排列使得祖先总是在自己之前出现的方案数。一个经典结论是这样的排列方案数为点数的阶乘除以每个点的子树大小。</p>
<p>考虑在初始状态上进行一次旋转会造成什么样的影响：</p>
<p><img src="https://i.loli.net/2020/04/18/3IOwP9UaCG6qntv.jpg" alt="4.jpg"></p>
<p>发现只有被旋转的那条边的子树大小改变了。预处理出初始状态的操作方案数，就能快速地得到旋转之后的答案。注意特判被旋转的边为根的情况。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>20200416 SCOI模拟1</title>
    <url>/2020/04/17/20200416-SCOI%E6%A8%A1%E6%8B%9F1/</url>
    <content><![CDATA[<h2 id="A-同桌与室友"><a href="#A-同桌与室友" class="headerlink" title="A - 同桌与室友"></a>A - 同桌与室友</h2><p>相当于是有一张图，边有两种，与每个点相邻的每种边至多有一条。求有多少种重标号的方案，使得重标号前后的图相同。</p>
<p>由于每个点的度数不超过 2，我们可以对连通块的形态讨论（每个连通块要么是链，要么是环）。</p>
<p><strong>记得取模</strong>。</p>
<h2 id="B-传送"><a href="#B-传送" class="headerlink" title="B - 传送"></a>B - 传送</h2><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>这是我考场上的想法。</p>
<p>一个观察是，只需要保证两个相邻的点之间的边权大于等于两个点的点权差，就能保证方案合法，因为考虑在同一条链上的三个点 $A,B,C$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dis(A,C) =& dis(A,B) + dis(B,C)\\
\ge& |a_A-a_B| + |a_B-a_C|\\
\ge& \left|\left(a_A - a_B\right) + \left(a_B - a_C\right)\right|\\
=& | a_A - a_C|
\end{aligned}</script><p>对于每个点，求出 $L_x,R_x$ 表示当 $a_x \in [L_x,R_x]$ 时存在一种合法的给 $x$ 的子树内的点赋值的方案。</p>
<p>设 $w(u,v)$ 为 $u,v$ 之间的边的边权，则有转移方程</p>
<script type="math/tex; mode=display">
\begin{gathered}
L_x = \max_{v\in son_x} \{ L_v-w(x,v)\}\\
R_x = \min_{v\in son_x} \{ R_v+w(x,v)\}
\end{gathered}</script><p>一组 $\{[l_i,r_i]\}$ 是合法的当且仅当对于所有的 $x$ 都有 $L_x \le R_x$。</p>
<p>对于 $type=1$ 的，套个二分就可以了。</p>
<p>复杂度 $O(n\log V)$，我以为能过，但是只有70分。。。:ambulance:</p>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>我们不妨带上未知数进行 dp。假设花费的代价是 $v$，发现有了 $v$ 之后 $L_x,R_x$ 只不过就是变成了 $L_x - v, R_x + v$（因为 min 和 max 函数里面每一项都是原来的值 $+v$）。</p>
<p>所以当 $type=1$ 的时候，答案就是</p>
<script type="math/tex; mode=display">
\left\lceil \frac{\max\{ \max_{i\in [1,n]}\{ L_x-R_x\},0\}}{2}\right\rceil</script><h2 id="C-生成树"><a href="#C-生成树" class="headerlink" title="C - 生成树"></a>C - 生成树</h2><p>设 $A_{i,j}$ 为一个二元生成函数，$x^ay^b(a,b\ge 0, a+b\in [0,1])$ 的系数为从 $i$ 到 $j$ 的边中选出 $a$ 条绿色边、$b$ 条蓝色边的方案数。</p>
<p>根据矩阵树定理我们知道</p>
<script type="math/tex; mode=display">
\det(L_r) = \sum_{T\text{为生成树}} \prod_{(i,j)\in T} A_{i,j}</script><p>我们只要求出 $\det(L_r)$ 的各项系数就能得到答案。</p>
<p>把 $A_{i,j}$ 的点值带入求行列式，最后再插值回去，可以做到 $O(n^5)$ 的复杂度。</p>
<p>一种实现：由于最后多项式中 $x$ 的次数至多是 $n-1$，所以可以把 $y$ 带成 $x^{n}$，避开二维插值。</p>
<p><strong>注意判掉输入的自环</strong>。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵树定理及证明</title>
    <url>/2020/04/17/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E5%8F%8A%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://oi-wiki.org/graph/matrix-tree/" target="_blank" rel="noopener">OI-wiki(没有证明)</a></li>
<li><a href="http://math.mit.edu/~levine/18.312/alg-comb-lecture-19.pdf" target="_blank" rel="noopener">通过 google search 找到的一篇资料</a></li>
</ul>
<h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><p>一个排列的逆序对数的奇偶性与（排列的长度-环数）相同。</p>
<p>证明：</p>
<p>观察 1：如果交换排列中的两个元素，逆序对数的奇偶性恰好会改变。</p>
<ul>
<li>假设交换的元素是 $i, j (i &lt; j)$</li>
<li>$i$ 左侧，$j$ 右侧的元素的贡献不会变化</li>
<li>开区间 $(i,j)$ 中的元素的贡献的奇偶性不变</li>
<li>$i,j$ 的贡献会变化 1（加 1 或者减 1）</li>
</ul>
<p>观察 2：单位排列的逆序对数为 0，是一个偶数。</p>
<p>观察 3：可以通过（排列 $P$ 的长度-环数）次“交换两个元素”的操作，将单位排列变成 $P$。</p>
<h2 id="定义们"><a href="#定义们" class="headerlink" title="定义们"></a>定义们</h2><p>定义有向图 $G$ 的以 $r$ 为根的有向生成树 (oriented spanning tree) 为：$r$ 出度为 $0$、其余点出度为 $1$ 的弱连通生成图。</p>
<p>定义有向图 $G$ 的拉普拉斯矩阵 $L$ 为 $D-A$，其中</p>
<script type="math/tex; mode=display">
D_{i,j} = \begin{cases}
\text{i 号点的出度} & i = j\\
0 & i\neq j
\end{cases}</script><p>而 $A$ 为 $G$ 的邻接矩阵（$A$ 为 01 矩阵且 $A_{i,j}$ 为 $1$ 当且仅当 $G$ 中存在一条从 $i$ 到 $j$ 的边）。</p>
<p>设 $L_r$ 为去掉 $L$ 的第 $r$ 行、第 $r$ 列之后得到的 $(n-1)\times (n-1)$ 的矩阵。</p>
<p>矩阵树定理：$G$ 的以 $r$ 为根的有向生成树个数为 $\det(L_r)$。</p>
<p>容易把矩阵树定理扩展到无向图的生成树计数。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>如果选取的根 $r \neq n$，则可以通过重标号让 $r=n$。所以下面我们只考虑 $r=n$ 的情况。</p>
<p>定义 $S_n$ 为长度为 $n$ 在所有排列构成的集合。对于一个排列 $\sigma$，定义 $\operatorname{sgn}(\sigma)$ 为 $(-1)^{\sigma \text{的逆序对个数}}$。</p>
<script type="math/tex; mode=display">
\det (L_r) = \sum_{\sigma \in S_{n-1}} \operatorname{sgn}(\sigma) L_{1,\sigma(1)} L_{2,\sigma(2)} \cdots L_{n-1,\sigma(n-1)}</script><p>考虑这个式子的组合意义：不考虑正负号，当 $\sigma(i) = i$ 的时候，$L_{i,\sigma(i)}$ 相当于选择一条从 $i$ 出发的边的方案数；当 $\sigma(i) \neq i$ 的时候，$L_{i,\sigma(i)}$ 相当于选择一条从 $i$ 到 $\sigma (i)$ 的边的方案数。注意到这也就相当于是在枚举 $n$ 点出度为 $0$、其余点出度为 $1$ 的子图。</p>
<p>我们要证明的是：在枚举 $\sigma$ 的过程中，所有是树的子图被统计到的系数都是 $1$，所有不是树的子图被统计到的系数都是 $0$。</p>
<p>注意到：由于 $\sigma$ 是一个排列，所以 $i\to \sigma(i)$ 必然形成若干个大小大于 $1$ 的环和一些 $i = \sigma(i)$ 的单点（自环）。</p>
<p>对于树：由于树无环，所以这种子图绝对不可能选择 $i\to \sigma(i)(\sigma(i)\neq i)$ 的边，所以它只会在 $\sigma = \{1,2,\cdots n-1\}$ 的时候被数到，其系数显然为 $1$。</p>
<p>对于不是树的子图：它至少包含了一个环。设子图中的环为 $C_1,C_2,\cdots C_k(k &gt; 0)$（$C_i$ 为第 $i$ 个环上的点构成的点集），设不在环上的点集为 $T$。考虑什么样的 $\sigma$ 会数到这个子图：$T$ 中的每个点 $x$ 一定都有 $\sigma(x) = x$；而对于每个 $C_i$，要么 $C_i$ 中的每个点都有 $\sigma(x) = x$，要么就用 $i\to \sigma(i)(i\neq \sigma(i))$ 这样的形式来表示出 $C_i$ 这个环。假设 $C_{i_1},C_{i_2},\cdots C_{i_l}$ 这些环上的点满足 $\sigma(x) = x$，而 $C_{j_1},C_{j_2},\cdots C_{j_m}$ 这些环是用 $i \to \sigma(i)(i\neq \sigma(i))$ 表示的，那么对应的 $\operatorname{sgn}(\sigma)$ 为（考虑前面的引理）</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\operatorname{sgn}(\sigma)\\
=& (-1)^{n-1-(|C_{i_1}|+|C_{i_2}|+\cdots +|C_{i_l}|+m)}\\
=& (-1)^{(|C_{j_1}|-1)+(|C_{j_2}|-1)+\cdots +(|C_{j_m}|-1)}\\
\end{aligned}</script><p>而 $\prod_{i=1}^{n-1} L_{i,\sigma(i)}$ 所带的系数为</p>
<script type="math/tex; mode=display">
(-1)^{|C_{j_1}| + |C_{j_2}| + \cdots + |C_{j_m}|}</script><p>注意到两者的乘积恰好为 $(-1)^m$。</p>
<p>所有可能的 $\sigma$ 的系数之和为</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \sum_{\{j_1,j_2,\cdots\}\subseteq \{1,2,\cdots k\}} (-1)^{|\{j_1,j_2,\cdots \}|}\\
= & \sum_{i=0}^{k} \binom{k}{i} (-1)^i\\
= &(1-1)^{k}
\end{aligned}</script><p>在 $k&gt;0$ 的时候这个系数为 $0$。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>这个证明的本质是：枚举所有的 $n$ 号点出度为 $0$、其余点出度为 $1$ 的子图，并说明这其中每个有环的子图贡献系数为 0，无环的子图贡献系数为 1。</p>
<p>我们可以得到一个更加一般的形式：</p>
<script type="math/tex; mode=display">
\det(L_r)=\sum_{\text{T is a oriented spanning tree rooted at r }} \prod_{\text{ j is i's father in T}} A_{i,j}</script>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3054 「HNOI2019」鱼</title>
    <url>/2020/04/16/LOJ3054-%E3%80%8CHNOI2019%E3%80%8D%E9%B1%BC/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/788299" target="_blank" rel="noopener">my AC submission</a></p>
<h2 id="关于题意的补充说明"><a href="#关于题意的补充说明" class="headerlink" title="关于题意的补充说明"></a>关于题意的补充说明</h2><ul>
<li>令 $\alpha(0\le \alpha &lt; 2\pi)$ 为 $\overrightarrow{DA}$ 逆时针旋转到 $\overrightarrow{DE}$ 经过的角度，$\beta ( 0\le \beta &lt; 2\pi )$ 为 $\overrightarrow{DA}$ 逆时针旋转到 $\overrightarrow{DF}$ 经过的角度，那么题意中对 $\angle ADE, \angle ADF$ 的限制等价于：$\frac{1}{2} \pi &lt; \alpha, \beta &lt; \frac{3}{2} \pi$。</li>
<li>可以参考我的这份<a href="https://loj.ac/submission/788307" target="_blank" rel="noopener">O(n^6)暴力</a>来确认自己没有读错题意。</li>
</ul>
<h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>枚举 $D$ 和 $A$，然后统计合法的 $B,C,E,F$ 的数量。</p>
<p>发现 $B,C$ 和 $E,F$ 是独立的，可以分别统计然后相乘。</p>
<p>统计 $B,C$ 的数量：某一对 $B,C$ 合法的充要条件是 $BC$ 的中垂线与 $AD$ 重合且交点（也就是 $BC$ 的中点）在线段 $AD$ 上（不含端点）。可以预先枚举所有的 $BC$，求出中垂线及中点并排好序，枚举 $AD$ 的时候直接在序列上二分即可。</p>
<p>统计 $E,F$ 的数量：枚举 $D$ 之后对其它点进行极角排序，扫描线维护。</p>
<p>总时间复杂度 $O(n^2 \log n)$。</p>
<h2 id="实现细节：直线方程的处理"><a href="#实现细节：直线方程的处理" class="headerlink" title="实现细节：直线方程的处理"></a>实现细节：直线方程的处理</h2><p>用 $Ax + Bx + C = 0(A,B,C \in \mathbb{Z})$ 的形式来表示直线。</p>
<h3 id="求-BC-的中垂线"><a href="#求-BC-的中垂线" class="headerlink" title="求 $BC$ 的中垂线"></a>求 $BC$ 的中垂线</h3><p>对于一个在 $BC$ 中垂线上的点 $P$，它满足</p>
<script type="math/tex; mode=display">
\begin{gathered}
(\overrightarrow{P} - \overrightarrow{B})\cdot (\overrightarrow{C} - \overrightarrow{B}) = \frac{1}{2}(\overrightarrow{C} - \overrightarrow{B})\cdot (\overrightarrow{C} - \overrightarrow{B})\\
2\overrightarrow{P}\cdot (\overrightarrow{C}-\overrightarrow{B}) - (\overrightarrow{C}-\overrightarrow{B}) \cdot (\overrightarrow{C} + \overrightarrow{B}) = 0
\end{gathered}</script><p>带入点乘定义式即可。</p>
<h3 id="求直线-AD"><a href="#求直线-AD" class="headerlink" title="求直线 $AD$"></a>求直线 $AD$</h3><p>对于一个直线 $AD$ 上的点 $P$，它满足</p>
<script type="math/tex; mode=display">
\begin{gathered}
(\overrightarrow{P} - \overrightarrow{A}) \times (\overrightarrow{D} - \overrightarrow{A}) = 0\\
\overrightarrow{P} \times (\overrightarrow{D} - \overrightarrow{A}) - \overrightarrow{A} \times (\overrightarrow{D} - \overrightarrow{A}) = 0
\end{gathered}</script><p>带入叉乘的定义式即可。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3045 「ZJOI2019」开关</title>
    <url>/2020/04/11/LOJ3045-%E3%80%8CZJOI2019%E3%80%8D%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<ul>
<li><a href="https://loj.ac/submission/784772" target="_blank" rel="noopener">my submission on loj.ac</a></li>
<li>参考了 <a href="https://www.cnblogs.com/zhoushuyu/p/10687696.html" target="_blank" rel="noopener">zsy的博客</a></li>
</ul>
<p>设</p>
<script type="math/tex; mode=display">
\begin{gathered}
A(x) = \sum_{i=0}^\infty [\text{操作 i 次之后状态为 s 的概率}]\frac{x^i}{i!}\\
B(x) = \sum_{i=0}^\infty [\text{操作 i 次之后状态为 000.....00 的概率}]\frac{x^i}{i!}
\end{gathered}</script><p>那么（可以类比奇自然数和偶自然数的 EGF）</p>
<script type="math/tex; mode=display">
\begin{gathered}
A(x) &=& \prod_{i=1}^n \frac{e^{\frac{p_i}{P}x}+(-1)^{s_i}e^{-\frac{p_i}{P}x}}{2}\\
B(x) &=& \prod_{i=1}^n \frac{e^{\frac{p_i}{P}x}+e^{-\frac{p_i}{P}x}}{2}
\end{gathered}</script><p>$A(x)$ 和 $B(x)$ 都可以表示为 $\sum_{i=-P}^P a_i e^{\frac{i}{P}x}$ 的形式。</p>
<p>设 $A(x),B(x)$ 对应的 OGF 为 $F(x),G(x)$。（$e^{cx}$ 对应的 OGF 为 $\sum_{i=0}^\infty (cx)^i = \frac{1}{1-cx}$）</p>
<p>设</p>
<script type="math/tex; mode=display">
H(x) = \sum_{i=0}^\infty [\text{操作 i 次之后第一次达到 s 的概率}]\frac{x^i}{i!}</script><p>则</p>
<script type="math/tex; mode=display">
\begin{gathered}
H(x) G(x) = F(x)\\
H(x) = \frac{F(x)}{G(x)}
\end{gathered}</script><p>答案是 $H(1)’ = \frac{F’(1)G(1) - F(1)G’(1)}{G^2(1)}$。</p>
<p>但是，因为 $\frac{1}{1-\frac{P}{P}x}$ 这一项在 $x=1$ 的时候没有定义，所以不能直接算。</p>
<p>对 $H(x)$ 上下同时乘以 $\prod_{i=-P}^P(1-\frac{i}{P}x)$，这时候的 $F(x),G(x)$ 都是这样的形式：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n a_i \prod_{j\neq i} (1-\frac{j}{P})</script><p>此时的 $F(x)$ 对应的 $F(1),F’(1)$ 为（由于 $x=1$，所以所有系数里面有 $(1-\frac{P}{P}x)$ 的项都没了）：</p>
<script type="math/tex; mode=display">
\begin{gathered}
F(1) = a_P\prod_{i\neq P} (1-\frac{i}{P})\\
F'(1) = \sum_{i} a_i \sum_{j\neq i} \left(-\frac{j}{P}\right) \prod_{k\neq i,k\neq j} \left(1-\frac{k}{P}x\right)\\
= \sum_{i\neq P} a_i (-1) \prod_{k\neq i, k\neq P} \left(1-\frac{k}{P}\right) + a_P \sum_{j\neq P} \left(-\frac{j}{P}\right)\prod_{k\neq P,k\neq j} \left(1-\frac{k}{P}\right)\\
= - \left(\prod_{k\neq P} ( 1-\frac{k}{P}) \right) \cdot \left( \sum_{i\neq P} \frac{1}{1-\frac{i}{P}} \left(a_i + a_P \cdot \frac{i}{P}\right)\right)
\end{gathered}</script><p>$G(1),G’(1)$ 的计算同理。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3044 「ZJOI2019」Minimax 搜索</title>
    <url>/2020/04/10/LOJ3044-%E3%80%8CZJOI2019%E3%80%8DMinimax-%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<ul>
<li><a href="https://loj.ac/submission/784365" target="_blank" rel="noopener">my AC submission on loj.ac</a></li>
<li><a href="https://loj.ac/submission/784068" target="_blank" rel="noopener">my O((R-L)n) solution on loj.ac</a></li>
<li>参考了<a href="https://memset0.cn/luogu5281" target="_blank" rel="noopener">memset0的博客</a>和<a href="https://www.cnblogs.com/suika/p/10725476.html" target="_blank" rel="noopener">fcwww的博客</a></li>
</ul>
<p>设 $W$ 为初始根节点的权值。由于每个叶子的权值互不相同，所以 $W$ 来自的叶子结点唯一。</p>
<p>改变 $W$ 的策略有以下三种：</p>
<ol>
<li>直接改变 $W$ 这个叶子的权值</li>
<li>不改变 $W$ 这个叶子的权值，把若干小于 $W$ 的叶子的权值改得大于 $W$，使得根节点的权值变得大于 $W$</li>
<li>不改变 $W$ 这个叶子的权值，把若干大于 $W$ 的叶子的权值改得小于 $W$，使得根节点的权值变得小于 $W$</li>
</ol>
<p>在可以采用第一种策略的时候 Cedyks 一定会采用第一种策略，因为把 $W$ 改成 $W-1$ 或者 $W+1$ 的花费仅为 $1$。所以，任何的包含 $W$ 这个叶子的集合，其稳定度都为 $1$。接下来我们只考虑不包含 $W$ 的集合。</p>
<p>如果采用第二种策略，最优的方法一定是把若干个小于 $W$ 的叶子改成 $W+1$；如果采用第三种策略，最优的方法一定是把若干个大于 $W$ 的叶子改成 $W-1$。（你可以把叶子结点的权值根据与 $W$ 的大小关系替换成 -1/0/1 然后 dp 以判断根节点的值是否被改变了）</p>
<p>差分一下答案，转化成对于 $k\in [L-1,\min\{n-1,R\}]$，求稳定度小于等于 $k$ 的子集数量。由于子集总数很好求，可以转化成有多少个集合 $S$ 满足：设 $T= S\cap ([W+1-k,W)\cup (W,W-1+k])$，将 $T$ 中所有小于 $W$ 的叶子的权值改成 $W+1$，所有大于 $W$ 的叶子改成 $W-1$，根节点的权值没有改变；也就是 $S$ 的稳定度大于 $k$。</p>
<p>为了式子推起来更简洁，把方案数转化成概率，即：除 $W$ 以外的每个叶子均有 $\frac{1}{2}$ 的概率 $\in S$，有 $\frac{1}{2}$ 的概率 $\notin S$，求根节点权值被改变了的概率。</p>
<p>显然第二种策略和第三种策略牵涉到的点是独立的，我们可以分别计算这两种策略无法改变根节点权值的概率，最后乘起来。</p>
<p>两者的计算方式是相似的，下面以第二种策略为例。</p>
<p>设 $f_u$ 为：将集合内所有在 $\left[W+1-k,W\right)$ 中的点改成 $W+1$，可以使得 $w_u &gt; W$ 的概率。</p>
<p>对于叶子结点，如果它在 $\left[W+1-k,W\right)$ 内，那么 $f_u= \frac{1}{2}$；否则 $f_u = [u&gt;W]$。</p>
<p>对于非叶子结点有</p>
<script type="math/tex; mode=display">
\begin{gathered}
f_u = \begin{cases}
\prod_{x\in son_u} f_v & 2\mid dep_u\\
1- \prod_{x\in son_u} (1-f_v) & 2\nmid dep_u
\end{cases}
\end{gathered}</script><p>设</p>
<script type="math/tex; mode=display">
\begin{gathered}
f'_u = \begin{cases}
f_u & 2 \mid dep_u\\
1-f_u & 2 \nmid dep_u
\end{cases}
\end{gathered}</script><p>那么有转移方程</p>
<script type="math/tex; mode=display">
f'_u = \prod_{v\in son_u} (1-f'_v)</script><p>这样每个点的转移方程就是一样的了。</p>
<p>从小到大依次枚举 $k$，$k$ 每次变化的时候只有 $O(1)$ 个叶子的 $f’_u$ 会改变，用动态 dp 维护即可。</p>
<p>具体地，设 $g_u = \prod_{v\in son_u, v\neq heavy_son_u} (1-f’_v)$，那么 $f’_u = (1-f’_{heavy_son_u}) g_u = - g_u \cdot f’_{heavy_son_u} + g_u$，如果把重儿子的 dp 值当成未知数则这是一个 $kx+b$ 的形式，可以区间合并（也就意味着可以用任意的数据结构维护）。</p>
<p>时间复杂度 $O(n\log^2 n)$，瓶颈是在修改 $g_u$ 的时候需要求 $O(\log n)$ 次 $1-f’_v$ 的逆元。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3093 「BJOI2019」光线</title>
    <url>/2020/04/09/LOJ3093-%E3%80%8CBJOI2019%E3%80%8D%E5%85%89%E7%BA%BF/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/783696" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<p>设 $f_i$ 表示从第 $i-1$ 块玻璃和第 $i$ 块玻璃之间向第 $n$ 块玻璃的方向射出了一束大小为 $1$ 的光线，最终能穿过第 $n$ 层玻璃的光的数量。特别地，$f_{n+1} = 1$，你可以想象成在第 $n$ 块玻璃的后面还有一块反射率为 $0\%$、透光率为 $100\%$ 的玻璃。</p>
<p>下文中的 $a_i,b_i$ 为原题中的 $a_i\%, b_i\%$。</p>
<p>根据定义有</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_i &= a_i f_{i+1} + b_i \left( b_{i-1}f_i + a_{i-1}b_{i-2}f_{i-1} + a_{i-1}a_{i-2}b_{i-3}f_{i-2}+\cdots \right)
\end{aligned}</script><p>移项得</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{i+1} &= \frac{1}{a_i} \left( f_i - b_i \left( b_{i-1}f_i + a_{i-1}b_{i-2}f_{i-1} + a_{i-1}a_{i-2}b_{i-3}f_{i-2}+\cdots \right) \right)
\end{aligned}</script><p>这样等号右边的项下标都小于等于 $i$。</p>
<p>设 $f_1 = x$，则所有的 $f_i$ 都可以用上面的递推式表示成 $kx$ 的形式。最后由 $f_{n+1} = 1$ 就可以解出 $x$ 的取值。</p>
<p>优化递推：设 $s_i = b_{i-1}f_i + a_{i-1}b_{i-2}f_{i-1} + a_{i-1}a_{i-2}b_{i-3}f_{i-2}+\cdots$，那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
s_1 &= 0\\
s_i &= a_{i-1}s_{i-1} + b_{i-1}f_i\\
f_{i+1} &= \frac{1}{a_i}\left(f_i - b_is_i\right)
\end{aligned}</script><p>时间复杂度为 $O(n)$ 或者 $O(n\log n)$，瓶颈为求逆元。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3090 「BJOI2019」勘破神机</title>
    <url>/2020/04/09/LOJ3090-%E3%80%8CBJOI2019%E3%80%8D%E5%8B%98%E7%A0%B4%E7%A5%9E%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/783396" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<h3 id="m-2"><a href="#m-2" class="headerlink" title="$m=2$"></a>$m=2$</h3><p>设填满 $2\times n$ 的方案数为 $f_n$，则 $F(n,k) = \binom {f_n}{k}$，而 $\binom{f_n}{k}$ 可以展开为一个关于 $f_n$ 的 $k$ 次多项式。故而问题转化为了：对于每个 $j\in [0,k]$，求 $\sum_{n=l}^r f_n^j$ 。</p>
<p>显然 $f_n = f_{n-1}+f_{n-2}$（考虑最后一列填两个横着的还是填一个竖着的）。</p>
<p>该递推式的特征根为 $x_1 = \frac{1+\sqrt 5}{2}, x_2 = \frac{1-\sqrt 5}{2}$，由 $f_0=1,f_1=1$ 解得通项公式为 $f_n = \frac{5+\sqrt 5}{10}x_1^n +\frac{5-\sqrt 5}{10} x_2^n$。</p>
<p>令 $A=x_1,B=x_2,p=\frac{5+\sqrt 5}{10},q=\frac{5-\sqrt 5}{10}$，则 $f_n = pA^n + qB^n$。</p>
<p>而我们要求的是</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{n=l}^r f_n^j\\
=& \sum_{n=l}^r (pA^n + qB^n)^j\\
=& \sum_{n=l}^r \sum_{i=0}^j \binom{j}{i} (pA^n)^i (qB^n)^{j-i}\\
=& \sum_{i=0}^j \binom{j}{i} p^i q^{j-i} \sum_{n=l}^r (A^iB^{j-i})^n
\end{aligned}</script><p>最后面是个等比数列求和，可以分治求解。</p>
<h3 id="m-3"><a href="#m-3" class="headerlink" title="$m=3$"></a>$m=3$</h3><p>设填满一个 $3\times n$ 的网格的方案数是 $f_n$，填满一个 $3\times n + 2$ 的网格的方案数为 $g_n$。其中，$3\times n + 2$ 的网格定义如下：</p>
<p><img src="https://i.loli.net/2020/04/09/XhTJzksyiePYjmB.png" alt="1.png"></p>
<p>枚举 $3\times n$ 的网格中最靠右的颗粒进行讨论，得到 $f_n = f_{n-2} + 2g_{n-2}$</p>
<p><img src="https://i.loli.net/2020/04/09/mqu8jTOraUHvS6Y.png" alt="0.png"></p>
<p>同理得到 $g_n = f_{n} + g_{n-2}$</p>
<p><img src="https://i.loli.net/2020/04/09/REkMnL24aOFHpvB.png" alt="2.png"></p>
<p>将 $g$ 的递推式展开得到 $g_n = f_n + f_{n-2} + f_{n-4} + \cdots + f_0$</p>
<p>对于任意的 $2\nmid n$ 显然有 $f_n = g_n = 0$。不妨设 $F_n = f_{2n}, l’=\lceil\frac{l}{2}\rceil, r’=\lfloor\frac{r}{2}\rfloor$。与 $m=2$ 的方法同理，我们只要求出 $\sum_{n=l’}^{r’} F_n^i$ 即可。</p>
<script type="math/tex; mode=display">
\begin{aligned}
F_n & = 3F_{n-1} + 2\sum_{i=0}^{n-2} F_i\\
F_n - F_{n-1} & = (3F_{n-1} + 2F_{n-2}) - (3F_{n-2})\\
& = 3F_{n-1}-F_{n-2}\\
\therefore F_n &= 4F_{n-1}- F_{n-2}
\end{aligned}</script><p>特征根为 $x_1 = 2+\sqrt 3, x_2 = 2-\sqrt 3$，带入 $F_0 = 1, F_1 = 3$ 得 $F_n = \frac{3+\sqrt 3}{6} x_1^n + \frac{3-\sqrt 3}{6} x_2^n$，和 $m=2$ 的情况类似做就可以了。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>弦图、完美消除序列与MCS算法</title>
    <url>/2020/04/05/%E5%BC%A6%E5%9B%BE%E3%80%81%E5%AE%8C%E7%BE%8E%E6%B6%88%E9%99%A4%E5%BA%8F%E5%88%97%E4%B8%8EMCS%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cs.cmu.edu/~janh/courses/411/18/lec/03-chordal-mcs.pdf" target="_blank" rel="noopener">一份通过google search找到的资料</a></li>
<li><a href="https://oi-wiki.org/graph/chord/#_8" target="_blank" rel="noopener">OI-wiki</a></li>
</ul>
<h2 id="定义们"><a href="#定义们" class="headerlink" title="定义们"></a>定义们</h2><p>记 $N(u)$ 为 $u$ 的所有的邻居构成的集合。对于一个点集 $S$，定义 $N(S)$ 为 $\{ x\mid \forall v\in S, x\in N(v)\}$。</p>
<p><strong>弦图 (chordal graph)</strong>：满足任意一个长度大于 3 的环都有弦的图。</p>
<p><strong>单纯点 (simplicial vertex)</strong>：如果 $N(u)$ 的导出子图为团，就称 $u$ 为单纯点。</p>
<p><strong>完美消除序列 (perfect elimination ordering)</strong>：称 $G$ 的结点的一个排列 $\{v_1,v_2,\cdots v_n\}$ 为 $G$ 的完美消除序列，当且仅当对于每一个 $i$ ，$v_i$ 在 $v_i,v_{i+1},\cdots v_n$ 的导出子图中是单纯点。</p>
<p>下文中，称完美消除序列的逆序为<strong>单纯消除序列 (simplicial elimination ordering)</strong>（这个中文名称是我编的，因为没有在网上找到相应的中文资料），也就是满足 $v_i$ 在 $v_1,v_2,\cdots v_i$ 的导出子图中为单纯点的排列。</p>
<h2 id="一个定理"><a href="#一个定理" class="headerlink" title="一个定理"></a>一个定理</h2><p>引理 1：弦图的任意导出子图也是弦图。</p>
<p>引理 2：任何弦图都至少有一个单纯点；不是完全图的弦图至少有两个不相邻的单纯点。</p>
<p>定理：$G$ 是弦图当且仅当 $G$ 存在完美消除序列。</p>
<p><a href="https://oi-wiki.org/graph/chord/" target="_blank" rel="noopener">证明可参考 OI-wiki</a></p>
<h2 id="完美消除序列判定"><a href="#完美消除序列判定" class="headerlink" title="完美消除序列判定"></a>完美消除序列判定</h2><p>判断一个序列是否为完美消除序列。</p>
<p>设 $v_i$ 在 $v_{i+1},v_{i+2}\cdots v_n$ 中相邻的点按照它们在序列中出现的顺序依次为 $v_{c_1},v_{c_2},\cdots v_{c_k}$，只需要判断 $v_{c_1}$ 与其它点是否相邻即可。</p>
<p>正确性证明：假设已知 $v_{i+1},v_{i+2},\cdots v_n$ 是合法的完美消除序列的后缀，那么由于 $v_{c_1}$ 在 $\{v_{c_1},v_{c_1+1},\cdots v_n\}$ 的导出子图中为单纯点，如果 $v_{c_1}$ 与 $v_{c_2},v_{c_3},\cdots v_{c_k}$ 都相邻，那么 $v_{c_2},v_{c_3},\cdots v_{c_k}$ 一定形成团。</p>
<h2 id="最大势算法"><a href="#最大势算法" class="headerlink" title="最大势算法"></a>最大势算法</h2><p>又称为<strong>maximum cardinality search algorithm</strong>、<strong>MCS algorithm</strong>。是用来求完美消除序列的一种算法。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>设图 $G$ 的点集为 $V$；用 $weight(u)$ 表示点 $u$ 的权重。</p>
<ol>
<li>初始化 $W$ 为 $V$，并将 $V$ 中所有点的权重置为 $0$</li>
<li>对 $i=1,2,\cdots n$ ，执行以下过程<ol>
<li>令 $u$ 为此时 $W$ 中权重最大的点</li>
<li>令 $v_i = u$</li>
<li>将 $u$ 的所有邻居的权重增加 $1$</li>
<li>将 $u$ 从 $W$ 中删除</li>
</ol>
</li>
<li>返回 $\{v_1,v_2,\cdots v_n\}$</li>
</ol>
<p>用链表实现可以做到 $O(n+m)$ 的复杂度。</p>
<p>可以证明，当 $G$ 为弦图时，MCS 算法返回的序列是 $G$ 的单纯消除序列。</p>
<h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>令 $V_i = \{v_,v_2,\cdots v_i\}$ ；令 $W_i$ 为第 2 步进行了 $i$ 次之后的 $W$ ；令 $weight_i(v)$ 表示第 2 步进行了 $i$ 次之后 $v$ 点的权重；令 $a \prec b$ 表示在返回的序列中 $a$ 在 $b$ 的前面。</p>
<p>我们通过证明以下循环不变式来证明命题：</p>
<ol>
<li>$v_i$ 在 $V_i$ 的导出子图中为单纯点</li>
<li>令 $S$ 为 $V$ 的一个子集，其中的每个点 $v_x$ 都满足 $v_x$ 在 $V_x$ 的导出子图中为单纯点；对于两个点 $a,v_i \in N(S) - S$ ，如果 $a\prec v_i$ 且 $N(S)-S$ 中存在一条从 $a$ 到 $v_i$ 的路径，那么 $N(S)-S$ 中存在一条从从 $a$ 到 $v_i$ 且经过的所有点都满足 $\prec v_i$ 的路径</li>
</ol>
<h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明 1."></a>证明 1.</h4><p>考虑反证：假设 $v_i$ 在 $V_i$ 的导出子图中不是单纯点，那么必定存在 $v_j,v_k\in N(v_i)\cap V_{i-1}$ 满足 $j&lt; k &lt; i, v_k\notin N(v_j)$。</p>
<h5 id="case-1-对于所有的-v-j-v-k-in-N-v-i-cap-V-i-1-v-k-notin-N-v-j-，都有-V-i-1-cap-N-v-i-cap-N-v-j-cap-N-v-k-varnothing"><a href="#case-1-对于所有的-v-j-v-k-in-N-v-i-cap-V-i-1-v-k-notin-N-v-j-，都有-V-i-1-cap-N-v-i-cap-N-v-j-cap-N-v-k-varnothing" class="headerlink" title="case 1: 对于所有的 $v_j,v_k\in N(v_i)\cap V_{i-1}, v_k \notin N(v_j)$，都有 $V_{i-1}\cap N(v_i)\cap N(v_j) \cap N(v_k) = \varnothing$"></a>case 1: 对于所有的 $v_j,v_k\in N(v_i)\cap V_{i-1}, v_k \notin N(v_j)$，都有 $V_{i-1}\cap N(v_i)\cap N(v_j) \cap N(v_k) = \varnothing$</h5><p>对于连通图 $G$ ，我们可以归纳地证明 $V_i$ 都是连通的。而 $N(v_i)$ 中的点显然在 $G$ 的同一个连通块中，所以 $N(v_i)\cap V_{i-1}$ 中的点在 $V_{i-1}$ 的导出子图中是连通的。</p>
<p>找出一对 $V_{i-1}$ 中的 $v_j,v_k$ 使其满足 $v_k \notin N(v_j)$ 且它们在 $V_{i-1}$ 的导出子图中的最短路最短。由于 $v_k \notin N(v_j)$ ，所以最短路的点数大于 2（含 $v_j,v_k$）。</p>
<p>那么最短路上的每个点一定都和 $v_i$ 直接有边相连（如果没有加额外的边则不符合弦图的定义；如果是加的其它的边则不符合最短路的定义）：</p>
<ul>
<li>如果最短路的长度大于 3，那么从这条最短路上随便选取连续的三个点，把第一个点和第三个点作为 $v_j,v_k$，就能得到更短的最短路</li>
<li>如果最短路的长度等于 3，那么最短路上的第二个点属于集合 $V_{i-1}\cap N(v_i) \cap N(v_j) \cap N(v_k)$，与 $V_{i-1}\cap N(v_i)\cap N(v_j) \cap N(v_k) = \varnothing$ 矛盾。</li>
</ul>
<h5 id="case-2-存在-v-j-v-k-in-V-i-1-cap-N-v-i-v-k-notin-N-v-j-满足-V-i-1-cap-N-v-j-cap-N-v-k-cap-N-v-i-neq-varnothing"><a href="#case-2-存在-v-j-v-k-in-V-i-1-cap-N-v-i-v-k-notin-N-v-j-满足-V-i-1-cap-N-v-j-cap-N-v-k-cap-N-v-i-neq-varnothing" class="headerlink" title="case 2: 存在 $v_j,v_k\in V_{i-1} \cap N(v_i), v_k \notin N(v_j)$ 满足 $V_{i-1} \cap N(v_j)\cap N(v_k) \cap N(v_i) \neq \varnothing$"></a>case 2: 存在 $v_j,v_k\in V_{i-1} \cap N(v_i), v_k \notin N(v_j)$ 满足 $V_{i-1} \cap N(v_j)\cap N(v_k) \cap N(v_i) \neq \varnothing$</h5><p>令 $S$ 为满足 $v_i,v_j,v_k\in N(S)-S$ 的仅由 $V_{i-1}$ 中的点构成的集合（显然不为空集的 $S$ 一定存在，并且由归纳假设我们知道 $S$ 中的每个点 $v_x$ 都满足 $v_x$ 在 $V_x$ 的导出子图中为单纯点）。那么 $v_j \to v_i \to v_k$ 是 $N(S)-S$ 中的一条路径，所以一定存在一条 $N(S)-S$ 中的路径 $P=\{v_j = x_0 \to x_1 \to x_2 \cdots x_{m-1} \to x_m = v_k\}$，路径上的每个点都满足 $\prec v_i$（应用不变式2.，注意这里与不变式中的形式不完全一样）。在所有可能的四元组 $(v_j,v_k,S,P)$ 中，我们选择一个 $|S|$ 最大的；如果有两个 $|S|$ 相同的，我们选择 $P$ 的长度更短的。如此，$v_i,v_j=x_0,x_1,\cdots x_m=v_k,v_i$ 将会是一个长度大于 3 的环。根据弦图的定义这个环上一定有弦：</p>
<ul>
<li>如果弦为 $(x_a,x_b)$，其中 $a+1&lt;b$，那么 $P$ 可以更短</li>
<li>如果弦为 $(x_a,v_i)$，其中 $0&lt;a&lt;m-1$，那么令 $v_j=x_a,P=\{v_j=x_a\to x_{a+1}\cdots x_{m-1}\to x_m=v_k\}$ 将会使 $P$ 更短；弦为 $(x_a,v_i), 1 &lt; a &lt; m$ 同理</li>
<li>否则，$m=2$ 且弦为 $(x_1,v_i)$ ，但是显然此时 $S\cup \{x_1\}$ 是一个更大的满足 $v_i,v_j,v_k \in N(S)-S$ 且每个点都属于 $V_{i-1}$ 的点集。</li>
</ul>
<h4 id="证明-2"><a href="#证明-2" class="headerlink" title="证明 2."></a>证明 2.</h4><p>如果 $a\in N(v_i)$ ，证毕。接下来考虑 $a\notin N(v_i)$ 的情况。</p>
<p>如果存在一个 $b\in (V_{i-1}-S) \cap N(v_i)$，那么对于每个 $s\in S$：</p>
<ul>
<li>若 $s\prec v_i$，则因为 $b,s\in N(v_i)$，在 $V_i$ 的导出子图中我们可以推出 $b,s$ 相邻，所以 $G$ 中 $b,s$ 相邻；</li>
<li>若 $a\prec v_i\prec s$，由于 $a,v_i\in N(s)$，在 $V_s$ 的导出子图中可以推出 $a\in N(v_i)$，矛盾</li>
</ul>
<p>所以一定有 $b\in N(S)-S$，由归纳假设知 $N(S)-S$ 中存在一条从 $a$ 到 $b$ 的只经过 $\prec \max\{a,b\}$ 的点的路径，在这条路径后面加上点 $v_i$ 即得证。</p>
<p>否则 $N(v_i) \cap (V_{i-1}-S)=\varnothing$，所以 $weight_{i-1}(v_i) = \left|S\cap V_{i-1} \right|$。由于 $N(S)-S$ 中存在一条从 $a$ 到 $v_i$ 的路径，这段路径上一定存在两个相邻的点 $c,d$，满足 $c\prec v_i\prec d$（因为从 $v_i$ 出发的第一个点一定 $\succ v_i$，而 $a\prec v_i$），于是推出 $weight_{i-1}(d) \ge |S\cap V_{i-1}|+1$（+1是因为 $c\in N(d),c\prec v_i$），这和 $weight_{i-1}(v_i)$ 为 $weight_{i-1}$ 的最大值矛盾。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ2719 「NOI2018」冒泡排序</title>
    <url>/2020/04/03/LOJ2719-%E3%80%8CNOI2018%E3%80%8D%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/779435" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<p>一个排列 $P$ 的冒泡排序交换次数达到下界当且仅当：对于某个位置 $i$ ，在它左边的、比 $P_i$ 大的数的个数不能超过 $\max\{0, i-P_i\}$ 个。</p>
<p>这个条件也等价于：</p>
<ul>
<li>对于 $P_i\le i$ 的元素，它的右侧至少有 $(n-P_i) - (i-P_i) = n-i$ 个比它大的元素，也就是说它是后缀最小值</li>
<li>对于 $P_i \ge i$ 的元素，它是前缀最大值</li>
</ul>
<p>此外一个观察是，对于任意的一个排列，除了 $P_i=i$ 的元素之外，不会有元素既是前缀最大值又是后缀最小值（因为既是前缀最大值又是后缀最小值也就意味着左边有 $P_i-1$ 个比它小的且右边有 $n-P_i$ 个比它大的）。</p>
<p>对于一个冒泡排序交换次数达到下界的排列 $P$ ，考虑把它的所有的前缀最大值都抠掉之后的序列：</p>
<ul>
<li>这些剩下的元素不是前缀最大值，所以它们一定满足 $P_i &lt; i$ ，也就是意味着它们一定是后缀最小值</li>
<li>所以，不是前缀最大值的元素一定是升序排列的</li>
<li>这也就意味着，只要知道了前缀最大值，就能够唯一地确定一个可能合法的排列 $P$</li>
<li>所以只需要对合法的前缀最大值序列计数就可以了</li>
</ul>
<p>一个前缀最大值序列 $\{ M_i = \max_{j\le i} \{P_j\} \}$ 合法当且仅当 $M_{i-1}\le M_i \wedge M_i\ge i$ ：</p>
<ul>
<li>必要性：因为除了 $P_i = i$ 的元素之外不会有元素同时是前缀最大值和后缀最小值，故而是前缀最大值的元素一定都满足 $P_i \ge i$，所以必须有 $M_i \ge i$</li>
<li>充分性：<ul>
<li>对于任意排列，是前缀最大值的元素都满足 $P_i \ge i$ ，满足 $P_i\ge i$ 必然是前缀最大值（左边的空位比小于它的数少）</li>
<li>将不是前缀最大值的位置升序填入之后，这些位置必然满足 $P_i &lt; i$ （因为 $i$ 左边的空位置比小于 $i$ 的数少）；$P_i &lt; i$ 的位置必然是后缀最小值（大于它的数的数量超过了它右边的空位的数量）</li>
</ul>
</li>
</ul>
<p>故而只要统计满足 $M_i \ge i, M_{i-1} \le M_i$ 的 $\{M_i\}$ 的数量即可。</p>
<p>考虑折线模型。例如，对于排列 $\{2,3,1,5,4\}$ ，它前缀最大值序列对应到的折线是这样的：</p>
<p><img src="https://i.loli.net/2020/04/03/NazDKZ7oySBChLT.png" alt="0.PNG"></p>
<p>发现本质上就是一条从 $(0,1)$ 到 $(n,n)$ 且不经过直线 $y=x-1$ 的折线。</p>
<p>回到原题。设 $ans(x,y)$ 表示从 $(x,y)$ 出发走到 $(n,n)$ 不经过 $y=x-1$ 的方案数，也就是$\binom{2n-x-y}{n-x} - \binom{2n-x-y}{n+1-x}$。我们枚举排列 $p$ 与输入给出的 $q$ 第一个不同的位置 $i$ ，分以下几种情况讨论（设 $mx=\max_{j &lt; i} \{ q_j \}$）：</p>
<ul>
<li>$q$ 的长度为 $i-1$ 的前缀不合法：必然也不存在合法的 $p$ ，所以对答案的贡献是 $0$</li>
<li>$q$ 的长度为 $i-1$ 的前缀合法：<ul>
<li>$q_i &gt; mx$<ul>
<li>由于要求 $p_i &gt; q_i$ ，所以 $p_i$ 也必然是个前缀最大值，所以方案数是 $ans(i-1,q_i + 1)$</li>
</ul>
</li>
<li>$q_i &lt; mx$<ul>
<li>$p_i &gt; mx$ ：此时方案数是 $ans(i-1,mx+1)$</li>
<li>$p_i &lt; mx$ ：将不是前缀最大值的数依次升序填入不是前缀最大值的位置，如果到 $i$ 这个位置，该填的数大于 $q_i$ ，这种情况就对答案产生 $ans(i,mx)$ 的贡献；否则贡献为 $0$ 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>预处理阶乘及其逆元就可以在 $O(1)$ 的时间内统计 $i$ 的贡献。总时间复杂度 $O(n)$ 。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分基础：极限、求导、导数的应用、积分</title>
    <url>/2020/04/02/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%9E%81%E9%99%90%E3%80%81%E6%B1%82%E5%AF%BC%E3%80%81%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%81%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<p>以下为我在校内讲课的课件。主要的参考资料为 James Stewart Calculus, 7th edition ，课件中的大部分的图片为这本书（6th or 7th edition）的截图，少部分图片来自维基百科（来自维基百科的图片均已在文中注明）。</p>
<p>错误可能比较多，欢迎指出。</p>
<p><a href="https://drive.google.com/open?id=1SyrqVCko7zbdFzfV_qOjDw4n70wlIzi6" target="_blank" rel="noopener">链接：在google drive中查看</a></p>
<div class="pdf" target="/files/calculus_is_gu-ing.pdf" height=""></div>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAcademy Round #35 Counting Quests</title>
    <url>/2020/03/30/CSAcademy-Round-35-Counting-Quests/</url>
    <content><![CDATA[<ul>
<li><a href="https://csacademy.com/contest/round-35/task/counting-quests/" target="_blank" rel="noopener">link to the problem</a></li>
<li><a href="https://csacademy.com/submission/2707618/" target="_blank" rel="noopener">my submission</a></li>
</ul>
<p>对于一个序列和一个询问集合，设 $S_i$ 为包含了 $i$ 这个位置的询问的集合。一个询问集合合法当且仅当 $S_i$ 互不相同。</p>
<p>性质 1 ：如果 $a&lt;b&lt;c&lt;d, S_a=S_c, S_b=S_d$，那么 $S_a=S_b=S_c=S_d$ 。</p>
<p>证明：包含了 $a$ 和 $c$ 的询问必然包含 $b$ ，而由于 $S_b=S_d$ ，所以也就必然包含了 $d$ 。其它情况同理。</p>
<p>性质 2 ：假设 $a$ 是序列中第一个其 $S_i$ 至少出现了两次的元素，$b$ 是 $S_a$ 最后一次出现的位置，那么询问集合中不存在区间与 $[a,b]$ 有交且不互相包含。</p>
<p>证明：对于一个与 $[a,b]$ 相交且不互相包含的区间，这个区间必然只包含了 $a,b$ 中的一个，于是推出 $S_a\neq S_b$ ，矛盾。</p>
<p>统计不合法的询问集合数量。对于一不合法的询问集合和一个序列，我们对 $\{S_i\}$ 进行如下的操作：</p>
<ol>
<li>找到第一个出现了至少两次的 $S_i$ ，然后找到它最后一次出现的位置，设这两个位置是 $l,r$</li>
<li>将 $[l,r]$ 区间内的元素删掉，替换为一个 $S_i = S_l$ 的元素，并重复 1.</li>
</ol>
<p>显然不会有与被删掉的区间有交但不包含的询问；所以确定“没有被包含于删掉了的区间的询问”的方案数就是把被删掉的区间换成一个点之后的合法的询问集合数；被包含在删除了的区间内部的询问可以任意地确定。</p>
<p>设表示 $f_i$ 序列长度为 $i$ 时，合法的询问集合的数量；设 $s_{i,j}$ 表示有 $i$ 个被删除的区间，其总长度为 $j$ ，确定被这些区间完全包含了的询问的方案数。计算 $f_i$ 的时候枚举被删掉的区间数量和长度总和即可。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>20200328 联考</title>
    <url>/2020/03/30/20200328-%E8%81%94%E8%80%83/</url>
    <content><![CDATA[<h2 id="A-数一数"><a href="#A-数一数" class="headerlink" title="A - 数一数"></a>A - 数一数</h2><p>总感觉是做过的题，甚至清晰的记得给赵爷讲过，但是想不起来做法了…… :sob:</p>
<p>ZJK 告诉我题意是有问题的，每一列只能有恰好一个 $1$ ，否则样例 1 的答案就应该是 $\frac{3}{4}$ 。</p>
<p>整个表格的数确定的时候，用一个简单的 dp（$g_{j,i} = \max\{ g_{j+1,i-1}, g_{j+1,i}, g_{j+1,i+1}\} + v_{j,i}$）就能得到这个表格的最大得分。可惜由于表格无限长，这个 dp 的可能的取值也是无限多的，不能作为 dp 状态。</p>
<p>不妨设 $g’_{j,i} = g_{j,i} - \min_{k\in [1,n]} \{ g_{j,k} \}$ ，不难发现 $g’_j$ 的取值是有限的，并且将 $g_j$ 替换成 $g’_j$ 并不会影响之后的转移。</p>
<p>考虑这样一张图：每个结点是一个 $g’_j$ ；有向边 $(u,v)$ 的权值为二元组 $(p,w)$ ，表示当前在 $u$ ，下一步走到 $v$ 的概率是 $p$ ，而 $v$ 的 $\min\{g’_{j,k}\}$ 比 $u$ 大 $w$ 。设在这张图上随机游走 $m$ 步之后，走过的边的 $w$ 的和的期望为 $f(m)$ ，答案就是 $\lim_{m\to \infty} \frac{f(m)}{m}$ 。</p>
<p>$\lim_{m\to \infty} \frac{f(m)}{m}$ 等价于每条边的权值按照其被经过的期望次数加权平均，用高斯消元算即可。</p>
<h2 id="B-数二数"><a href="#B-数二数" class="headerlink" title="B - 数二数"></a>B - 数二数</h2><ul>
<li><a href="https://csacademy.com/contest/round-35/task/counting-quests/" target="_blank" rel="noopener">link to the problem</a></li>
<li><a href="https://csacademy.com/submission/2707618/" target="_blank" rel="noopener">my submission</a></li>
</ul>
<p>对于一个序列和一个询问集合，设 $S_i$ 为包含了 $i$ 这个位置的询问的集合。一个询问集合合法当且仅当 $S_i$ 互不相同。</p>
<p>性质 1 ：如果 $a&lt;b&lt;c&lt;d, S_a=S_c, S_b=S_d$，那么 $S_a=S_b=S_c=S_d$ 。</p>
<p>证明：包含了 $a$ 和 $c$ 的询问必然包含 $b$ ，而由于 $S_b=S_d$ ，所以也就必然包含了 $d$ 。其它情况同理。</p>
<p>性质 2 ：假设 $a$ 是序列中第一个其 $S_i$ 至少出现了两次的元素，$b$ 是 $S_a$ 最后一次出现的位置，那么询问集合中不存在区间与 $[a,b]$ 有交且不互相包含。</p>
<p>证明：对于一个与 $[a,b]$ 相交且不互相包含的区间，这个区间必然只包含了 $a,b$ 中的一个，于是推出 $S_a\neq S_b$ ，矛盾。</p>
<p>统计不合法的询问集合数量。对于一不合法的询问集合和一个序列，我们对 $\{S_i\}$ 进行如下的操作：</p>
<ol>
<li>找到第一个出现了至少两次的 $S_i$ ，然后找到它最后一次出现的位置，设这两个位置是 $l,r$</li>
<li>将 $[l,r]$ 区间内的元素删掉，替换为一个 $S_i = S_l$ 的元素，并重复 1.</li>
</ol>
<p>显然不会有与被删掉的区间有交但不包含的询问；所以确定“没有被包含于删掉了的区间的询问”的方案数就是把被删掉的区间换成一个点之后的合法的询问集合数；被包含在删除了的区间内部的询问可以任意地确定。</p>
<p>设表示 $f_i$ 序列长度为 $i$ 时，合法的询问集合的数量；设 $s_{i,j}$ 表示有 $i$ 个被删除的区间，其总长度为 $j$ ，确定被这些区间完全包含了的询问的方案数。计算 $f_i$ 的时候枚举被删掉的区间数量和长度总和即可。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>KD-Tree 学习笔记</title>
    <url>/2020/03/27/KD-Tree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://oi-wiki.org/ds/kdt/" target="_blank" rel="noopener">OI-wiki</a></li>
<li><a href="https://en.wikipedia.org/wiki/K-d_tree" target="_blank" rel="noopener">wikipedia</a></li>
<li><a href="https://courses.cs.washington.edu/courses/cse373/02au/lectures/lecture22l.pdf" target="_blank" rel="noopener">一份有详细图解的课件</a></li>
</ol>
<h2 id="KD-Tree-是什么"><a href="#KD-Tree-是什么" class="headerlink" title="KD-Tree 是什么"></a>KD-Tree 是什么</h2><p>KD-Tree（k-dimensional tree 的简写）是一种用来维护 $k$ 维的<strong>点集</strong>的数据结构。它是一棵深度为 $O(\log n)$ 的二叉搜索树，每个结点代表了点集中的一个点。</p>
<p>它可以支持以下的操作（设 $n$ 为点集的大小）：</p>
<ol>
<li>插入/删除一个点，时间复杂度为均摊 $O(\log n)$</li>
<li>查询一个边界平行于坐标轴的矩形/超矩形内的点的信息，时间复杂度上界为 $O(n^{1-\frac{1}{k}})$</li>
<li>对一个边界平行于坐标轴的矩形/超矩形内的点进行支持标记合并的修改（维护和线段树类似的标记），时间复杂度上界为 $O(n^{1-\frac{1}{k}})$</li>
<li>查询一个点的最近点/最远点，数据随机的时候时间复杂度期望为 $O(\log n)$ ，最坏复杂度为 $O(n)$ 。</li>
</ol>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>选择一个维度，然后在点集中选择一个这一维的坐标是中位数的点作为根，然后把其它的点按照这一维的坐标和根的大小关系分成左右两棵子树，递归到子树内进行建造。</p>
<p>定义一个结点的<strong>范围</strong>是它子树内的点的坐标范围，也就是一个 $k$ 维的、所有边都平行于坐标轴的超矩形。</p>
<p>注意到：对于某个点，显然它的左右子树的范围的交要么为空，要么只包含了这个点所在的、垂直于这一次所选的维度的坐标轴的一条线段。</p>
<p>以下是二维情形的建树代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">rec[c] 代表 c 结点的范围</span></span><br><span class="line"><span class="comment">tr[c] 表示 c 结点所代表的点的坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> d)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> (<span class="keyword">void</span>)(c=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	nth_element(P+l,P+mid,P+r+<span class="number">1</span>,(d&amp;<span class="number">1</span>?cmpx:cmpy));</span><br><span class="line">	tr[c=newnode()]=P[mid];</span><br><span class="line">	build(l,mid<span class="number">-1</span>,ch[c][<span class="number">0</span>],d+<span class="number">1</span>),build(mid+<span class="number">1</span>,r,ch[c][<span class="number">1</span>],d+<span class="number">1</span>);</span><br><span class="line">	rec[c].lx=min(tr[c].x,min(rec[ch[c][<span class="number">0</span>]].lx,rec[ch[c][<span class="number">1</span>]].lx));</span><br><span class="line">	rec[c].rx=max(tr[c].x,max(rec[ch[c][<span class="number">0</span>]].rx,rec[ch[c][<span class="number">1</span>]].rx));</span><br><span class="line">	rec[c].ly=min(tr[c].y,min(rec[ch[c][<span class="number">0</span>]].ly,rec[ch[c][<span class="number">1</span>]].ly));</span><br><span class="line">	rec[c].ry=max(tr[c].y,max(rec[ch[c][<span class="number">0</span>]].ry,rec[ch[c][<span class="number">1</span>]].ry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入/删除"></a>插入/删除</h2><p>按照 KD-Tree 的子树划分方式递归到相应的位置，然后插入/删除即可。</p>
<p>为了保证平衡，我们要在某个点的某个儿子的子树大小大于这个点的子树大小 $\times \alpha$ 的时候对这个子树进行重构。其中 $\alpha$ 一般取 0.75 左右。</p>
<p>单次插入/删除的时间复杂度是均摊 $O(\log n)$ 的。</p>
<p>以下是二维情形的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(POINT A,POINT B)</span> </span>&#123; <span class="keyword">return</span> A.x&lt;B.x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(POINT A,POINT B)</span> </span>&#123; <span class="keyword">return</span> A.y&lt;B.y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmptx</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> tr[x].x&lt;tr[y].x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpty</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> tr[x].y&lt;tr[y].y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	sum[c]=sum[ch[c][<span class="number">0</span>]]+sum[ch[c][<span class="number">1</span>]]+val[c];</span><br><span class="line">	sz[c]=sz[ch[c][<span class="number">0</span>]]+sz[ch[c][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> (<span class="keyword">void</span>)(c=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	nth_element(b.begin()+l,b.begin()+mid,b.begin()+r+<span class="number">1</span>,(d?cmptx:cmpty));</span><br><span class="line">	c=b[mid];</span><br><span class="line">	rebuild(l,mid<span class="number">-1</span>,ch[c][<span class="number">0</span>],d^<span class="number">1</span>);</span><br><span class="line">	rebuild(mid+<span class="number">1</span>,r,ch[c][<span class="number">1</span>],d^<span class="number">1</span>);</span><br><span class="line">	rec[c].lx=min(tr[c].x,min(rec[ch[c][<span class="number">0</span>]].lx,rec[ch[c][<span class="number">1</span>]].lx));</span><br><span class="line">	rec[c].rx=max(tr[c].x,max(rec[ch[c][<span class="number">0</span>]].rx,rec[ch[c][<span class="number">1</span>]].rx));</span><br><span class="line">	rec[c].ly=min(tr[c].y,min(rec[ch[c][<span class="number">0</span>]].ly,rec[ch[c][<span class="number">1</span>]].ly));</span><br><span class="line">	rec[c].ry=max(tr[c].y,max(rec[ch[c][<span class="number">0</span>]].ry,rec[ch[c][<span class="number">1</span>]].ry));</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!rt) <span class="keyword">return</span>; b.PB(rt);</span><br><span class="line">	recycle(ch[rt][<span class="number">0</span>]),recycle(ch[rt][<span class="number">1</span>]);</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	recycle(rt),rebuild(<span class="number">0</span>,b.size()<span class="number">-1</span>,rt,d),b.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> d,POINT p,<span class="keyword">int</span> v,<span class="keyword">int</span> flg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!c) &#123;</span><br><span class="line">		tr[c=++ncnt]=p,val[c]=v,push_up(c);</span><br><span class="line">		rec[c].lx=rec[c].rx=tr[c].x;</span><br><span class="line">		rec[c].ly=rec[c].ry=tr[c].y;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> lr=(d?cmpx(tr[c],p):cmpy(tr[c],p));</span><br><span class="line">	<span class="keyword">int</span> cur_flg=(sz[c]<span class="number">-1</span>)*alpha&lt;=max(sz[ch[c][lr]]+<span class="number">1</span>,sz[ch[c][lr^<span class="number">1</span>]]);</span><br><span class="line">	ins(ch[c][lr],d^<span class="number">1</span>,p,v,flg|cur_flg);</span><br><span class="line">	rec[c].lx=min(rec[c].lx,p.x);</span><br><span class="line">	rec[c].rx=max(rec[c].rx,p.x);</span><br><span class="line">	rec[c].ly=min(rec[c].ly,p.y);</span><br><span class="line">	rec[c].ry=max(rec[c].ry,p.y);</span><br><span class="line">	push_up(c);</span><br><span class="line">	<span class="keyword">if</span>(!flg&amp;&amp;cur_flg) rebuild(c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩形查询"><a href="#矩形查询" class="headerlink" title="矩形查询"></a>矩形查询</h2><p>从根开始往下递归：</p>
<ol>
<li>如果当前结点的范围与查询的范围没有交，直接退出；</li>
<li>如果当前结点的范围被完全包含在查询的范围内，返回当前结点的子树信息</li>
<li>否则考虑当前结点所代表的点的贡献，并递归到子树内继续查询</li>
</ol>
<p>可以证明，单次操作的时间复杂度上界为 $O(n^{1-\frac{1}{k}})$ 。</p>
<p>以下是二维情形的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,<span class="keyword">int</span> ly,<span class="keyword">int</span> ry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rx&lt;rec[c].lx||lx&gt;rec[c].rx||ry&lt;rec[c].ly||ly&gt;rec[c].ry) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(lx&lt;=rec[c].lx&amp;&amp;rx&gt;=rec[c].rx&amp;&amp;ly&lt;=rec[c].ly&amp;&amp;ry&gt;=rec[c].ry) <span class="keyword">return</span> sum[c];</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(lx&lt;=tr[c].x&amp;&amp;rx&gt;=tr[c].x&amp;&amp;ly&lt;=tr[c].y&amp;&amp;ry&gt;=tr[c].y) tot+=val[c];</span><br><span class="line">	tot+=qry(ch[c][<span class="number">0</span>],d^<span class="number">1</span>,lx,rx,ly,ry);</span><br><span class="line">	tot+=qry(ch[c][<span class="number">1</span>],d^<span class="number">1</span>,lx,rx,ly,ry);</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩形修改"><a href="#矩形修改" class="headerlink" title="矩形修改"></a>矩形修改</h2><p>与矩形查询是类似的。</p>
<p>从根开始往下递归：</p>
<ol>
<li>如果当前结点的范围与查询的范围没有交，直接退出；</li>
<li>如果当前结点的范围被完全包含在查询的范围内，对当前结点打子树修改标记</li>
<li>否则考虑修改对当前结点代表的点的贡献，并递归到当前结点的子树内继续以上过程</li>
</ol>
<p>单次操作的时间复杂度上界是 $O(n^{1-\frac{1}{k}})$ 。</p>
<p>以下是二维情形的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,<span class="keyword">int</span> ly,<span class="keyword">int</span> ry,<span class="keyword">int</span> op,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rec[c].lx&gt;rx||rec[c].rx&lt;lx||rec[c].ly&gt;ry||rec[c].ry&lt;ly) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(rec[c].lx&gt;=lx&amp;&amp;rec[c].rx&lt;=rx&amp;&amp;rec[c].ly&gt;=ly&amp;&amp;rec[c].ry&lt;=ry) <span class="keyword">return</span> (<span class="keyword">void</span>)(op==<span class="number">1</span>?add(c,v):mul(c,v));</span><br><span class="line">	push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(lx&lt;=tr[c].x&amp;&amp;rx&gt;=tr[c].x&amp;&amp;ly&lt;=tr[c].y&amp;&amp;ry&gt;=tr[c].y) val[c]=(op==<span class="number">1</span>?(val[c]+v)%mod:<span class="number">1l</span>l*val[c]*v%mod);</span><br><span class="line">	upd(ch[c][<span class="number">0</span>],lx,rx,ly,ry,op,v);</span><br><span class="line">	upd(ch[c][<span class="number">1</span>],lx,rx,ly,ry,op,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询一个点的最近-最远点"><a href="#查询一个点的最近-最远点" class="headerlink" title="查询一个点的最近/最远点"></a>查询一个点的最近/最远点</h2><p>本质上是对暴力搜索的剪枝。</p>
<p>剪枝 1 ：如果一个结点的范围内的所有点到查询点的距离都不如现在的最优答案优秀，那么直接退出。</p>
<p>剪枝 2 ：在决定先往左子树走还是往右子树走的时候，走范围边界上最优的那个点更优的那个子树。</p>
<p>可以证明，随机数据的时候单次查询的期望复杂度为 $O(\log n)$ ，最坏情况下的时间复杂度为 $O(n)$ 。</p>
<h3 id="拓展：查询一个点的第-k-近-远的点"><a href="#拓展：查询一个点的第-k-近-远的点" class="headerlink" title="拓展：查询一个点的第 $k$ 近/远的点"></a>拓展：查询一个点的第 $k$ 近/远的点</h3><p>用优先队列维护现在已经搜到的答案最优的 $k$ 个，搜索的过程中进行和前面同理的剪枝；复杂度和上面最近/最远点的复杂度是相同的。</p>
<p>二维 $k$ 远点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">db <span class="title">Sqr</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="function">db <span class="title">dis_to_rec</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!c) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> max(Sqr(rec[c].lx-qx),Sqr(rec[c].rx-qx))+max(Sqr(rec[c].ly-qy),Sqr(rec[c].ry-qy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> Sqr(tr[c].x-qx)+Sqr(tr[c].y-qy); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!c) <span class="keyword">return</span>;</span><br><span class="line">	item tmp=(item)&#123;tr[c].id,dis(c)&#125;;</span><br><span class="line">	<span class="keyword">if</span>(tmp&lt;Q.top()) Q.pop(),Q.push(tmp);</span><br><span class="line">	db d[<span class="number">2</span>]=&#123;dis_to_rec(ch[c][<span class="number">0</span>]),dis_to_rec(ch[c][<span class="number">1</span>])&#125;;</span><br><span class="line">	<span class="keyword">int</span> lr=(d[<span class="number">1</span>]&gt;d[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span>(sgn(d[lr]-Q.top().d)&gt;=<span class="number">0</span>) qry(ch[c][lr]);</span><br><span class="line">	<span class="keyword">if</span>(sgn(d[lr^<span class="number">1</span>]-Q.top().d)&gt;=<span class="number">0</span>) qry(ch[c][lr^<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题表"><a href="#题表" class="headerlink" title="题表"></a>题表</h2><ul>
<li>luogu P2093 【国家集训队】JZPFAR</li>
<li>luogu P3710 方方方的数据结构</li>
<li>luogu P3710 方方方的数据结构</li>
<li>luogu P4148 简单题</li>
<li>luogu P4357 【CQOI2016】K远点对</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>20200325 联考</title>
    <url>/2020/03/26/20200325-%E8%81%94%E8%80%83/</url>
    <content><![CDATA[<h2 id="A-string"><a href="#A-string" class="headerlink" title="A - string"></a>A - string</h2><p>经典题目。</p>
<h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B - tree"></a>B - tree</h2><p>容易想到 $f_u$ 表示把 $u$ 子树变成 $T_1$ 中它们对应的子树，能够有的最大深度和。</p>
<p>设个中间量 $dp_{u,j}$ 表示 $u$ 子树中，$u$ 在的那条链的长度是 $j$ 时，最大深度和。</p>
<p>合并子树的时候，因为 $T_2$ 必须是二叉树，所以状态中再加入大小为 $2^2$ 的一维表示左右儿子选过没有。</p>
<p>总时间复杂度 $O(n^2)$ 。</p>
<h2 id="C-sort"><a href="#C-sort" class="headerlink" title="C - sort"></a>C - sort</h2><h3 id="思路和实现细节"><a href="#思路和实现细节" class="headerlink" title="思路和实现细节"></a>思路和实现细节</h3><p>考场上想的是线段树套trie，修改的时候需要支持可持久化分裂/合并，空间是两个 $\log$ 的，其中一个还是 $\log V$ ，用脚趾头想都知道开不下。</p>
<p>考后看题解发现自己 zz 了：<strong>如果不需要实时查询区间信息，就不需要在节点里维护整个子树的信息。</strong> 题解还是很妙的，用平衡树维护每个排过序的段，段内用 trie 维护元素。在这一段被再次分裂之前进行的操作都不要打到 trie 上，这样 trie 中的元素的大小关系就是它们在序列中的位置关系。输出答案的函数中传入对这整个 trie 进行过的操作，然后按照它们操作前的大小关系顺序输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d,uint v,TAG t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">-1</span>) &#123;</span><br><span class="line">        v&amp;=t.t0,v|=t.t1,v^=t.r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i) <span class="built_in">printf</span>(<span class="string">"%u "</span>,v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(u,d);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]) getans(ch[u][<span class="number">0</span>],d<span class="number">-1</span>,v,t);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>]) getans(ch[u][<span class="number">1</span>],d<span class="number">-1</span>,v|<span class="number">1u</span>&lt;&lt;d,t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外层用的是 fhq_treap ，因为这样区间操作很舒服。考虑到分裂的时候可能会分裂一个节点，给每个节点随机一个权值可能就不太均匀了，所以写的是这样的 <code>merge</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> &amp;r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||!b) <span class="keyword">return</span> (<span class="keyword">void</span>)(r=a+b);</span><br><span class="line">    push_down(a),push_down(b);</span><br><span class="line">    <span class="keyword">if</span>(rnd()&amp;<span class="number">1</span>) mer(ch[r][<span class="number">0</span>],a,ch[r=b][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span> mer(ch[r][<span class="number">1</span>],ch[r=a][<span class="number">1</span>],b);</span><br><span class="line">    push_up(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>rnd</code> 是返回随机数。</p>
<p>关于操作的标记的处理：把 <code>AND</code> 和 <code>OR</code> 想象成赋值，<code>XOR</code> 想象成取反。优先操作 <code>AND</code> 和 <code>OR</code> ，加入 <code>XOR</code> 标记的时候要计算它对 <code>AND</code> 和 <code>OR</code> 标记的影响。也就是没有被 <code>AND</code> 和 <code>OR</code> 覆盖到的位才去考虑 <code>XOR</code> 标记的影响。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uint S=~<span class="number">0u</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TAG</span> &#123;</span></span><br><span class="line">    uint t0,t1,r;</span><br><span class="line">    TAG(): t0(S),t1(<span class="number">0</span>),r(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add0</span><span class="params">(uint a)</span> </span>&#123; t0&amp;=a,t1&amp;=a,r&amp;=a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(uint a)</span> </span>&#123; t0|=a,t1|=a,r&amp;=~a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addr</span><span class="params">(uint a)</span> </span>&#123;</span><br><span class="line">        uint A0=(~t0)&amp;a,A1=t1&amp;a;</span><br><span class="line">        t1^=A1,t1|=A0;</span><br><span class="line">        t0^=A0,t0&amp;=~A1;</span><br><span class="line">        r=(r^a)&amp;((~t1)&amp;t0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TAG B)</span> </span>&#123;</span><br><span class="line">        t0&amp;=B.t0,t0|=B.t1;</span><br><span class="line">        t1&amp;=B.t0,t1|=B.t1;</span><br><span class="line">        r=r&amp;((~t1)&amp;t0);</span><br><span class="line">        addr(B.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于 trie 中下放标记的时候合并左右子树的复杂度：可以用和线段树合并复杂度同理的分析，得到复杂度均摊 $O(\log n)$ （可参看我的<a href="https://zhongyuwei.github.io/2020/03/01/NOI2018-%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/">这篇题解</a>的结尾处的分析）。是的你没看错下面这个反复递归调用的玩意的复杂度居然 TMD 只有一个 $\log$ ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> v,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u||!v) <span class="keyword">return</span> (<span class="keyword">void</span>)(u=u+v);</span><br><span class="line">    sz[u]+=sz[v];</span><br><span class="line">    push_down(u,d),push_down(v,d);</span><br><span class="line">    mer(ch[u][<span class="number">0</span>],ch[v][<span class="number">0</span>],d<span class="number">-1</span>),mer(ch[u][<span class="number">1</span>],ch[v][<span class="number">1</span>],d<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(tg[c].t0&gt;&gt;d&amp;<span class="number">1</span>)) mer(ch[c][<span class="number">0</span>],ch[c][<span class="number">1</span>],d<span class="number">-1</span>),ch[c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tg[c].t1&gt;&gt;d&amp;<span class="number">1</span>) mer(ch[c][<span class="number">1</span>],ch[c][<span class="number">0</span>],d<span class="number">-1</span>),ch[c][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tg[c].r&gt;&gt;d&amp;<span class="number">1</span>) swap(ch[c][<span class="number">0</span>],ch[c][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[c][<span class="number">0</span>]) tg[ch[c][<span class="number">0</span>]].add(tg[c]);</span><br><span class="line">    <span class="keyword">if</span>(ch[c][<span class="number">1</span>]) tg[ch[c][<span class="number">1</span>]].add(tg[c]);</span><br><span class="line">    tg[c]=TAG();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它的感觉就和这些数据结构的正常写法没有什么区别。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> uint S=~<span class="number">0u</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TAG</span> &#123;</span></span><br><span class="line">    uint t0,t1,r;</span><br><span class="line">    TAG(): t0(S),t1(<span class="number">0</span>),r(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add0</span><span class="params">(uint a)</span> </span>&#123; t0&amp;=a,t1&amp;=a,r&amp;=a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(uint a)</span> </span>&#123; t0|=a,t1|=a,r&amp;=~a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addr</span><span class="params">(uint a)</span> </span>&#123;</span><br><span class="line">        uint A0=(~t0)&amp;a,A1=t1&amp;a;</span><br><span class="line">        t1^=A1,t1|=A0;</span><br><span class="line">        t0^=A0,t0&amp;=~A1;</span><br><span class="line">        r=(r^a)&amp;((~t1)&amp;t0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TAG B)</span> </span>&#123;</span><br><span class="line">        t0&amp;=B.t0,t0|=B.t1;</span><br><span class="line">        t1&amp;=B.t0,t1|=B.t1;</span><br><span class="line">        r=r&amp;((~t1)&amp;t0);</span><br><span class="line">        addr(B.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> trie &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1e7</span>+N;</span><br><span class="line">    TAG tg[M];</span><br><span class="line">    <span class="keyword">int</span> ch[M][<span class="number">2</span>],sz[M],ncnt;</span><br><span class="line">    <span class="keyword">int</span> st[<span class="number">1000000</span>],top;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(x&amp;&amp;top&lt;<span class="number">1000000</span>) st[top++]=x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(top) &#123;</span><br><span class="line">    		<span class="keyword">int</span> u=st[--top];</span><br><span class="line">    		ch[u][<span class="number">0</span>]=ch[u][<span class="number">1</span>]=sz[u]=<span class="number">0</span>,tg[u]=TAG();</span><br><span class="line">    		<span class="keyword">return</span> u;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">return</span> ++ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; sz[c]=sz[ch[c][<span class="number">0</span>]]+sz[ch[c][<span class="number">1</span>]]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> v,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u||!v) <span class="keyword">return</span> (<span class="keyword">void</span>)(u=u+v);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        push_down(u,d),push_down(v,d);</span><br><span class="line">        mer(ch[u][<span class="number">0</span>],ch[v][<span class="number">0</span>],d<span class="number">-1</span>),mer(ch[u][<span class="number">1</span>],ch[v][<span class="number">1</span>],d<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(tg[c].t0&gt;&gt;d&amp;<span class="number">1</span>)) mer(ch[c][<span class="number">0</span>],ch[c][<span class="number">1</span>],d<span class="number">-1</span>),ch[c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tg[c].t1&gt;&gt;d&amp;<span class="number">1</span>) mer(ch[c][<span class="number">1</span>],ch[c][<span class="number">0</span>],d<span class="number">-1</span>),ch[c][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tg[c].r&gt;&gt;d&amp;<span class="number">1</span>) swap(ch[c][<span class="number">0</span>],ch[c][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ch[c][<span class="number">0</span>]) tg[ch[c][<span class="number">0</span>]].add(tg[c]);</span><br><span class="line">        <span class="keyword">if</span>(ch[c][<span class="number">1</span>]) tg[ch[c][<span class="number">1</span>]].add(tg[c]);</span><br><span class="line">        tg[c]=TAG();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> &amp;rt,uint x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=rt=newnode(); sz[cur]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ch[cur][c]) ch[cur][c]=newnode();</span><br><span class="line">            cur=ch[cur][c],sz[cur]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> &amp;v,<span class="keyword">int</span> k,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(u=<span class="number">0</span>,v=c);</span><br><span class="line">        <span class="keyword">if</span>(k==sz[c]) <span class="keyword">return</span> (<span class="keyword">void</span>)(u=c,v=<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!u) u=newnode();</span><br><span class="line">        <span class="keyword">if</span>(!v) v=newnode();</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">-1</span>) &#123;</span><br><span class="line">            sz[u]=k,sz[v]=sz[c]-k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(c,d);</span><br><span class="line">        <span class="keyword">if</span>(sz[ch[c][<span class="number">0</span>]]&gt;=k) &#123;</span><br><span class="line">            ch[v][<span class="number">1</span>]=ch[c][<span class="number">1</span>],ch[u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            split(ch[c][<span class="number">0</span>],ch[u][<span class="number">0</span>],ch[v][<span class="number">0</span>],k,d<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ch[u][<span class="number">0</span>]=ch[c][<span class="number">0</span>],ch[v][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            split(ch[c][<span class="number">1</span>],ch[u][<span class="number">1</span>],ch[v][<span class="number">1</span>],k-sz[ch[c][<span class="number">0</span>]],d<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        push_up(u),push_up(v);</span><br><span class="line">        rec(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d,uint v,TAG t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">-1</span>) &#123;</span><br><span class="line">            v&amp;=t.t0,v|=t.t1,v^=t.r;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i) <span class="built_in">printf</span>(<span class="string">"%u "</span>,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(u,d);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">0</span>]) getans(ch[u][<span class="number">0</span>],d<span class="number">-1</span>,v,t);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">1</span>]) getans(ch[u][<span class="number">1</span>],d<span class="number">-1</span>,v|<span class="number">1u</span>&lt;&lt;d,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> treap &#123;</span><br><span class="line">    uint seed=<span class="number">128</span>;</span><br><span class="line">    <span class="function">uint <span class="title">rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seed^=seed&lt;&lt;<span class="number">13</span>,seed^=seed&gt;&gt;<span class="number">17</span>,seed^=seed&lt;&lt;<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M=N+N*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[M][<span class="number">2</span>],ncnt;</span><br><span class="line">    <span class="keyword">int</span> len[M],sz[M],rt[M];</span><br><span class="line">    TAG tg[M],val[M];</span><br><span class="line">    <span class="keyword">int</span> RT;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++ncnt; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c,TAG t)</span> </span>&#123; tg[c].add(t),val[c].add(t); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[c][<span class="number">0</span>]) add(ch[c][<span class="number">0</span>],tg[c]);</span><br><span class="line">        <span class="keyword">if</span>(ch[c][<span class="number">1</span>]) add(ch[c][<span class="number">1</span>],tg[c]);</span><br><span class="line">        tg[c]=TAG();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; sz[c]=sz[ch[c][<span class="number">0</span>]]+sz[ch[c][<span class="number">1</span>]]+len[c]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span> (<span class="keyword">void</span>)(a=b=<span class="number">0</span>);</span><br><span class="line">        push_down(x);</span><br><span class="line">        <span class="keyword">if</span>(sz[ch[x][<span class="number">0</span>]]&lt;k&amp;&amp;sz[ch[x][<span class="number">0</span>]]+len[x]&gt;k) &#123;</span><br><span class="line">            a=newnode(),b=newnode();</span><br><span class="line">            val[a]=val[b]=val[x];</span><br><span class="line">            trie::split(rt[x],rt[a],rt[b],k-sz[ch[x][<span class="number">0</span>]],<span class="number">31</span>);</span><br><span class="line">            ch[a][<span class="number">0</span>]=ch[x][<span class="number">0</span>],ch[b][<span class="number">1</span>]=ch[x][<span class="number">1</span>];</span><br><span class="line">            ch[a][<span class="number">1</span>]=ch[b][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            len[a]=k-sz[ch[x][<span class="number">0</span>]],len[b]=len[x]-len[a];</span><br><span class="line">            push_up(a),push_up(b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sz[ch[x][<span class="number">0</span>]]&gt;=k) split(ch[x][<span class="number">0</span>],k,a,ch[b=x][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> split(ch[x][<span class="number">1</span>],k-sz[ch[x][<span class="number">0</span>]]-len[x],ch[a=x][<span class="number">1</span>],b);</span><br><span class="line">        push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> &amp;r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a||!b) <span class="keyword">return</span> (<span class="keyword">void</span>)(r=a+b);</span><br><span class="line">        push_down(a),push_down(b);</span><br><span class="line">        <span class="keyword">if</span>(rnd()&amp;<span class="number">1</span>) mer(ch[r][<span class="number">0</span>],a,ch[r=b][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> mer(ch[r][<span class="number">1</span>],ch[r=a][<span class="number">1</span>],b);</span><br><span class="line">        push_up(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split_rng</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> &amp;z)</span> </span>&#123;</span><br><span class="line">        split(RT,l<span class="number">-1</span>,x,y);</span><br><span class="line">        split(y,r-l+<span class="number">1</span>,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_mer</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        push_down(u);</span><br><span class="line">        trie::tg[rt[u]].add(val[u]),val[u]=TAG();</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">0</span>]) dfs_mer(ch[u][<span class="number">0</span>]),trie::mer(rt[u],rt[ch[u][<span class="number">0</span>]],<span class="number">31</span>);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">1</span>]) dfs_mer(ch[u][<span class="number">1</span>]),trie::mer(rt[u],rt[ch[u][<span class="number">1</span>]],<span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">opt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> op,l,r,v; rd(op),rd(l),rd(r); <span class="keyword">if</span>(op&lt;=<span class="number">3</span>) rd(v);</span><br><span class="line">        <span class="keyword">int</span> x,y,z; split_rng(l,r,x,y,z);</span><br><span class="line">        <span class="keyword">if</span>(op&lt;=<span class="number">3</span>) &#123;</span><br><span class="line">            TAG tmp;</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>) tmp.add1(v);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">2</span>) tmp.add0(v);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">3</span>) tmp.addr(v);</span><br><span class="line">            add(y,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> dfs_mer(y),len[y]=trie::sz[rt[y]],ch[y][<span class="number">0</span>]=ch[y][<span class="number">1</span>]=<span class="number">0</span>,push_up(y);</span><br><span class="line">        mer(RT,x,y),mer(RT,RT,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(uint *a,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=newnode();</span><br><span class="line">            trie::init(rt[u],a[i]),len[u]=<span class="number">1</span>,push_up(u);</span><br><span class="line">            mer(RT,RT,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> u=RT)</span> </span>&#123;</span><br><span class="line">        push_down(u);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">0</span>]) getans(ch[u][<span class="number">0</span>]);</span><br><span class="line">        trie::getans(rt[u],<span class="number">31</span>,<span class="number">0</span>,val[u]);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">1</span>]) getans(ch[u][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">uint a[N],n,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rd(n),rd(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]);</span><br><span class="line">    treap::build(a,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) treap::opt();</span><br><span class="line">    treap::getans();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>三角函数及其反函数的导数 整理+证明</title>
    <url>/2020/03/20/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%8F%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0-%E6%95%B4%E7%90%86-%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h2 id="定义-三角函数"><a href="#定义-三角函数" class="headerlink" title="定义-三角函数"></a>定义-三角函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数名称</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>正弦</td>
<td>$\sin \theta$</td>
</tr>
<tr>
<td>余弦</td>
<td>$\cos \theta$</td>
</tr>
<tr>
<td>正切</td>
<td>$\tan \theta$</td>
</tr>
<tr>
<td>余切</td>
<td>$\cot \theta$</td>
</tr>
<tr>
<td>正割</td>
<td>$\sec \theta = \frac{1}{\cos \theta}$</td>
</tr>
<tr>
<td>余割</td>
<td>$\csc \theta = \frac{1}{\sin \theta}$</td>
</tr>
</tbody>
</table>
</div>
<p>其中</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cot \theta &= \frac{1}{\tan \theta}\\
\sec \theta &= \frac{1}{\cos \theta}\\
\csc \theta &= \frac{1}{\sin \theta}
\end{aligned}</script><p>相关恒等式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin(x+y) &= \sin x \cos y + \cos x \sin y\\
\cos(x+y) &= \cos x \cos y - \sin x \sin y\\
\tan(x+y) &= \frac{\tan x + tan y}{1 - \tan x \tan y}\\
\sin^2 \theta + \cos^2 \theta &= 1\\
1 + \tan^2 \theta &= \sec^2 \theta\\
1 + \cot^2 \theta &= \csc^2 \theta
\end{aligned}</script><h2 id="求导-三角函数"><a href="#求导-三角函数" class="headerlink" title="求导-三角函数"></a>求导-三角函数</h2><h3 id="几个非常有用的结论"><a href="#几个非常有用的结论" class="headerlink" title="几个非常有用的结论"></a>几个非常有用的结论</h3><h4 id="a-lim-theta-to-0-frac-sin-theta-theta-1"><a href="#a-lim-theta-to-0-frac-sin-theta-theta-1" class="headerlink" title="a) $\lim_{\theta\to 0} \frac{\sin \theta}{\theta} = 1$"></a>a) $\lim_{\theta\to 0} \frac{\sin \theta}{\theta} = 1$</h4><h5 id="1-cos-theta-lt-frac-sin-theta-theta"><a href="#1-cos-theta-lt-frac-sin-theta-theta" class="headerlink" title="1. $\cos \theta &lt; \frac{\sin \theta}{\theta}$"></a>1. $\cos \theta &lt; \frac{\sin \theta}{\theta}$</h5><p><img src="https://i.loli.net/2020/02/28/6QbjXn4qyVBx5er.jpg" alt="0.jpg"></p>
<p>如图， $\odot A$ 是单位圆， $AC$ 为一条过 $A$ 的射线，它与 $x$ 轴正方向的夹角为 $\theta$ 。则：</p>
<ul>
<li>$\theta = \overset{\large\frown}{BC}$（由弧度制的定义得)</li>
<li>$\sin \theta = CH$</li>
<li>$\tan \theta = EB$</li>
</ul>
<p>于是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\theta = \overset{\large\frown}{BC}\\
< CD+DB\\
< ED + DB\\
= EB = \tan \theta\\
\therefore \theta < \tan \theta\\
\Rightarrow \theta < \frac{\sin \theta}{\cos \theta}\\
\Rightarrow \cos \theta < \frac{\sin \theta}{\theta}
\end{aligned}</script><h5 id="2-frac-sin-theta-theta-lt-1"><a href="#2-frac-sin-theta-theta-lt-1" class="headerlink" title="2. $\frac{\sin\theta}{\theta} &lt; 1$"></a>2. $\frac{\sin\theta}{\theta} &lt; 1$</h5><p>从上面的图可以看出来：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin \theta &= CH < BC < \overset{\large\frown}{BC} = \theta\\
\therefore \sin \theta &< \theta\\
\Rightarrow \frac{\sin \theta}{\theta} &< 1
\end{aligned}</script><h5 id="3-final-proof"><a href="#3-final-proof" class="headerlink" title="3. final proof"></a>3. final proof</h5><p>因为</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cos \theta < \frac{\sin \theta}{\theta} < 1\\
\lim_{\theta \to 0} \cos \theta = 1\\
\lim_{\theta \to 0} 1 = 1
\end{aligned}</script><p>由夹逼定理知</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lim_{\theta\to 0} \frac{\sin \theta}{\theta} = 1
\end{aligned}</script><h4 id="b-lim-theta-to-0-frac-cos-theta-1-theta-0"><a href="#b-lim-theta-to-0-frac-cos-theta-1-theta-0" class="headerlink" title="b) $\lim_{\theta\to 0} \frac{\cos \theta -1 }{\theta} = 0$"></a>b) $\lim_{\theta\to 0} \frac{\cos \theta -1 }{\theta} = 0$</h4><script type="math/tex; mode=display">
\begin{aligned}
&\lim_{\theta\to 0} \frac{\cos \theta -1 }{\theta}\\
=& \lim_{\theta\to 0} \frac{\cos \theta - 1}{\theta} \cdot \frac{\cos \theta + 1}{\cos \theta + 1}\\
=& \lim_{\theta\to 0} \frac{-\sin^2 \theta}{\theta(\cos \theta + 1)}\\
=& - \lim_{\theta\to 0} \frac{\sin \theta}{\theta} \cdot \lim_{\theta \to 0} \frac{\sin \theta}{\cos \theta + 1}\\
=& - 1 \cdot \frac{0}{1+1} = 0
\end{aligned}</script><h4 id="c-lim-x-to-0-frac-1-cos-x-frac-x-2-2-1"><a href="#c-lim-x-to-0-frac-1-cos-x-frac-x-2-2-1" class="headerlink" title="c) $\lim_{x\to 0} \frac{1-\cos x }{\frac{x^2}{2}} = 1$"></a>c) $\lim_{x\to 0} \frac{1-\cos x }{\frac{x^2}{2}} = 1$</h4><script type="math/tex; mode=display">
\begin{aligned}
& \lim_{x\to 0} \frac{1-\cos x}{\frac{x^2}{2}}\\
= & 2\lim_{x\to 0} \frac{1-\cos x}{x^2}\\
= & 2\lim_{x\to 0} \frac{(1-\cos x)(1+\cos x)}{x^2(\cos x +1)}\\
= & 2\lim_{x\to 0} \frac{\sin^2 x}{x^2(\cos x +1)}\\
= & 2\lim_{x\to 0} \left(\frac{\sin x}{x}\right)^2 \lim_{x\to 0} \frac{1}{1+\cos x}\\
= & 2 \cdot 1 \cdot \frac{1}{2}\\
= & 1
\end{aligned}</script><h3 id="sin-x-’-cos-x"><a href="#sin-x-’-cos-x" class="headerlink" title="$(\sin x)’ = \cos x$"></a>$(\sin x)’ = \cos x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\sin x)'\\
=& \lim_{h\to 0} \frac{\sin (x+h) - \sin x}{h}\\
=& \lim_{h\to 0} \frac{\sin x \cos h + \sin h \cos x - \sin x}{h}\\
=& \sin x \cdot \lim_{h\to 0} \frac{ \cos h - 1}{h} + \cos x\cdot \lim_{h\to 0} \frac{\sin h}{h}\\
=& \cos x
\end{aligned}</script><h3 id="cos-x-’-sin-x"><a href="#cos-x-’-sin-x" class="headerlink" title="$(\cos x)’ = -\sin x$"></a>$(\cos x)’ = -\sin x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\cos x)'\\
=& \lim_{h\to 0} \frac{\cos(x+h)-\cos x}{h}\\
=& \lim_{h\to 0} \frac{\cos x\cos h - \sin x \sin h - \cos x}{h}\\
=& \cos x \cdot \lim_{h\to 0} \frac{\cos h - 1}{h} - \sin x \lim_{h\to 0} \frac{\sin h}{h}\\
=& - \sin x
\end{aligned}</script><h3 id="tan-x-’-sec-2-x"><a href="#tan-x-’-sec-2-x" class="headerlink" title="$(\tan x)’ = \sec^2 x$"></a>$(\tan x)’ = \sec^2 x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\tan x)'\\
=& (\frac{\sin x}{\cos x})'\\
=& \frac{\cos^2 x + \sin^2 x}{\cos^2 x}\\
=& \sec^2 x
\end{aligned}</script><h3 id="cot-x-’-csc-2-x"><a href="#cot-x-’-csc-2-x" class="headerlink" title="$(\cot x)’ = -\csc^2 x$"></a>$(\cot x)’ = -\csc^2 x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\cot x)'\\
=& (\frac{\cos x}{\sin x})'\\
=& \frac{-\sin^2 x - \cos^2 x}{\sin^2 x}\\
=& - \csc^2 x
\end{aligned}</script><h3 id="sec-x-’-sec-x-cdot-tan-x"><a href="#sec-x-’-sec-x-cdot-tan-x" class="headerlink" title="$(\sec x)’ = \sec x \cdot \tan x$"></a>$(\sec x)’ = \sec x \cdot \tan x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\sec x)'\\
=& (\frac{1}{\cos x})'\\
=& \frac{\cos x \cdot 0 + \sin x \cdot 1}{\cos ^ 2 x}\\
=& \sec x\cdot \tan x
\end{aligned}</script><h3 id="csc-x-’-csc-x-cot-x"><a href="#csc-x-’-csc-x-cot-x" class="headerlink" title="$(\csc x)’ = -\csc x \cot x$"></a>$(\csc x)’ = -\csc x \cot x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\csc x)'\\
=& (\frac{1}{\sin x})'\\
=& \frac{\sin x \cdot 0 - \cos x \cdot 1}{\sin^2 x}\\
=& - \csc x\cdot \cot x
\end{aligned}</script><h2 id="求导-反三角函数"><a href="#求导-反三角函数" class="headerlink" title="求导-反三角函数"></a>求导-反三角函数</h2><h3 id="sin-1-x-’-frac-1-sqrt-1-x-2"><a href="#sin-1-x-’-frac-1-sqrt-1-x-2" class="headerlink" title="$(\sin^{-1} x)’ = \frac{1}{\sqrt {1-x^2}}$"></a>$(\sin^{-1} x)’ = \frac{1}{\sqrt {1-x^2}}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\sin y &= x\\
\cos y \cdot y'&= 1\\
y' &= \frac{1}{\cos \left(\sin^{-1} x\right)}\\
y' &= \frac{1}{\sqrt{1-x^2}}
\end{aligned}</script><h3 id="cos-1-x-’-frac-1-sqrt-1-x-2"><a href="#cos-1-x-’-frac-1-sqrt-1-x-2" class="headerlink" title="$(\cos^{-1} x)’ = -\frac{1}{\sqrt{1-x^2}}$"></a>$(\cos^{-1} x)’ = -\frac{1}{\sqrt{1-x^2}}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\cos y &= x\\
-\sin y \cdot y' &= 1\\
y' &= \frac{1}{-\sin \left(\cos^{-1} x\right)}\\
y' &= - \frac{1}{\sqrt{1-x^2}}
\end{aligned}</script><h3 id="tan-1-x-’-frac-1-1-x-2"><a href="#tan-1-x-’-frac-1-1-x-2" class="headerlink" title="$(\tan^{-1} x)’ = \frac{1}{1+x^2}$"></a>$(\tan^{-1} x)’ = \frac{1}{1+x^2}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\tan y &= x\\
\sec^2 y \cdot y' &=1\\
y' &= \frac{1}{\sec^2\left(\tan^{-1}x\right)}\\
\because \sec^2 \theta - 1 &= \left(\sec \theta \cdot \sqrt{1-\frac{1}{\sec^2 \theta }}\right)^2 = \tan^2 \theta\\
\therefore y'&= \frac{1}{1+x^2}
\end{aligned}</script><h3 id="cot-1-x-’-frac-1-1-x-2"><a href="#cot-1-x-’-frac-1-1-x-2" class="headerlink" title="$(\cot^{-1} x)’ = - \frac{1}{1+x^2}$"></a>$(\cot^{-1} x)’ = - \frac{1}{1+x^2}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\cot y &= x\\
-\csc^2 y \cdot y' &= 1\\
y' &= -\frac{1}{\csc^2 \left( \cot^{-1} x\right)}\\
\because \csc^2 \theta -1 &= \left( \csc x \sqrt{1-\frac{1}{\csc^2 x} }\right)^2 = \cot^2 x\\
y' &= -\frac{1}{x^2+1}
\end{aligned}</script><h3 id="sec-1-x-’-frac-1-x-sqrt-x-2-1"><a href="#sec-1-x-’-frac-1-x-sqrt-x-2-1" class="headerlink" title="$(\sec^{-1} x)’ = \frac{1}{x\sqrt{x^2 - 1}}$"></a>$(\sec^{-1} x)’ = \frac{1}{x\sqrt{x^2 - 1}}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\sec y &= x\\
\sec y' \cdot \tan y' \cdot y' &= 1\\
y' &= \frac{1}{\sec\left(\sec^{-1}{x}\right) \tan \left( \sec^{-1} x\right)}\\
y' &= \frac{1}{x\sqrt{x^2-1}}
\end{aligned}</script><h3 id="csc-1-x-’-frac-1-x-sqrt-x-2-1"><a href="#csc-1-x-’-frac-1-x-sqrt-x-2-1" class="headerlink" title="$(\csc^{-1} x)’ = - \frac{1}{x\sqrt{x^2 - 1}}$"></a>$(\csc^{-1} x)’ = - \frac{1}{x\sqrt{x^2 - 1}}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\csc y &= x\\
-\csc y' \cdot \cot y' \cdot y' &= 1\\
y' &= -\frac{1}{\csc\left(\csc^{-1}{x}\right) \cot \left(\csc^{-1} x\right)}\\
y' &= \frac{1}{x\sqrt{x^2-1}}
\end{aligned}</script>]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ2743 「JOI Open 2016」摩天大楼</title>
    <url>/2020/03/20/LOJ2743-%E3%80%8CJOI-Open-2016%E3%80%8D%E6%91%A9%E5%A4%A9%E5%A4%A7%E6%A5%BC/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>假设 $A$ 按照从小到大排好序之后得到的数组是 $B$ 。对于相邻的两个位置，假设其中一个是 $B_i$ ，另一个是 $B_j$ ，其中 $i&lt;j$ ，那么这两个位置对 $\sum |f_i - f_{i+1}|$ 的贡就是 $B_j - B_i = \sum_{k=i}^{j-1} (B_{i+1}-B_i)$ 。这个式子启发我们，对每个 $B_{i+1} - B_i$ 算有多少对相邻的位置满足其中一个数 $\le B_i$ 另一个 $\ge B_{i+1}$ ，就能得到 $\sum |f_{i+1}-f_i|$ 。这也等价于我们把所有 $\le B_i$ 的数插入之后得到的序列中，极大连续段的端点数。</p>
<p>设 $f_{i,j,k,d}$ 表示已经插入了 $i$ 个数，插入了的数在序列中形成了 $j$ 个极长的连续段，已经统计过的 $\sum |f_i-f_{i+1}|$ 的贡献和是 $k$ ，两个端点是否被占用过，对应的方案数。转移 $O(1)$ ，最后的答案是 $\sum_{j\le m} f_{n,1,j,2}$ ，总复杂度 $O(n^2m)$ 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/769208" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC026D Histogram Coloring</title>
    <url>/2020/03/20/AGC026D-Histogram-Coloring/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>考虑给一个第一行确定的矩形涂色的方案数：</p>
<ul>
<li>第一行是红蓝交错的（RBRBRBR…或者BRBRBRB…）<ul>
<li>那么，接下来的每一行都有恰好两种选择，RBRBR…或者BRBRBR…，方案数是 $2^{n-1}$ </li>
</ul>
</li>
<li>第一行存在两个相邻的位置颜色相同<ul>
<li>显然在第二行中，那两个位置的颜色也是相同的；以此类推，这个矩形中的每一行都会有两个相邻的位置颜色相同</li>
<li>对于第二行来说，由于上一行和这一行的至少两个格子的颜色是确定的，所以第二行每个格子的颜色都是确定的；后面的行也是同理</li>
<li>所以涂色的方案数是 $1$</li>
</ul>
</li>
</ul>
<p>考虑按照区间最小值进行分治，按照 $[1,n]$ 的最小值的出现位置把区间割开，对每个子区间分治下去，求出每个区间内：红蓝交错/不红蓝交错地填到区间最小值-1的高度的方案数，记为 $f_{l,r,0/1}$ 。</p>
<p><img src="https://i.loli.net/2020/03/20/6XYyhN7aCkvzmZg.png" alt=""></p>
<p>图中紫色的框出的是每一个子区间，红色标出每个子区间的 $f_{l,r,0/1}$ 考虑过的格子，蓝色标出大区间的 $f_{l,r,0/1}$ 需要考虑的格子。</p>
<p>合并子区间的信息，得到大区间的 $f_{l,r,0/1}$ 。直接算 $f_{l,r,1}$ 比较困难，可以考虑算总方案数，然后用总方案数减去 $f_{l,r,0}$ 。具体细节参见代码。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://atcoder.jp/contests/agc026/submissions/11021955" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF908G New Year and Original Order</title>
    <url>/2020/03/20/CF908G-New-Year-and-Original-Order/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>设 $c_i(0\le i\le 9)$ 表示 $i$ 这个数字在 $k$ 中出现了几次，则</p>
<script type="math/tex; mode=display">
\begin{aligned}
Ans &= \sum_{k=1}^X \sum_{i=1}^9 i \cdot \frac{10^{\sum_{j=i}^9 c_j}-10^{\sum_{j=i+1}^9 c_j}}{9}\\
&= \sum_{k=1}^X \sum_{i=1}^9 \sum_{y=1}^i \frac{10^{\sum_{j=i}^9 c_j}-10^{\sum_{j=i+1}^9 c_j}}{9}\\
&= \sum_{k=1}^X \sum_{y=1}^9 \sum_{i=y}^9 \frac{10^{\sum_{j=i}^9 c_j}-10^{\sum_{j=i+1}^9 c_j}}{9}\\
&= \sum_{k=1}^X \sum_{y=1}^9 \frac{10^{\sum_{j=y}^9 c_j}-1}{9}\\
\end{aligned}</script><p>在最外层枚举 $y$ 之后，可以用数位 dp 在 $O(\lg^2 X)$ 的时间内算出答案。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://codeforces.com/contest/908/submission/73772415" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC002E Candy Piles</title>
    <url>/2020/03/19/AGC002E-Candy-Piles/</url>
    <content><![CDATA[<p>简单转化之后（可以参考<a href="http://agc002.contest.atcoder.jp/data/agc/002/editorial.pdf" target="_blank" rel="noopener">官方题解</a>），变成了：网格中有个阶梯形状的轮廓线，棋子从 $(0,0)$ 开始走，每次可以往左走或者往上走，走到边界的那一步的操作者输（即，边界上的点是必胜态）。</p>
<p>可以证明，如果 $(x+1,y+1)$ 不在边界上，那么 $(x,y)$ 的胜负状态和 $(x+1,y+1)$ 的胜负状态相同。</p>
<p>证明：</p>
<p>1）可以从 $(x+1,y+1)$ 为必败态推出 $(x,y)$ 为必败态：如果 $(x+1,y+1)$ 必败，那么 $(x,y+1), (x+1,y)$ 都是必胜态，那么 $(x,y)$ 就必败。</p>
<p>2）可以从 $(x+1,y+1), (x+2,y+2)$ 是必胜态推出 $(x,y)$ 是必胜态：$(x+3,y+2)$ 和 $(x+2,y+3)$ 中至少有一个是必败态，我们假设 $(x+3,y+2)$ 是必败态，可以推出：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>\</th>
<th>x</th>
<th>x+1</th>
<th>x+2</th>
<th>x+3</th>
</tr>
</thead>
<tbody>
<tr>
<td>y+2</td>
<td>*</td>
<td>*</td>
<td><em>1</em></td>
<td><em>0</em></td>
<td></td>
</tr>
<tr>
<td>y+1</td>
<td>*</td>
<td><em>1</em></td>
<td>0 (b)</td>
<td>1 (a)</td>
<td></td>
</tr>
<tr>
<td>y</td>
<td>1 (e)</td>
<td>0 (d)</td>
<td>1 (c)</td>
<td>*</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>其中，* 表示不确定，斜体表示已知的条件，(a) ~ (e) 代表推理的顺序。</p>
<p>对于 $(x+2,y+3)$ 必败的情况可以同理证明。</p>
<p>代码实现：从 $(0,0)$ 出发往右上走，直到下一步会碰到边界，然后算出其上方和右边的格子的状态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) rd(a[i]);</span><br><span class="line">	sort(a,a+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(y+<span class="number">1</span>&lt;a[x+<span class="number">1</span>]) x++,y++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> t1=!((a[x]-(y+<span class="number">1</span>))&amp;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> r=x; <span class="keyword">while</span>(y&lt;a[r+<span class="number">1</span>]) r++;</span><br><span class="line">	<span class="keyword">int</span> t2=!((r+<span class="number">1</span>-(x+<span class="number">1</span>))&amp;<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!(t1&amp;t2)) <span class="built_in">printf</span>(<span class="string">"First"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Second"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ346 【清华集训2017】某位歌姬的故事</title>
    <url>/2020/03/09/UOJ346-%E3%80%90%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%E3%80%91%E6%9F%90%E4%BD%8D%E6%AD%8C%E5%A7%AC%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>分开考虑 $h$ 不同的限制。每个的位置的值在包含它的、 $h$ 最小的限制那里确定。</p>
<p>对于某个确定的 $h$ ，如果有两个限制满足 $l_1\le l_2\le r_2\le r_1$ 的，只保留 $[l_2,r_2]$ 就可以了（注意最后要给答案乘上给 $[l_1,l_2)\cup (r_2,r_1]$ 赋值的方案数）。这样处理以后，限制的区间的左右端点都是单调的。</p>
<p>然后，将区间按照端点位置排序之后，考虑极长的、相邻的两个区间都有交的段，对每个段单独统计方案数。</p>
<p>考虑容斥（即区间内所有数都 $\le h$ 的方案数 - 区间内所有数都 $\le h-1$ 的方案数）。设 $f_{i,j}$ 为考虑了前 $i$ 个区间、上一个要求所有数 $\le h-1$ 的区间右端点是 $j$ 时，给 $\le j$ 的位置赋值的方案数 * 对应的容斥系数。每次枚举下一个要求所有数 $\le h-1$ 的区间是谁进行转移即可。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="http://uoj.ac/submission/386686" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3046 「ZJOI2019」语言</title>
    <url>/2020/03/07/LOJ3046-%E3%80%8CZJOI2019%E3%80%8D%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>考虑对每个点算出能够与它进行贸易活动的点数，也就是到它的路径被那 $m$ 条路径中的某一条完全包含的点数。</p>
<p>对原树进行链分治（重链剖分），这样每条路径最多会经过 $\log n$ 条链。</p>
<p>对每条链考虑，经过了它的路径长这样：</p>
<p><img src="https://i.loli.net/2020/03/07/3dRAXn2xeM1B6Qt.png" alt=""></p>
<p>黑色代表那条链，其它每种颜色代表了一条路径。</p>
<p>对于这条链上的一个点，它能进行贸易的点数实际上就是：那些左端点在这个点左侧、右端点在这个点右侧的路径，它们的端点的虚树大小。</p>
<p>对链上的点扫描线，并动态维护满足条件的路径的虚树大小即可。</p>
<p>复杂度 $O(n\log ^ 2 n)$ 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/760970" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3042 「ZJOI2019」麻将</title>
    <url>/2020/03/05/LOJ3042-%E3%80%8CZJOI2019%E3%80%8D%E9%BA%BB%E5%B0%86/</url>
    <content><![CDATA[<p>参考 <a href="https://blog.csdn.net/qq_39972971/article/details/88981526" target="_blank" rel="noopener">cz_xuyixuan的blog</a></p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>把原问题转化成 $\sum_{i=0}^\infty P(S_i 不存在一个子集能胡)$ 。要算这个玩意则需要对每个 $i$ ，求出大小为 $i$ 且加上初始的牌之后不存在胡子集的子集的数量。</p>
<p>怎样判断一副牌能不能胡：</p>
<ol>
<li>如果有不少于 $7$ 种牌，每种牌的数量都不少于 $2$ ，就能胡；</li>
<li>设 $f_{i,x,y,0/1}$ 表示考虑了前 $i$ 种牌，从 $i-1$ 开始的 $(a,a+1,a+2)$ 型的面子有 $x$ 个，从 $i$ 开始的 $(a,a+1,a+2)$ 型的面子有 $y$ 个，前 $i$ 种牌是否凑出过对子，这种情况下能够得到的面子数量的最大值（不包括从 $i,i-1$ 开始的 $(a,a+1,a+2)$ 型面子）。由于三个 $(a,a+1,a+2)$ 型的面子可以转化成三个 $(a,a,a)$ 型的面子，所以 $0\le x,y &lt; 3$ 。如果 $f_{n,x,y,1} \ge 4$ ，就能胡；</li>
</ol>
<p>把 $f_i$ 每个位置的取值、以及能凑出对子的牌的数量，作为 dp 的状态进行 dp 即可。搜索发现状态数不超过 3227 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/759458" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown preview enhanced 以及 hexo 中的行间公式换行符问题</title>
    <url>/2020/03/04/markdown-preview-enhanced-%E4%BB%A5%E5%8F%8A-hexo-%E4%B8%AD%E7%9A%84%E8%A1%8C%E9%97%B4%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>在使用 <code>vscode</code> 的 <code>markdown preview enhanced</code> 进行预览的时候，经常会出现这种情况：如果行间公式包含了 <code>\\</code> ，预览就会显示：<code>ParseError: KaTeX parse error: \cr valid only within a tabular/array environment</code> 。重启 <code>vscode</code> 就能恢复正常。</p>
<p>最近无意中发现，如果把公式用 <code>\begin{aligned}</code> 和 <code>\end{aligned}</code> 包围起来，就不会出现上面的问题。</p>
<p><img src="https://i.loli.net/2020/03/04/axokF4XUdT7uqQ6.jpg" alt=""></p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>我最近重装了 <code>hexo</code> ，可能是配置的问题，行间公式里面的 <code>\\</code> 全部都没有换行。</p>
<p><img src="https://i.loli.net/2020/03/04/qiH6rVBmd7NLZ5l.jpg" alt=""><br><img src="https://i.loli.net/2020/03/04/MDGLWf1OtgrjRmH.jpg" alt=""></p>
<p>上图中，两个公式之间本来应该有一个换行，但是却挤在了一行。</p>
<p>我发现，把公式用 <code>\begin{aligned}</code> 和 <code>\end{aligned}</code> 包围起来，就可以正常换行了，效果如下</p>
<p><img src="https://i.loli.net/2020/03/04/D6NOPGvhljZmIrk.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3053 「十二省联考 2019」希望</title>
    <url>/2020/03/04/LOJ3053-%E3%80%8C%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%83-2019%E3%80%8D%E5%B8%8C%E6%9C%9B/</url>
    <content><![CDATA[<h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><h3 id="0"><a href="#0" class="headerlink" title="0"></a>0</h3><p>部署方案合法的条件是：存在一个点$u$，使得所有搜救范围都包含$u$且所有在搜救范围中出现过的点到$u$的距离不超过$L$。此时我们称部署方案可以被点$u$识别。</p>
<p>定义一种部署方案可以被一条边识别，当且仅当这条边的两个端点都能识别它。</p>
<p>显然，对于某种部署方案，可以识别它的$u$会构成一个连通块，而连通块点数 - 边数 = 1。所以，（每个点可以识别的部署方案数 - 每条边可以识别的部署方案数）就是答案。</p>
<p>设$s_u$表示包含$u$且所有点到$u$的距离均不超过$L$的连通块数，设$s_{(x,y)}$表示既包含在$s_x$里又包含在$s_y$里的连通块数，则</p>
<script type="math/tex; mode=display">
Ans = \sum_u s_u^k - \sum_{(x,y) \in T} s_{(x,y)}^k</script><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>用$dp$计算$s_u,s_{(x,y)}$。</p>
<p>设$f_{u,j}$表示只包含$u$子树内的点，且所有点到$u$的距离不超过$j$，且包含了$u$的连通块数。设$g_{u,j}$表示包含了$u$的父亲$fa_u$，且不包含$u$的子树内的点，且所有点到$fa_u$的距离不超过$j$的连通块数。距离定义为两个点之间最短路上的边数。</p>
<p>则</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{u,j} = \prod_{v\in son_u} (f_{v,j-1}+1) - 1\\
g_{u,j} = (g_{fa_u,j-1}+1)\prod_{v\in son_{fa_u},v\neq u}(f_{v,j-1}+1)\\
s_u = f_{u,L}\cdot (g_{u,L-1}+1),s_{(u,fa_u)}=f_{u,L-1}\cdot g_{u,L-1}
\end{aligned}</script><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>用长链剖分优化dp。</p>
<p>设$len_u$表示$u$的子树中深度最深的点到$u$的距离。观察可知$f_{u,len_u} = f_{u,len_u+1} = f_{u,len_u+2} \cdots$，所以我们只需要算$f_{u,0},f_{u,1},\cdots f_{u,len_u}$就可以了。</p>
<p>处理某个点的$f$的时候，直接让它继承重儿子的信息（这一步要求支持全局+1的操作）。合并轻儿子$v$的时候，对于$f_{v,0},f_{v,1}\cdots f_{v,len_v}$可以直接暴力，剩下的相当于是令$f_u$数组的一个后缀乘上$f_{v,len_v}$。</p>
<p>如果$f_{v,len_v}$不为$0$的话，我们可以让$f_{u,0},f_{u,1} \cdots f_{u,len_v}$都乘上$f_{v,len_v}$的逆元（注意，不应是直接对数组中的数进行乘$f_{v,len_v}$的逆元的操作，而应该将数组中的值赋为“经过当前的全局标记的运算之后为$f_{u,i}\over f_{v,len_v}$”的值），然后打上全局乘以$f_{v,len_v}$的标记。</p>
<p>如果$f_{v,len_v}$为$0$，就相当于是让一段后缀都变成了$0$，我们可以另外维护一个标记$(l,x)$，表示从$l$开始的位置，数组中的值都是$x$（同理，$x$不一定是$0$，而是“经过当前的全局标记的运算之后为$0$”的值）。</p>
<p>$g$的维护则要更加麻烦一些。首先，我们将所有的链分成两类：长度小于$L-1$的，我们只需要记录链顶元素$u$的$g_{u,L-1-len_u},g_{u,L-1-len_u+1} \cdots g_{u,L-1}$就能够算出这个子树内所有点的$g_{v,L-1}$；长度大于等于$L-1$的，记录链顶元素的$u$的$g_{u,0},g_{u,1} \cdots g_{u,L-1}$即可。而从某个点到它的重儿子时，$g_u$的长度至多加$1$。这样状态数降到了$O(n)$。</p>
<p>直接让重儿子继承当前点的$g$（这个也要求支持全局+1），然后把其他儿子的贡献$(f_{v,j}+1)$合并上来（这个需要支持对后缀的乘法，与$f$的处理类似）。而对于轻儿子$v$，把$\prod_{v’\in son_u,v’\neq v}(f_{v’,j}+1)$分为三部分：1.在我们处理这个轻儿子之前遍历过的轻儿子的贡献；2.还没有遍历过的轻儿子的贡献；3.重儿子的贡献。按照$len$从小到大的顺序依次处理轻儿子，就能够及其方便地统计在当前的轻儿子之前遍历过的轻儿子的贡献；在计算$f$的时候，我们按照轻儿子的$len$从大到小的顺序来合并，把$v$被并入之后的我们对$f$的那些操作撤销掉，就可以得到$v$被并入之前的$f$，也就是2. 3.两部分的贡献。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>将儿子按照$len$排序，可以先把重儿子找出来，然后对剩下的进行基数排序。这样总复杂度为$O(n)$。</p>
<p>实际上我们需要用到的逆元只有每个点的$f_{u,len_u}$，可以在$O(n)$的时间预处理出它们的逆元。</p>
<p>总复杂度$O(n)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://loj.ac/submission/733990" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF582D Number of Binominal Coefficients</title>
    <url>/2020/03/03/CF582D-Number-of-Binominal-Coefficients/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>如何判断 $p^\alpha \mid \binom{n}{k}$ 是否成立：只需要知道 $\binom{n}{k}$ 中 $p$ 的次数是否大于等于 $\alpha$ 。</p>
<p>设 $f(n)$ 为 $n!$ 中 $p$ 的次数，显然有 $f(n) = \sum_{i=1}^\infty \lfloor \frac{n}{p^i} \rfloor$。而我们要做的就是检查 $f(n)-f(k)-f(n-k)$ 是否成立。</p>
<p>$f(n)$ 实际上相当于：$n$ 的 $p$ 进制表示去掉最后一位后的值 + $n$ 的 $p$ 进制表示去掉最后两位后的值 + $n$ 的 $p$ 进制表示去掉最后三位后的值 ……</p>
<p>考虑 $f(a+b)$ 和 $f(a)+f(b)$ 的区别：如果 $a+b$ 在 $p$ 进制下没有进位，那么两者显然相同；考虑如果 $a+b$ 在 $p^k$ 这一位进位了，那么相较于 $f(a)+f(b)$ ，$f(a+b)$ 在 $i\le k$ 的时候的贡献是不变的，但是在 $i=k+1$ 的时候就会多贡献 $1$ 。又因为这是两个数的加法，每一位至多进位一次，所以不会出现在第 $k$ 位的进位贡献到第 $k+2$ 位的情况。所以 $f(a+b)-(f(a)+f(b))$ 就是 $a+b$ 在 $p$ 进制加法中进位的次数。</p>
<p>令 $a=k,b=n-k$ ，我们相当于要统计满足 $0\le a,0\le b, a+b\le A$ 且 $a+b$ 进位次数不小于 $\alpha$ 的 $(a,b)$ 的数量。这是一个基础的数位 dp 问题。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://codeforces.com/contest/582/submission/72292629" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI2018 你的名字</title>
    <url>/2020/03/01/NOI2018-%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>答案相当于 $T$ 中不被 $S_{l\cdots r}$ 包含的本质不同的子串数量。</p>
<p>求出 $T$ 中被 $S_{l\cdots r}$ 包含了的本质不同的子串数量，用 $T$ 的本质不同的子串数量减去它就是答案。后者容易求，我们考虑怎么求前者。</p>
<h4 id="部分分：-l-1-r-S"><a href="#部分分：-l-1-r-S" class="headerlink" title="部分分：$l=1,r=|S|$"></a>部分分：$l=1,r=|S|$</h4><p>对 $T$ 建出 SAM ，然后对 SAM 中的每个节点，考虑这个节点代表的子串集合的贡献。这个集合形如“ $T$ 的某个子串 $w$ 的所有长度不小于 $minlen$ 的后缀”。我们只需要知道 $w$ 最长的、在 $S$ 中出现过的后缀是谁，就能够统计这个集合中有多少个串在 $S$ 中出现过（长度更短的都出现过，长度更长的都没有出现过）。更进一步观察发现，我们其实只需要知道，以 $w$ 结尾的那个前缀，它的最长的、在 $S$ 中出现过的后缀是谁，就可以了（ $w$ 的最长的在 $S$ 中出现过的后缀长度就是那个后缀的长度和 $|w|$ 的较小值）。</p>
<p>这是个经典的后缀自动机问题。对 $S$ 建出 SAM ，然后让 $T$ 在 $S$ 上面跑匹配就可以了。具体地，维护一个 <code>u</code> 表示当前的位置，<code>len</code> 表示当前匹配上了的长度。每次从 <code>u</code> 走向 <code>ch[u][T[i]]</code> 的时候，就把变成 <code>len+1</code>；如果转移不存在，就从 <code>u</code> 跳到 <code>fail[u]</code> ， <code>len</code> 变成现在的 <code>u</code> 中最长的子串的长度。复杂度分析：一次跳 <code>fail</code> 会让匹配长度至少减少 1 ，而一次 <code>u -&gt; ch[u][T[i]]</code> 则会让匹配长度 + 1 ，匹配长度总是非负并且整个过程中匹配的长度只会增加 $|T|$ 次，所以复杂度是 $O(|T|)$ 的。</p>
<h4 id="l-r-任意"><a href="#l-r-任意" class="headerlink" title="$l,r$ 任意"></a>$l,r$ 任意</h4><p>考虑对前面在 SAM 的匹配做一些修改：我们称一个节点“存在”，当且仅当它所代表的子串集合中，最短的那个串在 $S_{l\cdots r}$ 中出现过。那么匹配过程中我们相当于需要支持：</p>
<ul>
<li>查询一个点是否存在</li>
<li>查询一个点所代表的子串集合中，在 $S_{l\cdots r}$ 中出现过的、最长的串</li>
</ul>
<p>第一问：设这个节点的子串集合中最短的串长度是 $minlen$ 。用可持久化线段树合并维护出每个节点的 endpos 集合，查询 $[l+minlen-1, r]$ 这个区间内是否有这个节点的 endpos 即可。</p>
<p>第二问：找出 $[l+minlen-1, r]$ 中最靠右的那个 endpos ，它到 $l$ 的距离和这个节点代表的最长子串长度的较小值即为答案。</p>
<p>具体细节见代码。</p>
<h4 id="附：可持久化线段树合并的空间复杂度"><a href="#附：可持久化线段树合并的空间复杂度" class="headerlink" title="附：可持久化线段树合并的空间复杂度"></a>附：可持久化线段树合并的空间复杂度</h4><p>可能有锅，欢迎指正。</p>
<p>分成两个部分：</p>
<ol>
<li>将 $n$ 个节点插进 $n$ 棵不同的树。</li>
<li>合并两棵树，并复制两棵树的公共部分，得到一棵新的树。</li>
</ol>
<p>第一部分会用到至多 $n\lceil\log_2 n\rceil$ 个节点。</p>
<p>第二部分中，考虑每个非叶子节点：每一次复制它，它子树内的叶子节点数量一定变多了，所以它被复制的次数至多是它子树内的叶子节点数量。每个叶子至多在 $\lceil \log_2 n\rceil$ 个节点的子树中，所以复制节点的次数至多是 $n\lceil\log_2 n\rceil$ 次。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/756501" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>Comet #3 F 毒瘤的菜菜子</title>
    <url>/2020/02/29/Comet-3-F-%E6%AF%92%E7%98%A4%E7%9A%84%E8%8F%9C%E8%8F%9C%E5%AD%90/</url>
    <content><![CDATA[<p><a href="https://www.cometoj.com/contest/38/problem/F?problem_id=1545" target="_blank" rel="noopener">link to the problem</a></p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>设 $s(a,b,c,d) = \sum_{i=a}^b \sum_{j=c}^d [ a_i \mid a_j ] + [ a_j \mid a_i ]$</p>
<p>考虑莫队，相当于将原问题转化成了 $O(n)$ 次形如 $\sum_{i=r+1}^{r’} s(l,i-1,i,i)$ 或 $\sum_{i=l’}^{l-1} s(i+1,r,i,i)$ 的询问（分别对应了左端点和右端点的移动）。</p>
<p>差分一下得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=r+1}^{r'} s(l,i-1,i,i) = \sum_{i=r+1}^{r'} s(1,i-1,i,i) - s(1,l-1,i,i)\\
\sum_{i=l'}^{l-1} s(i+1,r,i,i) = \sum_{i=l'}^{l-1} s(1,r,i,i) - s(1,i,i,i)
\end{aligned}</script><p>这样我们就把原问题转化成了 $O(n)$ 个形如 $\sum_{i=l}^r s(1,p,i,i)$ 的询问，并且 $\sum r-l = O(n\sqrt n)$。</p>
<p>考虑扫描线，那么我们要支持的操作就是：</p>
<ul>
<li>加入一个数</li>
<li>给出一个区间，枚举这个区间中的每一个数 $x$ ，查询已经加入的数中<br> 1) 有多少个数是 $x$ 的倍数<br> 2) 有多少个数是 $x$ 的因数</li>
</ul>
<p>对于第一问：每加入一个数，我们就枚举它所有的约数、打上标记，查询的时候直接返回 $x$ 的标记即可。</p>
<p>对于第二问：我们考虑对加入的数进行根号分治。对于超过 $\sqrt n$ 的数，直接枚举它所有的倍数打上标记；对于小于等于 $\sqrt n$ 的数，我们枚举所有的 $y\in [1,\sqrt n]$ ，然后处理出序列的每个前缀中有多少个数是 $y$ 的倍数（以支持查询一个区间内有多少个数是 $y$ 的倍数），扫描线的时候维护前 $p$ 个位置有多少个数等于 $y$ 即可。</p>
<p>总时间复杂度 $O(n\sqrt n)$ ，空间复杂度 $O(n)$ 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://www.cometoj.com/status/xscggv2xwqii3464k8bnj39h4di2dhi8" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3744 Gty的妹子序列</title>
    <url>/2020/02/29/BZOJ3744-Gty%E7%9A%84%E5%A6%B9%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p><a href="https://www.cnblogs.com/zzqsblog/p/7522528.html" target="_blank" rel="noopener">参考了zzq的blog</a></p>
<p>考虑分块。对于一次询问，涉及到的元素有如下的形式：</p>
<p><img src="https://i.loli.net/2020/02/29/ZCrAkeET4JOj31X.png" alt=""></p>
<p>讨论逆序对中的两个元素分别属于哪个部分，即得到一个时间复杂度 $O(n\sqrt n)$ ，空间复杂度 $O(n\sqrt n)$ 的算法：</p>
<h5 id="x-in-A-y-in-A"><a href="#x-in-A-y-in-A" class="headerlink" title="$x\in A,y\in A$"></a>$x\in A,y\in A$</h5><p>预处理每个块的每个后缀中的逆序对数。</p>
<h5 id="x-in-C-y-in-C"><a href="#x-in-C-y-in-C" class="headerlink" title="$x\in C,y\in C$"></a>$x\in C,y\in C$</h5><p>预处理每个块的每个后缀中的逆序对数。</p>
<h5 id="x-in-B-y-in-B"><a href="#x-in-B-y-in-B" class="headerlink" title="$x\in B,y\in B$"></a>$x\in B,y\in B$</h5><p>预处理出 $f_{i,j}$ 表示第 $i$ 块到第 $j$ 块这个区间中的元素两两之间的逆序对数。</p>
<p>具体地，先对每个块预处理出块内的元素排序后的结果，然后归并求出 $g_{i,j}$ 表示第 $i$ 块和第 $j$ 块中的元素两两之间的逆序对数。这一步的复杂度是 $O(n\log n + \sqrt n \cdot (\sqrt n)^2 ) = O(n\sqrt n)$ 。</p>
<p>然后对 $g_{i,j}$ 做个类似区间 dp 的东西就能得到 $f$ （即：$f_{i,j} = g_{i,j} + f_{i,j-1} + f_{i+1,j} - f_{i+1,j-1}$）。这一步的复杂度是 $O((\sqrt n)^2) = O(n)$ 。</p>
<h5 id="x-in-A-y-in-B"><a href="#x-in-A-y-in-B" class="headerlink" title="$x\in A,y\in B$"></a>$x\in A,y\in B$</h5><p>预处理出 $s_{i,j}$ 表示前 $i$ 块中小于等于 $j$ 的数有多少个，然后枚举 $A$ 中的每一个数进行查询就好。预处理复杂度 $O(n\sqrt n)$ ，单次查询的复杂度 $O(\sqrt n)$ 。空间复杂度是 $O(n\sqrt n)$ 。</p>
<h5 id="x-in-B-y-in-C"><a href="#x-in-B-y-in-C" class="headerlink" title="$x\in B,y\in C$"></a>$x\in B,y\in C$</h5><p>同 $x\in A, y\in B$ 。</p>
<h5 id="x-in-A-y-in-C"><a href="#x-in-A-y-in-C" class="headerlink" title="$x\in A,y\in C$"></a>$x\in A,y\in C$</h5><p>对 $A$ 所在的整块和 $C$ 所在的整块进行归并，复杂度 $O(\sqrt n)$ 。</p>
<p>具体地，归并的时候每加入一个 $C$ 中的元素，就让 <code>cnt++</code> ；每加入一个 $A$ 中的元素，就让 <code>ans+=cnt</code> 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">260</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">	<span class="keyword">int</span> a[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">I</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> t)</span> </span>&#123; <span class="keyword">for</span>(;i&lt;=m;i+=i&amp;-i) a[i]+=t; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="keyword">for</span>(;i;i-=i&amp;-i) ans+=a[i]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bel[N],T;</span><br><span class="line"><span class="keyword">int</span> pos[N],s[M][N];</span><br><span class="line"><span class="keyword">int</span> f[M][M],pre[N],suf[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmppos</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> a[x]==a[y]?x&lt;y:a[x]&lt;a[y]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lv,<span class="keyword">int</span> rv)</span> </span>&#123; <span class="keyword">return</span> s[x][rv]-s[x][lv<span class="number">-1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> lv,<span class="keyword">int</span> rv)</span> </span>&#123; <span class="keyword">return</span> Qry(r,lv,rv)-Qry(l<span class="number">-1</span>,lv,rv); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ql,qr,lastans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]),b[i]=a[i];</span><br><span class="line">	sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>); m=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=lower_bound(b+<span class="number">1</span>,b+m+<span class="number">1</span>,a[i])-b;</span><br><span class="line">	</span><br><span class="line">	T=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) bel[i]=(i<span class="number">-1</span>)/T+<span class="number">1</span>,pos[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=T) &#123;</span><br><span class="line">		<span class="keyword">int</span> len=min(T,n-i+<span class="number">1</span>);</span><br><span class="line">		sort(pos+i,pos+i+len,cmppos);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) s[bel[i]][j]=s[bel[i]<span class="number">-1</span>][j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+len;++j) s[bel[i]][a[j]]++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+len;++j) pre[j]=BIT::Q(m-(a[j]+<span class="number">1</span>)+<span class="number">1</span>),BIT::I(m-a[j]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+len;++j) BIT::I(m-a[j]+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+len<span class="number">-1</span>;j&gt;=i;--j) suf[j]=BIT::Q(a[j]<span class="number">-1</span>),BIT::I(a[j],<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+len<span class="number">-1</span>;j&gt;=i;--j) BIT::I(a[j],<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;i+len;++j) pre[j]+=pre[j<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+len<span class="number">-2</span>;j&gt;=i;--j) suf[j]+=suf[j+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bel[n];++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) s[i][j]+=s[i][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bel[n];++i) f[i][i]=suf[(i<span class="number">-1</span>)*T+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+<span class="number">1</span>&lt;=bel[n];++i) f[i][i+<span class="number">1</span>]=suf[(i<span class="number">-1</span>)*T+<span class="number">1</span>]+suf[i*T+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=bel[n];++l)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> r=l+<span class="number">1</span>;r&lt;=bel[n];++r) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> pl=(l<span class="number">-1</span>)*T+<span class="number">1</span>,liml=l*T;</span><br><span class="line">			<span class="keyword">int</span> pr=(r<span class="number">-1</span>)*T+<span class="number">1</span>,limr=min(r*T,n);</span><br><span class="line">			<span class="keyword">while</span>(pl&lt;=liml||pr&lt;=limr)</span><br><span class="line">				<span class="keyword">if</span>(pl&lt;=liml&amp;&amp;(pr&gt;limr||a[pos[pl]]&lt;=a[pos[pr]]))</span><br><span class="line">					f[l][r]+=cnt,pl++;</span><br><span class="line">				<span class="keyword">else</span> cnt++,pr++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=bel[n];++len)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=bel[n];++l) &#123;</span><br><span class="line">			<span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">			f[l][r]+=f[l+<span class="number">1</span>][r]+f[l][r<span class="number">-1</span>]-f[l+<span class="number">1</span>][r<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">int</span> q; rd(q);</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		rd(ql),rd(qr);</span><br><span class="line">		ql^=lastans,qr^=lastans;</span><br><span class="line">		<span class="keyword">if</span>(ql&gt;qr) swap(ql,qr);</span><br><span class="line">		<span class="keyword">if</span>(bel[ql]==bel[qr]) &#123;</span><br><span class="line">			<span class="keyword">int</span> pl=(bel[ql]<span class="number">-1</span>)*T+<span class="number">1</span>,pr=min(bel[ql]*T,n);</span><br><span class="line">			<span class="keyword">if</span>(ql==pl) lastans=pre[qr];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(qr==pr) lastans=suf[ql];</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				lastans=pre[qr]-pre[ql<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=pl;i&lt;=pr;++i) &#123;</span><br><span class="line">					<span class="keyword">if</span>(pos[i]&gt;=ql&amp;&amp;pos[i]&lt;=qr) cnt++;</span><br><span class="line">					<span class="keyword">if</span>(pos[i]&lt;=ql<span class="number">-1</span>) lastans-=cnt;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> bl=bel[ql]+<span class="number">1</span>,br=bel[qr]<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(ql==(bel[ql]<span class="number">-1</span>)*T+<span class="number">1</span>) bl--;</span><br><span class="line">			<span class="keyword">if</span>(qr==min(bel[qr]*T,n)) br++;</span><br><span class="line">			lastans=f[bl][br]+(bel[ql]==bl?<span class="number">0</span>:suf[ql])+(bel[qr]==br?<span class="number">0</span>:pre[qr]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=ql;bel[i]!=bl;++i) lastans+=Qry(bl,br,<span class="number">1</span>,a[i]<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=qr;bel[i]!=br;--i) lastans+=Qry(bl,br,a[i]+<span class="number">1</span>,m);</span><br><span class="line">			<span class="keyword">if</span>(bel[ql]!=bl&amp;&amp;bel[qr]!=br) &#123;</span><br><span class="line">				<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">int</span> pl=(bl<span class="number">-2</span>)*T+<span class="number">1</span>,liml=(bl<span class="number">-1</span>)*T;</span><br><span class="line">				<span class="keyword">int</span> pr=br*T+<span class="number">1</span>,limr=min((br+<span class="number">1</span>)*T,n);</span><br><span class="line">				<span class="keyword">while</span>(pl&lt;=liml||pr&lt;=limr)</span><br><span class="line">					<span class="keyword">if</span>(pl&lt;=liml&amp;&amp;(pr&gt;limr||a[pos[pl]]&lt;=a[pos[pr]])) &#123;</span><br><span class="line">						<span class="keyword">if</span>(pos[pl]&gt;=ql) lastans+=cnt;</span><br><span class="line">						pl++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span>(pos[pr]&lt;=qr) cnt++;</span><br><span class="line">						pr++;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lastans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3289 Mato的文件管理</title>
    <url>/2020/02/29/BZOJ3289-Mato%E7%9A%84%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>设 $s(l_1,r_1,l_2,r_2) = \sum_{i\in [l_1,r_1]} \sum_{j\in [l_2,r_2]} [i &lt; j \wedge a_i &gt; a_j]$ 。</p>
<p>考虑莫队算法，当右端点从$r-1$移动到$r$的时候，答案的改变量是</p>
<script type="math/tex; mode=display">
s(l,r-1,r,r) = s(1,r-1,r,r) - s(1,l-1,r,r)</script><p>第一项只与 $r$ 有关，可以预处理；第二项中， $[1,l-1]$ 是整个序列的一段前缀。我们把所有第二项的询问都离线下来，然后扫描线处理。注意到总共有 $O(n)$ 次修改以及 $O(n\sqrt n)$ 次询问，我们用修改 $O(\sqrt n)$ ，查询 $O(1)$ 的分块，即可在 $O(n\sqrt n)$ 的复杂度解决问题。</p>
<p>右端点的左移、左端点的移动都是同理。</p>
<p>总时间复杂度 $O(n\sqrt n)$ ，空间复杂度 $O(n)$ 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],b[N];</span><br><span class="line">ll sl[N],sr[N],qans[N];</span><br><span class="line"><span class="keyword">int</span> bel[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">	<span class="keyword">int</span> c[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) c[i]=<span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">I</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">for</span>(;i&lt;=m;i+=i&amp;-i) c[i]++; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="keyword">for</span>(;i;i-=i&amp;-i) ans+=c[i]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WRY</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,id;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpQ</span><span class="params">(WRY A,WRY B)</span> </span>&#123; <span class="keyword">return</span> bel[A.l]==bel[B.l]?(bel[A.l]&amp;<span class="number">1</span>?A.r&lt;B.r:A.r&gt;B.r):A.l&lt;B.l; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,id,ty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Qry&gt; Pl[N],Pr[N];</span><br><span class="line"><span class="keyword">namespace</span> sol2 &#123;</span><br><span class="line">	<span class="keyword">int</span> bel[N];</span><br><span class="line">	<span class="keyword">int</span> s1[M],s0[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">I</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=x;bel[i]==bel[x];++i) s0[i]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=bel[x];i&lt;=bel[m];++i) s1[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> s1[bel[x]<span class="number">-1</span>]+s0[x]; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> T=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(m));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) bel[i]=(i<span class="number">-1</span>)/T+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">			I(m-a[i]+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Pl[i].size();++j)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=Pl[i][j].l;x&lt;=Pl[i][j].r;++x)</span><br><span class="line">					qans[Pl[i][j].id]+=Pl[i][j].ty*Q(m-a[x]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) s0[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=bel[m];++i) s1[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) &#123;</span><br><span class="line">			I(a[i]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Pr[i].size();++j)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=Pr[i][j].l;x&lt;=Pr[i][j].r;++x)</span><br><span class="line">					qans[Pr[i][j].id]+=Pr[i][j].ty*Q(a[x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cid,L,R;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addR</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	qans[cid]+=t*sr[R];</span><br><span class="line"><span class="comment">//	Pl[L-1].PB(MP(R,-t*cid));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addL</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;	</span><br><span class="line">	qans[cid]+=t*sl[L];</span><br><span class="line"><span class="comment">//	Pr[R+1].PB(MP(L,-t*cid));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]),b[i]=a[i];</span><br><span class="line">	sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>),m=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=lower_bound(b+<span class="number">1</span>,b+m+<span class="number">1</span>,a[i])-b;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) sr[i]=BIT::Q(m-a[i]+<span class="number">1</span>),BIT::I(m-a[i]+<span class="number">1</span>); BIT::init();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) sl[i]=BIT::Q(a[i]),BIT::I(a[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> T=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) bel[i]=(i<span class="number">-1</span>)/T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> q; rd(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) rd(Q[i].l),rd(Q[i].r),Q[i].id=i;</span><br><span class="line">	sort(Q+<span class="number">1</span>,Q+q+<span class="number">1</span>,cmpQ);</span><br><span class="line">	L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) &#123;</span><br><span class="line">		cid=Q[i].id;</span><br><span class="line">		<span class="keyword">if</span>(R&lt;Q[i].r) Pl[L<span class="number">-1</span>].PB((Qry)&#123;R+<span class="number">1</span>,Q[i].r,cid,<span class="number">-1</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(R&gt;Q[i].r) Pl[L<span class="number">-1</span>].PB((Qry)&#123;Q[i].r+<span class="number">1</span>,R,cid,<span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">while</span>(R&lt;Q[i].r) R++,addR(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(R&gt;Q[i].r) addR(<span class="number">-1</span>),R--;</span><br><span class="line">		<span class="keyword">if</span>(L&gt;Q[i].l) Pr[R+<span class="number">1</span>].PB((Qry)&#123;Q[i].l,L<span class="number">-1</span>,cid,<span class="number">-1</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(L&lt;Q[i].l) Pr[R+<span class="number">1</span>].PB((Qry)&#123;L,Q[i].l<span class="number">-1</span>,cid,<span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">while</span>(L&gt;Q[i].l) --L,addL(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(L&lt;Q[i].l) addL(<span class="number">-1</span>),L++;</span><br><span class="line">	&#125;</span><br><span class="line">	sol2::main();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) qans[Q[i].id]+=qans[Q[i<span class="number">-1</span>].id];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,qans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>lemon配置捆绑测试</title>
    <url>/2020/02/27/lemon%E9%85%8D%E7%BD%AE%E6%8D%86%E7%BB%91%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>首先添加试题，然后选择“添加多组测试点”。</p>
<p><img src="https://i.loli.net/2020/02/27/RnLUOyA6zrCSgFE.jpg" alt="0.jpg"></p>
<p>在出现的测试点添加向导中，可以直接点击下一步。每个测试点（也就是每个子任务）的时间、空间限制以及分值都是可以在配置完成之后单独调整的。</p>
<p><img src="https://i.loli.net/2020/02/27/L4rGlw7BzxXKODt.jpg" alt="1.jpg"></p>
<p>在输入输出文件格式中，输入 <code>试题名称\文件名称格式</code> 。</p>
<p>其中，打了勾的正则表达式，表示这一项相同的会在同一个测试点（即子任务）中。</p>
<p>可以用 <code>\d*</code> 或者 <code>[0-9]*</code> 来匹配任意数量的数字。</p>
<p>例如，我的第 i 个子任务的第 j 组数据的文件名是 <code>i_j.in/ans</code>，就可以这样写：</p>
<p><img src="https://i.loli.net/2020/02/27/RUvsoZQY59OB1br.jpg" alt="2.jpg"></p>
<p>点击下一步之后，就可以预览配置的结果。如果有问题，则可以点击左上角的箭头返回上一步修改。</p>
<p><img src="https://i.loli.net/2020/02/27/7xGAfcTWSHm8KeX.jpg" alt="3.jpg"></p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ2498 Xavier is Learning to Count</title>
    <url>/2020/02/22/BZOJ2498-Xavier-is-Learning-to-Count/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>容易想到$O(Bell(P))$地枚举$P$的集合划分，然后进行容斥（强制同一个集合里的数取值相同），但是容斥系数应该如何取呢？</p>
<p>对于一个大小为$x$的集合，设它的容斥系数为$f_x$。一种集合划分的容斥系数为每个集合的容斥系数的乘积。</p>
<p>对于某一种选$P$个数的方案，假设其中第$a_{1,1},a_{1,2},\cdots a_{1,k_1}$个数相同，第$a_{2,1},a_{2,2},\cdots a_{2,k_2}$个数相同，……第$a_{m,1},a_{m,2},\cdots a_{m,k_m}$个数相同，那么这种方案将会被计算的次数是</p>
<script type="math/tex; mode=display">
\prod_{i=1}^m (\sum_{\{S_1,S_2\cdots S_l\}是\{a_{i,1},a_{i,2},\cdots a_{i,k_i}\}的集合划分} \prod_{j=1}^l f(|S_j|))</script><p>根据定义我们需要让这个式子在至少有一个$k_i &gt; 1$的时候为$0$，所有的$k_i$都为$1$的时候为$1$。</p>
<p>记</p>
<script type="math/tex; mode=display">
g(n) = \sum_{\{S_1,S_2\cdots S_l\}是\{1,2,\cdots n\}的集合划分} \prod_{j=1}^l f(|S_j|)</script><p>我们相当于是要让</p>
<script type="math/tex; mode=display">
g(n) = [ n = 1]</script><p>枚举$n$所属的集合的大小得</p>
<script type="math/tex; mode=display">
g(n) = \sum_{i=1}^n \binom{n-1}{i-1} g(n-i) f(i)</script><p>因为$\forall i&gt;1, g(i)=0$，所以</p>
<script type="math/tex; mode=display">
g(n) = (n-1) \cdot f(n-1) + f(n) =0</script><p>令$f(n) = -(n-1)f(n-1), f(1) = 1$，也就是$f(i) = (-1)^{i-1}(i-1)!$，即得到一组满足条件的容斥系数。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> db Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Comp</span> &#123;</span></span><br><span class="line">    db a,b;</span><br><span class="line">    Comp (db a=<span class="number">0</span>,db b=<span class="number">0</span>): a(a),b(b) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> *(Comp A,Comp B)&#123;<span class="keyword">return</span> Comp(A.a*B.a-A.b*B.b,A.a*B.b+A.b*B.a);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> +(Comp A,Comp B)&#123;<span class="keyword">return</span> Comp(A.a+B.a,A.b+B.b);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> -(Comp A,Comp B)&#123;<span class="keyword">return</span> Comp(A.a-B.a,A.b-B.b);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> /(Comp A,db B)&#123;<span class="keyword">return</span> Comp(A.a/B,A.b/B);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> *(Comp A,db B)&#123;<span class="keyword">return</span> Comp(A.a*B,A.b*B);&#125;</span><br><span class="line">    <span class="function">Comp <span class="title">conj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Comp(a,-b);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;l);++i) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;l<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Comp A[],<span class="keyword">int</span> len,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) <span class="keyword">if</span>(rev[i]&lt;i) swap(A[i],A[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Comp wn=Comp(<span class="built_in">cos</span>(<span class="number">2</span>*Pi/l),f*<span class="built_in">sin</span>(<span class="number">2</span>*Pi/l));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=l)</span><br><span class="line">        &#123;</span><br><span class="line">            Comp w=Comp(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;i+(l&gt;&gt;<span class="number">1</span>);++k,w=w*wn)</span><br><span class="line">            &#123;</span><br><span class="line">                Comp t1=A[k],t2=A[k+(l&gt;&gt;<span class="number">1</span>)]*w;</span><br><span class="line">                A[k]=t1+t2,A[k+(l&gt;&gt;<span class="number">1</span>)]=t1-t2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[i]=A[i]/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Comp A[<span class="number">6</span>][N],B[N];</span><br><span class="line">db frac[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,len;</span><br><span class="line"><span class="keyword">int</span> buc[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> mx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==m+<span class="number">1</span>) &#123;</span><br><span class="line">		db coe=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i) coe*=frac[buc[i]<span class="number">-1</span>]*(buc[i]&amp;<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j) &#123;</span><br><span class="line">			Comp t=Comp(coe,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i) t=t*A[buc[i]][j];</span><br><span class="line">			B[j]=B[j]+t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx+<span class="number">1</span>;++i)</span><br><span class="line">		buc[i]++,dfs(u+<span class="number">1</span>,max(i,mx)),buc[i]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	frac[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i) frac[i]=frac[i<span class="number">-1</span>]*i;</span><br><span class="line">	<span class="keyword">int</span> T,cas=<span class="number">0</span>; rd(T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> num; rd(num),rd(m);</span><br><span class="line">		n=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=num;++i) &#123;</span><br><span class="line">			rd(x);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) A[j][x*j].a+=<span class="number">1</span>;</span><br><span class="line">			n=max(n,x*m);</span><br><span class="line">		&#125;</span><br><span class="line">		len=<span class="number">1</span>; <span class="keyword">int</span> cnt=<span class="number">0</span>; <span class="keyword">while</span>(len&lt;=n) len&lt;&lt;=<span class="number">1</span>,cnt++; getr(cnt);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) FFT(A[j],len,<span class="number">1</span>);</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		FFT(B,len,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++cas);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) &#123;</span><br><span class="line">			db ans=B[i].a/frac[m];</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;<span class="number">0.5</span>) <span class="built_in">printf</span>(<span class="string">"%d: %.0Lf\n"</span>,i,ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[j][i].a=A[j][i].b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) B[i].a=B[i].b=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3840 【WF2011】Chips Challenge</title>
    <url>/2020/02/21/HDU3840-%E3%80%90WF2011%E3%80%91Chips-Challenge/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>2016年集训队论文的第二篇讲到了这道题，但是论文中的建图方式似乎会出现负环（也有可能是我写炸了？）。下面的建图方法是从KIDGIN7439的<a href="https://blog.csdn.net/KIDGIN7439/article/details/84637086" target="_blank" rel="noopener">这篇博客</a>中看到的，因为觉得原文的阐述十分不清楚，重新阐述如下。</p>
<p>首先枚举$lim$为每一行、每一列的部件数量的最大值。求出在$lim$限制下能个放的最大零件数$tot’$，只要判断$lim \le \lfloor tot’ \cdot \frac{A}{B} \rfloor$是否成立，就能限制为$lim$时是否存在合法的方案，并更新答案。</p>
<p>建图方法：</p>
<ol>
<li>对第$i$行建一个点$A_i$，对第$i$列建一个点$B_i$</li>
<li>从$S$向$A_i$连容量下界为$0$，上界为$lim$，费用为$0$的边</li>
<li>从$B_i$向$T$连容量下界为$0$，上界为$lim$，费用为$0$的边</li>
<li>从$A_i$向$B_i$连容量下界为$0$，上界为$\infty$，费用为$0$的边</li>
<li>如果$(i,j)$这个位置是<code>.</code>，就从$A_i$向$B_j$连一条容量下界为$0$，上界为$1$，费用为$1$的边</li>
<li>如果$(i,j)$这个位置是<code>C</code>，就从$A_i$向$B_j$连一条容量下界为$1$，上界为$1$，费用为$1$的边</li>
</ol>
<p>这张图的最大费用最大流 - <code>C</code>的个数就是答案。</p>
<p>考虑如何满足题目中的几个限制：</p>
<ul>
<li>一个观察是，$S$到$A_i$、$B_i$到$T$的边都会满流<ul>
<li>流量大小 = $S$到$A_i$的边的流量和 = $B_i$到$T$的流量和</li>
<li>存在方案使这些边都满流：只流第2，3，4类边，不流第5类边</li>
<li>我们求的是最大费用最大流</li>
</ul>
</li>
<li>第二观察是，从$A_i$流出的第5，6类边的流量，等于流入$B_i$的第5，6类边的流量，这样就满足了“第$i$行的零件数量等于第$i$列的零件数量<ul>
<li>从$A_i$流出的总流量 = 流入$B_i$的总流量 = $lim$</li>
<li>从$A_i$通过第4类边流出的流量 =通过第4类边流入$B_i$的流量</li>
<li>两式相减即得出上面的观察</li>
</ul>
</li>
<li>从第二个观察也可看出，每个$A_i$流出的第5，6类边的流量不超过$lim$，流入$B_i$的第5，6类边的流量不超过$lim$，也就满足了每行、每列的部件数量不超过$lim$的限制</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> S,T;</span><br><span class="line"><span class="keyword">namespace</span> Flow &#123;</span><br><span class="line">    <span class="keyword">int</span> head[N],cur[N],dis[N],vis[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ed</span> &#123;</span> <span class="keyword">int</span> to,next,f,w; &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ed&gt; e;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e.PB((ed)&#123;y,head[x],f,w&#125;); head[x]=e.size()<span class="number">-1</span>;</span><br><span class="line">        e.PB((ed)&#123;x,head[y],<span class="number">0</span>,-w&#125;); head[y]=e.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="built_in">memcpy</span>(cur,head,<span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(S),vis[S]=<span class="number">1</span>,dis[S]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.front(); q.pop(),vis[u]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=head[u];~k;k=e[k].next) <span class="keyword">if</span>(e[k].f) &#123;</span><br><span class="line">                <span class="keyword">int</span> v=e[k].to;</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&lt;dis[u]+e[k].w) &#123;</span><br><span class="line">                    dis[v]=dis[u]+e[k].w;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[v]) vis[v]=<span class="number">1</span>,q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T]&gt;<span class="number">-1e9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==T||!f) <span class="keyword">return</span> f; <span class="keyword">int</span> ret=<span class="number">0</span>,tmp;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;k=cur[u];~k;k=e[k].next) <span class="keyword">if</span>(e[k].f) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[k].to;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]&amp;&amp;dis[v]==dis[u]+e[k].w&amp;&amp;(tmp=dfs(v,min(f,e[k].f)))) &#123;</span><br><span class="line">                e[k].f-=tmp,e[k^<span class="number">1</span>].f+=tmp;</span><br><span class="line">                ret+=tmp,f-=tmp;</span><br><span class="line">                <span class="keyword">if</span>(!f) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="keyword">while</span>(bfs()) ans+=dis[T]*dfs(S,<span class="number">1e9</span>); <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,A,B;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ts=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;A,&amp;B)) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!n&amp;&amp;!A&amp;&amp;!B) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">		S=<span class="number">2</span>*n+<span class="number">1</span>,T=<span class="number">2</span>*n+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> M=n*n*n+<span class="number">10</span>; <span class="comment">// shoule be larger than length of any possible path</span></span><br><span class="line">		<span class="keyword">int</span> mx=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> lim=n;lim&gt;=<span class="number">0</span>;--lim) &#123;</span><br><span class="line">			Flow::init();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">				Flow::ad(S,i,lim,<span class="number">0</span>),</span><br><span class="line">				Flow::ad(i,i+n,<span class="number">1e9</span>,<span class="number">0</span>),</span><br><span class="line">				Flow::ad(i+n,T,lim,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) &#123;</span><br><span class="line">					<span class="keyword">if</span>(mp[i][j]==<span class="string">'.'</span>) Flow::ad(i,j+n,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">					<span class="keyword">if</span>(mp[i][j]==<span class="string">'C'</span>) Flow::ad(i,j+n,<span class="number">1</span>,M+<span class="number">1</span>),tot++;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">int</span> ans=Flow::work();</span><br><span class="line">			<span class="keyword">if</span>(ans&lt;tot*(M+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">			ans%=M;</span><br><span class="line">			<span class="keyword">if</span>(ans*A&lt;lim*B) <span class="keyword">continue</span>;</span><br><span class="line">			mx=max(mx,ans-tot);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++ts);</span><br><span class="line">		<span class="keyword">if</span>(mx&lt;=<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>PKUWC2020</title>
    <url>/2020/02/20/PKUWC2020/</url>
    <content><![CDATA[<h1 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h1><h2 id="A-排列"><a href="#A-排列" class="headerlink" title="A - 排列"></a>A - 排列</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个$\{1,2,\cdots n\}$的排列$P$。按照字典序从小到大的顺序，依次连接所有字典序不大于$P$的$\{1,2,\cdots n\}$的排列（例如$[2,1,3]$得到的是$[1,2,3,1,3,2,2,1,3]$）。</p>
<p>求得到的序列的本质不同的子序列的数量。$n\le 50$，答案对$998244353$取模。</p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>我们设$A_S[i][j]$表示满足下列条件的子序列$t$的个数：</p>
<ol>
<li>$t$的开头是字符$i$，结尾是字符$j$</li>
<li>$t$不是$S$的子序列</li>
<li>$t$删掉最后一个字符之后是$S$的子序列</li>
</ol>
<p>用$S+T$表示将$T$拼在$S$的后面得到的字符串，则$A_{S+T}[i][j] = \sum_k A_S[i][k] \times A_T[k][j]$。</p>
<p>令$P_i$表示最小的$i!$个排列首尾相接得到的序列。$A_{P_1}$可以直接求得。</p>
<p>考虑如何求得$A_{P_i}$求得$A_{P_{i+1}}$，发现$P_{i+1}$的可以分成$i+1$段，每一段的长度为$i!$，并且每一段与$P_i$的构成是相同的，所以每一段的$A$可以通过$A_{P_i}$交换一些行列得到。</p>
<p>预处理出所有的$A_{P_i}$之后，原序列可以被拆分成若干个极长的段，满足每一段是将末$i$个数进行全排列，将得到的排列按照字典序从小到大拼起来得到的。而这一段的$A$一定能通过$A_{P_i}$交换一些行列得到。</p>
<h2 id="B-火山哥与集合"><a href="#B-火山哥与集合" class="headerlink" title="B - 火山哥与集合"></a>B - 火山哥与集合</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>初始有$n$个集合，第$i$个集合只包含$1$个元素$a_i$。</p>
<p>每一次操作会随机选择两个集合合并。</p>
<p>定义一个集合的价值为这个集合中最大值与最小值的差的平方。定义$f(k)$为进行$n-k$次操作后，所有集合的价值的和的期望。</p>
<p>给出$l,r$，求$\sum_{k\in [l,r]} f(k)^{97376} \pmod {998244353}$</p>
<p>$n\le 2\times 10^5,1\le l\le r\le n,a_i &lt; 998244353$</p>
<h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>设$g(t,k)$表示若最终合并为$k$个集合，某个大小为$t$的集合出现的概率。设$h(i)$表示所有大小为$i$的集合的$( \max - \min )^2$的和。则$f(k)=\sum_{i=1}^n h(i) \cdot g(i,k)$。</p>
<p>将$a$从小到大排序后，可以得到$h(i) = \sum_{l\le r} (a_r-a_l)^2 \cdot {r-l-1\choose i-2}$。先对于每一个$t$算出$\sum_{t=r-l} (a_r-a_l)^2$，然后再算$h(i)$。这两步都可以用NTT做到$O(n\log n)$。</p>
<p>将$n$个集合恰好合并成$k$个的方案数是$\prod_{i=k+1}^n {i\choose 2}$（即第$i$次合并的时候，共有$n-i+1$个集合，所以合并的方案数是$n-i+1\choose 2$）。令$D(n)=\prod_{i=2}^n {i\choose 2}$。</p>
<p>则$g(i,k) = {n-k\choose i-1} \cdot D(i) \cdot {D(n-i)\over D(k-1)} \over {D(n)\over D(k)} = {n-k\choose i-1} \cdot  {k\choose 2} \cdot D(i) \cdot D(n-i) \cdot{1\over D(n)}$</p>
<p>则$f(k) = \sum_i h(i)g(i,k)<br>={k\choose 2} \cdot {1\over D(n)}\sum_i h(i)D(i)D(n-i)\cdot  {n-k\choose i-1}$</p>
<p>这是个卷积的形式，可以NTT优化。</p>
<h2 id="C-数论结构"><a href="#C-数论结构" class="headerlink" title="C - 数论结构"></a>C - 数论结构</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一个$n\times m$的矩阵，初始所有位置的数为$0$。先进行$q_1$次修改操作，给出参数$s,l,r,x$，表示给所有满足$\gcd(s,a)=1,b\in [l,r]$的格子$(a,b)$加上$x$。然后进行$q_2$次询问操作，每次给出$(s,l,r)$，你需要回答所有满足$\gcd(s,a)=1,b\in[l,r]$的格子$(a,b)$的和。</p>
<p>保证修改和询问的$s$随机生成。</p>
<p>$n,q_1\le 50000, m,q_2\le 200000,1\le l\le r\le m, 1\le s\le n$</p>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><p>考虑所有修改$(s_i,l_i,r_i,x_i)$对询问$(s,l,r)$的贡献。</p>
<p>设$Q_d$为所有满足$d\mid s_i$的$i$构成的集合。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{q_1} card( [ l_i,r_i]\cap [l,r]) x_i \cdot \sum_{j=1}^n [(s_i,j)=1 ] [(s,j)=1] \\
=\sum_{i=1}^{q_1} card( [ l_i,r_i]\cap [l,r]) x_i \cdot \sum_{j=1}^n ( \sum_{d_1\mid (s_i,j)}\mu (d_1) \sum_{d_2\mid (s,j)} \mu(d_2))\\
=\sum_{d_2\mid s} \mu(d_2) \sum_{d_1=1}^{n} \mu(d_1) \lfloor { n\over lcm(d_1,d_2)} \rfloor \cdot \sum_{i\in Q_{d_1}} card( [ l_i,r_i]\cap [l,r]) x_i
\end{aligned}</script><p>考虑枚举$d_1,d_2$的最大公约数$D$，令$t_1 = {d_1 \over D}, t_2 = {d_2 \over D}$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
原式 = \sum_{D\mid s} \sum_{t_2 \mid {s\over D}} \mu(t_2D) \sum_{t_1=1}^{\lfloor {n\over D} \rfloor}\mu(t_1D) \lfloor {n\over t_1t_2D} \rfloor [(t_1,t_2)=1] \sum_{i\in Q_{t_1D}} card( [ l_i,r_i]\cap [l,r]) x_i\\
= \sum_{D\mid s} \sum_{t_2 \mid {s\over D}} \mu(t_2D) \sum_{t_1=1}^{\lfloor {n\over D} \rfloor}\mu(t_1D) \lfloor {n\over t_1t_2D} \rfloor \sum_{d\mid (t_1,t_2)} \mu(d)\sum_{i\in Q_{t_1D}} card( [ l_i,r_i]\cap [l,r]) x_i\\
\end{aligned}</script><p>令$T=D\cdot d, u_1 = {t_1\over d} = {d_1 \over T},u_2 = {t_2\over d} = {d_2\over T}$，得到</p>
<script type="math/tex; mode=display">
原式 = \sum_{T\mid s} \sum_{d\mid T} \mu(d) \sum_{u_2 \mid {s\over T}} \mu(u_2T) \sum_{u_1=1}^{\lfloor {n\over T}\rfloor} \mu(u_1T) \lfloor {n\over u_1u_2dT}\rfloor \sum_{i\in Q_{u_1T}} card( [ l_i,r_i]\cap [l,r]) x_i</script><p>在最外层枚举$T$，然后考虑所有的$Q_T$对$A_T$（表示所有$T\mid s_i$的询问）的贡献。</p>
<p>维护一个二维的矩阵。对于每个修改，枚举所有$d\mid T, u_1\in [1,\lfloor {n\over T}\rfloor ]$，然后对于每一个$i \in Q_{u_1T}$把第$\lfloor {n\over u_1dT}\rfloor$行的区间$[l_i,r_i]$加上$x_i \cdot \mu(u_1T) \cdot \mu(d)$。对于每一个询问，枚举所有的$u_2$，然后枚举$t$，则所有满足$\lfloor {j\over u_2} \rfloor = t$的$j$形成一个连续的区间，查这个区间的所有行的$[l_i,r_i]$的元素的和，乘上$t$加入答案中。</p>
<p>修改的复杂度：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{T=1}^n \sum_{d\mid T} \sum_{u_1=1}^{\lfloor {n\over T}\rfloor} |Q_{u_1T}|\\
= \sum_{T=1}^n \sum_{d\mid T} \sum_{u_1=1}^{\lfloor {n\over T}\rfloor} {q_1\over u_1T}
\end{aligned}</script><p>因为$n,q_1$同级，用$n$换掉$q_1$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
原式= \sum_{T=1}^n \sum_{d\mid T} {n\over T} \log {n\over T}    \\
\le \sum_{T=1}^n \sum_{d\mid T} {n\over T} \log n    \\
=\sum_{d=1}^n \sum_{T'=1}^{\lfloor {n\over d}\rfloor} {n\over dT'} \log n \\
=\sum_{d=1}^n {n\over d} \log {n\over d} \log n \\
\le \sum_{d=1}^n {n\over d} \log^2 n \\
= n\log^3 n
\end{aligned}</script><p>处理前缀和的复杂度是矩阵的大小。矩阵的行数是$O(\sqrt {n\over T})$的，尽管矩阵的列数是$n$，但是其中只有$|Q_T|+|A_T|$列有用，所以复杂度是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{T=1}^n \sqrt {n\over T} \cdot {q_1+q_2\over T}\\
{\sqrt n (q_1+q_2) }\sum_{T=1}^n {1\over T^{1.5}}
\end{aligned}</script><p>后面部分</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{T=1}^{n} {1\over T^{1.5}} \\
\int_{1}^n T^{-1.5} dT \\
= - {1\over 0.5} n^{-0.5} + {1\over 0.5}1^{-0.5} + C\\
= n^{-0.5} \cdot 0 + C \\
= O(1)
\end{aligned}</script><p>所以这一步的复杂度是$O((q_1+q_2)\sqrt n)$。</p>
<p>离散化那$|Q_T|+|A_T|$列的复杂度是$\sum_{T=1}^n ( |Q_T|+|A_T| )\log n = O(q_2\log ^2 n)$。</p>
<p>询问的复杂度：对于某一个$u_2$，我们会枚举到的$t$一定有$\lfloor {n\over u_1u_2dT} \rfloor = \lfloor { \lfloor {n\over u_2T}\rfloor \over x} \rfloor$的形式，所以，这样的$t$只有$O(\sqrt {n\over u_2T})$个。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{T=1}^n \sum_{j\in A_{T}} \sum_{u_2 \mid {s_j\over T}} \sqrt {n\over u_2T} \\
= \sqrt n\sum_{u_2=1}^n \sqrt { 1 \over u_2 }  \sum_{T=1}^{n\over u_2 } \sqrt{1\over T} |A_{u_2T}| \\
= \sqrt n \sum_{u_2=1}^n \sqrt { 1 \over u_2}  \sum_{T=1}^{n\over u_2 } \sqrt{1\over T} {q_2\over u_2T}\\ 
= \sqrt nq_2 \sum_{u_1=1}^n u_2^{-1.5}\sum_{T=1}^{n\over u_2} T^{-1.5} \\
= O(\sqrt nq_2)
\end{aligned}</script><p>总时间复杂度$O(n\log^3 n +q_2\sqrt n)$。</p>
<h1 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h1><h2 id="A-火山哥的打铁传说"><a href="#A-火山哥的打铁传说" class="headerlink" title="A - 火山哥的打铁传说"></a>A - 火山哥的打铁传说</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>进攻方有两种鱼：小鱼和剧毒鱼。防御方有两种鱼，圣盾鱼和大鱼。每一回合，进攻方会选择自己的一条鱼，然后让它与防御方的某一条鱼战斗。战斗遵循如下规则：</p>
<ol>
<li>如果圣盾鱼与任意一种鱼战斗，它会变成一条大鱼。</li>
<li>如果大鱼和剧毒鱼战斗，它会消失。如果大鱼和小鱼战斗，大鱼不会消失。</li>
</ol>
<p>现在你知道了进攻方前$n$个回合会选择自己的哪种鱼。有$q$次询问，每次询问给出$X$,$K$，你需要回答，如果防御方有$X$条大鱼，进攻方进行前$K$个回合，防御方最多能有多少条圣盾鱼，使得进攻方可以让防御方所有的鱼都消失。</p>
<p>$n,q\le 4\times 10^5$</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数$n,q$。</p>
<p>第二行一个长度为$n$的字符串$s$，$s_i$为<code>1</code>表示第$i$个回合进攻方出剧毒鱼，$s_i$为<code>0</code>则表示第$i$个回合进攻方出小鱼。</p>
<p>接下来$q$行，每行两个整数$X,K(1\le K\le n)$，表示第$i$次询问。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问，输出一行一个整数表示答案。如果圣盾鱼个数为$0$的时候进攻方仍不能消灭所有的鱼，输出$-1$。</p>
<h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol"></a>Sol</h3><p>问题等价于：我方先出$X$条小鱼，然后再进行前$K$个回合，最多能消灭掉多少条对方的圣盾鱼。假设答案为$y$，若$y&lt; x$输出$-1$，否则输出$y-x$。</p>
<p>转化成求出尽可能多的小鱼和剧毒鱼的匹配（要求小鱼在前面），答案就是这个匹配数加上剩下的剧毒鱼的数量的一半下取整。</p>
<p>如果只有一次询问，可以直接贪心：从前往后考虑，用一个变量记录下前面的还没有匹配过的小鱼，遇到剧毒鱼的时候如果前面没有匹配的小鱼数量不为$0$就让它匹配。</p>
<p>从前往后贪心和从后往前贪心得到的结果显然是一样的。先从前往后贪心，求出每一个前缀能够得到的最大的匹配数。询问的时候增加的$X$条小鱼所能够增加的匹配数，是前$K$个回合中还没有匹配的剧毒鱼数量和$X$的较小值。</p>
<p>时间复杂度$O(n+q)$。</p>
<h2 id="B-火山哥的分式"><a href="#B-火山哥的分式" class="headerlink" title="B - 火山哥的分式"></a>B - 火山哥的分式</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>定义如下的表示一个分式的方式：给出一个长度为$l+1$的序列和长度为$l$的排列，排列中的第$i$个数代表了从上往下第$i$条分数线的长度，序列中的第$i$个元素代表了分式从上往下的第$i$个元素。例如，序列$\{ a,b,c\}$和排列$\{2,1\}$所对应的分式是：</p>
<script type="math/tex; mode=display">
{a\over {b\over c}}</script><p>越短的分数线，运算的优先级越高。</p>
<p>现在有一个长度为$n+1$的序列$a$和长度为$n$的$\{1,2,\cdots n\}$的排列。有$q$次询问，每次询问给出$l,r$，你需要求出$a[l-1\cdots r]$和$p[l\cdots r]$对应的分式的值对$998244353$取模的结果。</p>
<p>$n,q\le 5\times 10^5, 0&lt; a_i &lt; 998244353$</p>
<h3 id="Sol-4"><a href="#Sol-4" class="headerlink" title="Sol"></a>Sol</h3><p>单独考虑每一个元素对答案的贡献，这个贡献要么是它本身，要么是它的逆元；找出这个元素左边第一条分数线，然后找出这条分数线的左边第一条比它长的分数线，然后找左边第一条比它长的分数线……直到找到的分数线位置超出了区间，这期间找到过的分数线的个数如果是奇数那么这个数的贡献就是它的逆元，否则就是它本身。</p>
<p>将询问离线下来，然后从左到右扫描整个序列，并用单调栈维护已经扫过的元素（栈顶是最后加入的分数线，栈中的每一个元素的下面是它左边的第一个比它长的分数线）。扫到$r$的时候，我们分两部分求$l$的答案：一部分是仍然在栈中的元素的贡献，对于下标在$l$之后且在栈中的元素，分别查出下标为奇数和偶数的所有元素的乘积就可以得到答案；一部分是已经出栈了的元素的贡献，我们在元素出栈的时候维护。把出栈的元素的贡献分为两部分：一部分是$l$小于出栈后的栈顶的，直接让出栈后的栈顶的权值乘等于当前的栈顶的权值的逆元就可以了；另一部分是$l$在出栈后的栈顶和当前的栈顶之间的，这些$l$形成连续的一段区间且当前出栈的元素对它们的贡献是相同的，用线段树维护即可。</p>
<p>时间复杂度$O((n+q)\log n)$。</p>
<h2 id="C-最小割"><a href="#C-最小割" class="headerlink" title="C - 最小割"></a>C - 最小割</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>对于一张边带权的无向图，定义$s$与$t$的最小割$f(s,t)$：求一个边集$E$使得删去$E$中的边之后$s,t$不连通且$E$中的边的边权和最小，$E$的边权和即为$f(s,t)$。</p>
<p>现在给出了一张$n$个点$m$条边的图，其中第$i$条边连接$x_i$和$y_i$，边权为$w_i(w_i\le 10^4)$。然后可怜又往图中加了$n$条边，第$i$条边连接$i$和$i\pmod n + 1$，每条边的边权都是$10^9$。</p>
<p>可怜希望你求出$\sum_{s=1}^{n-1} \sum_{t=s+1}^n f(s,t) \pmod {998244353}$。</p>
<p>$n\le 7000,m\le 10^5$</p>
<h3 id="Sol-5"><a href="#Sol-5" class="headerlink" title="Sol"></a>Sol</h3><p>由于所有边的权值和最多为$10^9$，所以边权为$10^9$的边肯定恰好被割两条，把原图划分成两条链，然后将链之间的边割掉。</p>
<p>利用二维前缀和可以在$O(n^2)$的时间内求出选择割某两条边，其它需要割掉的边的权值和。</p>
<p>对于$s,t$，我们要求割的一条边在$s,s+1,\cdots ,t-1,t$之间，另一条不在这些点之间。</p>
<p>可能的方案形成了这样的区域（横坐标代表一条边的位置，纵坐标代表另一条边的位置）：</p>
<p><img src="https://i.loli.net/2019/12/26/xcyDwWG9QmMBaVT.png" alt=""></p>
<p>第一种：求出每一列的后缀最小，然后对于第$s$行，求出从第$s$列开始的前缀最小。</p>
<p>第二种：求出每一行的后缀最小，然后对于第$t$列，求出从第$t$行开始的前缀最小。</p>
<p>总时间复杂度$O(n^2 + m)$。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>IOI2020北大集训</title>
    <url>/2020/02/20/IOI2020%E5%8C%97%E5%A4%A7%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="A-递增树列"><a href="#A-递增树列" class="headerlink" title="A - 递增树列"></a>A - 递增树列</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一棵有根树，定义$dis(i)$为$i$点到根经过的边数。求有多少个排列$p$，满足$\forall i \in [1,n-1), dis(lca(p_i,p_{i+1}))\le dis(lca(p_{i+1},p_{i+2}))$。</p>
<p>答案对$10^9+7$取模。$n\le 80$。</p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>一个观察：从前往后考虑这个排列，一旦出现了相邻两个点的lca不为根，那么此后的点都在根的同一个子树内。而前面的相邻两个点的lca都为根等价于相邻两个点来自根的不同子树。对不是根的点考虑仅由它的子树内的点构成的排列时也有类似的结论。</p>
<p>设$g_{u,j}$表示以$u$为根，用了$u$子树内的$j$个点去构成一个合法的排列的方案数。则最后的答案是$g_{1,n}$。</p>
<p>如果排列中始终没有出现两个相邻的点lca的深度大于$u$，则可以直接用容斥原理计算。对$u$的每一个儿子枚举这个儿子的子树内选了多少个点，以及这些点中有多少对在最终排列里相邻了，并对（选了的点数）和（在同一个儿子的子树内且在排列中相邻的点对数）做背包。</p>
<p>如果存在相邻点lca深度大于$u$，假设其所属的儿子是$v’$，我们最后得到的排列只需满足：在lca均在$v’$之内的那一段（即$g_{v’,x}$所代表的）之前，最后一个点不属于$v’$的子树。这个仍然可以用类似于上一种情况的方法进行容斥，使得在$v’$子树内的点位于$g_{v’,x}$的那段之前的方案被减掉。在背包中再加入一维$0/1$，表示是否已经算过$v’$的贡献就可以处理这种情况。</p>
<p>时间复杂度$O(n^4)$。<del>我n^5过了</del></p>
<h2 id="B-Article"><a href="#B-Article" class="headerlink" title="B - Article"></a>B - Article</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>定义$w(s_1,s_2)$表示$s_1,s_2$的本质不同的公共子串的数量。</p>
<p>定义一个字符串$t$的权值为$\sum_{i=1}^{|t|-1} w^2(s[1\cdots i],s[i+1\cdots |t|])$。</p>
<p>给出一个字符串$s$和正整数$k$，问将$s$划分成恰好$k$段，权值最大的那段的权值最小可以是多少。</p>
<p>$|S|\le 50000$，保证答案不超过$10^{18}$。</p>
<h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>考虑如何在$O(|t|)$的时间内算出$t$的权值：对$t$建SAM，对于每个节点处理出它的出现位置的最小值和最大值；SAM上的每个节点对$i=1$到$|t|-1$时的$w$的贡献，会是一个形如$maxlen,maxlen,\cdots maxlen,maxlen-1,maxlen-2\cdots $的数列，用二次差分就可以处理。求出每个$w$之后再平方、求和即可。</p>
<p>首先二分答案，将问题转化成：要求每段的权值小于等于某值，问能否划分成至多$k$段。由于这个题的权值满足单调性（即一个串的权值一定不小于它的任何一个子串），所以可以直接贪心，让划分的位置尽可能靠后就可以了。</p>
<p>利用倍增找下一个划分点：先检查长度$2^0,2^1,\cdots$直到长度为$2^k$的串的权值大于了限制，然后再依次枚举$2^{k-1},2^{k-2}\cdots$进行倍增。假设这一次划分的段的长度的$L$，由于每一次倍增时需要计算权值的串长度大于等于$2^{k-1}$而小于$2^k$，所以找出这个划分点的复杂度是$\Theta(L\log L)$的。</p>
<p>总复杂度$O(|S|\log |S|\log Ans)$。</p>
<h2 id="C-Travel"><a href="#C-Travel" class="headerlink" title="C - Travel"></a>C - Travel</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有$n$个可重集合$S_1,S_2\cdots S_n$，你可以从每个可重集合中选出一个元素，然后用这$n$个元素构成$k$个环，要求每个环的长度都是奇数。</p>
<p>定义一个环的价值为，相邻两个元素的差的绝对值的最小值。特别地，一个只包含一个元素的环的价值是正无穷。</p>
<p>你需要最大化所有环的价值的最小值，并输出最大化的结果。</p>
<p>$n\le 300,|S_i|\le 5,k&lt; n$。</p>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><h4 id="Lemma-1"><a href="#Lemma-1" class="headerlink" title="Lemma 1"></a>Lemma 1</h4><p>对于确定的$n$个已经从小到大排好序的元素$a_1,a_2,a_3\cdots a_n$，令$m={n-1\over 2}$，则它们构成的环的价值最大值是$\min \{ a_{i+m}-a_i \}$。</p>
<p>证明：考虑$\{a_i,a_{i+1},\cdots a_{i+m}\}$这个集合内有$m+1$个元素，集合外有$m$个元素，所以集合中必然存在一对在环中相邻的元素，所以这是答案的下界。而达到这个下界的解可以这样构造：</p>
<p><img src="https://i.loli.net/2019/12/17/dgliqKfZzND7ROt.png" alt=""></p>
<h4 id="Lemma-2"><a href="#Lemma-2" class="headerlink" title="Lemma 2"></a>Lemma 2</h4><p>最终的答案是由$k-1$个孤立的点和一个长度为$n-k+1$的环构成的。</p>
<p>证明：考虑现在有两个长度大于$1$的环$\{a_1,a_2\cdots a_m\}$和$\{b_1,b_2\cdots b_n\}$（$a_i,b_i$随下标递增），只要证明将它们变成一个孤立点和一个环答案不会变劣就可以了。</p>
<p>如果某个环使用的不是上面的图片中的构造方法，将其改为图片中的构造方法不会变劣。所以下面均认为环是按照上面图片的方式构造的。</p>
<p>从$a$中取出一个孤立点$a_{m+1\over 2}$，得到一条一端为$a_1$，另一端为$a_m$的链。</p>
<p>断开$b$中的边$(b_1,b_{n+1\over 2})$或者边$(b_{n+1\over 2},b_n)$。</p>
<p>考虑如何将两条链拼起来。假设第一条链是的端点分别为$a,b(a&lt; b)$，第二条链的端点为$c,d(c&lt; d)$。若$[a,b]$与$[c,d]$没有交或者包含，则很容易构造使得拼接用的边的权值都大于等于$\min\{b-a,d-c\}$。否则一定有$b_1&lt; a_1 \le b_{n+1\over 2} \le a_m &lt; b_n$，此时若$b_{n+1\over 2}\ge a_{m+1\over 2}$，就连$(b_{n+1\over 2},a_1)$和$(a_m,b_1)$，否则就连$(b_{n+1\over 2},a_m)$和$(b_n,a_1)$。这样构造之后答案都不会变劣。</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>首先二分答案$w$，然后判断能否求出长度为$n-k+1$的哈密顿回路。</p>
<p>令$N=n-k+1$，存在长度为$N$的哈密顿回路等价于存在$N-3\over 2$对匹配和一个三元匹配。</p>
<p>其中$i,j$这两个集合可以匹配，当且仅当$\exists a\in S_i,b\in S_j, |a-b| \ge w$。</p>
<p>其中$i,j,k$这三个集合可以构成三元匹配，当且仅当$\forall x\in S_i,y\in S_j,z\in S_k, \min\{|x-y|,|y-z|,|z-x|\}\ge w$。</p>
<p>必要性：可以把环画成之前的图中的形式，图中红色的边为匹配边。</p>
<p>充分性：显然一个集合只会属于一个匹配。对于每个集合拿出一个它参与了匹配条件判定的那个元素，将所有集合按照它拿出的那个元素的大小排好序。如果它们的匹配边的连法不是之前的图中的那样，则可以进行等价的调整。然后用与前面构造相同的方法就可以构造出解。</p>
<p>最后是怎么求这个匹配。枚举三元匹配中元素的值为中位数的那个集合并枚举它选的元素，然后将这个集合拆成两个点，一个只能连比它小的点，另一个只能连比它大的点，然后跑一般图的最大匹配就可以了（说得就跟我会似的。。。。</p>
<hr>
<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="A-循环数列"><a href="#A-循环数列" class="headerlink" title="A - 循环数列"></a>A - 循环数列</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有一个无限长的下标从$1$开始的序列，初始的时候所有在模$n$意义下等于$m$的位置的数为$1$，其余位置的数为$0$。</p>
<p>每一次操作会使得操作后的序列$F’_i=F_i+F_{i+1}$。</p>
<p>现在给出$n,m,k,pos,P$。你需要求出$k$次操作之后，$F_{pos}\pmod P$的值。</p>
<p>数据组数$T\le 500$，$k\le 10^9, P\le 10^7, \sum n\le 10^6, 1\le m&lt; n, 1\le pos&lt; n$，数据保证$P$为质数且$n\mid p-1$。</p>
<h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol"></a>Sol</h3><p>假设某个初始序列中的$1$的下标为$x$，那么它将对$F_{pos}$产生的贡献等价于：每一次可以让$x$不变或减一，操作$k$次后恰好$x=pos$的方案数。也就是${k \choose x-pos}$。</p>
<p>故而答案为</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{\infty} {k\choose i\cdot n+m-pos }</script><p>令$t=m-pos$，进行单位根反演：</p>
<script type="math/tex; mode=display">
\begin{aligned}
Ans=\sum_{i=0}^{\infty} {k\choose i\cdot n+t}\\
=\sum_{i=0}^{\infty}{k\choose i} [n\mid (i-t)]\\
=\sum_{i=0}^{\infty}{k\choose i} {1\over n} \sum_{j=0}^{n-1} \omega_n^{j(i-t)}\\
={1\over n}\sum_{j=0}^{n-1} \omega_n^{-jt} \sum_{i=0}^{\infty}{k\choose i}\omega_n^{ij}\\
={1\over n}\sum_{j=0}^{n-1} \omega_n^{-jt} (1+\omega_n^j)^k
\end{aligned}</script><p>暴力枚举$j$计算，复杂度$O(n\log k)$。</p>
<h2 id="B-Matrix"><a href="#B-Matrix" class="headerlink" title="B - Matrix"></a>B - Matrix</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出一个$n\times n$的整数矩阵$A$。</p>
<p>问能否求出一组置换矩阵$\{B_1,B_2\cdots B_m\}$，使得<strong>唯一</strong>存在一组非负整系数$\alpha_1,\alpha_2\cdots \alpha_m$，满足$A=\alpha_1\cdot B_1 + \alpha_2\cdot B_2+\cdots +\alpha_m\cdot B_m$。</p>
<p>求出一组$m\le n^2$的解或判定无解。</p>
<p>$n\le 50,T\le 10,A_{i,j}\le 2\times 10^7$</p>
<h3 id="Sol-4"><a href="#Sol-4" class="headerlink" title="Sol"></a>Sol</h3><p>参考Birkhoff–von Neumann theorem。</p>
<p>一个$A$能够被表示出来的充分必要条件是$A$中的每一行元素的和、每一列元素的和都相同。</p>
<p>充分性证明：设$C$为某一行的所有元素的和。构造一个二分图，左侧有$n$个点表示每一行，右侧有$n$个点表示每一列。$(i,j)$这条边存在当且仅当$A_{i,j}&gt;0$。用Hall定理证明这张图存在完备匹配：任选一个左边的点构成的集合$X$，考虑与他们相邻的列集合$Y$，由于$|X|\cdot C = \sum_{x\in X,y\in Y} A_{x,y} \le |Y|\cdot C$，所以有$|X|\le |Y|$，证毕。所以这张二分图一定存在完备匹配，将完备匹配对应的置换矩阵从$A$中减掉（$\alpha$取匹配中的最小边权），就转化成了规模更小的问题。</p>
<p>上述的证明过程也描述了算法的过程。显然这样最多会用$n\times n$个置换矩阵。由于每一次都会让一个位置变成$0$，所以这一步拿出来的置换矩阵与之后拿出来的置换矩阵必然线性无关。</p>
<h2 id="C-杀蚂蚁简单版"><a href="#C-杀蚂蚁简单版" class="headerlink" title="C - 杀蚂蚁简单版"></a>C - 杀蚂蚁简单版</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>有一棵包含$n$个节点的树，每个点有一个权值$v_i$。有一只蚂蚁，如果它当前在的节点为$x$，与它相邻的点集为$\{y_1,y_2\cdots y_m\}$，则它下一秒将以${v_{y_i}\over \sum v_{y_j}}$的概率走到$y_i$这个点。蚂蚁一旦走到$1$节点就会消失。</p>
<p>有$q$次询问，每次询问给出$s,x,y$，你需要回答：如果蚂蚁的初始位置是在$s$，它期望有多少秒停留在$x$到$y$的最短路径上。</p>
<p>$n,q\le 10^5$，答案对$998244353$取模。</p>
<h3 id="Sol-5"><a href="#Sol-5" class="headerlink" title="Sol"></a>Sol</h3><p>设$P_{x,y}$表示从$x$走到$y$的概率。</p>
<p>下面考虑部分分$v=u+1,s=2$的情况怎么做。设$f_i$表示$i$期望被经过多少次，那么显然有$f_2=P_{2,3}\cdot f_2+1={1\over 1-P_{2,3}}$，$f_3 = P_{2,3}f_2 + P_{4,3}\cdot f_4 $，由于出发点是$2$，终点是$1$，所以必然有$f_4P_{4,3} = f_3P_{3,4}$，所以$f_3={1\over 1-P_{3,4}}P_{2,3}f_2$。后面的可以类似的方法推导。概括一下就是，设$g_i = {1\over 1-P_{i,i+1}},h_i=P_{i-1,i}$，则$f_2 = g_2, f_i = h_ig_if_{i-1}(i&gt;2)$。</p>
<p>考虑$v=u+1,s\not = 2$的情况：此时的答案等价于蚂蚁第一次走到$s-1$之前经过每个点的次数的期望 加上 以$s-1$作为出发点的时候的答案。如果限制了不能够经过$s-1$这个点，等价于让$s-1$做根，故而此时$f_s = g_s, f_i = h_ig_if_{i-1}(i&gt;s)$。所以这种情况的答案为$\sum_{i\in [x,y]} \sum_{j=2}^s g_j\prod_{k=j+1}^i h_ig_i$。考虑如何快速计算答案：令$F_i$表示当以$2$作为起点的时候期望经过$i$的次数，那么$F_i$对答案的贡献相当于$F_i(1 + {1\over g_2h_3}+{1\over g_2g_3h_3h_4}+\cdots {1\over g_2g-_3\cdots g_{s-1}h_3h_4\cdots h_s})$。按照从小到大依次枚举$s$，当从$s-1$变成$s$的时候，相当于对于所有大于了$s$的$x$，它的贡献都增加了$F_x\cdot {1\over g_2g-_3\cdots g_{s-1}h_3h_4\cdots h_s}$，可以用线段树维护区间内的贡献和。</p>
<p>上面的结论推广到树仍然成立。对整棵树进行dfs遍历，进入一个点$s$的时候，就使它的子树内的点$x$都加上贡献$F_x \cdot {1\over h_sg_{fa_s}h_{fa_s}g_{fa_{fa_s}}\cdots }$，用树链剖分维护链的贡献和即可。时间复杂度$O(n\log ^2 n)$。</p>
<hr>
<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><h2 id="A-投影对称"><a href="#A-投影对称" class="headerlink" title="A - 投影对称"></a>A - 投影对称</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给定$n$个点，求有多少过$(0,0)$的直线，满足这$n$个点在直线上的投影为中心对称图形。</p>
<p>$n\le 2000$，$|x_i|,|y_i|\le 10^6$，可能会有重合的点。</p>
<h3 id="Sol-6"><a href="#Sol-6" class="headerlink" title="Sol"></a>Sol</h3><p>假设对称中心为$P$，考虑过$P$且与$OP$垂直的直线$l$，对于一对其投影关于$P$对称的点$A,B$，它们到$l$的距离相等。故线段$AB$的中点也一定经过了$l$。枚举$1,2$这两个点匹配的另一个点是什么就可以确定$l$，然后再$O(n\log n)$检查，这样总复杂度是$O(n^3\log n)$的。</p>
<p>考虑由于$l$过所有点对的中点，所以$l$一定过这$n$个点的重心。因此只需要枚举$1$号点匹配的点，再考虑上重心，就可以确定$l$了。时间复杂度$O(n^2\log n)$。</p>
<p>有一种写法是，先对这$n$个点求一次凸包，由于凸包上的点只能和凸包上的点配对，（再加上出题人没有考虑到凸包，因此数据中凸包上的点数很少），可以将总复杂度优化到$O(Cn\log n)$，其中$C$为凸包上的点数。</p>
<h2 id="B-数圈"><a href="#B-数圈" class="headerlink" title="B - 数圈"></a>B - 数圈</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>有$n$个整数排成一个圈，初始它们为$A_1,A_2\cdots A_n$。</p>
<p>定义一次操作为，选择一个数$a$，将与它相邻的数加上$a$，将它变成$-a$。</p>
<p>问至少进行多少次操作，可以使得所有的数非负。如果办不到输出$-1$。</p>
<p>$n\le 10^5, -1000\le A_i \le 1000$</p>
<h3 id="Sol-7"><a href="#Sol-7" class="headerlink" title="Sol"></a>Sol</h3><p>考虑如果是序列怎么做：观察发现，一次操作等价于交换了前缀和数组中的两个元素，所以答案就是前缀和数组的逆序对数。</p>
<p>而对于圈，我们定义它的广义前缀和是一个双向无限的序列$S_i(i\in \mathbb {Z})$，如1,2,-3,4的一个可能的广义前缀和是……-8,-4,-3,-1,-4,0,1,3,0,4,5,7,4,8,9,……定义它的一次交换操作为：选定一个$i$，对于所有在模$n$意义下与$i$同余的位置$x$，交换$S_x$与$S_{x-1}$。</p>
<p>设$sum=\sum_{i=1}^nA_i$，如果$sum&lt; 0$显然无解，如果$sum=0$则当且仅当序列中所有元素都是$0$的时候有解，否则无解。下面只讨论$sum&gt;0$的情况。</p>
<p>定义$R_i = \sum_{j&gt;i} [ S_j&lt; S_i]$，定义逆序对数为$R_1+R_2+\cdots R_n$。由于$sum&gt;0$，所以$R_i$是有限的。由于$S_{x+n}=S_x+sum$，所以$R_i = R_{i+n}$。一次操作会交换所有的$S_{i+kn}$与$S_{i-1+kn}(k\in \mathbb Z)$，对于某一个$k’$，$R_{i+k’n}$只会受到交换$S_{i+k’n},S_{i-1+k’n}$的影响，所以一次操作我们恰好可以让某一个$R_i(i\in [1,n])$减掉一。所以答案就是这个逆序对数。</p>
<p>枚举$j-i$在模$n$意义下的取值。由于$S_{i+n}=S_i + sum$，所以$R_i = \sum_{j=1,S_{i+j}&lt; S_i}^{n-1} \lceil{S_i-S_{i+j}    \over sum}\rceil$。利用这个式子可以在$O(n^2)$的时间内解决问题。</p>
<p>考虑将$S_i$分解为$S_i = u_i \cdot sum +v_i(0 \le v_i &lt; sum)$，则前面的式子转化为$\sum_{j=1,S_{i+j}&lt; S_i}^{n-1} u_i - u_{i+j} + [v_i &gt; v_{i+j}]$。从小到大枚举$i$并动态维护二维点集$(S_{i+j},v_{i+j})$以及点权$u_{i+j}$，可以做到$O(n\log ^ 2 n)$的复杂度。进一步观察，这个动态维护的过程中，我们每一次删除的是$((S_x,v_x),u_x)$，而加入的是$((S_{x+n},v_{x+n}) ,u_{x+n}) = (( S_x +sum, v_x), u_x +1)$。如果我们不去做这个修改，造成的影响是：对于所有的$i&gt;x,S_i &gt; S_x$，$R_i$会多算上$1$的贡献，这是一个二维偏序问题。不做修改的原问题也是个二维偏序问题。这样就做到了$O(n\log n)$的复杂度。</p>
<h2 id="C-search"><a href="#C-search" class="headerlink" title="C - search"></a>C - search</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p>交互题。有一个$n\times n$的单调矩阵（同一行的元素右边的比左边的大，同一列的元素下面的比上面的大），此外还有一个数$x$。保证矩阵内的元素以及$x$两两互不相同。有两种询问：</p>
<ul>
<li>询问矩形内的某两个格子，返回它们的大小关系。</li>
<li>询问矩形内的某一个格子，返回这个格子与$x$的大小关系。</li>
</ul>
<p>你需要回答，矩形内比$x$小的位置的个数。</p>
<p>$n\le 2000$，时限2s，限制询问1的次数不超过$64n$，询问2的次数不超过$34$。</p>
<h3 id="Sol-8"><a href="#Sol-8" class="headerlink" title="Sol"></a>Sol</h3><h4 id="一个随机算法"><a href="#一个随机算法" class="headerlink" title="一个随机算法"></a>一个随机算法</h4><p>随机一个格子$(i,j)$，然后抠出如下图的这个轮廓线：</p>
<p><img src="https://i.loli.net/2019/12/25/wJTPcaYkMhtdEgb.png" alt=""></p>
<p>有颜色的格子是用过询问1的，橘色表示问出来比$x$小，蓝色表示问出来比$x$大。</p>
<p>这样抠一次，$i$行之前的，橘色格子每列至多有一个，蓝色格子每行至多有一个；$i$行之后的，橘色格子每行至多有一个，蓝色格子每列至多有一个。所以这一步会用掉至多$2n$次询问1。</p>
<p>比较$(i,j)$与$x$的大小关系。若$(i,j) &lt; x$，则轮廓线上方的全部都$&lt; x$，可以记入贡献之后删掉；否则，$(i,j) &gt; x$，则轮廓线下方的也全部$&gt; x$，可以删掉。</p>
<p>期望只需要进行$O(\log n)$次上述操作，就可以结束程序。</p>
<hr>
<h1 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h1><h2 id="A-xor"><a href="#A-xor" class="headerlink" title="A - xor"></a>A - xor</h2><h3 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h3><p>给定$n,d$，求</p>
<script type="math/tex; mode=display">
\sum_{0\le x,y,z < n }(x \oplus y\oplus z)^d \pmod {998244353}</script><p>其中$\oplus$表示按位异或。</p>
<p>$n&lt; 2^{30},d\le 100000$。</p>
<h3 id="Sol-9"><a href="#Sol-9" class="headerlink" title="Sol"></a>Sol</h3><h4 id="部分分：-d-le-10"><a href="#部分分：-d-le-10" class="headerlink" title="部分分：$d\le 10$"></a>部分分：$d\le 10$</h4><p>下面是一个和正解毫无关系的暴力。</p>
<p>通过数位$dp$单独对二进制每一位进行考虑。考虑怎么算答案，设$p_i$表示第$i$位是$0$还是$1$，由多项式乘法的组合意义可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\sum_{i=0}^{\log n} p_i 2^i)^d =d!\sum_{l_1+l_2 + \cdots +l_{\log n}=d} \prod_i {(p_i2^i)^{l_i}\over l_i!}
\end{aligned}</script><p>在$dp$状态中加入一维表示$l_1 + l_2  +\cdots l_{cur_len}$，就可以在$O(\log n \cdot 2^3 \cdot d^2)$的时间内解决问题。</p>
<h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><p>枚举$x,y,z$最高的和$n$不同的一位，假设为$a,b,c$。不失一般性地令$a\le b\le c$。$x\oplus y\oplus z$可能取到的数，满足$c$以上的位全部与$n$相同，$c$位为$0$且$n$的$c$位为$1$，$c$以下的位任意。考虑末$c$位取到某个$L\in [0,2^c)$的方案数，发现我们可以先让$x$的末$a$位、$y$的末$b$位随便取，然后根据$x,y$和$L$唯一地确定$z$的末$c$位，故而方案数为$2^{a+b}$。这也就是说，枚举完$a,b,c$之后，$x\oplus y\oplus z$的每一个可能的取值出现的方案数是一样的。所以只需要求出所有的可能取到的数的$d$次方的和就可以了。可能取到的数形成了一个连续的区间，是经典的自然数幂和问题。直接枚举$a,b,c$计算的复杂度为$O(d\log ^ 3 n)$，观察发现可取到的数形成的区间只与$\max\{ a,b,c\}$有关，所以只需要算$\log n$次自然数幂和就可以了，复杂度$O(d\log n + \log^3 n)$。</p>
<h2 id="B-N门问题"><a href="#B-N门问题" class="headerlink" title="B -  N门问题"></a>B -  N门问题</h2><h3 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h3><p>$N$扇门中有一扇门是有奖的。初始的时候$A$认为所有门有奖的概率是相等的。每一轮，$A$会在有奖概率最大的门中随机选择一扇，然后主持人会从没有被$A$选择且没有奖的所有门中随机选择一扇门打开。进行到第$N-1$轮时，$A$的选择就是他的最终选择。</p>
<p>现在你来当主持人，你可以决定（而不是随机地）每一次打开哪一扇没有被$A$选择且没有奖的门，问$A$最终选择的门后面有奖的概率最小是多少。假定$A$不知道你是托儿，即$A$仍然认为你是在随机选择门。</p>
<p>$N\le 10^{18}$</p>
<h3 id="Sol-10"><a href="#Sol-10" class="headerlink" title="Sol"></a>Sol</h3><p><del>假设在某一轮，$n$个门后面有奖且主持人做出这样的选择的概率（贝叶斯公式中的$P(B\mid A)$）分别是$p_1,p_2,\cdots p_n$。</del></p>
<p><del>假设$A$选择的门是$x$，而你打开的门是$y$，则：</del></p>
<script type="math/tex; mode=display">
\begin{aligned}
p'_x = p_x {1\over n-1} \\
p'_k = p_k {1\over n-2} (k\not =x, y) \\
\end{aligned}</script><p><del>下面将证明，在某一轮$\forall k \not = x,y, p’_x &lt; p’_k$。考虑归纳。对于第一轮显然成立。假设现在是第$t$轮，还剩下$n$扇门没有开。由于$p’_k(k\not=x,y)$之间的大小关系由$p_k$决定，所以只需要考虑$p_k$中的最小值$p_q$乘上$1\over n-2$与$p_x \cdot {1\over n-1}$的大小关系。而由于归纳，$p_q$在上一轮中是最大的，用$\{ p’’_i\}$表示上一轮的数，则$p’_q = p’’_q \cdot {1\over (n-2)(n-2)}$，而$p’_x = p’’_x \cdot{ 1\over (n-3)(n-1)}$，所以可以推出。。。什么也推不出来。</del></p>
<p>不知道怎么证明的，$N&gt;10$的时候答案为$0$，$N\le 10$的时候直接搜索。</p>
<h2 id="C-区间匹配"><a href="#C-区间匹配" class="headerlink" title="C - 区间匹配"></a>C - 区间匹配</h2><h3 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h3><p>有两个长度为$n$的序列$a[1\cdots n],b[1\cdots n]$和两个非负整数$la,lb(lb \le la)$，你需要求出一个$1$到$n$的排列$\{p\}$，使得对于所有$i$都有$a[i] \le b[p[i]] \le a[i] + la$，在此基础上你需要最大化满足$a[i] + lb \ge b[p[i]]$的$i$的数量，并输出最大化的结果。</p>
<p>$n\le 500000$，$a[i],b[i],la,lb\le 500000$，且保证存在合法的$p$。</p>
<h3 id="Sol-11"><a href="#Sol-11" class="headerlink" title="Sol"></a>Sol</h3><p>考虑这样的一种贪心：从右到左考虑每一个$a$的元素，确定与它匹配的$b[p[i]]$。设现在还没有匹配过的元素中，最靠右的一个是$b[x]$，以及最靠右且满足$a[i] \le b[y] \le a[i]+lb$的是$b[y]$。如果让$a[i]$匹配上$b[y]$，剩下的点仍然存在合法的匹配，则让$a[i]$匹配$b[y]$；否则让$a[i]$匹配$b[x]$。</p>
<p>正确性证明：假设这样得到的不是最优解，考虑最优匹配中第一个与这样求出来的匹配不同的位置$i$，如果$i$匹配的既不是$x$也不是$y$，将$i$匹配的改成$x$或者$y$，答案一定不会变劣；假设最优匹配中$i$匹配了$y$，则意味着让$i$匹配$y$之后仍然存在完备匹配，所以我们的贪心策略也会让$i$匹配$y$；而如果最优匹配中$i$匹配了$x$，我们的贪心策略让$i$匹配了$y$，设我们的贪心策略中匹配了$x$的是$q_x$（显然$q_x$对答案没有贡献），而最优策略中$q_x$匹配$z$，则有两种情况：</p>
<ol>
<li>$z\le y$，则$q_x,z$这一对有可能对答案产生了贡献，此时我们将最优决策改为$x$匹配$q_x$，$i$匹配$y$，显然是不会变劣的。</li>
<li>$z&gt; y$，则$q_x,z$这一对一定对答案没有贡献。继续考虑$q_z$和最优策略中$q_z$所匹配的$w$，若$w\le y$就改成$q_x$匹配$x$，$q_z$匹配$z$，$i$匹配$y$，答案不会变劣，因为用到的$y$的右侧的点的集合是一样的，并且用到的$y$的左侧的点（从$w$变成了$y$）没有向左移，而已经确定了的匹配的贡献也没有变小；否则，继续考虑$q_w$直到匹配的点在$y$的左侧。</li>
</ol>
<p>直接检查是否存在完备匹配是$O(n\log n)$的（排序+贪心）。由Hall定理可得，存在完备匹配的条件是，不存在$z$使得$\sum_{i} [b[i] \ge z] &gt; \sum_{j} [a[j] + la \ge z]$。用线段树维护每个$z$的$\sum_{i} [b[i] \ge z] - \sum_{j} [a[j] + la \ge z]$以及区间最小值，并支持区间$+1/-1$，即可在$O(n\log n)$的时间内解决问题。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ171 【WC2016】挑战NPC</title>
    <url>/2020/02/19/UOJ171-%E3%80%90WC2016%E3%80%91%E6%8C%91%E6%88%98NPC/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>这道题的建图方法：</p>
<ol>
<li>每个筐拆成三个点分别代表三个位置，三个点两两之间互相连边</li>
<li>每个球向它可以放入的筐的三个点都连边</li>
</ol>
<p>求出这张图的最大匹配，减去球数就是答案。</p>
<p>如果一个筐的三个位置只被球占用了0个或者1个，那么这个筐内的位置就能够再构成一个匹配，对最大匹配产生1的贡献；否则，这个筐内的位置将无法再构成匹配。</p>
<p>为什么能保证一定存在一组最大匹配，所有的球都在匹配中？因为题目保证了合法方案存在，而合法方案一定可以对应到一组匹配。</p>
<p>那么如何确保每个球都在最大匹配中呢？在带花树算法中，优先对球进行bfs，其次再bfs筐。因为整个算法过程中，一个点一旦找到匹配的点了，之后就不会再变成孤立点（虽然它的配偶可能会改变）。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="http://uoj.ac/submission/385063" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>对带花树算法的一些思考</title>
    <url>/2020/02/19/%E5%AF%B9%E5%B8%A6%E8%8A%B1%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>推荐两个带花树算法的学习资料：<a href="https://en.wikipedia.org/wiki/Blossom_algorithm" target="_blank" rel="noopener">维基百科</a> <a href="https://blog.bill.moe/blossom-algorithm-notes/" target="_blank" rel="noopener">Bill Yang’s blog</a></p>
<h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>缩掉奇环之后，会不会存在一条交错路，和奇环相交的部分没有经过花根，成为了一条在缩掉了花之后的图中找不到的增广路？</p>
<p><img src="https://i.loli.net/2020/02/19/vjMD6BmsPTpqAHZ.jpg" alt=""></p>
<p>如上图，实线表示匹配边，虚线表示非匹配边，1和12是孤立点，$\{5,6,7,8,9\}$是已经缩起来的一朵花，5是花根。一条交错路是1-3-4-6-7-10-11-12，可以看到这条交错路进入花的最后一条边和离开花的第一条边都是非匹配边，无法在缩掉蓝色的花之后的图中找到。但是当我们访问到6-4这条边的时候，由于蓝色的花已经被缩起来了，就会发现$\{1,3,4,6,7,8,9,5,2\}$这个奇环并把它缩起来。所以这样的交错路是仍然能够被带花树算法找到的。</p>
<hr>
<p>后面的问题和代码实现有关，所以先贴上我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a solution for uoj79</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> n,fa[N],vis[N],par[N],pre[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	fa: 用来缩点的并查集</span></span><br><span class="line"><span class="comment">	vis:</span></span><br><span class="line"><span class="comment">		0 未被访问过</span></span><br><span class="line"><span class="comment">		1 所在的层数奇偶性和出发点相同</span></span><br><span class="line"><span class="comment">		2 所在的层数奇偶性和出发点不同</span></span><br><span class="line"><span class="comment">	par: 现在的配偶，0表示现在没有配偶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d=<span class="number">0</span>)</span> </span>&#123; <span class="keyword">if</span>(d&gt;n) <span class="keyword">return</span> x; <span class="keyword">return</span> fa[x]==x?x:fa[x]=find(fa[x],d+<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> vis[N],tim;	</span><br><span class="line">	tim++;</span><br><span class="line">	x=find(x),y=find(y);</span><br><span class="line">	<span class="keyword">while</span>(x) vis[x]=tim,x=find(pre[par[x]]); <span class="comment">// (1)</span></span><br><span class="line">	<span class="keyword">while</span>(vis[y]!=tim) y=find(pre[par[y]]); <span class="comment">// (1)</span></span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLOWER</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(find(x)!=L) &#123; <span class="comment">// (2)</span></span><br><span class="line">		<span class="keyword">if</span>(fa[x]==x) fa[x]=L; <span class="comment">// (3)</span></span><br><span class="line">		<span class="keyword">if</span>(fa[par[x]]==par[x]) fa[par[x]]=L; <span class="comment">// (3)</span></span><br><span class="line">		<span class="keyword">if</span>(vis[par[x]]==<span class="number">2</span>) vis[par[x]]=<span class="number">1</span>,que.push(par[x]);</span><br><span class="line">		pre[x]=y;</span><br><span class="line">		y=par[x],x=pre[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i,vis[i]=pre[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty()) que.pop();</span><br><span class="line">	que.push(s),vis[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u=que.front(); que.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> v=G[u][i];</span><br><span class="line">			<span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">				pre[v]=u,vis[v]=<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(!par[v]) &#123;</span><br><span class="line">					<span class="keyword">while</span>(v) &#123;</span><br><span class="line">						<span class="keyword">int</span> tmp=par[u];</span><br><span class="line">						par[v]=u,par[u]=v;</span><br><span class="line">						v=tmp,u=pre[v];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				vis[par[v]]=<span class="number">1</span>;</span><br><span class="line">				que.push(par[v]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(vis[v]==<span class="number">1</span>&amp;&amp;find(v)!=find(u)) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp=LCA(u,v);</span><br><span class="line">				FLOWER(u,v,tmp),FLOWER(v,u,tmp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m; rd(n),rd(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i) rd(x),rd(y),G[x].PB(y),G[y].PB(x);	</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123; <span class="keyword">if</span>(!par[i]) ans+=bfs(i); &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,par[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q2-1-2"><a href="#Q2-1-2" class="headerlink" title="Q2 (1) (2)"></a>Q2 (1) (2)</h2><p>(1) 不能写作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x) vis[x]=tim,x=pre[par[x]]; </span><br><span class="line"><span class="keyword">while</span>(vis[y]!=tim) y=pre[par[y]];</span><br></pre></td></tr></table></figure></p>
<p>(2) 不能写作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=L) &#123;</span><br></pre></td></tr></table></figure></p>
<p>原因是，可能尽管我们没有进行显式的缩点，在走到奇环的时候会顺着边爬，但是在奇环嵌套偶环的时候可能会陷入死循环。</p>
<p><img src="https://i.loli.net/2020/02/19/X7Wldj5F6sYHJpR.jpg" alt=""></p>
<p>比如，上面这张图中，我们已经找到 (2,1) ，(3,4) 这两对匹配，现在开始尝试找从 5 开始的增广路。首先会找到 $\{5,1,2\}$ 这个奇环并缩起来，之后会找到 $\{5,1,3,4,2\}$ 这个奇环并缩起来，但是在缩这个奇环的过程中，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(find(x)!=L) &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	pre[x]=y;</span><br><span class="line">	y=par[x],x=pre[y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就会陷入<code>(x=2, y=4) -&gt; (x=3, y=1) -&gt; (x=2, y=4) -&gt; ...</code>的死循环。</p>
<h2 id="Q3-3"><a href="#Q3-3" class="headerlink" title="Q3 (3)"></a>Q3 (3)</h2><p>(3) 不能写作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fa[find(x)]=L;</span><br><span class="line">fa[find(par[x])]=L;</span><br></pre></td></tr></table></figure><br>因为在往上爬的过程中，我们会先经过一些在花中但不是花根的点，这时候如果修改了这个花中所有的点的所属的花编号，会影响下一步用<code>find(x)!=L</code>判断是否已经走到了<code>L所在的花</code>。正确的做法是，走到花根的时候才修改花中的点所属的花编号。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ577 「LibreOJ NOI Round #2」简单算术</title>
    <url>/2020/02/17/LOJ577-%E3%80%8CLibreOJ-NOI-Round-2%E3%80%8D%E7%AE%80%E5%8D%95%E7%AE%97%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>考虑多项式乘法的组合意义，枚举第$i$项被选的次数$b_i$，要求$\sum b_i = m, \sum b_i i = k$，则对应的贡献为</p>
<script type="math/tex; mode=display">
\binom{m}{b_0}\binom{m-b_0}{b_1}\binom{m-b_0-b_1}{b_2} \cdots \cdot \prod_i a_i ^ {b_i}</script><p>如果$p \mid m$，我们对上面的式子应用Lucas定理，发现：</p>
<ul>
<li>若$p \nmid b_0$则第一项一定为$0$，要使整个式子不为$0$就一定要有$p \mid b_0$</li>
<li>于是有$p \mid m - b_0$，于是可以推出$p\mid b_1$</li>
<li>……</li>
</ul>
<p>也就是说，所有的$b_i$都是$p$的倍数。</p>
<p>令</p>
<script type="math/tex; mode=display">
B(x) = \sum_{i=0}^n a_i^{p}x^{ip}</script><p>那么就可以把此时的答案写成</p>
<script type="math/tex; mode=display">
[x^k] A^m(x) = [x^k] B^{\frac{m}{p}}(x)</script><p>这个$B^{\frac{m}{p}}(x)$的意义相当于让原来的$b_i$和$m$都除以$p$，不会影响系数的计算。</p>
<p>考虑到$a_i^p \equiv a_i \pmod p$，所以答案也可以写成</p>
<script type="math/tex; mode=display">
[x^{\frac{k}{p}}]A^{\frac{m}{p}}(x)</script><p>更一般的，对于任意的$m$，设$m = up + v(0\le v &lt; p)$，则有</p>
<script type="math/tex; mode=display">
[x^k] A^m(x) = \sum_{i=0}^{\min\{vn,k\}} [x^{k-i}]A^{up}(x)\cdot [x^i]A^v(x)</script><p>$[x^{k-i}]A^{up}(x)$直接递归，$[x^i]A^v(x)$可以通过预处理$A(x)$的$0$到$p-1$次幂解决。要对访问到过的状态进行记忆化。</p>
<p>因为当$p\nmid i-k$时$[x^{k-i}]A^{up}(x) = 0$，所以只需要枚举和$k$同余的$i$，这样的$i$会有$\frac{vn}{p} \le n$个。</p>
<p>考虑复杂度：</p>
<ul>
<li>每一次往下递归$m$会变成$\lfloor \frac{m}{p} \rfloor$，$k$会变成$\lfloor \frac{k}{p}\rfloor - i’$，$i’$的范围是$<a href="lim\le n">0,lim</a>$；</li>
<li>每一层的$m$都是一样的，所以只用考虑$k$会有多少种不同的取值；</li>
<li>对于第$i$层，$k$能取到的最大值是$\frac{k}{p^{i-1}}$，最小值则不小于$\frac{\frac{\frac{k}{p}-n}{p}-n}{p}\cdots \approx O(\frac{k}{p^{i-1}} - n \cdot {1\over p-1})$，所以每一层不同的$k$的数量至多是$O(n)$的；</li>
<li>状态数$O(n\log_pm)$，转移$O(n)$，所以这里的复杂度是$O(Tn^2\log_p m)$，算上预处理的复杂度就是$O(p^2n^2 + Tn^2\log_p m)$</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/746679" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>From Suffix Tree to SAM</title>
    <url>/2020/02/17/From-Suffix-Tree-to-SAM/</url>
    <content><![CDATA[<p>You may check <a href="https://cp-algorithms.com/string/suffix-automaton.html" target="_blank" rel="noopener">this article on cp-algorithms.com</a> (or OI-wiki if you prefer reading in Chinese) for more precise information and proof of complexity about SAM. Here I just want to write about another perspective to understand SAM, which I’ve learned from Huadun Hong, PKU, through Zhengruioi’s online courses on 4th, Feb, 2020.</p>
<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>We can get the suffix tree of string $S$ simply by inserting all of its suffixes into a trie (though this will involve $O(|S|^2)$ vertices). Note that: </p>
<ul>
<li>Each vertex in the suffix tree represents a substring of $S$ (since a substring is a prefix of a suffix of $S$). Let’s call the vertices that represent a suffix of $S$ ‘the suffix vertices’.</li>
<li>The number a substring occurs in $S$ equals to the number of suffix vertices in the subtree of the corresponding  vertex.</li>
<li>The well-known data structure Suffix Array is actually the DFS ordering of the suffix tree. (Sort the suffix vertices by the time we discover them.)</li>
<li>LCP of two suffixes is the LCA of the corresponding suffix vertices in the suffix tree.</li>
</ul>
<p>Define:</p>
<ul>
<li>$len_x$:  the length of the string that vertex $x$ represents, also equals to the depth of $x$ in the suffix tree.</li>
<li>$fail_x$: father of $x$ in the suffix tree.</li>
<li>$go_{x,ch}$: (this definition <strong>differs from traditional definition of SAM</strong>) suppose $x$ represents string $T$, then $go_{x,ch}$ is the vertex that corresponds to the string $cT$. I may write $go_{T,ch}$ for $go_{x,ch}$ or the string $go_{x,ch}$ represents for convenience in the following paragraph, so don’t get confused with it.</li>
</ul>
<p>It seems there is some delicate contact between $go_{x,ch}$ and the suffix links in the Aho–Corasick algorithm, isn’t it? And when the suffix tree is compressed later it turns out that it’s no longer convenient to find the son of a pariticular vertex in the suffix tree, and that’s why we’ve got to maintain the array $go_{x,ch}$. Thus if we want to find the corresponding vertex of a particular string $T$, we just start from the root of the suffix tree, enumerate each character of $T$ from right to left and go to $go_{\text{current node,current character}}$.</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>In this section we’ll talk about how to construct the suffix tree and maintain $len_x, fail_x, go_{x,ch}$ by adding characters of $S$ one by one from right to left.</p>
<p>That is, we have already built SAM of $S$, now we wanna get SAM of $cS$ out of it.</p>
<p>From $S$ to $cS$, only one more suffix’s added, that’s $cS$. So first we’ll insert $cS$ into the suffix tree (remember the suffix tree here is still a trie) and maintain $len_x, fail_x$ of the newly-added vertices. We do it in the following way: we create a new vertex $u$ that represents $cS$, then we find the longest $cS[1:i]$ that occurred in $S$ and let the corresponding vertex be $v$. Then we add vertices representing $cS[1:|S|-1],cS[1:|S|-2], \cdots S[1:i+1]$ between $u$ and $v$.</p>
<p>Consider about the changes in $go_{x,ch}$, they can be divided into two types:</p>
<ul>
<li>$x$ is one of those newly-added vertices, or</li>
<li>$go_{x,ch}$ is one of those newly-added vertices</li>
</ul>
<p>Note it’s impossible to have $x$ and $go_{x,ch}$ both newly-added.</p>
<p>For the first type, since strings the newly-added vertices represent do not occur in $S$, so after adding $c$ at the front they won’t occur either. Then just set all $go_{x,ch}$ of the newly-added vertices to <code>null</code>.</p>
<p>For the second type, we enumerate all prefixes of $S$ that $go_{S[1:j],c}$ is <code>null</code>, then let $go_{S[1:j],c}$ be $cS[1:j]$. This can be done by starting from $S$ and each time jumping to the father of current node until $go_{\text{current node},ch}$ is not <code>null</code>.</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>Note there can be $O(|S|^2)$ vertices in the suffix tree, but number of vertices with degree greater than $2$ is at most $2|S|-1$. Then if a vertex has only one child, we compress it and its’ only-child and say the original father is ‘compressed’. Specially, because suffix vertices contain a lot of important information so we’ll never compress a suffix vertex, even if it has only one child. We call all remaining vertices after the process ‘key vertices’.</p>
<p>Define:</p>
<ul>
<li>$Z(x)$: let $Z(x)$ be the set of strings that vertices compressed into $x$ represented in the original suffix tree. Note that all strings in $Z(x)$ can be represented as one prefix of the longest string in $Z(x)$.</li>
<li>$len_x$: the length of longest string in $Z(x)$.</li>
<li>$fail_x$: the first key vertex we meet in the original suffix tree by starting from $x$ and continuously jumping to father of the current node.</li>
<li>$go_{x,ch}$:<ul>
<li>An important fact is that in the original suffix tree $go_{x,ch}$ must be compressed if $x$ is compressed. To prove this let $T$ be the string $x$ represents and $cT$ be some key vertex.<ul>
<li>If $cT$ is a suffix vertex then $T$ should also be a suffix vertex which made $T$ impossible to be compressed.</li>
<li>Then $cT$ must have two distinct children, let them be $cTx$ and $cTy$. It turns out that $T$ should also have $Tx$ and $Ty$ as its children, which meets a contradiction.</li>
</ul>
</li>
<li>But if $x$ is a key vertex, $go_{x,ch}$ in the original suffix tree may be compressed. In this case we let $go_{x,ch}$ be the key vertex that the original $go_{x,ch}$ has been compressed into. Thus we can ensure $\forall Y\in Z(x), cY \in Z(go_{x,c})$.</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/17/vOGy15NqmpSt9wr.png" alt=""></p>
<p>(This is a picture from Huadun Hong’s slide, representing $go_{x,c}$.)</p>
<p>Then consider how to build SAM with our previous algorithm. First we create a new vertex stands for $cS$. </p>
<p>Finding the greatest $i$ that $cS[1:i]$ occurs in $S$ is equivalent to finding the greatest $i$ that $go_{S[1:i],c}$ is not <code>null</code>. So we can just start from $S$ and continuously jump to $fail_{\text{current node}}$ until the current node satisfies $go_{\text{current node},c}$ is not <code>null</code>. Let this vertex be $Q$ and $E$ be $go_{Q,c}$.</p>
<p>We should set $fail_{cS}$ to a vertex that the longest string it represents is $cQ$. But note that $cQ$ may not be the longest one in $Z(E)$, if so we shall ‘decompress’ it from $E$ since we’re about to add a new child to it. Let the newly-decompressed vertex be $K$ (let $K$ be $E$ in case that $cQ$ is the longest one in $Z(E)$) and let $fail_{cS} = K$.</p>
<p>Now we’ll take a look at changes in $go_{x,ch}$: </p>
<ul>
<li>like the original $O(|S|^2)$ suffix tree, we set $go_{x,c}$ of all vertices on the chain from $S$ to $Q$ to $cS$</li>
<li>and for $Q$ and $Q$’s ancestors satisfying $go_{x,c} = E$, we change $go_{x,c}$ to $K$.</li>
</ul>
<p>Thus we’ve completed contruction of SAM.</p>
<p>It turns out that time complexity and memory complexity of this algorithm are both $O(|S|)$. </p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>APIO2019</title>
    <url>/2020/02/14/APIO2019/</url>
    <content><![CDATA[<h2 id="桥梁"><a href="#桥梁" class="headerlink" title="桥梁"></a>桥梁</h2><p>将所有的操作按照时间顺序分成$T$个大小为$\frac{q}{T}$的块。对于每个块，将块内的询问按照$w_j$排序，将未被块内的操作修改过的边按照执行这个块内的操作之前的边权排序。</p>
<p>按照$w_j$降序枚举块内的询问，然后将所有重$w_j$的车能够通过的、“未被块内的操作修改过的”边加入；再加入块内修改过的、这次询问的时候的边权$\ge w_j$的边，查询$s_j$所在连通块的大小，然后再撤销掉加入的块内修改过的边。</p>
<p>复杂度是$O(\frac{q}{T}(m\log m + m\log n) + qT\log n)$，当$T$大致取到$\sqrt m$的时候最优。由于排序的那个$\log m$比并查集的$\log n$大得多，所以可以适当调大$T$。</p>
<p><a href="https://loj.ac/submission/731393" target="_blank" rel="noopener">Code</a></p>
<h2 id="路灯"><a href="#路灯" class="headerlink" title="路灯"></a>路灯</h2><p>对每个时刻的序列，维护它的极长的、只包含$1$的区间构成的集合。</p>
<p>对每个曾经在集合中出现过的极长$1$区间，将它对每个询问的贡献分成两部分：</p>
<ol>
<li>询问的时候它还在序列中，贡献是询问的时刻 - 它被加入的时刻（由于极长$1$区间不交，所以对于一个询问，这种区间如果有则一定只有一个）；</li>
<li>询问的时候它已经不在序列中了，贡献就是它出现过的时刻数；</li>
</ol>
<p>而一个极长$1$区间$[l,r]$对一个询问$[a,b]$能产生贡献当且仅当$l\le a, b-1\le r$，是个二维偏序。加上“离开序列的时间小于询问的时间”就是三维偏序，可以cdq分治解决。</p>
<p>而第一种贡献用set维护当前时刻所有的极长$1$区间就能计算。</p>
<p><a href="https://loj.ac/submission/744366" target="_blank" rel="noopener">Code</a></p>
<h2 id="奇怪装置"><a href="#奇怪装置" class="headerlink" title="奇怪装置"></a>奇怪装置</h2><p>考虑什么情况下两个时刻的$(x,y)$会相同。</p>
<p>因为$y=(t\bmod B)$，所以这两个时刻可以写成$t,t+kB$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
t + \lfloor \frac{t}{B} \rfloor \equiv t + kB + \lfloor \frac{t+kB}{B} \rfloor \pmod A\\
t + \lfloor \frac{t}{B} \rfloor \equiv t + kB + \lfloor \frac{t}{B} \rfloor + k \pmod A\\
0 \equiv k(B+1) \pmod A\\
A \mid k(B+1)
\end{aligned}</script><p>考虑$B+1,A$的质因数分解：</p>
<script type="math/tex; mode=display">
\begin{aligned}
B+1 = \prod p_i^{b_i}\\
A = \prod p_i^{a_i}
\end{aligned}</script><p>则最小的满足条件的$k$就是</p>
<script type="math/tex; mode=display">
\begin{aligned}
k_{min}\prod p_i^{\max\{a_i - b_i,0\}}\\
= \prod p_i^{a_i - \min\{b_i,a_i\}}\\
= \frac{A}{\gcd(A,B+1)}
\end{aligned}</script><p>且其它满足条件的$k$都是它的倍数。</p>
<p>所以$t_1,t_2$的二元组$(x,y)$相同当且仅当$t_1\equiv t_2\pmod{k_{min}B}$</p>
<p>这样就转化成了简单的区间并问题。</p>
<p>注意考虑$k_{min}B$超过long long范围的情况。</p>
<p><a href="https://loj.ac/submission/744366" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1270 Goodbye 2019 (C,D,E,F,G,H)</title>
    <url>/2020/01/27/CF1270-Goodbye-2019-C-D-E-F-G-H/</url>
    <content><![CDATA[<h2 id="C-Make-Good"><a href="#C-Make-Good" class="headerlink" title="C - Make Good"></a>C - Make Good</h2><p>记$sum$为所有数的异或和，$tot$为所有数的和。$tot$显然必须是偶数。所以如果$tot$是奇数的话，就先往数组里面加入一个$1$。</p>
<p>如果$2\times sum &gt; tot$，就往数组里面加入两个${2\times sum - tot \over 2}$，这对数组中的数的异或和没有影响。</p>
<p>否则，先加入一个$2^{58}$（一个很大的$2$的整数次幂），然后就会转化成$2\times sum &gt; tot$的情况。</p>
<p>如果又要加入$1$又要加入$2^{58}$，可以直接加入数$1+2^{58}$，这样就可以满足加的数至多是三个的限制。</p>
<p><a href="https://codeforces.com/contest/1270/submission/67904998" target="_blank" rel="noopener">Code</a></p>
<h2 id="D-Strange-Device"><a href="#D-Strange-Device" class="headerlink" title="D - Strange Device"></a>D - Strange Device</h2><p>首先考虑$k=n-1$怎么做：可以把每个大小为$n-1$的子集都问一遍，这样第$m+1$小的会出现$m$次，第$m$小的会出现$n-m$次，根据出现过的元素的大小关系以及它们分别的出现次数就可以推出$m$。</p>
<p>当$n&gt;k+1$，直接对前$k+1$个元素通过上面的方法计算就可以了。</p>
<p><a href="https://codeforces.com/contest/1270/submission/67910798" target="_blank" rel="noopener">Code</a></p>
<h2 id="E-Divide-Points"><a href="#E-Divide-Points" class="headerlink" title="E - Divide Points"></a>E - Divide Points</h2><p>将点分成四组：$A_{0,0},A_{0,1},A_{1,0},A_{1,1}$。点$(x,y)$属于组$A_{x\pmod 2,y\pmod 2}$。用$P,Q$代表最后分得的两个点集。</p>
<p>若所有点都属于同一个组，则将所有点的坐标除以$2$（如果原数是奇数，则向下取整）之后再做，与原问题等价。</p>
<p>如果$A_{0,0}\cup A_{1,1}$非空，且$A_{0,1}\cup A_{1,0}$非空，令$P=A_{0,0}\cup A_{1,1},Q=A_{0,1}\cup A_{1,0}$即可。【同一组内的点的$(x+y)\bmod 2$相同】</p>
<p>否则，若$A_{0,0}\cup A_{1,1}$为空集，令$P=A_{0,1},Q=A_{1,0}$即可。【只有同一组内的点的$(x_1-x_2)^2 + (y_1-y_2)^2$是$4$的倍数】</p>
<p>否则$A_{0,1}\cup A_{1,0}$为空集，令$P=A_{0,0},Q=A_{1,1}$。【同上】</p>
<p><a href="https://codeforces.com/contest/1270/submission/68144464" target="_blank" rel="noopener">Code</a></p>
<h2 id="F-Awesome-Substrings"><a href="#F-Awesome-Substrings" class="headerlink" title="F - Awesome Substrings"></a>F - Awesome Substrings</h2><p>设$x = {L\over cnt}$，其中$L$表示子串的长度，$cnt$表示子串内$1$的个数。设$T$为某个定值。</p>
<p>设$a_i = \sum_{j\le i} [s_j = 1]$。</p>
<p>将答案分为两部分计算；</p>
<ol>
<li>$x\le T$：枚举每一个$x$，然后枚举子串右端点$r$，则左端点应满足${r-(l-1)\over a_r-a_{l-1}} = x\Rightarrow r-a_rx = l-1-a_{l-1}x$，直接用map或者hash_table统计一下即可。</li>
<li>$x&gt; T$，显然有$cnt = {L\over x} \le {n\over T}$，所以可以枚举子串的左端点和$cnt$，此时要求右端点必须落在某个区间内且$r-l+1 \pmod {cnt}$为$0$，可以$O(1)$计算这样的右端点的数量。</li>
</ol>
<p>如果用map，时间复杂度$O(nT\log n + n\cdot {n \over T})$，当$T$取${\sqrt{n\over \log n}}$的时候复杂度最优，为$O(n\sqrt {n\log n})$。</p>
<p><a href="https://codeforces.com/contest/1270/submission/68145267" target="_blank" rel="noopener">Code</a></p>
<h2 id="G-Subset-with-Zero-Sum"><a href="#G-Subset-with-Zero-Sum" class="headerlink" title="G - Subset with Zero Sum"></a>G - Subset with Zero Sum</h2><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>$i-n\le a_i \le i-1$等价于$1\le i - a_i \le n$。</p>
<p>令$i$向$i-a_i$连边，会得到基环内向树森林。取一个环上的所有元素：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x - a_x = y \\
y - a_y = z \\
\vdots \\
u - a_u = x
\end{aligned}</script><p>将所有式子加起来，会得到$a_x+a_y+\cdots a_u = 0$。</p>
<p><a href="https://codeforces.com/contest/1270/submission/68150511" target="_blank" rel="noopener">Code</a></p>
<h2 id="H-Number-of-Components"><a href="#H-Number-of-Components" class="headerlink" title="H - Number of Components"></a>H - Number of Components</h2><p>观察发现，如果$i,j(i&lt;j)$连通，那么对于任意的$k\in (i,j)$，$k$与$i,j$连通。</p>
<p>证明：考虑连通块中从$i$到$j$的一条路径，若$k$在这条路径上结论显然成立；否则，这其中必定存在一条边$(u,v)$满足$u &lt; k &lt; v$，由于$a_u &lt; a_v$，所以$a_u &lt; a_k \vee a_k&lt; a_v$一定成立。</p>
<p>所以，连通块一定是序列上的一段连续的区间。</p>
<p>将问题转化成：计算有多少个$p$，满足$[1,p]$和$[p+1,n]$之间没有边。而这个限制条件也等价于$\forall x\in [1,p], y\in [p+1,n], a_x &gt; a_y$。</p>
<p>考虑枚举$[p+1,n]$中的最大值$v$，记序列中小于等于$v$的值为$0$，大于$v$的值为$1$，则$p$合法的条件就是整个序列形如$\overbrace{111\cdots 111}^{\text{p个1}}000\cdots 000$。</p>
<p>发现对于每个$v$而言，它对应的$01$序列是确定的，也就是说尽管一个$v$可以对应多个$p$，但是这些$p$中至多只有一个合法。</p>
<p>所以我们不妨直接统计有多少个$v$对应的$01$序列形如$111\cdots 111000\cdots 000$。</p>
<p>为了方便处理，我们令$a_0 = + \infty, a_{n+1} = -\infty$</p>
<p>用线段树维护对每一个$v$维护它对应的$01$序列中相邻的$10$对的数量，以及$v$是否作为序列中的某个元素出现。由于$10$对的数量至少有一个，所以维护最小值以及最小值的数量，即可得到合法的$v$的数量。</p>
<p><a href="https://codeforces.com/contest/1270/submission/68155123" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>一类序列上的最短路问题-倍增</title>
    <url>/2020/01/27/%E4%B8%80%E7%B1%BB%E5%BA%8F%E5%88%97%E4%B8%8A%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98-%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<h2 id="CF1246F-Cursor-Distance"><a href="#CF1246F-Cursor-Distance" class="headerlink" title="CF1246F Cursor Distance"></a>CF1246F Cursor Distance</h2><p>考虑对于每一个$i$，求出至多走$k$步就能够到达它的位置所构成的区间$[L_{i,k},R_{i,k}]$。我们只要对每个$i$分别求出$\sum_k L_{i,k},\sum_k R_{i,k}$就能得到答案。</p>
<p>最短路不一定是单向的（比如对于baaaaac，从b走到最后一个a），所以$L,R$可能不独立，不能直接倍增计算$L,R$的和。</p>
<p>进一步观察，$R_{i,k+2}$的取值与$[L_{i,k+1},L_{i,k})$中的位置有关的必要条件是$[L_{i,k+1},R_{i,k+1}]$的字符集大于$[L_{i,k},R_{i,k}]$的字符集；如果$[L_{i,k+1},R_{i,k+1}],[L_{i,k},R_{i,k}]$字符集相同，则$R_{i,k+2}$就只与$R_{i,k+1}$和$[L_{i,k},R_{i,k}]$的字符集大小有关。</p>
<p>对于每个$i$，当$k$从$0$取到$+\infty$的时候，$[L_{i,k},R_{i,k}]$的字符集大小只会变化$|\Sigma|$次（$|\Sigma|$表示字符集大小）。故而，我们可以枚举当前这些区间的字符集大小，这时候$L,R$是独立的，可以直接倍增求出它们的和。</p>
<p>实现细节上，在最外层枚举区间的字符集大小$t$，然后对每个位置$i$处理出$fl_i$——表示当$L$为某个满足$[L,i]$字符集大小为$t$的位置，$R=i$的时候，跳一步能够把$R$扩展到哪里；以及类似定义的$fr_i$。预处理出$fl_i,fr_i$倍增的结果。然后对每个$i$从大到小枚举$j$，然后看它现在的区间端点扩展$2^j$次以后，区间内是否仍然只有$t$种字符。</p>
<p><a href="https://codeforces.com/contest/1246/submission/69554739" target="_blank" rel="noopener">Code</a></p>
<hr>
<h2 id="LOJ6435-「PKUSC2018」星际穿越"><a href="#LOJ6435-「PKUSC2018」星际穿越" class="headerlink" title="LOJ6435 「PKUSC2018」星际穿越"></a>LOJ6435 「PKUSC2018」星际穿越</h2><p><a href="https://www.cnblogs.com/HocRiser/p/9166459.html" target="_blank" rel="noopener">参考这篇blog</a></p>
<p>设$f_{i,k}$为从$i$出发，走$k$步能够到达的最靠左的点。则有$f_{i,k+1} &lt; f_{i,k}$。</p>
<p>显然$f_{i,1} = l_i$。</p>
<p>然后是$f_{i,2} = \min_{j \ge l_i} \{l_j\}$：</p>
<ul>
<li>对于$j\in [l_i,i)$，$i$可以在第一步走到$j$；</li>
<li>对于$j&gt;i$，如果$l_j\le i$我们可以选择在第一步走到$j$，否则$l_j &gt; i$，$l_j$一定不会被$\min_{x\ge l_i}\{l_x\}$取到。</li>
</ul>
<p>对于$f_{i,k} (k &gt; 2)$，有$f_{i,k} = \min_{j\in [f_{i,k-1},f_{i,k-2})} \{ l_j \} = \min_{j\in [f_{i,k-1},i)} \{ l_j \}$。由于显然$f_{i,k} &lt; f_{i,2} \le \min_{j\ge i} \{l_j\}(k &gt; 2)$，所以也可以写作$f_{i,k} = \min_{j\in [f_{i,k-1},n]} \{ l_j \}$。这个式子中$f_{i,k}$的取值与$i$无关而只与$f_{i,k-1}$有关，所以可以倍增求出$k=2^j$时的$f_{i,k}$和$\sum_{x\in [1,k]}f_{i,x}$。</p>
<p>实现上，可以强制先走$k=1$的第一步$f_{i,1} = l_i$，这样的话之后的每一步的转移都满足$f_{i,k} = \min_{j\ge f_{i,k-1}} \{ l_j\}$</p>
<p><a href="https://loj.ac/submission/730991" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划练习题</title>
    <url>/2020/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="TopCoder14929-MaxSquare"><a href="#TopCoder14929-MaxSquare" class="headerlink" title="TopCoder14929 MaxSquare"></a>TopCoder14929 MaxSquare</h2><p><a href="https://www.topcoder.com/single-round-match-735-editorials/" target="_blank" rel="noopener">official editorial</a></p>
<p>设$s_i$表示$B$的前缀和。</p>
<script type="math/tex; mode=display">
Ans = \max_{r_1-l_1=r_2-l_2} \{(r_1-l_1)(s_{r_2}-s_{l_2}) +(r_2-l_2)(s_{r_1}-s_{l_1})\}</script><p>显然最优的时候$r_2=r_1,l_2=l_1$，所以</p>
<script type="math/tex; mode=display">
Ans = 2 \max_{l,r} \{ (r-l)(s_r-s_l) \}</script><p>想象成平面上有$n$个点$(i,s_i)$，那么上式等价于：选择两个点作为矩形的两个相对的顶点，矩形的面积的最大值。</p>
<p>我们先考虑一个点作为左下角的点，另一个点作为右上角的点的情况（一个点作为左上角，另一个作为右下角是同理的）。</p>
<p>显然对于作为左下角的那些点来说，如果$i &lt; j\wedge s_i &lt; s_j$，那么$(i,s_i)$是没有用的。右上角同理。</p>
<p>所以有用的点会形成这样的分布：</p>
<p><img src="https://i.loli.net/2020/01/20/aDlrPFwYMVf6nTN.png" alt="TopCoder14929_1_.png"></p>
<p>然后对于每个右上角的点，考虑矩形面积在左下角的哪一个点取到最大值。观察下图：</p>
<p><img src="https://i.loli.net/2020/01/20/LXA8iwFR3cjnDvJ.png" alt="TopCoder14929_2_.png"></p>
<p>可以得到结论：如果对于$p_1$，$q_2$比$q_1$优，那么对于$p_2$，$q_2$一定比$q_1$优秀。</p>
<p>证明：考虑反证</p>
<script type="math/tex; mode=display">
\begin{aligned}
S_{p_1,q_1} < S_{p_1,q_2},S_{p_2,q_1} > S_{p_2,q_2}\\
\Rightarrow S_{p_1,q_1} + S_{p_2,q_2} < S_{p_1,q_2} +S_{p_2,q_1}\\
\Rightarrow S_{p_1,q_1} + S_{p_2,q_2} - S_{p_1,q_2} - S_{p_2,q_1} < 0\\
\end{aligned}</script><p>也就是上图中绿色标出的部分，其面积要小于$0$，推出了矛盾。</p>
<p>用经典的决策单调性的分治算法，就可以在$O(n\log n)$的时间内解决问题。</p>
<h2 id="CF908H-New-Year-and-Boolean-Bridges"><a href="#CF908H-New-Year-and-Boolean-Bridges" class="headerlink" title="CF908H New Year and Boolean Bridges"></a>CF908H New Year and Boolean Bridges</h2><p>$f(i,j) \operatorname{AND} f(j,i) =1$的肯定在同一个SCC里面，而$f(i,j) \operatorname{XOR} f(j,i) =1$的肯定不在同一个SCC里面。而由于$f(i,j) \operatorname{AND} f(j,i) =1,f(i,j) \operatorname{XOR} f(j,i) =1$中都蕴含着$f(i,j) \operatorname{OR} f(j,i) =1$，所以我们必须把所有的SCC都连成一条链。由于要让边数尽可能少，所以每个SCC一定都是单独一个点或者一个环。我们只要最小化点数大于$1$的SCC的数量就可以了。</p>
<p>$f(i,j) \operatorname{AND} f(j,i) =1$的点可以直接缩起来。缩完点之后，在原图中的点数为$1$的都不需要考虑；对于剩下的点，对所有的$f(i,j) \operatorname{XOR} f(j,i) =1$在$i,j$之间建一条边，问题转化成求最小的$k$，使得在这张图中可以将这些点划分成$k$个独立集。</p>
<p>注意到在原图中对应的点数大于$1$的点的数量不超过$\lfloor{n\over 2}\rfloor = 23$。</p>
<p>直接子集$dp$的复杂度是$O(3^{n\over 2})$或者$O(n^22^{n\over 2})$。</p>
<p>先枚举$k$，在判断的时候我们把条件放松一些：我们只要求能够选出$k$个独立集，它们的并是全集就可以了。</p>
<p>设$f_S$表示$S$的子集中是独立集的数量，通过容斥就可以得到：</p>
<script type="math/tex; mode=display">
Ans = \sum_{T\in V} (-1)^{|V|-|T|}f_T^k</script><p>这个$Ans$会很大，但是我们只关心$Ans$是否为$0$，用取模或者直接溢出后的结果判断就可以了。</p>
<p>时间复杂度$O(n2^{n\over 2})$。</p>
<p><a href="https://codeforces.com/contest/908/submission/69094070" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2292-「THUSC-2016」成绩单"><a href="#LOJ2292-「THUSC-2016」成绩单" class="headerlink" title="LOJ2292 「THUSC 2016」成绩单"></a>LOJ2292 「THUSC 2016」成绩单</h2><p>设$f_{i,j,l,r}$表示区间$[i,j]$已经删掉若干，剩下的那些元素中的最大值为$r$，最小值为$l$，删掉那若干个元素的最小代价；$g_{i,j}$表示将区间$[i,j]$全部删完的最小代价。</p>
<p>对于$f_{i,j,l,r}$，考虑$j$这个元素是否被删掉了：</p>
<ul>
<li>如果它已经被删掉，我们枚举它是和哪些元素一起删掉的，就有：<script type="math/tex; mode=display">
f_{i,k,l,r} + g_{k+1,j} \to f_{i,j,l,r}</script></li>
<li>否则，$j$没有被删掉，则得到<script type="math/tex; mode=display">
f_{i,j-1,l,r} \to f_{i,j,\min\{l,w_j\},\max\{r,w_j\}}</script></li>
</ul>
<p>对于$g$，考虑我们是否对$[i,j]$整体进行过操作：</p>
<ul>
<li>如果没有，则<script type="math/tex; mode=display">
g_{i,k} + g_{k+1,j}\to g_{i,j}</script></li>
<li>否则<script type="math/tex; mode=display">
f_{i,j,l,r} + a + b(r-l)^2 \to g_{i,j}</script></li>
</ul>
<p>复杂度$O(n^5)$。</p>
<p><a href="https://loj.ac/submission/726342" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>图论练习题</title>
    <url>/2020/01/19/%E5%9B%BE%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="LOJ2146-「SHOI2017」寿司餐厅"><a href="#LOJ2146-「SHOI2017」寿司餐厅" class="headerlink" title="LOJ2146 「SHOI2017」寿司餐厅"></a>LOJ2146 「SHOI2017」寿司餐厅</h2><p>把$mx^2 + cx$拆一下就是：只要吃的寿司里面有代号为$x$的就要付出$mx^2$的代价；每吃一种代号为$x$的寿司就要付出$x$的代价。直接令$d_{i,i}$减掉$a_i$，就可以不再考虑$cx$这部分。</p>
<p>对每个区间$[l,r]$建一个点，权值为$d_{l,r}$；对每个代号建一个点，权值为$-mx^2$。如果选了$d_{l,r}$就必须选$d_{l,r-1}$和$d_{l+1,r}$，如果选了$d_{i,i}$就必须选$ma_i^2$。求出这张图的最大权闭合子图即可。</p>
<p><a href="https://loj.ac/submission/723604" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2100-「TJOI2015」线性代数"><a href="#LOJ2100-「TJOI2015」线性代数" class="headerlink" title="LOJ2100 「TJOI2015」线性代数"></a>LOJ2100 「TJOI2015」线性代数</h2><p>把$A$想象成$\{1,2,\cdots n\}$的一个子集，$0$表示不选，$1$表示选。则：</p>
<script type="math/tex; mode=display">
val(A) = \sum_{i\in A\wedge j\in A} B_{i,j} - \sum_{i\in A} C_i</script><p>对每个$B_{i,j}$和$C_i$建一个点，权值分别为$B_{i,j},-C_i$，要求如果选了$B_{i,j}$则必须选$-C_i$和$-C_j$。求出这张图的最大权闭合子图即可。</p>
<p><a href="https://loj.ac/submission/723647" target="_blank" rel="noopener">Code</a></p>
<h2 id="UOJ41-【清华集训2014】矩阵变换"><a href="#UOJ41-【清华集训2014】矩阵变换" class="headerlink" title="UOJ41 【清华集训2014】矩阵变换"></a>UOJ41 【清华集训2014】矩阵变换</h2><p>考虑什么样的方案是不合法的：第$x$行选择了$y$，并且存在另一行$x’$，$y$在$x’$行的出现的列编号大于$y$在$x$行出现的列编号，且$x’$行选择的那个数字的列编号在$y$之后。</p>
<p>可以转化成稳定婚姻问题：由于要求每列中每个数至多出现一次，所以每一行选择的数显然是不同的，所以可以把问题看作求行和数字的匹配。对于每一行，在那一行出现的列编号越小的数字越好；对于每一个数字，它在其中出现的位置越靠后的行越好。这样求出的解显然能够规避上面说的不合法情况。</p>
<p><a href="http://uoj.ac/submission/380077" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2052-「HNOI2016」矿区"><a href="#LOJ2052-「HNOI2016」矿区" class="headerlink" title="LOJ2052 「HNOI2016」矿区"></a>LOJ2052 「HNOI2016」矿区</h2><p>分母很容易算，考虑怎么求分子。</p>
<p>将平面图转化成对偶图之后，以无穷域为根，求出一棵dfs树，并处理出子树内的块的矿量和。</p>
<p>考虑给出的开发区域的每一条边：如果它在对偶图中是非树边则不管它；如果它是树边，且它连接的两个点中，开发区域外的点是父亲，那么就让总和加上区域内的那个子树的权值；如果它是树边，且它连接的两个点中，区域里的点是父亲，那么就让总和减去区域外的那个子树的权值。</p>
<p>注意对偶图中可能是有重边的。</p>
<p><a href="https://loj.ac/submission/725254" target="_blank" rel="noopener">Code</a></p>
<h2 id="TopCoder14750-HeroicSchedule"><a href="#TopCoder14750-HeroicSchedule" class="headerlink" title="TopCoder14750 HeroicSchedule"></a>TopCoder14750 HeroicSchedule</h2><p><a href="https://vjudge.net/problem/TopCoder-14750" target="_blank" rel="noopener">可以在vjudge上提交</a> </p>
<p>下面用$n$表示点数，$m$表示边数。</p>
<p>由费用流的过程可以知道，将所有的任务按照收益从大到小排序之后，依次考虑每个任务，能够加入则加入，则一定能够得到最优的解。</p>
<p>尝试加入的过程就是求匹配的过程，考虑用匈牙利算法来实现这一部分。直接做的复杂度是$O(n^2m^2)$的。</p>
<p>发现尽管边数很大，但是遍历边集的时候我们实际上是在一个区间内的点中找到一个vis不为$0$的点，用set就可以在$O(\log m)$的时间内完成。复杂度优化到$O(n(\log m + m\log m))$。</p>
<p>更进一步观察发现，只要当前已经求出的匹配没有变化，就没有清空vis的必要。而匹配的大小只会从$1$变到至多$m$，也意味着匹配至多会改变$m$次。所以我们的等到匹配改变的时候才清空vis，就能把复杂度做到$O(n\log m + m^2 \log m)$。</p>
<p><a href="https://vjudge.net/solution/23740620" target="_blank" rel="noopener">Code</a></p>
<h2 id="HDU6431-NewNippori"><a href="#HDU6431-NewNippori" class="headerlink" title="HDU6431 NewNippori"></a>HDU6431 NewNippori</h2><p>分别求出$maxflow(x,y)$为1,2的点对的数量，就可以算出答案。</p>
<p>$maxflow(x,y)=1$的点对即不在同一个边双连通分量的点对。</p>
<p>$maxflow(x,y)=2$的点对一定在同一个边双连通分量且可以通过割掉两条边使它们不连通。</p>
<p>对每个边双连通分量分别考虑。首先求出一棵dfs树。考虑割掉哪些边能够把这个边双分成不连通的两个部分：</p>
<ul>
<li>割一条树边和一条非树边。我们称一条非树边覆盖了一条树边，当且仅当非树边的两个端点在树上的最短路包含了那条树边。由于这是一个边双，所以每条树边至少被一条非树边覆盖；又由于我们只能割一条非树边，而覆盖了我们割的那条树边的非树边必须全部被割掉，所以我们割的树边一定恰好只有一条非树边覆盖了它。把那条树边和覆盖它的非树边割掉，可以把dfs树上树边两侧的部分割开。</li>
<li><p>割两条树边。考虑这两条树边割开之后树边将dfs树分成了三部分：<br><img src="https://i.loli.net/2020/01/18/28qR5MKJlmvCa3w.png" alt="hdu6431.png"><br>其中黑色的圈表示树上的连通块，黑色的虚线表示割掉的树边，1，2，3分别表示在这三个连通块之间的非树边。</p>
<ul>
<li>如果1存在，由于每条树边都至少有一条非树边覆盖了它，所以2和3至少有一条边存在，所以这时三个块仍然连通。2存在同理。</li>
<li>如果这三种边中，只有3这种边存在，发现割了两条树边之后，A和B组成的连通块和C之间没有边。</li>
</ul>
<p>所以，割的两条树边一定满足：所有的非树边要么同时覆盖这两条边，要么同时不覆盖这两条边。</p>
</li>
</ul>
<p>如何判断覆盖了两条树边的非树边集合是否相同：可以用与<a href="http://uoj.ac/problem/207" target="_blank" rel="noopener">uoj207</a>那道题一样的方法，给每一条非树边随机一个$[0,2^{64})$的权值，设每个点的权值为所有以它作为一端的非树边的权值的异或和。则当两个点的子树内所有点的权值的异或和相同的时候，我们认为这两个点到它们的父亲的那两条边被非树边覆盖的情况相同；当某个点子树内点的权值异或和为某条非树边的权值，我们就认为这个点到父亲的那条边只被那条非树边覆盖。</p>
<p>首先统计跨越了只被一条非树边覆盖了的树边的点对的贡献，然后把这些树边都断开。下面考虑的是断开了这些边之后的每个连通块。</p>
<p>对每个点$x$，统计出满足下面条件的点的数量：存在一对树边，割开之后能够把$x$和这个点隔开，且$x$位于与两条树边都相邻的那个连通块里面（上图中的连通块C）。</p>
<p>由于我们求的是dfs树，所有的非树边都是返祖边，不存在横叉边。所以，被覆盖情况相同的两条树边也一定是祖孙关系。</p>
<p>考虑把$x$夹在了中间的那些可以割掉的树边对：</p>
<p><img src="https://i.loli.net/2020/01/18/8cZQa4xRTtLAPCl.jpg" width="40%" height="100%" ></p>
<p>观察到：</p>
<ul>
<li>对于某条树边，能够和它配对的边显然都在一条祖孙链上。</li>
<li>不可能存在两对树边$(u,v),(x,y)$，满足$dep_u &lt; dep_x &lt; dep_v &lt; dep_y$。</li>
</ul>
<p>所以，对于某个$x$，把它夹在了中间的树边对一定满足：假设这些树边对按照在$x$的上面的那条边的深度升序排序得到的序列是$w_1,w_2,\cdots w_k$，那么按照在$x$的下面的那条边的深度升序排序得到的序列就是$w_k,w_{k-1},\cdots w_1$。我们只需要找出$w_k$：$w_k$把整棵树分成三部分中不包含$x$的那两部分的大小，就是能够通过割两条树边与$x$隔开的点数。</p>
<p>对连通块进行dfs，到达某个点$u$的时候，先递归处理$u$的子树内的点，然后再处理$u$到它的父亲之间的这条边与$u$的子树内的边配对所能够产生的贡献。</p>
<p>找出最后一次访问到的与$e(u,fa_u)$的覆盖情况相同的边$e’$，如果这条边不在$u$的子树内说明$e(u,fa_u)$无法与子树内的边配对；否则，我们只需要考虑$e(u,fa_u)$与$e’$配对就可以了（因为对每个$x$我们只关心包含了它且离它最近的边对，$e(u,fa_u)$和其它的边配对显然不满足这个条件）。我们找出$e’,e(u,fa_u)$之间还没有找到最近的树边对的点，统计它们的贡献，并把它们标记为已经找到了最近的树边对的点。实现上可以用一个数组$ex[u]$来记录每个点的子树内还没有找到最近树边对的点数；由于$e(u,fa_u)$已经和$e’$配对了，所以$e(u,fa_u)$上方的边不可能与$e(u,fa_u)$和$e’$之间的边配对，因此我们不需要维护$e(u,fa_u),e’$之间的点的$ex$，只对$ex[u]$做出相应的更新就可以了。</p>
<p>总复杂度$O(n+m)$或者$O(n\log n + m)$（取决于使用map还是hash_table）</p>
<p>下面是我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> RNG &#123;</span><br><span class="line">    ull seed=<span class="number">13244074693642402u</span>ll;</span><br><span class="line">    <span class="function">ull <span class="title">rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seed^=seed&lt;&lt;<span class="number">13</span>,seed^=seed&gt;&gt;<span class="number">7</span>,seed^=seed&lt;&lt;<span class="number">17</span>;</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> RNG::rnd;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span> &#123;</span> <span class="keyword">int</span> to,id; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;ed&gt; G[N];</span><br><span class="line">ll ans0,ans1;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">namespace</span> tree &#123;</span><br><span class="line">    <span class="keyword">int</span> In[N],vis[N];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line">    <span class="built_in">set</span>&lt;ull&gt; val;</span><br><span class="line">    ull xi[N];</span><br><span class="line">    <span class="keyword">int</span> vise[M];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) <span class="keyword">if</span>(!vise[G[u][i].id]&amp;&amp;In[G[u][i].to]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[u][i].to; vise[G[u][i].id]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]) &#123;</span><br><span class="line">                ull tmp=rnd();</span><br><span class="line">                val.insert(tmp),xi[u]^=tmp,xi[v]^=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> son[u].PB(v),dfs1(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;ull,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> _size,__size;</span><br><span class="line">    <span class="keyword">int</span> ex[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        ex[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre_c=mp.count(xi[u])?mp[xi[u]]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[u].size();++i)</span><br><span class="line">            <span class="keyword">if</span>(vis[son[u][i]]!=<span class="number">2</span>) dfs3(son[u][i]),ex[u]+=ex[son[u][i]];</span><br><span class="line">        <span class="keyword">int</span> c=mp.count(xi[u])?mp[xi[u]]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c&amp;&amp;c!=pre_c) &#123;</span><br><span class="line">            ans1+=<span class="number">2l</span>l*(ex[u]-ex[c])*(ll)(_size-(ex[u]-ex[c]));</span><br><span class="line">            _size-=ex[u]-ex[c];</span><br><span class="line">            ex[u]=ex[c];</span><br><span class="line">        &#125;</span><br><span class="line">        mp[xi[u]]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[u].size();++i)</span><br><span class="line">            tot+=dfs2(son[u][i]),xi[u]^=xi[son[u][i]];</span><br><span class="line">        <span class="keyword">if</span>(val.count(xi[u])) &#123;</span><br><span class="line">            ans1+=tot*(ll)(__size-tot);</span><br><span class="line">            mp.clear(),_size=tot,dfs3(u);</span><br><span class="line">            vis[u]=<span class="number">2</span>,tot=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        __size=a.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();++i) In[a[i]]=<span class="number">1</span>;</span><br><span class="line">        dfs1(a[<span class="number">0</span>]); val.insert(<span class="number">0</span>);</span><br><span class="line">        dfs2(a[<span class="number">0</span>]);</span><br><span class="line">        val.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();++i) In[a[i]]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) xi[i]=vis[i]=<span class="number">0</span>,son[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) vise[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N],top;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],id;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> lasteid)</span> </span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++id,st[++top]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) <span class="keyword">if</span>(G[u][i].id!=lasteid) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[u][i].to;</span><br><span class="line">        <span class="keyword">if</span>(dfn[v]) low[u]=min(low[u],dfn[v]);</span><br><span class="line">        <span class="keyword">else</span> tarjan(v,G[u][i].id),low[u]=min(low[u],low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u]) &#123;</span><br><span class="line">        <span class="keyword">do</span> a.PB(st[top]); <span class="keyword">while</span>(st[top--]!=u);</span><br><span class="line">        tree::sol(a),ans0+=a.size()*(n-a.size());</span><br><span class="line">        a.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; rd(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        rd(n),rd(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i) &#123;</span><br><span class="line">            rd(x),rd(y);</span><br><span class="line">            G[x].PB((ed)&#123;y,i&#125;),G[y].PB((ed)&#123;x,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        ans0/=<span class="number">2</span>,ans1/=<span class="number">2</span>;</span><br><span class="line">        ll ans2=n*(ll)(n<span class="number">-1</span>)/<span class="number">2</span>-ans0-ans1;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans0+ans1*<span class="number">2</span>+ans2*<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) G[i].clear(),dfn[i]=<span class="number">0</span>; id=top=<span class="number">0</span>;</span><br><span class="line">        ans0=ans1=<span class="number">0</span>;</span><br><span class="line">        tree::init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>组合计数练习题</title>
    <url>/2020/01/15/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="UOJ422-小z的礼物"><a href="#UOJ422-小z的礼物" class="headerlink" title="UOJ422 小z的礼物"></a>UOJ422 小z的礼物</h2><p>考虑min-max容斥：</p>
<script type="math/tex; mode=display">
\max (S) = \sum_{T\subseteq S} (-1)^{|T|+1} \min (T)</script><p>对希望得到的物品的每一个子集，求出期望最早什么时候子集里至少有一个物品被拿到了，就能算出答案。</p>
<p>设包含了至少一个这个子集内的物品的相邻的格子对的数量是$a$，所有的相邻的格子对的数量是$b$，那么这个期望值就是$b\over a$。$a$是一个定值；$b$则可以看做（子集内每一个物品包含它的相邻格子对数量的和）-（同时包含了子集内的两个物品的相邻格子对的数量）。</p>
<p>设$f_{S,t}$表示上一列选了的格子的集合是$S$，之前选过的格子的（子集内每一个物品包含它的相邻格子对数量的和）-（同时包含了子集内的两个物品的相邻格子对的数量）为$t$，所有方案的容斥系数的和。用类似轮廓线dp的方法转移，就可以做到$O(2^n n^2m^2)$的复杂度。</p>
<p><a href="http://uoj.ac/submission/379524" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2320「清华集训-2017」生成树计数"><a href="#LOJ2320「清华集训-2017」生成树计数" class="headerlink" title="LOJ2320「清华集训 2017」生成树计数"></a>LOJ2320「清华集训 2017」生成树计数</h2><p>把原题的式子换一个表达的方式：把每个连通块看做一个点，设$d_i$为每个点的度数，则</p>
<script type="math/tex; mode=display">
val (T) = (\sum_{i=1}^n d_i^m) (\prod_{i=1}^n d_i^m )(\prod_{i=1}^n a_i^{d_i})</script><p>因为式子里面有度数，所以考虑用prufer序列来计数。枚举每一个点在prufer序列中出现的次数$k_i$，得到</p>
<script type="math/tex; mode=display">
Ans = \sum_{k_1+k_2+\cdots +k_n=n-2} {(n-2)!\over k_1!k_2!\cdots k_n!} \cdot \sum_{i=1}^n (k_i+1)^{2m}a_i^{k_i+1} \prod_{j\neq i} (k_j+1)^ma_j^{k_j+1}</script><p>设</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_i(x) = \sum_{k=0}^\infty {a_i^{k+1}(k+1)^m\over k!} x^k\\
B_i(x) = \sum_{k=0}^\infty {a_i^{k+1}(k+1)^{2m} \over k!}x^k
\end{aligned}</script><p>则</p>
<script type="math/tex; mode=display">
Ans= (n-2)!\sum_{i=1}^n (B_i(x)\prod_{j\neq i} A_j(x) )[x^{n-2}]</script><p>因为$A_i(x)$里面有指数为$k+1$，还有$x^k \over k!$，所以尝试对$A_i(x)$积分得到$T(x)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(x) = \sum_{k=0}^\infty {a_i^{k+1}(k+1)^m \over (k+1)!} x^{k+1}\\
=\sum_{k=1}^\infty {a_i^kk^m\over k!}x^k
\end{aligned}</script><p>将$k^m$展开：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(x) = \sum_{k=1}^\infty {a_i^k \over k!} x^k \sum_{j=0}^{\min\{m,k\}} \begin{Bmatrix}m\\ j\end{Bmatrix} {k\choose j} j!
\end{aligned}</script><p>把${k\choose j}j!$与前面的$k!$抵消，得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(x) = \sum_{k=1}^\infty a_i^k x^k \sum_{j=0}^{\min\{m,k\}} {1\over (k-j)!}\begin{Bmatrix}m\\ j\end{Bmatrix}
\end{aligned}</script><p>把$j$提前</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(x) = \sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} \sum_{k=j}^\infty {a_ix^k\over (k-j)!}\\
=\sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} a_i^jx^j \sum_{k=0}^\infty {a_i^kx^k\over k!}\\
=\sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} a_i^jx^j e^{a_ix}
\end{aligned}</script><p>然后对$T(x)$求导得到$A_i(x)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_i(x) = T'(x)\\
=\sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} (j \cdot a_i^jx^{j-1} e^{a_ix} + a_i \cdot a_i^jx^j e^{a_ix}) \\
=\sum_{j=0}^{m} \begin{Bmatrix}m\\ j+1\end{Bmatrix} (j+1)( a_i^{j+1}x^je^{a_ix}) + \sum_{j=0}^{m} \begin{Bmatrix}m\\ j\end{Bmatrix} (a_i^{j+1} x^j e^{a_ix}) \\
= \sum_{j=0}^{m}(\begin{Bmatrix}m\\ j+1\end{Bmatrix} (j+1)+\begin{Bmatrix}m\\ j\end{Bmatrix} ) a_i^{j+1}x^je^{a_ix}\\
= e^{a_ix}\sum_{j=0}^{m}\begin{Bmatrix}m+1\\ j+1\end{Bmatrix} a_i^{j+1}x^j\\
\end{aligned}</script><p>对$B_i(x)$同理，得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
B_i(x) = e^{a_ix}\sum_{j=0}^{2m}\begin{Bmatrix}2m+1\\ j+1\end{Bmatrix} a_i^{j+1}x^j\\
\end{aligned}</script><p>所以</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n B_i(x)\prod_{j\neq i} A_i(x)\\
= e^s \sum_{i=1}^n (\sum_{j=0}^{2m}\begin{Bmatrix}2m+1\\ j+1\end{Bmatrix} a_i^{j+1}x^j) \prod_{k\neq i}(\sum_{j=0}^{m}\begin{Bmatrix}m+1\\ j+1\end{Bmatrix} a_k^{j+1}x^j)\\
\end{aligned}</script><p>上式可以分治NTT求出。</p>
<p><a href="https://loj.ac/submission/719326" target="_blank" rel="noopener">Code</a></p>
<h2 id="ARC062D-Painting-Graphs-with-AtCoDeer"><a href="#ARC062D-Painting-Graphs-with-AtCoDeer" class="headerlink" title="ARC062D Painting Graphs with AtCoDeer"></a>ARC062D Painting Graphs with AtCoDeer</h2><p>每一个边双连通分量显然是独立的。所有边双的本质不同的染色方案数的乘积即是答案。</p>
<p>如果一个边双只包含一条边，那么答案显然是$K$。</p>
<p>如果一个边双恰好只有一个简单环，则是一个经典的Polya（有$K$种颜色的珠子，问有多少种旋转置换下本质不同的项链）。</p>
<p>而如果一个边双包含多于一个环，则从下面的图（来自<a href="http://arc062.contest.atcoder.jp/data/arc/062/editorial.pdf" target="_blank" rel="noopener">官方题解</a>）可以看出，通过若干次操作我们可以交换一对相邻的边（下图中交换了绿色和蓝色的边）。故而两个给这个边双染色的方案是本质不同的，当且仅当它们染成某种颜色的边的数量不同。所以方案数为${K+C-1\choose K-1}$，其中$C$为这个边双内的边数。</p>
<p><img src="https://i.loli.net/2020/01/15/gPTJSesGaVAMH6E.png" alt="image.png"></p>
<p><a href="https://atcoder.jp/contests/arc062/submissions/9511619" target="_blank" rel="noopener">Code</a></p>
<h2 id="HDU6402-Boolean-3-Array"><a href="#HDU6402-Boolean-3-Array" class="headerlink" title="HDU6402 Boolean 3-Array"></a>HDU6402 Boolean 3-Array</h2><p>可以参考<a href="https://projecteuler.net/problem=626" target="_blank" rel="noopener">PE626</a>，它是这道题的低维情形。</p>
<p>下文中的$A,B,C$表示原题中每一维的大小。</p>
<p>考虑简化题目中的置换：令$p_a,p_b,p_c$为三个长度分别为$A,B,C$的排列，每个排列的第$i$个元素表示这个维度上的swap操作使得最初的第$i$层到了哪个位置，令$a_i,b_i,c_i$分别表示每一维的第$i$层进行的翻转操作次数的奇偶性。我们规定先进行$p_a,p_b,p_c$的操作，再进行$a,b,c$的操作。那么原题中的一系列操作的结果将唯一对应到一组$(p_a,p_b,p_c,a,b,c)$。</p>
<p>利用Burnside lemma，数每一个置换的不动点数目。</p>
<p>先只考虑swap操作。枚举$p_a,p_b,p_c$的循环节，假设当前枚举到的循环节长度分别为$la,lb,lc$，考虑循环节中的方块对应的那个$la\times lb\times lc$的正方体。将每个点$(x,y,z)$与$({p_a}_x,{p_b}_y,{p_c}_z)$连边，则这些方块恰好会分裂成$la\cdot lb\cdot lc\over \operatorname{lcm}\{la,lb,lc\}$个连通块（并且每个连通块都是一个环）。显然每个连通块内的格子必须填同一个数，不同连通块的格子没有影响。</p>
<p>考虑flip操作对每一个连通块的影响：记$d_{x,y,z} = (a_x+b_y+c_z) \bmod 2$，则如果连通块内所有点的$\sum d_{x,y,z}$为奇数，则不存在不动点；否则，如下图，环上打了叉的点表示$d_{x,y,z}=1$的点，箭头表示置换的方向：</p>
<p><img src="https://i.loli.net/2020/01/15/iVUJvFXzDeO653Y.jpg" alt="1.jpg"></p>
<p>那么显然只有两种填数方案是不动点：</p>
<p><img src="https://i.loli.net/2020/01/15/hxeA8qLUlyd9QFX.jpg" alt="2.jpg"><br><img src="https://i.loli.net/2020/01/15/dRp3DWlBGZsJjEV.jpg" alt="3.jpg"></p>
<p>首先枚举$p_a,p_b,p_c$的每种长度的循环节的出现次数（设$k_i,l_i$表示长度为$l_i$的循环节出现了$k_i$次，那么对应的排列数是$n!\over \prod l_i^{k_i} k_i!$），然后求出对于每一组循环节的每一个连通块都满足$\sum d_{x,y,z} \equiv 0 \pmod 2$的$a,b,c$的数量，就能够快速统计贡献。</p>
<p>我们考虑某一组循环节（那个$la\times lb\times lc$的正方体）的某一个连通块对$a,b,c$的限制，设循环节包含的每个维度的下标集合为$a’,b’,c’$，则限制为</p>
<script type="math/tex; mode=display">
\sum_{x\in a'} a_x \operatorname{lcm}{\{la,lb,lc\}\over la} +\sum_{x\in b'} b_x \operatorname{lcm}{\{la,lb,lc\}\over lb} + \sum_{x\in c'} c_x {\operatorname{lcm}\{la,lb,lc\}\over lc} \equiv 0 \pmod 2</script><p>现在将每一个$a_x,b_x,c_x$看做未知数，则问题转化成求方程的解数，是一个经典的线性基问题。</p>
<p>由于数据范围很小，可以直接打表。</p>
<p>下面是我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;x=x*(ll)x%mod,y&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*(ll)x%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lcm[<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">20</span>],inv[<span class="number">20</span>],ipw[<span class="number">8000</span>],pw[<span class="number">8000</span>];</span><br><span class="line"><span class="keyword">int</span> Inv[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;PII&gt; &gt; g[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">namespace</span> Mat &#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;39&gt; f[<span class="number">39</span>],b;</span><br><span class="line">    <span class="keyword">int</span> m,cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) f[i].reset(); m=len,cnt=<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;r;++i) b[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"INS:"; for(int i=0;i&lt;m;++i) cout&lt;&lt;(b[i]==1); cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="keyword">if</span>(b[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][i]) b^=f[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i]=b,cnt++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cnt; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i,<span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) <span class="built_in">cout</span>&lt;&lt;(f[i][j]==<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> predo_calc &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b?gcd(b,a%b):a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCM</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a/gcd(a,b)*b; &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; s;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tot==cur) &#123; g[cur].PB(s); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot+u&gt;cur) <span class="keyword">return</span>;</span><br><span class="line">        dfs(u+<span class="number">1</span>,tot);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;tot+j*u&lt;=cur;++j) &#123;</span><br><span class="line">            s.PB(MP(u,j));</span><br><span class="line">            dfs(u+<span class="number">1</span>,tot+j*u);</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getpw</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        pw[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">2l</span>l%mod;</span><br><span class="line">        ipw[n]=Pow(pw[n],mod<span class="number">-2</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) ipw[i<span class="number">-1</span>]=ipw[i]*<span class="number">2l</span>l%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">predo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) Inv[i]=Pow(i,mod<span class="number">-2</span>);</span><br><span class="line">        fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=fac[i<span class="number">-1</span>]*(ll)i%mod;</span><br><span class="line">        inv[n]=Pow(fac[n],mod<span class="number">-2</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) inv[i<span class="number">-1</span>]=inv[i]*(ll)i%mod;</span><br><span class="line">        getpw(n*n*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">                    lcm[i][j][k]=LCM(LCM(i,j),k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cur=i,dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> A,<span class="keyword">int</span> B,<span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa=<span class="number">0</span>;pa&lt;g[A].size();++pa)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pb=<span class="number">0</span>;pb&lt;g[B].size();++pb)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pc=<span class="number">0</span>;pc&lt;g[C].size();++pc) &#123;</span><br><span class="line">        <span class="keyword">int</span> tans=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;PII&gt; &amp;pA=g[A][pa],&amp;pB=g[B][pb],&amp;pC=g[C][pc];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pA.size();++j) tans=tans*(ll)inv[pA[j].SEC]%mod*Pow(Inv[pA[j].FIR],pA[j].SEC)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pB.size();++j) tans=tans*(ll)inv[pB[j].SEC]%mod*Pow(Inv[pB[j].FIR],pB[j].SEC)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pC.size();++j) tans=tans*(ll)inv[pC[j].SEC]%mod*Pow(Inv[pC[j].FIR],pC[j].SEC)%mod;</span><br><span class="line">        Mat::init(A+B+C);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> iA=<span class="number">0</span>,tA=<span class="number">0</span>;iA&lt;pA.size();++iA)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> jA=<span class="number">0</span>;jA&lt;pA[iA].SEC;++jA,tA+=pA[iA].FIR)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> iB=<span class="number">0</span>,tB=A;iB&lt;pB.size();++iB)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> jB=<span class="number">0</span>;jB&lt;pB[iB].SEC;++jB,tB+=pB[iB].FIR)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> iC=<span class="number">0</span>,tC=A+B;iC&lt;pC.size();++iC)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> jC=<span class="number">0</span>;jC&lt;pC[iC].SEC;++jC,tC+=pC[iC].FIR) &#123;</span><br><span class="line">                    <span class="keyword">int</span> a=pA[iA].FIR,b=pB[iB].FIR,c=pC[iC].FIR;</span><br><span class="line">                    tans=tans*(ll)pw[a*b*c/lcm[a][b][c]]%mod;</span><br><span class="line">                    Mat::ins(tA,tA+pA[iA].FIR,lcm[a][b][c]/a);</span><br><span class="line">                    Mat::ins(tB,tB+pB[iB].FIR,lcm[a][b][c]/b);</span><br><span class="line">                    Mat::ins(tC,tC+pC[iC].FIR,lcm[a][b][c]/c);</span><br><span class="line">                    Mat::Ins();</span><br><span class="line">                &#125;</span><br><span class="line">        tans=tans*(ll)pw[A+B+C-Mat::sol()]%mod;</span><br><span class="line">        <span class="comment">// Mat::Debug();</span></span><br><span class="line">        ans=(ans+tans)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans*(ll)ipw[A+B+C]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    predo_calc::predo(<span class="number">13</span>);</span><br><span class="line">    <span class="keyword">int</span> T; rd(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> A,B,C; rd(A),rd(B),rd(C);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sol(A,B,C)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>单位根反演练习题</title>
    <url>/2020/01/14/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="loj6485-LJJ学二项式定理"><a href="#loj6485-LJJ学二项式定理" class="headerlink" title="loj6485 LJJ学二项式定理"></a>loj6485 LJJ学二项式定理</h2><p>首先枚举$i\pmod 4$的余数$t$，然后转化成对于每一个$t$，求</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^n {n\choose i}s^i [ 4\mid (i-t) ]
\end{aligned}</script><p>单位根反演：</p>
<script type="math/tex; mode=display">
\begin{aligned}
= \sum_{i=0}^n {n\choose i}s^i {1\over 4}\sum_{j=0}^3 \omega_{4}^{j(i-t)}\\
= {1\over 4} \sum_{j=0}^3 \omega_{4}^{-jt} \sum_{i=0}^n {n\choose i}s^i w_4^{ij}
\end{aligned}</script><p>最后面的那一坨东西，由二项式定理知$(1+x)^n = \sum_{i=0}^n {n\choose i}x^i$，所以：</p>
<script type="math/tex; mode=display">
= {1\over 4} \sum_{j=0}^3 \omega_{4}^{-jt} (s\omega_4^j + 1)^n</script><p>直接算就可以了。</p>
<p><a href="https://loj.ac/submission/715070" target="_blank" rel="noopener">Code</a></p>
<h2 id="uoj450【集训队作业2018】复读机"><a href="#uoj450【集训队作业2018】复读机" class="headerlink" title="uoj450【集训队作业2018】复读机"></a>uoj450【集训队作业2018】复读机</h2><p>考虑一个复读机复读次数的生成函数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(x) = \sum_{i=0}^{\infty} {x^i\over i!} [d\mid i]
\end{aligned}</script><p>而我们要算的实际上是$n! \cdot F^k(x) [x^n]$。</p>
<p>对$F(x)$进行单位根反演：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(x) = {1\over d}\sum_{i=0}^{\infty} {x^i\over i!} \sum_{j=0}^{d-1} \omega^{ij}\\
= {1\over d}\sum_{j=0}^{d-1} \sum_{i=0}^{\infty} {x^iw^{ij}\over i!}\\
= {1\over d} \sum_{j=0}^{d-1} e^{\omega^j x}
\end{aligned}</script><p>$1\over d$是常数，我们先把它忽视掉，最后再在答案里乘上一个$1\over d^k$。</p>
<p>考虑$F^k(x)$的组合意义，相当于对于这$k$个多项式，从每一个里面选一项相乘，所有的方案得到的乘积的和。枚举$e^{\omega^jx}$被选的次数$p_j$，得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
F^k (x) = \sum_{p_0+p_1\cdots p_{d-1}=k}k!\prod_{j=0}^{d-1} {1\over p_j!}e^{p_j \omega_jx}\\
= \sum_{p_0+p_1\cdots p_{d-1}=k} e^{(\sum_{j=0}^{d-1}p_jw_j)x} \cdot k!\prod_{j=0}^{d-1} {1\over p_j!}
\end{aligned}</script><p>而</p>
<script type="math/tex; mode=display">
F^k (x) [ x^n ] = \sum_{p_0+p_1\cdots p_{d-1}=k} {(\sum_{j=0}^{d-1}p_jw_j)^n \over n!} \cdot k!\prod_{j=0}^{d-1} {1\over p_j!}</script><p>直接计算，复杂度$O(k^d \log n)$。</p>
<p><a href="http://uoj.ac/submission/376702" target="_blank" rel="noopener">Code</a></p>
<h2 id="bzoj3328-PYXFIB"><a href="#bzoj3328-PYXFIB" class="headerlink" title="bzoj3328 PYXFIB"></a>bzoj3328 PYXFIB</h2><p>设</p>
<script type="math/tex; mode=display">
\begin{aligned}
A = \begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}\\
B = \begin{bmatrix} 1\\1 \end{bmatrix}
\end{aligned}</script><p>则我们相当于要求出</p>
<script type="math/tex; mode=display">
(\sum_{i=0}^n {n\choose i} A^i [k\mid i] )B</script><p>对前面的那个括号里面的东西单位根反演，得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
{1\over k} \sum_{j=0}^{k-1} \sum_{i=0}^n {n\choose i}A^i\omega^{ij}\\
= {1\over k} \sum_{j=0}^{k-1} (\omega^j\cdot A + E)^n 
\end{aligned}</script><p>其中$E$表示单位矩阵。</p>
<p>直接矩阵快速幂计算，时间复杂度为$O(2^3 \cdot \log n \cdot k)$。</p>
<h2 id="loj3058-「HNOI2019」白兔之舞"><a href="#loj3058-「HNOI2019」白兔之舞" class="headerlink" title="loj3058 「HNOI2019」白兔之舞"></a>loj3058 「HNOI2019」白兔之舞</h2><p>设矩阵$A$是满足$A_{i,j} = w(i,j)$的$n\times n$的矩阵。</p>
<p>走$m$步的方案数为${L\choose m}T_{x,y}$，其中$T=A^m$。</p>
<p>则对于每一个$t$，我们需要求出</p>
<script type="math/tex; mode=display">
\sum_{m=0}^L {L\choose m}A^m [k\mid (t-m)]</script><p>单位根反演之后得到</p>
<script type="math/tex; mode=display">
{1\over k}\sum_{j=0}^{k-1} \omega_k^{-tj}(\omega_k^jA + E)^L</script><p>对于每一个$j$，分别算出$F_j = (\omega_k^j A+ E)^L$，设$f_j$为$F_j$的$x$行$y$列的元素，则$t$的答案就是</p>
<script type="math/tex; mode=display">
Ans_t = {1\over k}\sum_{j=0}^{k-1} f_j \omega_k^{-tj}</script><p>由于$-tj={t\choose 2}+{j\choose 2}-{t+j\choose 2}$，所以</p>
<script type="math/tex; mode=display">
Ans_t = {1\over k}\cdot \omega_k^{t\choose 2} \sum_{j=0}^{k-1} (f_j\cdot \omega_k^{j\choose 2} ) \omega_k^{-{i+j\choose 2}}</script><p>这是一个卷积的形式，用MTT优化一下就可以了。</p>
<p>总时间复杂度$O(kn^3\log L + k\log k)$。</p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望练习题</title>
    <url>/2020/01/14/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="CF963E-Circles-of-Waiting"><a href="#CF963E-Circles-of-Waiting" class="headerlink" title="CF963E Circles of Waiting"></a>CF963E Circles of Waiting</h2><p>圆内的整点形成了一个类似方阵的结构。设$f_{x,y}$为$(x,y)$期望被经过的次数。我们可以对每一个点列出一个方程：</p>
<script type="math/tex; mode=display">
f_{x,y} = {p_0} f_{x+1,y} + p_1 f_{x,y+1} +p_2 f_{x-1,y} + p_3f_{x,y-1} + [(x,y)=(0,0)]</script><p>将每一行最左侧的点设为主元，其它的点都用主元表示。从左往右考虑每一列的点：$f_{x,y}$可以用$f_{x-1,y}$的方程表示出来（因为方程中涉及到的$f_{x-1,y},f_{x-1,y-1},f_{x-1,y+1},f_{x-2,y}$在之前都已经考虑过了，只有$f_{x,y}$是未知的）。</p>
<p>这样过后，每一行最右侧的点对应的方程我们还没有用过，用这些方程一定可以解出主元的值，然后再带回去就可以得到每个点的期望被经过次数。</p>
<p>时间复杂度$O(R^3)$。</p>
<p><a href="https://codeforces.com/contest/963/submission/68692851" target="_blank" rel="noopener">Code</a></p>
<h2 id="CTSC2006-歌唱王国"><a href="#CTSC2006-歌唱王国" class="headerlink" title="CTSC2006 歌唱王国"></a>CTSC2006 歌唱王国</h2><p>题号：luogu4548, bzoj1152</p>
<p>设$f_i$为加入第$i$个字符的时候恰好结束的概率，$g_i$为加入$i$个字符之后还没有结束的概率。设$F(x) = \sum_{i=0}^\infty f_i x^i, G(x) = \sum_{i=0}^\infty g_ix^i$。</p>
<p>则有$G(x)x - F(x) = G(x) - 1$，即：$g_{i-1}-f_i = g_i$。</p>
<p>由$F(x)$的定义我们知道$F(1)=1$，即在每一轮结束的概率的和是$1$。</p>
<p>而我们要求的答案是$F’(1)$。</p>
<p>再设$H(x) = \sum_{i=j}^{m}x^{m-j} ({1\over n})^{m-j} [s_1s_2\cdots s_j\text{is a border of s}]$。</p>
<p>则</p>
<script type="math/tex; mode=display">
G(x) ({1\over n})^mx^m = F(x) H(x)</script><p>这里$F(x)$的意义相当于是枚举了，$G(x)$在末尾加上一个$s$之后，最早在什么位置出现了完整的$s$。</p>
<p>带入$x=1$得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
G(1) ({1\over n})^m = F(1) H(1)\\
G(1) = n^m H(1)
\end{aligned}</script><p>此外</p>
<script type="math/tex; mode=display">
G(x)x-F(x) = G(x)-1</script><p>两边同时求导得到</p>
<script type="math/tex; mode=display">
G(x) + G'(x)x - F'(x) = G'(x)</script><p>带入$x=1$</p>
<script type="math/tex; mode=display">
\begin{aligned}
G(1) + G'(1) - F'(1) = G'(1)\\
G(1) = F'(1)
\end{aligned}</script><p>所以答案就是$n^m H(1)$。</p>
<h2 id="PE522"><a href="#PE522" class="headerlink" title="PE522"></a><a href="https://projecteuler.net/problem=522" target="_blank" rel="noopener">PE522</a></h2><p>如果所有的连通块都是孤立的环（没有叶子），那么答案是环数。</p>
<p>否则敲定一个不为孤立的环的连通块，对于这个连通块每一个入度为$0$的点，把某个入度大于$1$的点的某一个儿子拿过来接在它的下面（接过来的部分如果还有入度为$0$的点，就重复前面的操作）。</p>
<p>如果图内存在孤立的环，就还必须在上述过程的最后一次操作之前（此时我们敲定的那个连通块内恰好只有一个叶子）对每一个孤立的环进行额外的操作：把环断成链接在叶子的下面。</p>
<p>综上所述，一张图的答案为叶子数+孤立的环数。</p>
<p>叶子数总和为：</p>
<script type="math/tex; mode=display">
n ((n-2)^{n-1} \cdot (n-1))</script><p>也就是每个点成为叶子的方案数。</p>
<p>孤立的环的数量总和为</p>
<script type="math/tex; mode=display">
\sum_{i=2}^n {n\choose i} (i-1)!(n-i-1)^{n-i}</script><p>每一个长度为$i$的环出现的方案数是$(n-i-1)^{n-i}$，而这样的环有${n\choose i} \cdot (i-1)!$个。</p>
<h2 id="CF457D-Bingo"><a href="#CF457D-Bingo" class="headerlink" title="CF457D Bingo!"></a>CF457D Bingo!</h2><p>考虑$2^s$的组合意义，也就是一个大小为$s$的集合的子集数量。所以权值的期望也就是：每一个行、列的子集在最后的矩阵中只包含了那$k$个数的概率的和。</p>
<p>假设某一个子集包含了$t$个格子，那么它只包含了那$k$个数的概率是$f_t = {P_k^t \over P_m^t}$。直接预处理阶乘来计算$f_t$无法用long double存下；推导可得$f_t = f_{t-1} \cdot {k-t+1\over m-t+1}$，由这个递推计算就可以避免上面的问题。</p>
<p>最后的答案就是</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n \sum_{j=0}^n {n\choose i}{n\choose j} f_{(i+j)n-ij}</script><p><a href="https://codeforces.com/contest/457/submission/68708656" target="_blank" rel="noopener">Code</a></p>
<h2 id="UOJ352-新年的五维几何"><a href="#UOJ352-新年的五维几何" class="headerlink" title="UOJ352 新年的五维几何"></a>UOJ352 新年的五维几何</h2><p>对于所有$l_i=r_i$的变量，考虑它们对其它变量的取值范围的影响，然后把这些变量删掉。</p>
<p>不妨将$l_i \le x_i \le r_i$看做$l_i \le x_i &lt; r_i$，两者算出来的答案是一样的。所以$x_i$的整数部分的取值范围是$[l_i,r_i)$。</p>
<p>我们首先枚举$x_i$的小数部分的大小关系，然后暴搜整数部分的合法的取值方案。由于$a_{i,j}$都是整数，所以$x_i - x_j \ge a_{i,j}$是否被满足只取决于$x_i$和$x_j$的整数部分和它们小数部分的大小关系。</p>
<p>时间复杂度$O(n!\prod_i(r_i-l_i))$。</p>
<p><a href="http://uoj.ac/submission/379410" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
</search>
