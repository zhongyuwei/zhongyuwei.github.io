<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BZOJ3289 Mato的文件管理</title>
    <url>/2020/02/29/BZOJ3289-Mato%E7%9A%84%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>设 $s(l_1,r_1,l_2,r_2) = \sum_{i\in [l_1,r_1]} \sum_{j\in [l_2,r_2]} [i &lt; j \wedge a_i &gt; a_j]$ 。</p>
<p>考虑莫队算法，当右端点从$r$移动到$r+1$的时候，答案的改变量是</p>
<script type="math/tex; mode=display">
s(l,r-1,r,r) = s(1,r-1,r,r) - s(1,l-1,r,r)</script><p>第一项只与 $r$ 有关，可以预处理；第二项中， $[1,l-1]$ 是整个序列的一段前缀。我们把所有第二项的询问都离线下来，然后扫描线处理。注意到总共有 $O(n)$ 次修改以及 $O(n\sqrt n)$ 次询问，我们用修改 $O(\sqrt n)$ ，查询 $O(1)$ 的分块，即可在 $O(n\sqrt n)$ 的复杂度解决问题。</p>
<p>右端点的左移、左端点的移动都是同理。</p>
<p>总时间复杂度 $O(n\sqrt n)$ ，空间复杂度 $O(n)$ 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],b[N];</span><br><span class="line">ll sl[N],sr[N],qans[N];</span><br><span class="line"><span class="keyword">int</span> bel[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">	<span class="keyword">int</span> c[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) c[i]=<span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">I</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">for</span>(;i&lt;=m;i+=i&amp;-i) c[i]++; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="keyword">for</span>(;i;i-=i&amp;-i) ans+=c[i]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WRY</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,id;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpQ</span><span class="params">(WRY A,WRY B)</span> </span>&#123; <span class="keyword">return</span> bel[A.l]==bel[B.l]?(bel[A.l]&amp;<span class="number">1</span>?A.r&lt;B.r:A.r&gt;B.r):A.l&lt;B.l; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,id,ty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Qry&gt; Pl[N],Pr[N];</span><br><span class="line"><span class="keyword">namespace</span> sol2 &#123;</span><br><span class="line">	<span class="keyword">int</span> bel[N];</span><br><span class="line">	<span class="keyword">int</span> s1[M],s0[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">I</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=x;bel[i]==bel[x];++i) s0[i]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=bel[x];i&lt;=bel[m];++i) s1[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> s1[bel[x]<span class="number">-1</span>]+s0[x]; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> T=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(m));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) bel[i]=(i<span class="number">-1</span>)/T+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">			I(m-a[i]+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Pl[i].size();++j)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=Pl[i][j].l;x&lt;=Pl[i][j].r;++x)</span><br><span class="line">					qans[Pl[i][j].id]+=Pl[i][j].ty*Q(m-a[x]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) s0[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=bel[m];++i) s1[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) &#123;</span><br><span class="line">			I(a[i]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Pr[i].size();++j)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=Pr[i][j].l;x&lt;=Pr[i][j].r;++x)</span><br><span class="line">					qans[Pr[i][j].id]+=Pr[i][j].ty*Q(a[x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cid,L,R;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addR</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	qans[cid]+=t*sr[R];</span><br><span class="line"><span class="comment">//	Pl[L-1].PB(MP(R,-t*cid));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addL</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;	</span><br><span class="line">	qans[cid]+=t*sl[L];</span><br><span class="line"><span class="comment">//	Pr[R+1].PB(MP(L,-t*cid));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]),b[i]=a[i];</span><br><span class="line">	sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>),m=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=lower_bound(b+<span class="number">1</span>,b+m+<span class="number">1</span>,a[i])-b;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) sr[i]=BIT::Q(m-a[i]+<span class="number">1</span>),BIT::I(m-a[i]+<span class="number">1</span>); BIT::init();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) sl[i]=BIT::Q(a[i]),BIT::I(a[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> T=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) bel[i]=(i<span class="number">-1</span>)/T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> q; rd(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) rd(Q[i].l),rd(Q[i].r),Q[i].id=i;</span><br><span class="line">	sort(Q+<span class="number">1</span>,Q+q+<span class="number">1</span>,cmpQ);</span><br><span class="line">	L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) &#123;</span><br><span class="line">		cid=Q[i].id;</span><br><span class="line">		<span class="keyword">if</span>(R&lt;Q[i].r) Pl[L<span class="number">-1</span>].PB((Qry)&#123;R+<span class="number">1</span>,Q[i].r,cid,<span class="number">-1</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(R&gt;Q[i].r) Pl[L<span class="number">-1</span>].PB((Qry)&#123;Q[i].r+<span class="number">1</span>,R,cid,<span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">while</span>(R&lt;Q[i].r) R++,addR(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(R&gt;Q[i].r) addR(<span class="number">-1</span>),R--;</span><br><span class="line">		<span class="keyword">if</span>(L&gt;Q[i].l) Pr[R+<span class="number">1</span>].PB((Qry)&#123;Q[i].l,L<span class="number">-1</span>,cid,<span class="number">-1</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(L&lt;Q[i].l) Pr[R+<span class="number">1</span>].PB((Qry)&#123;L,Q[i].l<span class="number">-1</span>,cid,<span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">while</span>(L&gt;Q[i].l) --L,addL(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(L&lt;Q[i].l) addL(<span class="number">-1</span>),L++;</span><br><span class="line">	&#125;</span><br><span class="line">	sol2::main();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) qans[Q[i].id]+=qans[Q[i<span class="number">-1</span>].id];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,qans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>lemon配置捆绑测试</title>
    <url>/2020/02/27/lemon%E9%85%8D%E7%BD%AE%E6%8D%86%E7%BB%91%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>首先添加试题，然后选择“添加多组测试点”。</p>
<p><img src="https://i.loli.net/2020/02/27/RnLUOyA6zrCSgFE.jpg" alt="0.jpg"></p>
<p>在出现的测试点添加向导中，可以直接点击下一步。每个测试点（也就是每个子任务）的时间、空间限制以及分值都是可以在配置完成之后单独调整的。</p>
<p><img src="https://i.loli.net/2020/02/27/L4rGlw7BzxXKODt.jpg" alt="1.jpg"></p>
<p>在输入输出文件格式中，输入 <code>试题名称\文件名称格式</code> 。</p>
<p>其中，打了勾的正则表达式，表示这一项相同的会在同一个测试点（即子任务）中。</p>
<p>可以用 <code>\d*</code> 或者 <code>[0-9]*</code> 来匹配任意数量的数字。</p>
<p>例如，我的第 i 个子任务的第 j 组数据的文件名是 <code>i_j.in/ans</code>，就可以这样写：</p>
<p><img src="https://i.loli.net/2020/02/27/RUvsoZQY59OB1br.jpg" alt="2.jpg"></p>
<p>点击下一步之后，就可以预览配置的结果。如果有问题，则可以点击左上角的箭头返回上一步修改。</p>
<p><img src="https://i.loli.net/2020/02/27/7xGAfcTWSHm8KeX.jpg" alt="3.jpg"></p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ2498 Xavier is Learning to Count</title>
    <url>/2020/02/22/BZOJ2498-Xavier-is-Learning-to-Count/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>容易想到$O(Bell(P))$地枚举$P$的集合划分，然后进行容斥（强制同一个集合里的数取值相同），但是容斥系数应该如何取呢？</p>
<p>对于一个大小为$x$的集合，设它的容斥系数为$f_x$。一种集合划分的容斥系数为每个集合的容斥系数的乘积。</p>
<p>对于某一种选$P$个数的方案，假设其中第$a_{1,1},a_{1,2},\cdots a_{1,k_1}$个数相同，第$a_{2,1},a_{2,2},\cdots a_{2,k_2}$个数相同，……第$a_{m,1},a_{m,2},\cdots a_{m,k_m}$个数相同，那么这种方案将会被计算的次数是</p>
<script type="math/tex; mode=display">
\prod_{i=1}^m (\sum_{\{S_1,S_2\cdots S_l\}是\{a_{i,1},a_{i,2},\cdots a_{i,k_i}\}的集合划分} \prod_{j=1}^l f(|S_j|))</script><p>根据定义我们需要让这个式子在至少有一个$k_i &gt; 1$的时候为$0$，所有的$k_i$都为$1$的时候为$1$。</p>
<p>记</p>
<script type="math/tex; mode=display">
g(n) = \sum_{\{S_1,S_2\cdots S_l\}是\{1,2,\cdots n\}的集合划分} \prod_{j=1}^l f(|S_j|)</script><p>我们相当于是要让</p>
<script type="math/tex; mode=display">
g(n) = [ n = 1]</script><p>枚举$n$所属的集合的大小得</p>
<script type="math/tex; mode=display">
g(n) = \sum_{i=1}^n \binom{n-1}{i-1} g(n-i) f(i)</script><p>因为$\forall i&gt;1, g(i)=0$，所以</p>
<script type="math/tex; mode=display">
g(n) = (n-1) \cdot f(n-1) + f(n) =0</script><p>令$f(n) = -(n-1)f(n-1), f(1) = 1$，也就是$f(i) = (-1)^{i-1}(i-1)!$，即得到一组满足条件的容斥系数。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> db Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Comp</span> &#123;</span></span><br><span class="line">    db a,b;</span><br><span class="line">    Comp (db a=<span class="number">0</span>,db b=<span class="number">0</span>): a(a),b(b) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> *(Comp A,Comp B)&#123;<span class="keyword">return</span> Comp(A.a*B.a-A.b*B.b,A.a*B.b+A.b*B.a);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> +(Comp A,Comp B)&#123;<span class="keyword">return</span> Comp(A.a+B.a,A.b+B.b);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> -(Comp A,Comp B)&#123;<span class="keyword">return</span> Comp(A.a-B.a,A.b-B.b);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> /(Comp A,db B)&#123;<span class="keyword">return</span> Comp(A.a/B,A.b/B);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> *(Comp A,db B)&#123;<span class="keyword">return</span> Comp(A.a*B,A.b*B);&#125;</span><br><span class="line">    <span class="function">Comp <span class="title">conj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Comp(a,-b);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;l);++i) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;l<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Comp A[],<span class="keyword">int</span> len,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) <span class="keyword">if</span>(rev[i]&lt;i) swap(A[i],A[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Comp wn=Comp(<span class="built_in">cos</span>(<span class="number">2</span>*Pi/l),f*<span class="built_in">sin</span>(<span class="number">2</span>*Pi/l));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=l)</span><br><span class="line">        &#123;</span><br><span class="line">            Comp w=Comp(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;i+(l&gt;&gt;<span class="number">1</span>);++k,w=w*wn)</span><br><span class="line">            &#123;</span><br><span class="line">                Comp t1=A[k],t2=A[k+(l&gt;&gt;<span class="number">1</span>)]*w;</span><br><span class="line">                A[k]=t1+t2,A[k+(l&gt;&gt;<span class="number">1</span>)]=t1-t2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[i]=A[i]/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Comp A[<span class="number">6</span>][N],B[N];</span><br><span class="line">db frac[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,len;</span><br><span class="line"><span class="keyword">int</span> buc[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> mx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==m+<span class="number">1</span>) &#123;</span><br><span class="line">		db coe=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i) coe*=frac[buc[i]<span class="number">-1</span>]*(buc[i]&amp;<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j) &#123;</span><br><span class="line">			Comp t=Comp(coe,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i) t=t*A[buc[i]][j];</span><br><span class="line">			B[j]=B[j]+t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx+<span class="number">1</span>;++i)</span><br><span class="line">		buc[i]++,dfs(u+<span class="number">1</span>,max(i,mx)),buc[i]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	frac[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i) frac[i]=frac[i<span class="number">-1</span>]*i;</span><br><span class="line">	<span class="keyword">int</span> T,cas=<span class="number">0</span>; rd(T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> num; rd(num),rd(m);</span><br><span class="line">		n=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=num;++i) &#123;</span><br><span class="line">			rd(x);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) A[j][x*j].a+=<span class="number">1</span>;</span><br><span class="line">			n=max(n,x*m);</span><br><span class="line">		&#125;</span><br><span class="line">		len=<span class="number">1</span>; <span class="keyword">int</span> cnt=<span class="number">0</span>; <span class="keyword">while</span>(len&lt;=n) len&lt;&lt;=<span class="number">1</span>,cnt++; getr(cnt);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) FFT(A[j],len,<span class="number">1</span>);</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		FFT(B,len,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++cas);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) &#123;</span><br><span class="line">			db ans=B[i].a/frac[m];</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;<span class="number">0.5</span>) <span class="built_in">printf</span>(<span class="string">"%d: %.0Lf\n"</span>,i,ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[j][i].a=A[j][i].b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) B[i].a=B[i].b=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3840 【WF2011】Chips Challenge</title>
    <url>/2020/02/21/HDU3840-%E3%80%90WF2011%E3%80%91Chips-Challenge/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>2016年集训队论文的第二篇讲到了这道题，但是论文中的建图方式似乎会出现负环（也有可能是我写炸了？）。下面的建图方法是从KIDGIN7439的<a href="https://blog.csdn.net/KIDGIN7439/article/details/84637086" target="_blank" rel="noopener">这篇博客</a>中看到的，因为觉得原文的阐述十分不清楚，重新阐述如下。</p>
<p>首先枚举$lim$为每一行、每一列的部件数量的最大值。求出在$lim$限制下能个放的最大零件数$tot’$，只要判断$lim \le \lfloor tot’ \cdot \frac{A}{B} \rfloor$是否成立，就能限制为$lim$时是否存在合法的方案，并更新答案。</p>
<p>建图方法：</p>
<ol>
<li>对第$i$行建一个点$A_i$，对第$i$列建一个点$B_i$</li>
<li>从$S$向$A_i$连容量下界为$0$，上界为$lim$，费用为$0$的边</li>
<li>从$B_i$向$T$连容量下界为$0$，上界为$lim$，费用为$0$的边</li>
<li>从$A_i$向$B_i$连容量下界为$0$，上界为$\infty$，费用为$0$的边</li>
<li>如果$(i,j)$这个位置是<code>.</code>，就从$A_i$向$B_j$连一条容量下界为$0$，上界为$1$，费用为$1$的边</li>
<li>如果$(i,j)$这个位置是<code>C</code>，就从$A_i$向$B_j$连一条容量下界为$1$，上界为$1$，费用为$1$的边</li>
</ol>
<p>这张图的最大费用最大流 - <code>C</code>的个数就是答案。</p>
<p>考虑如何满足题目中的几个限制：</p>
<ul>
<li>一个观察是，$S$到$A_i$、$B_i$到$T$的边都会满流<ul>
<li>流量大小 = $S$到$A_i$的边的流量和 = $B_i$到$T$的流量和</li>
<li>存在方案使这些边都满流：只流第2，3，4类边，不流第5类边</li>
<li>我们求的是最大费用最大流</li>
</ul>
</li>
<li>第二观察是，从$A_i$流出的第5，6类边的流量，等于流入$B_i$的第5，6类边的流量，这样就满足了“第$i$行的零件数量等于第$i$列的零件数量<ul>
<li>从$A_i$流出的总流量 = 流入$B_i$的总流量 = $lim$</li>
<li>从$A_i$通过第4类边流出的流量 =通过第4类边流入$B_i$的流量</li>
<li>两式相减即得出上面的观察</li>
</ul>
</li>
<li>从第二个观察也可看出，每个$A_i$流出的第5，6类边的流量不超过$lim$，流入$B_i$的第5，6类边的流量不超过$lim$，也就满足了每行、每列的部件数量不超过$lim$的限制</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> S,T;</span><br><span class="line"><span class="keyword">namespace</span> Flow &#123;</span><br><span class="line">    <span class="keyword">int</span> head[N],cur[N],dis[N],vis[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ed</span> &#123;</span> <span class="keyword">int</span> to,next,f,w; &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ed&gt; e;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e.PB((ed)&#123;y,head[x],f,w&#125;); head[x]=e.size()<span class="number">-1</span>;</span><br><span class="line">        e.PB((ed)&#123;x,head[y],<span class="number">0</span>,-w&#125;); head[y]=e.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="built_in">memcpy</span>(cur,head,<span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(S),vis[S]=<span class="number">1</span>,dis[S]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.front(); q.pop(),vis[u]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=head[u];~k;k=e[k].next) <span class="keyword">if</span>(e[k].f) &#123;</span><br><span class="line">                <span class="keyword">int</span> v=e[k].to;</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&lt;dis[u]+e[k].w) &#123;</span><br><span class="line">                    dis[v]=dis[u]+e[k].w;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[v]) vis[v]=<span class="number">1</span>,q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T]&gt;<span class="number">-1e9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==T||!f) <span class="keyword">return</span> f; <span class="keyword">int</span> ret=<span class="number">0</span>,tmp;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;k=cur[u];~k;k=e[k].next) <span class="keyword">if</span>(e[k].f) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[k].to;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]&amp;&amp;dis[v]==dis[u]+e[k].w&amp;&amp;(tmp=dfs(v,min(f,e[k].f)))) &#123;</span><br><span class="line">                e[k].f-=tmp,e[k^<span class="number">1</span>].f+=tmp;</span><br><span class="line">                ret+=tmp,f-=tmp;</span><br><span class="line">                <span class="keyword">if</span>(!f) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="keyword">while</span>(bfs()) ans+=dis[T]*dfs(S,<span class="number">1e9</span>); <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,A,B;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ts=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;A,&amp;B)) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!n&amp;&amp;!A&amp;&amp;!B) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">		S=<span class="number">2</span>*n+<span class="number">1</span>,T=<span class="number">2</span>*n+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> M=n*n*n+<span class="number">10</span>; <span class="comment">// shoule be larger than length of any possible path</span></span><br><span class="line">		<span class="keyword">int</span> mx=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> lim=n;lim&gt;=<span class="number">0</span>;--lim) &#123;</span><br><span class="line">			Flow::init();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">				Flow::ad(S,i,lim,<span class="number">0</span>),</span><br><span class="line">				Flow::ad(i,i+n,<span class="number">1e9</span>,<span class="number">0</span>),</span><br><span class="line">				Flow::ad(i+n,T,lim,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) &#123;</span><br><span class="line">					<span class="keyword">if</span>(mp[i][j]==<span class="string">'.'</span>) Flow::ad(i,j+n,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">					<span class="keyword">if</span>(mp[i][j]==<span class="string">'C'</span>) Flow::ad(i,j+n,<span class="number">1</span>,M+<span class="number">1</span>),tot++;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">int</span> ans=Flow::work();</span><br><span class="line">			<span class="keyword">if</span>(ans&lt;tot*(M+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">			ans%=M;</span><br><span class="line">			<span class="keyword">if</span>(ans*A&lt;lim*B) <span class="keyword">continue</span>;</span><br><span class="line">			mx=max(mx,ans-tot);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++ts);</span><br><span class="line">		<span class="keyword">if</span>(mx&lt;=<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>PKUWC2020</title>
    <url>/2020/02/20/PKUWC2020/</url>
    <content><![CDATA[<h1 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h1><h2 id="A-排列"><a href="#A-排列" class="headerlink" title="A - 排列"></a>A - 排列</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个$\{1,2,\cdots n\}$的排列$P$。按照字典序从小到大的顺序，依次连接所有字典序不大于$P$的$\{1,2,\cdots n\}$的排列（例如$[2,1,3]$得到的是$[1,2,3,1,3,2,2,1,3]$）。</p>
<p>求得到的序列的本质不同的子序列的数量。$n\le 50$，答案对$998244353$取模。</p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>我们设$A_S[i][j]$表示满足下列条件的子序列$t$的个数：</p>
<ol>
<li>$t$的开头是字符$i$，结尾是字符$j$</li>
<li>$t$不是$S$的子序列</li>
<li>$t$删掉最后一个字符之后是$S$的子序列</li>
</ol>
<p>用$S+T$表示将$T$拼在$S$的后面得到的字符串，则$A_{S+T}[i][j] = \sum_k A_S[i][k] \times A_T[k][j]$。</p>
<p>令$P_i$表示最小的$i!$个排列首尾相接得到的序列。$A_{P_1}$可以直接求得。</p>
<p>考虑如何求得$A_{P_i}$求得$A_{P_{i+1}}$，发现$P_{i+1}$的可以分成$i+1$段，每一段的长度为$i!$，并且每一段与$P_i$的构成是相同的，所以每一段的$A$可以通过$A_{P_i}$交换一些行列得到。</p>
<p>预处理出所有的$A_{P_i}$之后，原序列可以被拆分成若干个极长的段，满足每一段是将末$i$个数进行全排列，将得到的排列按照字典序从小到大拼起来得到的。而这一段的$A$一定能通过$A_{P_i}$交换一些行列得到。</p>
<h2 id="B-火山哥与集合"><a href="#B-火山哥与集合" class="headerlink" title="B - 火山哥与集合"></a>B - 火山哥与集合</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>初始有$n$个集合，第$i$个集合只包含$1$个元素$a_i$。</p>
<p>每一次操作会随机选择两个集合合并。</p>
<p>定义一个集合的价值为这个集合中最大值与最小值的差的平方。定义$f(k)$为进行$n-k$次操作后，所有集合的价值的和的期望。</p>
<p>给出$l,r$，求$\sum_{k\in [l,r]} f(k)^{97376} \pmod {998244353}$</p>
<p>$n\le 2\times 10^5,1\le l\le r\le n,a_i &lt; 998244353$</p>
<h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>设$g(t,k)$表示若最终合并为$k$个集合，某个大小为$t$的集合出现的概率。设$h(i)$表示所有大小为$i$的集合的$( \max - \min )^2$的和。则$f(k)=\sum_{i=1}^n h(i) \cdot g(i,k)$。</p>
<p>将$a$从小到大排序后，可以得到$h(i) = \sum_{l\le r} (a_r-a_l)^2 \cdot {r-l-1\choose i-2}$。先对于每一个$t$算出$\sum_{t=r-l} (a_r-a_l)^2$，然后再算$h(i)$。这两步都可以用NTT做到$O(n\log n)$。</p>
<p>将$n$个集合恰好合并成$k$个的方案数是$\prod_{i=k+1}^n {i\choose 2}$（即第$i$次合并的时候，共有$n-i+1$个集合，所以合并的方案数是$n-i+1\choose 2$）。令$D(n)=\prod_{i=2}^n {i\choose 2}$。</p>
<p>则$g(i,k) = {n-k\choose i-1} \cdot D(i) \cdot {D(n-i)\over D(k-1)} \over {D(n)\over D(k)} = {n-k\choose i-1} \cdot  {k\choose 2} \cdot D(i) \cdot D(n-i) \cdot{1\over D(n)}$</p>
<p>则$f(k) = \sum_i h(i)g(i,k)<br>={k\choose 2} \cdot {1\over D(n)}\sum_i h(i)D(i)D(n-i)\cdot  {n-k\choose i-1}$</p>
<p>这是个卷积的形式，可以NTT优化。</p>
<h2 id="C-数论结构"><a href="#C-数论结构" class="headerlink" title="C - 数论结构"></a>C - 数论结构</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一个$n\times m$的矩阵，初始所有位置的数为$0$。先进行$q_1$次修改操作，给出参数$s,l,r,x$，表示给所有满足$\gcd(s,a)=1,b\in [l,r]$的格子$(a,b)$加上$x$。然后进行$q_2$次询问操作，每次给出$(s,l,r)$，你需要回答所有满足$\gcd(s,a)=1,b\in[l,r]$的格子$(a,b)$的和。</p>
<p>保证修改和询问的$s$随机生成。</p>
<p>$n,q_1\le 50000, m,q_2\le 200000,1\le l\le r\le m, 1\le s\le n$</p>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><p>考虑所有修改$(s_i,l_i,r_i,x_i)$对询问$(s,l,r)$的贡献。</p>
<p>设$Q_d$为所有满足$d\mid s_i$的$i$构成的集合。</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{q_1} card( [ l_i,r_i]\cap [l,r]) x_i \cdot \sum_{j=1}^n [(s_i,j)=1 ] [(s,j)=1] \\
=\sum_{i=1}^{q_1} card( [ l_i,r_i]\cap [l,r]) x_i \cdot \sum_{j=1}^n ( \sum_{d_1\mid (s_i,j)}\mu (d_1) \sum_{d_2\mid (s,j)} \mu(d_2))\\
=\sum_{d_2\mid s} \mu(d_2) \sum_{d_1=1}^{n} \mu(d_1) \lfloor { n\over lcm(d_1,d_2)} \rfloor \cdot \sum_{i\in Q_{d_1}} card( [ l_i,r_i]\cap [l,r]) x_i  \\</script><p>考虑枚举$d_1,d_2$的最大公约数$D$，令$t_1 = {d_1 \over D}, t_2 = {d_2 \over D}$：</p>
<script type="math/tex; mode=display">
原式 = \sum_{D\mid s} \sum_{t_2 \mid {s\over D}} \mu(t_2D) \sum_{t_1=1}^{\lfloor {n\over D} \rfloor}\mu(t_1D) \lfloor {n\over t_1t_2D} \rfloor [(t_1,t_2)=1] \sum_{i\in Q_{t_1D}} card( [ l_i,r_i]\cap [l,r]) x_i \\
= \sum_{D\mid s} \sum_{t_2 \mid {s\over D}} \mu(t_2D) \sum_{t_1=1}^{\lfloor {n\over D} \rfloor}\mu(t_1D) \lfloor {n\over t_1t_2D} \rfloor \sum_{d\mid (t_1,t_2)} \mu(d)\sum_{i\in Q_{t_1D}} card( [ l_i,r_i]\cap [l,r]) x_i \\</script><p>令$T=D\cdot d, u_1 = {t_1\over d} = {d_1 \over T},u_2 = {t_2\over d} = {d_2\over T}$，得到</p>
<script type="math/tex; mode=display">
原式 = \sum_{T\mid s} \sum_{d\mid T} \mu(d) \sum_{u_2 \mid {s\over T}} \mu(u_2T) \sum_{u_1=1}^{\lfloor {n\over T}\rfloor} \mu(u_1T) \lfloor {n\over u_1u_2dT}\rfloor \sum_{i\in Q_{u_1T}} card( [ l_i,r_i]\cap [l,r]) x_i</script><p>在最外层枚举$T$，然后考虑所有的$Q_T$对$A_T$（表示所有$T\mid s_i$的询问）的贡献。</p>
<p>维护一个二维的矩阵。对于每个修改，枚举所有$d\mid T, u_1\in [1,\lfloor {n\over T}\rfloor ]$，然后对于每一个$i \in Q_{u_1T}$把第$\lfloor {n\over u_1dT}\rfloor$行的区间$[l_i,r_i]$加上$x_i \cdot \mu(u_1T) \cdot \mu(d)$。对于每一个询问，枚举所有的$u_2$，然后枚举$t$，则所有满足$\lfloor {j\over u_2} \rfloor = t$的$j$形成一个连续的区间，查这个区间的所有行的$[l_i,r_i]$的元素的和，乘上$t$加入答案中。</p>
<p>修改的复杂度：</p>
<script type="math/tex; mode=display">
\sum_{T=1}^n \sum_{d\mid T} \sum_{u_1=1}^{\lfloor {n\over T}\rfloor} |Q_{u_1T}| \\
= \sum_{T=1}^n \sum_{d\mid T} \sum_{u_1=1}^{\lfloor {n\over T}\rfloor} {q_1\over u_1T}</script><p>因为$n,q_1$同级，用$n$换掉$q_1$：</p>
<script type="math/tex; mode=display">
原式= \sum_{T=1}^n \sum_{d\mid T} {n\over T} \log {n\over T}    \\
\le \sum_{T=1}^n \sum_{d\mid T} {n\over T} \log n    \\
=\sum_{d=1}^n \sum_{T'=1}^{\lfloor {n\over d}\rfloor} {n\over dT'} \log n \\
=\sum_{d=1}^n {n\over d} \log {n\over d} \log n \\
\le \sum_{d=1}^n {n\over d} \log^2 n \\
= n\log^3 n</script><p>处理前缀和的复杂度是矩阵的大小。矩阵的行数是$O(\sqrt {n\over T})$的，尽管矩阵的列数是$n$，但是其中只有$|Q_T|+|A_T|$列有用，所以复杂度是：</p>
<script type="math/tex; mode=display">
\sum_{T=1}^n \sqrt {n\over T} \cdot {q_1+q_2\over T} \\
{\sqrt n (q_1+q_2) }\sum_{T=1}^n {1\over T^{1.5}}</script><p>后面部分</p>
<script type="math/tex; mode=display">
\sum_{T=1}^{n} {1\over T^{1.5}} \\
\int_{1}^n T^{-1.5} dT \\
= - {1\over 0.5} n^{-0.5} + {1\over 0.5}1^{-0.5} + C\\
= n^{-0.5} \cdot 0 + C \\
= O(1)</script><p>所以这一步的复杂度是$O((q_1+q_2)\sqrt n)$。</p>
<p>离散化那$|Q_T|+|A_T|$列的复杂度是$\sum_{T=1}^n ( |Q_T|+|A_T| )\log n = O(q_2\log ^2 n)$。</p>
<p>询问的复杂度：对于某一个$u_2$，我们会枚举到的$t$一定有$\lfloor {n\over u_1u_2dT} \rfloor = \lfloor { \lfloor {n\over u_2T}\rfloor \over x} \rfloor$的形式，所以，这样的$t$只有$O(\sqrt {n\over u_2T})$个。</p>
<script type="math/tex; mode=display">
\sum_{T=1}^n \sum_{j\in A_{T}} \sum_{u_2 \mid {s_j\over T}} \sqrt {n\over u_2T} \\
= \sqrt n\sum_{u_2=1}^n \sqrt { 1 \over u_2 }  \sum_{T=1}^{n\over u_2 } \sqrt{1\over T} |A_{u_2T}| \\
= \sqrt n \sum_{u_2=1}^n \sqrt { 1 \over u_2}  \sum_{T=1}^{n\over u_2 } \sqrt{1\over T} {q_2\over u_2T}\\ 
= \sqrt nq_2 \sum_{u_1=1}^n u_2^{-1.5}\sum_{T=1}^{n\over u_2} T^{-1.5} \\
= O(\sqrt nq_2)</script><p>总时间复杂度$O(n\log^3 n +q_2\sqrt n)$。</p>
<h1 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h1><h2 id="A-火山哥的打铁传说"><a href="#A-火山哥的打铁传说" class="headerlink" title="A - 火山哥的打铁传说"></a>A - 火山哥的打铁传说</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>进攻方有两种鱼：小鱼和剧毒鱼。防御方有两种鱼，圣盾鱼和大鱼。每一回合，进攻方会选择自己的一条鱼，然后让它与防御方的某一条鱼战斗。战斗遵循如下规则：</p>
<ol>
<li>如果圣盾鱼与任意一种鱼战斗，它会变成一条大鱼。</li>
<li>如果大鱼和剧毒鱼战斗，它会消失。如果大鱼和小鱼战斗，大鱼不会消失。</li>
</ol>
<p>现在你知道了进攻方前$n$个回合会选择自己的哪种鱼。有$q$次询问，每次询问给出$X$,$K$，你需要回答，如果防御方有$X$条大鱼，进攻方进行前$K$个回合，防御方最多能有多少条圣盾鱼，使得进攻方可以让防御方所有的鱼都消失。</p>
<p>$n,q\le 4\times 10^5$</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数$n,q$。</p>
<p>第二行一个长度为$n$的字符串$s$，$s_i$为<code>1</code>表示第$i$个回合进攻方出剧毒鱼，$s_i$为<code>0</code>则表示第$i$个回合进攻方出小鱼。</p>
<p>接下来$q$行，每行两个整数$X,K(1\le K\le n)$，表示第$i$次询问。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问，输出一行一个整数表示答案。如果圣盾鱼个数为$0$的时候进攻方仍不能消灭所有的鱼，输出$-1$。</p>
<h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol"></a>Sol</h3><p>问题等价于：我方先出$X$条小鱼，然后再进行前$K$个回合，最多能消灭掉多少条对方的圣盾鱼。假设答案为$y$，若$y&lt; x$输出$-1$，否则输出$y-x$。</p>
<p>转化成求出尽可能多的小鱼和剧毒鱼的匹配（要求小鱼在前面），答案就是这个匹配数加上剩下的剧毒鱼的数量的一半下取整。</p>
<p>如果只有一次询问，可以直接贪心：从前往后考虑，用一个变量记录下前面的还没有匹配过的小鱼，遇到剧毒鱼的时候如果前面没有匹配的小鱼数量不为$0$就让它匹配。</p>
<p>从前往后贪心和从后往前贪心得到的结果显然是一样的。先从前往后贪心，求出每一个前缀能够得到的最大的匹配数。询问的时候增加的$X$条小鱼所能够增加的匹配数，是前$K$个回合中还没有匹配的剧毒鱼数量和$X$的较小值。</p>
<p>时间复杂度$O(n+q)$。</p>
<h2 id="B-火山哥的分式"><a href="#B-火山哥的分式" class="headerlink" title="B - 火山哥的分式"></a>B - 火山哥的分式</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>定义如下的表示一个分式的方式：给出一个长度为$l+1$的序列和长度为$l$的排列，排列中的第$i$个数代表了从上往下第$i$条分数线的长度，序列中的第$i$个元素代表了分式从上往下的第$i$个元素。例如，序列$\{ a,b,c\}$和排列$\{2,1\}$所对应的分式是：</p>
<script type="math/tex; mode=display">
{a\over {b\over c}}</script><p>越短的分数线，运算的优先级越高。</p>
<p>现在有一个长度为$n+1$的序列$a$和长度为$n$的$\{1,2,\cdots n\}$的排列。有$q$次询问，每次询问给出$l,r$，你需要求出$a[l-1\cdots r]$和$p[l\cdots r]$对应的分式的值对$998244353$取模的结果。</p>
<p>$n,q\le 5\times 10^5, 0&lt; a_i &lt; 998244353$</p>
<h3 id="Sol-4"><a href="#Sol-4" class="headerlink" title="Sol"></a>Sol</h3><p>单独考虑每一个元素对答案的贡献，这个贡献要么是它本身，要么是它的逆元；找出这个元素左边第一条分数线，然后找出这条分数线的左边第一条比它长的分数线，然后找左边第一条比它长的分数线……直到找到的分数线位置超出了区间，这期间找到过的分数线的个数如果是奇数那么这个数的贡献就是它的逆元，否则就是它本身。</p>
<p>将询问离线下来，然后从左到右扫描整个序列，并用单调栈维护已经扫过的元素（栈顶是最后加入的分数线，栈中的每一个元素的下面是它左边的第一个比它长的分数线）。扫到$r$的时候，我们分两部分求$l$的答案：一部分是仍然在栈中的元素的贡献，对于下标在$l$之后且在栈中的元素，分别查出下标为奇数和偶数的所有元素的乘积就可以得到答案；一部分是已经出栈了的元素的贡献，我们在元素出栈的时候维护。把出栈的元素的贡献分为两部分：一部分是$l$小于出栈后的栈顶的，直接让出栈后的栈顶的权值乘等于当前的栈顶的权值的逆元就可以了；另一部分是$l$在出栈后的栈顶和当前的栈顶之间的，这些$l$形成连续的一段区间且当前出栈的元素对它们的贡献是相同的，用线段树维护即可。</p>
<p>时间复杂度$O((n+q)\log n)$。</p>
<h2 id="C-最小割"><a href="#C-最小割" class="headerlink" title="C - 最小割"></a>C - 最小割</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>对于一张边带权的无向图，定义$s$与$t$的最小割$f(s,t)$：求一个边集$E$使得删去$E$中的边之后$s,t$不连通且$E$中的边的边权和最小，$E$的边权和即为$f(s,t)$。</p>
<p>现在给出了一张$n$个点$m$条边的图，其中第$i$条边连接$x_i$和$y_i$，边权为$w_i(w_i\le 10^4)$。然后可怜又往图中加了$n$条边，第$i$条边连接$i$和$i\pmod n + 1$，每条边的边权都是$10^9$。</p>
<p>可怜希望你求出$\sum_{s=1}^{n-1} \sum_{t=s+1}^n f(s,t) \pmod {998244353}$。</p>
<p>$n\le 7000,m\le 10^5$</p>
<h3 id="Sol-5"><a href="#Sol-5" class="headerlink" title="Sol"></a>Sol</h3><p>由于所有边的权值和最多为$10^9$，所以边权为$10^9$的边肯定恰好被割两条，把原图划分成两条链，然后将链之间的边割掉。</p>
<p>利用二维前缀和可以在$O(n^2)$的时间内求出选择割某两条边，其它需要割掉的边的权值和。</p>
<p>对于$s,t$，我们要求割的一条边在$s,s+1,\cdots ,t-1,t$之间，另一条不在这些点之间。</p>
<p>可能的方案形成了这样的区域（横坐标代表一条边的位置，纵坐标代表另一条边的位置）：</p>
<p><img src="https://i.loli.net/2019/12/26/xcyDwWG9QmMBaVT.png" alt=""></p>
<p>第一种：求出每一列的后缀最小，然后对于第$s$行，求出从第$s$列开始的前缀最小。</p>
<p>第二种：求出每一行的后缀最小，然后对于第$t$列，求出从第$t$行开始的前缀最小。</p>
<p>总时间复杂度$O(n^2 + m)$。</p>
]]></content>
      <tags>
        <tag>Contests</tag>
      </tags>
  </entry>
  <entry>
    <title>IOI2020北大集训</title>
    <url>/2020/02/20/IOI2020%E5%8C%97%E5%A4%A7%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="A-递增树列"><a href="#A-递增树列" class="headerlink" title="A - 递增树列"></a>A - 递增树列</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一棵有根树，定义$dis(i)$为$i$点到根经过的边数。求有多少个排列$p$，满足$\forall i \in [1,n-1), dis(lca(p_i,p_{i+1}))\le dis(lca(p_{i+1},p_{i+2}))$。</p>
<p>答案对$10^9+7$取模。$n\le 80$。</p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>一个观察：从前往后考虑这个排列，一旦出现了相邻两个点的lca不为根，那么此后的点都在根的同一个子树内。而前面的相邻两个点的lca都为根等价于相邻两个点来自根的不同子树。对不是根的点考虑仅由它的子树内的点构成的排列时也有类似的结论。</p>
<p>设$g_{u,j}$表示以$u$为根，用了$u$子树内的$j$个点去构成一个合法的排列的方案数。则最后的答案是$g_{1,n}$。</p>
<p>如果排列中始终没有出现两个相邻的点lca的深度大于$u$，则可以直接用容斥原理计算。对$u$的每一个儿子枚举这个儿子的子树内选了多少个点，以及这些点中有多少对在最终排列里相邻了，并对（选了的点数）和（在同一个儿子的子树内且在排列中相邻的点对数）做背包。</p>
<p>如果存在相邻点lca深度大于$u$，假设其所属的儿子是$v’$，我们最后得到的排列只需满足：在lca均在$v’$之内的那一段（即$g_{v’,x}$所代表的）之前，最后一个点不属于$v’$的子树。这个仍然可以用类似于上一种情况的方法进行容斥，使得在$v’$子树内的点位于$g_{v’,x}$的那段之前的方案被减掉。在背包中再加入一维$0/1$，表示是否已经算过$v’$的贡献就可以处理这种情况。</p>
<p>时间复杂度$O(n^4)$。<del>我n^5过了</del></p>
<h2 id="B-Article"><a href="#B-Article" class="headerlink" title="B - Article"></a>B - Article</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>定义$w(s_1,s_2)$表示$s_1,s_2$的本质不同的公共子串的数量。</p>
<p>定义一个字符串$t$的权值为$\sum_{i=1}^{|t|-1} w^2(s[1\cdots i],s[i+1\cdots |t|])$。</p>
<p>给出一个字符串$s$和正整数$k$，问将$s$划分成恰好$k$段，权值最大的那段的权值最小可以是多少。</p>
<p>$|S|\le 50000$，保证答案不超过$10^{18}$。</p>
<h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>考虑如何在$O(|t|)$的时间内算出$t$的权值：对$t$建SAM，对于每个节点处理出它的出现位置的最小值和最大值；SAM上的每个节点对$i=1$到$|t|-1$时的$w$的贡献，会是一个形如$maxlen,maxlen,\cdots maxlen,maxlen-1,maxlen-2\cdots $的数列，用二次差分就可以处理。求出每个$w$之后再平方、求和即可。</p>
<p>首先二分答案，将问题转化成：要求每段的权值小于等于某值，问能否划分成至多$k$段。由于这个题的权值满足单调性（即一个串的权值一定不小于它的任何一个子串），所以可以直接贪心，让划分的位置尽可能靠后就可以了。</p>
<p>利用倍增找下一个划分点：先检查长度$2^0,2^1,\cdots$直到长度为$2^k$的串的权值大于了限制，然后再依次枚举$2^{k-1},2^{k-2}\cdots$进行倍增。假设这一次划分的段的长度的$L$，由于每一次倍增时需要计算权值的串长度大于等于$2^{k-1}$而小于$2^k$，所以找出这个划分点的复杂度是$\Theta(L\log L)$的。</p>
<p>总复杂度$O(|S|\log |S|\log Ans)$。</p>
<h2 id="C-Travel"><a href="#C-Travel" class="headerlink" title="C - Travel"></a>C - Travel</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有$n$个可重集合$S_1,S_2\cdots S_n$，你可以从每个可重集合中选出一个元素，然后用这$n$个元素构成$k$个环，要求每个环的长度都是奇数。</p>
<p>定义一个环的价值为，相邻两个元素的差的绝对值的最小值。特别地，一个只包含一个元素的环的价值是正无穷。</p>
<p>你需要最大化所有环的价值的最小值，并输出最大化的结果。</p>
<p>$n\le 300,|S_i|\le 5,k&lt; n$。</p>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><h4 id="Lemma-1"><a href="#Lemma-1" class="headerlink" title="Lemma 1"></a>Lemma 1</h4><p>对于确定的$n$个已经从小到大排好序的元素$a_1,a_2,a_3\cdots a_n$，令$m={n-1\over 2}$，则它们构成的环的价值最大值是$\min \{ a_{i+m}-a_i \}$。</p>
<p>证明：考虑$\{a_i,a_{i+1},\cdots a_{i+m}\}$这个集合内有$m+1$个元素，集合外有$m$个元素，所以集合中必然存在一对在环中相邻的元素，所以这是答案的下界。而达到这个下界的解可以这样构造：</p>
<p><img src="https://i.loli.net/2019/12/17/dgliqKfZzND7ROt.png" alt=""></p>
<h4 id="Lemma-2"><a href="#Lemma-2" class="headerlink" title="Lemma 2"></a>Lemma 2</h4><p>最终的答案是由$k-1$个孤立的点和一个长度为$n-k+1$的环构成的。</p>
<p>证明：考虑现在有两个长度大于$1$的环$\{a_1,a_2\cdots a_m\}$和$\{b_1,b_2\cdots b_n\}$（$a_i,b_i$随下标递增），只要证明将它们变成一个孤立点和一个环答案不会变劣就可以了。</p>
<p>如果某个环使用的不是上面的图片中的构造方法，将其改为图片中的构造方法不会变劣。所以下面均认为环是按照上面图片的方式构造的。</p>
<p>从$a$中取出一个孤立点$a_{m+1\over 2}$，得到一条一端为$a_1$，另一端为$a_m$的链。</p>
<p>断开$b$中的边$(b_1,b_{n+1\over 2})$或者边$(b_{n+1\over 2},b_n)$。</p>
<p>考虑如何将两条链拼起来。假设第一条链是的端点分别为$a,b(a&lt; b)$，第二条链的端点为$c,d(c&lt; d)$。若$[a,b]$与$[c,d]$没有交或者包含，则很容易构造使得拼接用的边的权值都大于等于$\min\{b-a,d-c\}$。否则一定有$b_1&lt; a_1 \le b_{n+1\over 2} \le a_m &lt; b_n$，此时若$b_{n+1\over 2}\ge a_{m+1\over 2}$，就连$(b_{n+1\over 2},a_1)$和$(a_m,b_1)$，否则就连$(b_{n+1\over 2},a_m)$和$(b_n,a_1)$。这样构造之后答案都不会变劣。</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>首先二分答案$w$，然后判断能否求出长度为$n-k+1$的哈密顿回路。</p>
<p>令$N=n-k+1$，存在长度为$N$的哈密顿回路等价于存在$N-3\over 2$对匹配和一个三元匹配。</p>
<p>其中$i,j$这两个集合可以匹配，当且仅当$\exists a\in S_i,b\in S_j, |a-b| \ge w$。</p>
<p>其中$i,j,k$这三个集合可以构成三元匹配，当且仅当$\forall x\in S_i,y\in S_j,z\in S_k, \min\{|x-y|,|y-z|,|z-x|\}\ge w$。</p>
<p>必要性：可以把环画成之前的图中的形式，图中红色的边为匹配边。</p>
<p>充分性：显然一个集合只会属于一个匹配。对于每个集合拿出一个它参与了匹配条件判定的那个元素，将所有集合按照它拿出的那个元素的大小排好序。如果它们的匹配边的连法不是之前的图中的那样，则可以进行等价的调整。然后用与前面构造相同的方法就可以构造出解。</p>
<p>最后是怎么求这个匹配。枚举三元匹配中元素的值为中位数的那个集合并枚举它选的元素，然后将这个集合拆成两个点，一个只能连比它小的点，另一个只能连比它大的点，然后跑一般图的最大匹配就可以了（说得就跟我会似的。。。。</p>
<hr>
<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="A-循环数列"><a href="#A-循环数列" class="headerlink" title="A - 循环数列"></a>A - 循环数列</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有一个无限长的下标从$1$开始的序列，初始的时候所有在模$n$意义下等于$m$的位置的数为$1$，其余位置的数为$0$。</p>
<p>每一次操作会使得操作后的序列$F’_i=F_i+F_{i+1}$。</p>
<p>现在给出$n,m,k,pos,P$。你需要求出$k$次操作之后，$F_{pos}\pmod P$的值。</p>
<p>数据组数$T\le 500$，$k\le 10^9, P\le 10^7, \sum n\le 10^6, 1\le m&lt; n, 1\le pos&lt; n$，数据保证$P$为质数且$n\mid p-1$。</p>
<h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol"></a>Sol</h3><p>假设某个初始序列中的$1$的下标为$x$，那么它将对$F_{pos}$产生的贡献等价于：每一次可以让$x$不变或减一，操作$k$次后恰好$x=pos$的方案数。也就是${k \choose x-pos}$。</p>
<p>故而答案为</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{\infty} {k\choose i\cdot n+m-pos }</script><p>令$t=m-pos$，进行单位根反演：</p>
<script type="math/tex; mode=display">
Ans=\sum_{i=0}^{\infty} {k\choose i\cdot n+t}\\
=\sum_{i=0}^{\infty}{k\choose i} [n\mid (i-t)]\\
=\sum_{i=0}^{\infty}{k\choose i} {1\over n} \sum_{j=0}^{n-1} \omega_n^{j(i-t)}\\
={1\over n}\sum_{j=0}^{n-1} \omega_n^{-jt} \sum_{i=0}^{\infty}{k\choose i}\omega_n^{ij}\\
={1\over n}\sum_{j=0}^{n-1} \omega_n^{-jt} (1+\omega_n^j)^k</script><p>暴力枚举$j$计算，复杂度$O(n\log k)$。</p>
<h2 id="B-Matrix"><a href="#B-Matrix" class="headerlink" title="B - Matrix"></a>B - Matrix</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出一个$n\times n$的整数矩阵$A$。</p>
<p>问能否求出一组置换矩阵$\{B_1,B_2\cdots B_m\}$，使得<strong>唯一</strong>存在一组非负整系数$\alpha_1,\alpha_2\cdots \alpha_m$，满足$A=\alpha_1\cdot B_1 + \alpha_2\cdot B_2+\cdots +\alpha_m\cdot B_m$。</p>
<p>求出一组$m\le n^2$的解或判定无解。</p>
<p>$n\le 50,T\le 10,A_{i,j}\le 2\times 10^7$</p>
<h3 id="Sol-4"><a href="#Sol-4" class="headerlink" title="Sol"></a>Sol</h3><p>参考Birkhoff–von Neumann theorem。</p>
<p>一个$A$能够被表示出来的充分必要条件是$A$中的每一行元素的和、每一列元素的和都相同。</p>
<p>充分性证明：设$C$为某一行的所有元素的和。构造一个二分图，左侧有$n$个点表示每一行，右侧有$n$个点表示每一列。$(i,j)$这条边存在当且仅当$A_{i,j}&gt;0$。用Hall定理证明这张图存在完备匹配：任选一个左边的点构成的集合$X$，考虑与他们相邻的列集合$Y$，由于$|X|\cdot C = \sum_{x\in X,y\in Y} A_{x,y} \le |Y|\cdot C$，所以有$|X|\le |Y|$，证毕。所以这张二分图一定存在完备匹配，将完备匹配对应的置换矩阵从$A$中减掉（$\alpha$取匹配中的最小边权），就转化成了规模更小的问题。</p>
<p>上述的证明过程也描述了算法的过程。显然这样最多会用$n\times n$个置换矩阵。由于每一次都会让一个位置变成$0$，所以这一步拿出来的置换矩阵与之后拿出来的置换矩阵必然线性无关。</p>
<h2 id="C-杀蚂蚁简单版"><a href="#C-杀蚂蚁简单版" class="headerlink" title="C - 杀蚂蚁简单版"></a>C - 杀蚂蚁简单版</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>有一棵包含$n$个节点的树，每个点有一个权值$v_i$。有一只蚂蚁，如果它当前在的节点为$x$，与它相邻的点集为$\{y_1,y_2\cdots y_m\}$，则它下一秒将以${v_{y_i}\over \sum v_{y_j}}$的概率走到$y_i$这个点。蚂蚁一旦走到$1$节点就会消失。</p>
<p>有$q$次询问，每次询问给出$s,x,y$，你需要回答：如果蚂蚁的初始位置是在$s$，它期望有多少秒停留在$x$到$y$的最短路径上。</p>
<p>$n,q\le 10^5$，答案对$998244353$取模。</p>
<h3 id="Sol-5"><a href="#Sol-5" class="headerlink" title="Sol"></a>Sol</h3><p>设$P_{x,y}$表示从$x$走到$y$的概率。</p>
<p>下面考虑部分分$v=u+1,s=2$的情况怎么做。设$f_i$表示$i$期望被经过多少次，那么显然有$f_2=P_{2,3}\cdot f_2+1={1\over 1-P_{2,3}}$，$f_3 = P_{2,3}f_2 + P_{4,3}\cdot f_4 $，由于出发点是$2$，终点是$1$，所以必然有$f_4P_{4,3} = f_3P_{3,4}$，所以$f_3={1\over 1-P_{3,4}}P_{2,3}f_2$。后面的可以类似的方法推导。概括一下就是，设$g_i = {1\over 1-P_{i,i+1}},h_i=P_{i-1,i}$，则$f_2 = g_2, f_i = h_ig_if_{i-1}(i&gt;2)$。</p>
<p>考虑$v=u+1,s\not = 2$的情况：此时的答案等价于蚂蚁第一次走到$s-1$之前经过每个点的次数的期望 加上 以$s-1$作为出发点的时候的答案。如果限制了不能够经过$s-1$这个点，等价于让$s-1$做根，故而此时$f_s = g_s, f_i = h_ig_if_{i-1}(i&gt;s)$。所以这种情况的答案为$\sum_{i\in [x,y]} \sum_{j=2}^s g_j\prod_{k=j+1}^i h_ig_i$。考虑如何快速计算答案：令$F_i$表示当以$2$作为起点的时候期望经过$i$的次数，那么$F_i$对答案的贡献相当于$F_i(1 + {1\over g_2h_3}+{1\over g_2g_3h_3h_4}+\cdots {1\over g_2g-_3\cdots g_{s-1}h_3h_4\cdots h_s})$。按照从小到大依次枚举$s$，当从$s-1$变成$s$的时候，相当于对于所有大于了$s$的$x$，它的贡献都增加了$F_x\cdot {1\over g_2g-_3\cdots g_{s-1}h_3h_4\cdots h_s}$，可以用线段树维护区间内的贡献和。</p>
<p>上面的结论推广到树仍然成立。对整棵树进行dfs遍历，进入一个点$s$的时候，就使它的子树内的点$x$都加上贡献$F_x \cdot {1\over h_sg_{fa_s}h_{fa_s}g_{fa_{fa_s}}\cdots }$，用树链剖分维护链的贡献和即可。时间复杂度$O(n\log ^2 n)$。</p>
<hr>
<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><h2 id="A-投影对称"><a href="#A-投影对称" class="headerlink" title="A - 投影对称"></a>A - 投影对称</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给定$n$个点，求有多少过$(0,0)$的直线，满足这$n$个点在直线上的投影为中心对称图形。</p>
<p>$n\le 2000$，$|x_i|,|y_i|\le 10^6$，可能会有重合的点。</p>
<h3 id="Sol-6"><a href="#Sol-6" class="headerlink" title="Sol"></a>Sol</h3><p>假设对称中心为$P$，考虑过$P$且与$OP$垂直的直线$l$，对于一对其投影关于$P$对称的点$A,B$，它们到$l$的距离相等。故线段$AB$的中点也一定经过了$l$。枚举$1,2$这两个点匹配的另一个点是什么就可以确定$l$，然后再$O(n\log n)$检查，这样总复杂度是$O(n^3\log n)$的。</p>
<p>考虑由于$l$过所有点对的中点，所以$l$一定过这$n$个点的重心。因此只需要枚举$1$号点匹配的点，再考虑上重心，就可以确定$l$了。时间复杂度$O(n^2\log n)$。</p>
<p>有一种写法是，先对这$n$个点求一次凸包，由于凸包上的点只能和凸包上的点配对，（再加上出题人没有考虑到凸包，因此数据中凸包上的点数很少），可以将总复杂度优化到$O(Cn\log n)$，其中$C$为凸包上的点数。</p>
<h2 id="B-数圈"><a href="#B-数圈" class="headerlink" title="B - 数圈"></a>B - 数圈</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>有$n$个整数排成一个圈，初始它们为$A_1,A_2\cdots A_n$。</p>
<p>定义一次操作为，选择一个数$a$，将与它相邻的数加上$a$，将它变成$-a$。</p>
<p>问至少进行多少次操作，可以使得所有的数非负。如果办不到输出$-1$。</p>
<p>$n\le 10^5, -1000\le A_i \le 1000$</p>
<h3 id="Sol-7"><a href="#Sol-7" class="headerlink" title="Sol"></a>Sol</h3><p>考虑如果是序列怎么做：观察发现，一次操作等价于交换了前缀和数组中的两个元素，所以答案就是前缀和数组的逆序对数。</p>
<p>而对于圈，我们定义它的广义前缀和是一个双向无限的序列$S_i(i\in \mathbb {Z})$，如1,2,-3,4的一个可能的广义前缀和是……-8,-4,-3,-1,-4,0,1,3,0,4,5,7,4,8,9,……定义它的一次交换操作为：选定一个$i$，对于所有在模$n$意义下与$i$同余的位置$x$，交换$S_x$与$S_{x-1}$。</p>
<p>设$sum=\sum_{i=1}^nA_i$，如果$sum&lt; 0$显然无解，如果$sum=0$则当且仅当序列中所有元素都是$0$的时候有解，否则无解。下面只讨论$sum&gt;0$的情况。</p>
<p>定义$R_i = \sum_{j&gt;i} [ S_j&lt; S_i]$，定义逆序对数为$R_1+R_2+\cdots R_n$。由于$sum&gt;0$，所以$R_i$是有限的。由于$S_{x+n}=S_x+sum$，所以$R_i = R_{i+n}$。一次操作会交换所有的$S_{i+kn}$与$S_{i-1+kn}(k\in \mathbb Z)$，对于某一个$k’$，$R_{i+k’n}$只会受到交换$S_{i+k’n},S_{i-1+k’n}$的影响，所以一次操作我们恰好可以让某一个$R_i(i\in [1,n])$减掉一。所以答案就是这个逆序对数。</p>
<p>枚举$j-i$在模$n$意义下的取值。由于$S_{i+n}=S_i + sum$，所以$R_i = \sum_{j=1,S_{i+j}&lt; S_i}^{n-1} \lceil{S_i-S_{i+j}    \over sum}\rceil$。利用这个式子可以在$O(n^2)$的时间内解决问题。</p>
<p>考虑将$S_i$分解为$S_i = u_i \cdot sum +v_i(0 \le v_i &lt; sum)$，则前面的式子转化为$\sum_{j=1,S_{i+j}&lt; S_i}^{n-1} u_i - u_{i+j} + [v_i &gt; v_{i+j}]$。从小到大枚举$i$并动态维护二维点集$(S_{i+j},v_{i+j})$以及点权$u_{i+j}$，可以做到$O(n\log ^ 2 n)$的复杂度。进一步观察，这个动态维护的过程中，我们每一次删除的是$((S_x,v_x),u_x)$，而加入的是$((S_{x+n},v_{x+n}) ,u_{x+n}) = (( S_x +sum, v_x), u_x +1)$。如果我们不去做这个修改，造成的影响是：对于所有的$i&gt;x,S_i &gt; S_x$，$R_i$会多算上$1$的贡献，这是一个二维偏序问题。不做修改的原问题也是个二维偏序问题。这样就做到了$O(n\log n)$的复杂度。</p>
<h2 id="C-search"><a href="#C-search" class="headerlink" title="C - search"></a>C - search</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p>交互题。有一个$n\times n$的单调矩阵（同一行的元素右边的比左边的大，同一列的元素下面的比上面的大），此外还有一个数$x$。保证矩阵内的元素以及$x$两两互不相同。有两种询问：</p>
<ul>
<li>询问矩形内的某两个格子，返回它们的大小关系。</li>
<li>询问矩形内的某一个格子，返回这个格子与$x$的大小关系。</li>
</ul>
<p>你需要回答，矩形内比$x$小的位置的个数。</p>
<p>$n\le 2000$，时限2s，限制询问1的次数不超过$64n$，询问2的次数不超过$34$。</p>
<h3 id="Sol-8"><a href="#Sol-8" class="headerlink" title="Sol"></a>Sol</h3><h4 id="一个随机算法"><a href="#一个随机算法" class="headerlink" title="一个随机算法"></a>一个随机算法</h4><p>随机一个格子$(i,j)$，然后抠出如下图的这个轮廓线：</p>
<p><img src="https://i.loli.net/2019/12/25/wJTPcaYkMhtdEgb.png" alt=""></p>
<p>有颜色的格子是用过询问1的，橘色表示问出来比$x$小，蓝色表示问出来比$x$大。</p>
<p>这样抠一次，$i$行之前的，橘色格子每列至多有一个，蓝色格子每行至多有一个；$i$行之后的，橘色格子每行至多有一个，蓝色格子每列至多有一个。所以这一步会用掉至多$2n$次询问1。</p>
<p>比较$(i,j)$与$x$的大小关系。若$(i,j) &lt; x$，则轮廓线上方的全部都$&lt; x$，可以记入贡献之后删掉；否则，$(i,j) &gt; x$，则轮廓线下方的也全部$&gt; x$，可以删掉。</p>
<p>期望只需要进行$O(\log n)$次上述操作，就可以结束程序。</p>
<hr>
<h1 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h1><h2 id="A-xor"><a href="#A-xor" class="headerlink" title="A - xor"></a>A - xor</h2><h3 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h3><p>给定$n,d$，求</p>
<script type="math/tex; mode=display">
\sum_{0\le x,y,z < n }(x \oplus y\oplus z)^d \pmod {998244353}</script><p>其中$\oplus$表示按位异或。</p>
<p>$n&lt; 2^{30},d\le 100000$。</p>
<h3 id="Sol-9"><a href="#Sol-9" class="headerlink" title="Sol"></a>Sol</h3><h4 id="部分分：-d-le-10"><a href="#部分分：-d-le-10" class="headerlink" title="部分分：$d\le 10$"></a>部分分：$d\le 10$</h4><p>下面是一个和正解毫无关系的暴力。</p>
<p>通过数位$dp$单独对二进制每一位进行考虑。考虑怎么算答案，设$p_i$表示第$i$位是$0$还是$1$，由多项式乘法的组合意义可得：</p>
<script type="math/tex; mode=display">
(\sum_{i=0}^{\log n} p_i 2^i)^d \\
=d!\sum_{l_1+l_2 + \cdots +l_{\log n}=d} \prod_i {(p_i2^i)^{l_i}\over l_i!}</script><p>在$dp$状态中加入一维表示$l_1 + l_2  +\cdots l_{cur_len}$，就可以在$O(\log n \cdot 2^3 \cdot d^2)$的时间内解决问题。</p>
<h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><p>枚举$x,y,z$最高的和$n$不同的一位，假设为$a,b,c$。不失一般性地令$a\le b\le c$。$x\oplus y\oplus z$可能取到的数，满足$c$以上的位全部与$n$相同，$c$位为$0$且$n$的$c$位为$1$，$c$以下的位任意。考虑末$c$位取到某个$L\in [0,2^c)$的方案数，发现我们可以先让$x$的末$a$位、$y$的末$b$位随便取，然后根据$x,y$和$L$唯一地确定$z$的末$c$位，故而方案数为$2^{a+b}$。这也就是说，枚举完$a,b,c$之后，$x\oplus y\oplus z$的每一个可能的取值出现的方案数是一样的。所以只需要求出所有的可能取到的数的$d$次方的和就可以了。可能取到的数形成了一个连续的区间，是经典的自然数幂和问题。直接枚举$a,b,c$计算的复杂度为$O(d\log ^ 3 n)$，观察发现可取到的数形成的区间只与$\max\{ a,b,c\}$有关，所以只需要算$\log n$次自然数幂和就可以了，复杂度$O(d\log n + \log^3 n)$。</p>
<h2 id="B-N门问题"><a href="#B-N门问题" class="headerlink" title="B -  N门问题"></a>B -  N门问题</h2><h3 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h3><p>$N$扇门中有一扇门是有奖的。初始的时候$A$认为所有门有奖的概率是相等的。每一轮，$A$会在有奖概率最大的门中随机选择一扇，然后主持人会从没有被$A$选择且没有奖的所有门中随机选择一扇门打开。进行到第$N-1$轮时，$A$的选择就是他的最终选择。</p>
<p>现在你来当主持人，你可以决定（而不是随机地）每一次打开哪一扇没有被$A$选择且没有奖的门，问$A$最终选择的门后面有奖的概率最小是多少。假定$A$不知道你是托儿，即$A$仍然认为你是在随机选择门。</p>
<p>$N\le 10^{18}$</p>
<h3 id="Sol-10"><a href="#Sol-10" class="headerlink" title="Sol"></a>Sol</h3><p><del>假设在某一轮，$n$个门后面有奖且主持人做出这样的选择的概率（贝叶斯公式中的$P(B\mid A)$）分别是$p_1,p_2,\cdots p_n$。</del></p>
<p><del>假设$A$选择的门是$x$，而你打开的门是$y$，则：</del></p>
<script type="math/tex; mode=display">
p'_x = p_x {1\over n-1} \\
p'_k = p_k {1\over n-2} (k\not =x, y) \\</script><p><del>下面将证明，在某一轮$\forall k \not = x,y, p’_x &lt; p’_k$。考虑归纳。对于第一轮显然成立。假设现在是第$t$轮，还剩下$n$扇门没有开。由于$p’_k(k\not=x,y)$之间的大小关系由$p_k$决定，所以只需要考虑$p_k$中的最小值$p_q$乘上$1\over n-2$与$p_x \cdot {1\over n-1}$的大小关系。而由于归纳，$p_q$在上一轮中是最大的，用$\{ p’’_i\}$表示上一轮的数，则$p’_q = p’’_q \cdot {1\over (n-2)(n-2)}$，而$p’_x = p’’_x \cdot{ 1\over (n-3)(n-1)}$，所以可以推出。。。什么也推不出来。</del></p>
<p>不知道怎么证明的，$N&gt;10$的时候答案为$0$，$N\le 10$的时候直接搜索。</p>
<h2 id="C-区间匹配"><a href="#C-区间匹配" class="headerlink" title="C - 区间匹配"></a>C - 区间匹配</h2><h3 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h3><p>有两个长度为$n$的序列$a[1\cdots n],b[1\cdots n]$和两个非负整数$la,lb(lb \le la)$，你需要求出一个$1$到$n$的排列$\{p\}$，使得对于所有$i$都有$a[i] \le b[p[i]] \le a[i] + la$，在此基础上你需要最大化满足$a[i] + lb \ge b[p[i]]$的$i$的数量，并输出最大化的结果。</p>
<p>$n\le 500000$，$a[i],b[i],la,lb\le 500000$，且保证存在合法的$p$。</p>
<h3 id="Sol-11"><a href="#Sol-11" class="headerlink" title="Sol"></a>Sol</h3><p>考虑这样的一种贪心：从右到左考虑每一个$a$的元素，确定与它匹配的$b[p[i]]$。设现在还没有匹配过的元素中，最靠右的一个是$b[x]$，以及最靠右且满足$a[i] \le b[y] \le a[i]+lb$的是$b[y]$。如果让$a[i]$匹配上$b[y]$，剩下的点仍然存在合法的匹配，则让$a[i]$匹配$b[y]$；否则让$a[i]$匹配$b[x]$。</p>
<p>正确性证明：假设这样得到的不是最优解，考虑最优匹配中第一个与这样求出来的匹配不同的位置$i$，如果$i$匹配的既不是$x$也不是$y$，将$i$匹配的改成$x$或者$y$，答案一定不会变劣；假设最优匹配中$i$匹配了$y$，则意味着让$i$匹配$y$之后仍然存在完备匹配，所以我们的贪心策略也会让$i$匹配$y$；而如果最优匹配中$i$匹配了$x$，我们的贪心策略让$i$匹配了$y$，设我们的贪心策略中匹配了$x$的是$q_x$（显然$q_x$对答案没有贡献），而最优策略中$q_x$匹配$z$，则有两种情况：</p>
<ol>
<li>$z\le y$，则$q_x,z$这一对有可能对答案产生了贡献，此时我们将最优决策改为$x$匹配$q_x$，$i$匹配$y$，显然是不会变劣的。</li>
<li>$z&gt; y$，则$q_x,z$这一对一定对答案没有贡献。继续考虑$q_z$和最优策略中$q_z$所匹配的$w$，若$w\le y$就改成$q_x$匹配$x$，$q_z$匹配$z$，$i$匹配$y$，答案不会变劣，因为用到的$y$的右侧的点的集合是一样的，并且用到的$y$的左侧的点（从$w$变成了$y$）没有向左移，而已经确定了的匹配的贡献也没有变小；否则，继续考虑$q_w$直到匹配的点在$y$的左侧。</li>
</ol>
<p>直接检查是否存在完备匹配是$O(n\log n)$的（排序+贪心）。由Hall定理可得，存在完备匹配的条件是，不存在$z$使得$\sum_{i} [b[i] \ge z] &gt; \sum_{j} [a[j] + la \ge z]$。用线段树维护每个$z$的$\sum_{i} [b[i] \ge z] - \sum_{j} [a[j] + la \ge z]$以及区间最小值，并支持区间$+1/-1$，即可在$O(n\log n)$的时间内解决问题。</p>
]]></content>
      <tags>
        <tag>Contests</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ179 挑战NPC</title>
    <url>/2020/02/19/UOJ179-%E6%8C%91%E6%88%98NPC/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>这道题的建图方法：</p>
<ol>
<li>每个筐拆成三个点分别代表三个位置，三个点两两之间互相连边</li>
<li>每个球向它可以放入的筐的三个点都连边</li>
</ol>
<p>求出这张图的最大匹配，减去球数就是答案。</p>
<p>如果一个筐的三个位置只被球占用了0个或者1个，那么这个筐内的位置就能够再构成一个匹配，对最大匹配产生1的贡献；否则，这个筐内的位置将无法再构成匹配。</p>
<p>为什么能保证一定存在一组最大匹配，所有的球都在匹配中？因为题目保证了合法方案存在，而合法方案一定可以对应到一组匹配。</p>
<p>那么如何确保每个球都在最大匹配中呢？在带花树算法中，优先对球进行bfs，其次再bfs筐。因为整个算法过程中，一个点一旦找到匹配的点了，之后就不会再变成孤立点（虽然它的配偶可能会改变）。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="http://uoj.ac/submission/385063" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>对带花树算法的一些思考</title>
    <url>/2020/02/19/%E5%AF%B9%E5%B8%A6%E8%8A%B1%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>推荐两个带花树算法的学习资料：<a href="https://en.wikipedia.org/wiki/Blossom_algorithm" target="_blank" rel="noopener">维基百科</a> <a href="https://blog.bill.moe/blossom-algorithm-notes/" target="_blank" rel="noopener">Bill Yang’s blog</a></p>
<h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>缩掉奇环之后，会不会存在一条交错路，和奇环相交的部分没有经过花根，成为了一条在缩掉了花之后的图中找不到的增广路？</p>
<p><img src="https://i.loli.net/2020/02/19/vjMD6BmsPTpqAHZ.jpg" alt=""></p>
<p>如上图，实线表示匹配边，虚线表示非匹配边，1和12是孤立点，$\{5,6,7,8,9\}$是已经缩起来的一朵花，5是花根。一条交错路是1-3-4-6-7-10-11-12，可以看到这条交错路进入花的最后一条边和离开花的第一条边都是非匹配边，无法在缩掉蓝色的花之后的图中找到。但是当我们访问到6-4这条边的时候，由于蓝色的花已经被缩起来了，就会发现$\{1,3,4,6,7,8,9,5,2\}$这个奇环并把它缩起来。所以这样的交错路是仍然能够被带花树算法找到的。</p>
<hr>
<p>后面的问题和代码实现有关，所以先贴上我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a solution for uoj79</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> n,fa[N],vis[N],par[N],pre[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	fa: 用来缩点的并查集</span></span><br><span class="line"><span class="comment">	vis:</span></span><br><span class="line"><span class="comment">		0 未被访问过</span></span><br><span class="line"><span class="comment">		1 所在的层数奇偶性和出发点相同</span></span><br><span class="line"><span class="comment">		2 所在的层数奇偶性和出发点不同</span></span><br><span class="line"><span class="comment">	par: 现在的配偶，0表示现在没有配偶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d=<span class="number">0</span>)</span> </span>&#123; <span class="keyword">if</span>(d&gt;n) <span class="keyword">return</span> x; <span class="keyword">return</span> fa[x]==x?x:fa[x]=find(fa[x],d+<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> vis[N],tim;	</span><br><span class="line">	tim++;</span><br><span class="line">	x=find(x),y=find(y);</span><br><span class="line">	<span class="keyword">while</span>(x) vis[x]=tim,x=find(pre[par[x]]); <span class="comment">// (1)</span></span><br><span class="line">	<span class="keyword">while</span>(vis[y]!=tim) y=find(pre[par[y]]); <span class="comment">// (1)</span></span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLOWER</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(find(x)!=L) &#123; <span class="comment">// (2)</span></span><br><span class="line">		<span class="keyword">if</span>(fa[x]==x) fa[x]=L; <span class="comment">// (3)</span></span><br><span class="line">		<span class="keyword">if</span>(fa[par[x]]==par[x]) fa[par[x]]=L; <span class="comment">// (3)</span></span><br><span class="line">		<span class="keyword">if</span>(vis[par[x]]==<span class="number">2</span>) vis[par[x]]=<span class="number">1</span>,que.push(par[x]);</span><br><span class="line">		pre[x]=y;</span><br><span class="line">		y=par[x],x=pre[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i,vis[i]=pre[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty()) que.pop();</span><br><span class="line">	que.push(s),vis[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u=que.front(); que.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> v=G[u][i];</span><br><span class="line">			<span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">				pre[v]=u,vis[v]=<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(!par[v]) &#123;</span><br><span class="line">					<span class="keyword">while</span>(v) &#123;</span><br><span class="line">						<span class="keyword">int</span> tmp=par[u];</span><br><span class="line">						par[v]=u,par[u]=v;</span><br><span class="line">						v=tmp,u=pre[v];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				vis[par[v]]=<span class="number">1</span>;</span><br><span class="line">				que.push(par[v]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(vis[v]==<span class="number">1</span>&amp;&amp;find(v)!=find(u)) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp=LCA(u,v);</span><br><span class="line">				FLOWER(u,v,tmp),FLOWER(v,u,tmp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m; rd(n),rd(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i) rd(x),rd(y),G[x].PB(y),G[y].PB(x);	</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123; <span class="keyword">if</span>(!par[i]) ans+=bfs(i); &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,par[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q2-1-2"><a href="#Q2-1-2" class="headerlink" title="Q2 (1) (2)"></a>Q2 (1) (2)</h2><p>(1) 不能写作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x) vis[x]=tim,x=pre[par[x]]; </span><br><span class="line"><span class="keyword">while</span>(vis[y]!=tim) y=pre[par[y]];</span><br></pre></td></tr></table></figure></p>
<p>(2) 不能写作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=L) &#123;</span><br></pre></td></tr></table></figure></p>
<p>原因是，可能尽管我们没有进行显式的缩点，在走到奇环的时候会顺着边爬，但是在奇环嵌套偶环的时候可能会陷入死循环。</p>
<p><img src="https://i.loli.net/2020/02/19/X7Wldj5F6sYHJpR.jpg" alt=""></p>
<p>比如，上面这张图中，我们已经找到 (2,1) ，(3,4) 这两对匹配，现在开始尝试找从 5 开始的增广路。首先会找到 $\{5,1,2\}$ 这个奇环并缩起来，之后会找到 $\{5,1,3,4,2\}$ 这个奇环并缩起来，但是在缩这个奇环的过程中，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(find(x)!=L) &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	pre[x]=y;</span><br><span class="line">	y=par[x],x=pre[y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就会陷入<code>(x=2, y=4) -&gt; (x=3, y=1) -&gt; (x=2, y=4) -&gt; ...</code>的死循环。</p>
<h2 id="Q3-3"><a href="#Q3-3" class="headerlink" title="Q3 (3)"></a>Q3 (3)</h2><p>(3) 不能写作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fa[find(x)]=L;</span><br><span class="line">fa[find(par[x])]=L;</span><br></pre></td></tr></table></figure><br>因为在往上爬的过程中，我们会先经过一些在花中但不是花根的点，这时候如果修改了这个花中所有的点的所属的花编号，会影响下一步用<code>find(x)!=L</code>判断是否已经走到了<code>L所在的花</code>。正确的做法是，走到花根的时候才修改花中的点所属的花编号。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ577 「LibreOJ NOI Round #2」简单算术</title>
    <url>/2020/02/17/LOJ577-%E3%80%8CLibreOJ-NOI-Round-2%E3%80%8D%E7%AE%80%E5%8D%95%E7%AE%97%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>考虑多项式乘法的组合意义，枚举第$i$项被选的次数$b_i$，要求$\sum b_i = m, \sum b_i i = k$，则对应的贡献为</p>
<script type="math/tex; mode=display">
\binom{m}{b_0}\binom{m-b_0}{b_1}\binom{m-b_0-b_1}{b_2} \cdots \cdot \prod_i a_i ^ {b_i}</script><p>如果$p \mid m$，我们对上面的式子应用Lucas定理，发现：</p>
<ul>
<li>若$p \nmid b_0$则第一项一定为$0$，要使整个式子不为$0$就一定要有$p \mid b_0$</li>
<li>于是有$p \mid m - b_0$，于是可以推出$p\mid b_1$</li>
<li>……</li>
</ul>
<p>也就是说，所有的$b_i$都是$p$的倍数。</p>
<p>令</p>
<script type="math/tex; mode=display">
B(x) = \sum_{i=0}^n a_i^{p}x^{ip}</script><p>那么就可以把此时的答案写成</p>
<script type="math/tex; mode=display">
[x^k] A^m(x) = [x^k] B^{\frac{m}{p}}(x)</script><p>这个$B^{\frac{m}{p}}(x)$的意义相当于让原来的$b_i$和$m$都除以$p$，不会影响系数的计算。</p>
<p>考虑到$a_i^p \equiv a_i \pmod p$，所以答案也可以写成</p>
<script type="math/tex; mode=display">
[x^{\frac{k}{p}}]A^{\frac{m}{p}}(x)</script><p>更一般的，对于任意的$m$，设$m = up + v(0\le v &lt; p)$，则有</p>
<script type="math/tex; mode=display">
[x^k] A^m(x) = \sum_{i=0}^{\min\{vn,k\}} [x^{k-i}]A^{up}(x)\cdot [x^i]A^v(x)</script><p>$[x^{k-i}]A^{up}(x)$直接递归，$[x^i]A^v(x)$可以通过预处理$A(x)$的$0$到$p-1$次幂解决。要对访问到过的状态进行记忆化。</p>
<p>因为当$p\nmid i-k$时$[x^{k-i}]A^{up}(x) = 0$，所以只需要枚举和$k$同余的$i$，这样的$i$会有$\frac{vn}{p} \le n$个。</p>
<p>考虑复杂度：</p>
<ul>
<li>每一次往下递归$m$会变成$\lfloor \frac{m}{p} \rfloor$，$k$会变成$\lfloor \frac{k}{p}\rfloor - i’$，$i’$的范围是$<a href="lim\le n">0,lim</a>$；</li>
<li>每一层的$m$都是一样的，所以只用考虑$k$会有多少种不同的取值；</li>
<li>对于第$i$层，$k$能取到的最大值是$\frac{k}{p^{i-1}}$，最小值则不小于$\frac{\frac{\frac{k}{p}-n}{p}-n}{p}\cdots \approx O(\frac{k}{p^{i-1}} - n \cdot {1\over p-1})$，所以每一层不同的$k$的数量至多是$O(n)$的；</li>
<li>状态数$O(n\log_pm)$，转移$O(n)$，所以这里的复杂度是$O(Tn^2\log_p m)$，算上预处理的复杂度就是$O(p^2n^2 + Tn^2\log_p m)$</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/746679" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>From Suffix Tree to SAM</title>
    <url>/2020/02/17/From-Suffix-Tree-to-SAM/</url>
    <content><![CDATA[<p>You may check <a href="https://cp-algorithms.com/string/suffix-automaton.html" target="_blank" rel="noopener">this article on cp-algorithms.com</a> (or OI-wiki if you prefer reading in Chinese) for more precise information and proof of complexity about SAM. Here I just want to write about another perspective to understand SAM, which I’ve learned from Huadun Hong, PKU, through Zhengruioi’s online courses on 4th, Feb, 2020.</p>
<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>We can get the suffix tree of string $S$ simply by inserting all of its suffixes into a trie (though this will involve $O(|S|^2)$ vertices). Note that: </p>
<ul>
<li>Each vertex in the suffix tree represents a substring of $S$ (since a substring is a prefix of a suffix of $S$). Let’s call the vertices that represent a suffix of $S$ ‘the suffix vertices’.</li>
<li>The number a substring occurs in $S$ equals to the number of suffix vertices in the subtree of the corresponding  vertex.</li>
<li>The well-known data structure Suffix Array is actually the DFS ordering of the suffix tree. (Sort the suffix vertices by the time we discover them.)</li>
<li>LCP of two suffixes is the LCA of the corresponding suffix vertices in the suffix tree.</li>
</ul>
<p>Define:</p>
<ul>
<li>$len_x$:  the length of the string that vertex $x$ represents, also equals to the depth of $x$ in the suffix tree.</li>
<li>$fail_x$: father of $x$ in the suffix tree.</li>
<li>$go_{x,ch}$: (this definition <strong>differs from traditional definition of SAM</strong>) suppose $x$ represents string $T$, then $go_{x,ch}$ is the vertex that corresponds to the string $cT$. I may write $go_{T,ch}$ for $go_{x,ch}$ or the string $go_{x,ch}$ represents for convenience in the following paragraph, so don’t get confused with it.</li>
</ul>
<p>It seems there is some delicate contact between $go_{x,ch}$ and the suffix links in the Aho–Corasick algorithm, isn’t it? And when the suffix tree is compressed later it turns out that it’s no longer convenient to find the son of a pariticular vertex in the suffix tree, and that’s why we’ve got to maintain the array $go_{x,ch}$. Thus if we want to find the corresponding vertex of a particular string $T$, we just start from the root of the suffix tree, enumerate each character of $T$ from right to left and go to $go_{\text{current node,current character}}$.</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>In this section we’ll talk about how to construct the suffix tree and maintain $len_x, fail_x, go_{x,ch}$ by adding characters of $S$ one by one from right to left.</p>
<p>That is, we have already built SAM of $S$, now we wanna get SAM of $cS$ out of it.</p>
<p>From $S$ to $cS$, only one more suffix’s added, that’s $cS$. So first we’ll insert $cS$ into the suffix tree (remember the suffix tree here is still a trie) and maintain $len_x, fail_x$ of the newly-added vertices. We do it in the following way: we create a new vertex $u$ that represents $cS$, then we find the longest $cS[1:i]$ that occurred in $S$ and let the corresponding vertex be $v$. Then we add vertices representing $cS[1:|S|-1],cS[1:|S|-2], \cdots S[1:i+1]$ between $u$ and $v$.</p>
<p>Consider about the changes in $go_{x,ch}$, they can be divided into two types:</p>
<ul>
<li>$x$ is one of those newly-added vertices, or</li>
<li>$go_{x,ch}$ is one of those newly-added vertices</li>
</ul>
<p>Note it’s impossible to have $x$ and $go_{x,ch}$ both newly-added.</p>
<p>For the first type, since strings the newly-added vertices represent do not occur in $S$, so after adding $c$ at the front they won’t occur either. Then just set all $go_{x,ch}$ of the newly-added vertices to <code>null</code>.</p>
<p>For the second type, we enumerate all prefixes of $S$ that $go_{S[1:j],c}$ is <code>null</code>, then let $go_{S[1:j],c}$ be $cS[1:j]$. This can be done by starting from $S$ and each time jumping to the father of current node until $go_{\text{current node},ch}$ is not <code>null</code>.</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>Note there can be $O(|S|^2)$ vertices in the suffix tree, but number of vertices with degree greater than $2$ is at most $2|S|-1$. Then if a vertex has only one child, we compress it and its’ only-child and say the original father is ‘compressed’. Specially, because suffix vertices contain a lot of important information so we’ll never compress a suffix vertex, even if it has only one child. We call all remaining vertices after the process ‘key vertices’.</p>
<p>Define:</p>
<ul>
<li>$Z(x)$: let $Z(x)$ be the set of strings that vertices compressed into $x$ represented in the original suffix tree. Note that all strings in $Z(x)$ can be represented as one prefix of the longest string in $Z(x)$.</li>
<li>$len_x$: the length of longest string in $Z(x)$.</li>
<li>$fail_x$: the first key vertex we meet in the original suffix tree by starting from $x$ and continuously jumping to father of the current node.</li>
<li>$go_{x,ch}$:<ul>
<li>An important fact is that in the original suffix tree $go_{x,ch}$ must be compressed if $x$ is compressed. To prove this let $T$ be the string $x$ represents and $cT$ be some key vertex.<ul>
<li>If $cT$ is a suffix vertex then $T$ should also be a suffix vertex which made $T$ impossible to be compressed.</li>
<li>Then $cT$ must have two distinct children, let them be $cTx$ and $cTy$. It turns out that $T$ should also have $Tx$ and $Ty$ as its children, which meets a contradiction.</li>
</ul>
</li>
<li>But if $x$ is a key vertex, $go_{x,ch}$ in the original suffix tree may be compressed. In this case we let $go_{x,ch}$ be the key vertex that the original $go_{x,ch}$ has been compressed into. Thus we can ensure $\forall Y\in Z(x), cY \in Z(go_{x,c})$.</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/17/vOGy15NqmpSt9wr.png" alt=""></p>
<p>(This is a picture from Huadun Hong’s slide, representing $go_{x,c}$.)</p>
<p>Then consider how to build SAM with our previous algorithm. First we create a new vertex stands for $cS$. </p>
<p>Finding the greatest $i$ that $cS[1:i]$ occurs in $S$ is equivalent to finding the greatest $i$ that $go_{S[1:i],c}$ is not <code>null</code>. So we can just start from $S$ and continuously jump to $fail_{\text{current node}}$ until the current node satisfies $go_{\text{current node},c}$ is not <code>null</code>. Let this vertex be $Q$ and $E$ be $go_{Q,c}$.</p>
<p>We should set $fail_{cS}$ to a vertex that the longest string it represents is $cQ$. But note that $cQ$ may not be the longest one in $Z(E)$, if so we shall ‘decompress’ it from $E$ since we’re about to add a new child to it. Let the newly-decompressed vertex be $K$ (let $K$ be $E$ in case that $cQ$ is the longest one in $Z(E)$) and let $fail_{cS} = K$.</p>
<p>Now we’ll take a look at changes in $go_{x,ch}$: </p>
<ul>
<li>like the original $O(|S|^2)$ suffix tree, we set $go_{x,c}$ of all vertices on the chain from $S$ to $Q$ to $cS$</li>
<li>and for $Q$ and $Q$’s ancestors satisfying $go_{x,c} = E$, we change $go_{x,c}$ to $K$.</li>
</ul>
<p>Thus we’ve completed contruction of SAM.</p>
<p>It turns out that time complexity and memory complexity of this algorithm are both $O(|S|)$. </p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>APIO2019</title>
    <url>/2020/02/14/APIO2019/</url>
    <content><![CDATA[<h2 id="桥梁"><a href="#桥梁" class="headerlink" title="桥梁"></a>桥梁</h2><p>将所有的操作按照时间顺序分成$T$个大小为$\frac{q}{T}$的块。对于每个块，将块内的询问按照$w_j$排序，将未被块内的操作修改过的边按照执行这个块内的操作之前的边权排序。</p>
<p>按照$w_j$降序枚举块内的询问，然后将所有重$w_j$的车能够通过的、“未被块内的操作修改过的”边加入；再加入块内修改过的、这次询问的时候的边权$\ge w_j$的边，查询$s_j$所在连通块的大小，然后再撤销掉加入的块内修改过的边。</p>
<p>复杂度是$O(\frac{q}{T}(m\log m + m\log n) + qT\log n)$，当$T$大致取到$\sqrt m$的时候最优。由于排序的那个$\log m$比并查集的$\log n$大得多，所以可以适当调大$T$。</p>
<p><a href="https://loj.ac/submission/731393" target="_blank" rel="noopener">Code</a></p>
<h2 id="路灯"><a href="#路灯" class="headerlink" title="路灯"></a>路灯</h2><p>对每个时刻的序列，维护它的极长的、只包含$1$的区间构成的集合。</p>
<p>对每个曾经在集合中出现过的极长$1$区间，将它对每个询问的贡献分成两部分：</p>
<ol>
<li>询问的时候它还在序列中，贡献是询问的时刻 - 它被加入的时刻（由于极长$1$区间不交，所以对于一个询问，这种区间如果有则一定只有一个）；</li>
<li>询问的时候它已经不在序列中了，贡献就是它出现过的时刻数；</li>
</ol>
<p>而一个极长$1$区间$[l,r]$对一个询问$[a,b]$能产生贡献当且仅当$l\le a, b-1\le r$，是个二维偏序。加上“离开序列的时间小于询问的时间”就是三维偏序，可以cdq分治解决。</p>
<p>而第一种贡献用set维护当前时刻所有的极长$1$区间就能计算。</p>
<p><a href="https://loj.ac/submission/744366" target="_blank" rel="noopener">Code</a></p>
<h2 id="奇怪装置"><a href="#奇怪装置" class="headerlink" title="奇怪装置"></a>奇怪装置</h2><p>考虑什么情况下两个时刻的$(x,y)$会相同。</p>
<p>因为$y=(t\bmod B)$，所以这两个时刻可以写成$t,t+kB$。</p>
<script type="math/tex; mode=display">
t + \lfloor \frac{t}{B} \rfloor \equiv t + kB + \lfloor \frac{t+kB}{B} \rfloor \pmod A\\
t + \lfloor \frac{t}{B} \rfloor \equiv t + kB + \lfloor \frac{t}{B} \rfloor + k \pmod A\\
0 \equiv k(B+1) \pmod A\\
A \mid k(B+1)</script><p>考虑$B+1,A$的质因数分解：</p>
<script type="math/tex; mode=display">
B+1 = \prod p_i^{b_i}\\
A = \prod p_i^{a_i}</script><p>则最小的满足条件的$k$就是</p>
<script type="math/tex; mode=display">
k_{min}\prod p_i^{\max\{a_i - b_i,0\}}\\
= \prod p_i^{a_i - \min\{b_i,a_i\}}\\
= \frac{A}{\gcd(A,B+1)}</script><p>且其它满足条件的$k$都是它的倍数。</p>
<p>所以$t_1,t_2$的二元组$(x,y)$相同当且仅当$t_1\equiv t_2\pmod{k_{min}B}$</p>
<p>这样就转化成了简单的区间并问题。</p>
<p>注意考虑$k_{min}B$超过long long范围的情况。</p>
<p><a href="https://loj.ac/submission/744366" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1270 Goodbye 2019 (C,D,E,F,G,H)</title>
    <url>/2020/01/27/CF1270-Goodbye-2019-C-D-E-F-G-H/</url>
    <content><![CDATA[<h2 id="C-Make-Good"><a href="#C-Make-Good" class="headerlink" title="C - Make Good"></a>C - Make Good</h2><p>记$sum$为所有数的异或和，$tot$为所有数的和。$tot$显然必须是偶数。所以如果$tot$是奇数的话，就先往数组里面加入一个$1$。</p>
<p>如果$2\times sum &gt; tot$，就往数组里面加入两个${2\times sum - tot \over 2}$，这对数组中的数的异或和没有影响。</p>
<p>否则，先加入一个$2^{58}$（一个很大的$2$的整数次幂），然后就会转化成$2\times sum &gt; tot$的情况。</p>
<p>如果又要加入$1$又要加入$2^{58}$，可以直接加入数$1+2^{58}$，这样就可以满足加的数至多是三个的限制。</p>
<p><a href="https://codeforces.com/contest/1270/submission/67904998" target="_blank" rel="noopener">Code</a></p>
<h2 id="D-Strange-Device"><a href="#D-Strange-Device" class="headerlink" title="D - Strange Device"></a>D - Strange Device</h2><p>首先考虑$k=n-1$怎么做：可以把每个大小为$n-1$的子集都问一遍，这样第$m+1$小的会出现$m$次，第$m$小的会出现$n-m$次，根据出现过的元素的大小关系以及它们分别的出现次数就可以推出$m$。</p>
<p>当$n&gt;k+1$，直接对前$k+1$个元素通过上面的方法计算就可以了。</p>
<p><a href="https://codeforces.com/contest/1270/submission/67910798" target="_blank" rel="noopener">Code</a></p>
<h2 id="E-Divide-Points"><a href="#E-Divide-Points" class="headerlink" title="E - Divide Points"></a>E - Divide Points</h2><p>将点分成四组：$A_{0,0},A_{0,1},A_{1,0},A_{1,1}$。点$(x,y)$属于组$A_{x\pmod 2,y\pmod 2}$。用$P,Q$代表最后分得的两个点集。</p>
<p>若所有点都属于同一个组，则将所有点的坐标除以$2$（如果原数是奇数，则向下取整）之后再做，与原问题等价。</p>
<p>如果$A_{0,0}\cup A_{1,1}$非空，且$A_{0,1}\cup A_{1,0}$非空，令$P=A_{0,0}\cup A_{1,1},Q=A_{0,1}\cup A_{1,0}$即可。【同一组内的点的$(x+y)\bmod 2$相同】</p>
<p>否则，若$A_{0,0}\cup A_{1,1}$为空集，令$P=A_{0,1},Q=A_{1,0}$即可。【只有同一组内的点的$(x_1-x_2)^2 + (y_1-y_2)^2$是$4$的倍数】</p>
<p>否则$A_{0,1}\cup A_{1,0}$为空集，令$P=A_{0,0},Q=A_{1,1}$。【同上】</p>
<p><a href="https://codeforces.com/contest/1270/submission/68144464" target="_blank" rel="noopener">Code</a></p>
<h2 id="F-Awesome-Substrings"><a href="#F-Awesome-Substrings" class="headerlink" title="F - Awesome Substrings"></a>F - Awesome Substrings</h2><p>设$x = {L\over cnt}$，其中$L$表示子串的长度，$cnt$表示子串内$1$的个数。设$T$为某个定值。</p>
<p>设$a_i = \sum_{j\le i} [s_j = 1]$。</p>
<p>将答案分为两部分计算；</p>
<ol>
<li>$x\le T$：枚举每一个$x$，然后枚举子串右端点$r$，则左端点应满足${r-(l-1)\over a_r-a_{l-1}} = x\Rightarrow r-a_rx = l-1-a_{l-1}x$，直接用map或者hash_table统计一下即可。</li>
<li>$x&gt; T$，显然有$cnt = {L\over x} \le {n\over T}$，所以可以枚举子串的左端点和$cnt$，此时要求右端点必须落在某个区间内且$r-l+1 \pmod {cnt}$为$0$，可以$O(1)$计算这样的右端点的数量。</li>
</ol>
<p>如果用map，时间复杂度$O(nT\log n + n\cdot {n \over T})$，当$T$取${\sqrt{n\over \log n}}$的时候复杂度最优，为$O(n\sqrt {n\log n})$。</p>
<p><a href="https://codeforces.com/contest/1270/submission/68145267" target="_blank" rel="noopener">Code</a></p>
<h2 id="G-Subset-with-Zero-Sum"><a href="#G-Subset-with-Zero-Sum" class="headerlink" title="G - Subset with Zero Sum"></a>G - Subset with Zero Sum</h2><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>$i-n\le a_i \le i-1$等价于$1\le i - a_i \le n$。</p>
<p>令$i$向$i-a_i$连边，会得到基环内向树森林。取一个环上的所有元素：</p>
<script type="math/tex; mode=display">
x - a_x = y \\
y - a_y = z \\
\vdots \\
u - a_u = x</script><p>将所有式子加起来，会得到$a_x+a_y+\cdots a_u = 0$。</p>
<p><a href="https://codeforces.com/contest/1270/submission/68150511" target="_blank" rel="noopener">Code</a></p>
<h2 id="H-Number-of-Components"><a href="#H-Number-of-Components" class="headerlink" title="H - Number of Components"></a>H - Number of Components</h2><p>观察发现，如果$i,j(i&lt;j)$连通，那么对于任意的$k\in (i,j)$，$k$与$i,j$连通。</p>
<p>证明：考虑连通块中从$i$到$j$的一条路径，若$k$在这条路径上结论显然成立；否则，这其中必定存在一条边$(u,v)$满足$u &lt; k &lt; v$，由于$a_u &lt; a_v$，所以$a_u &lt; a_k \vee a_k&lt; a_v$一定成立。</p>
<p>所以，连通块一定是序列上的一段连续的区间。</p>
<p>将问题转化成：计算有多少个$p$，满足$[1,p]$和$[p+1,n]$之间没有边。而这个限制条件也等价于$\forall x\in [1,p], y\in [p+1,n], a_x &gt; a_y$。</p>
<p>考虑枚举$[p+1,n]$中的最大值$v$，记序列中小于等于$v$的值为$0$，大于$v$的值为$1$，则$p$合法的条件就是整个序列形如$\overbrace{111\cdots 111}^{\text{p个1}}000\cdots 000$。</p>
<p>发现对于每个$v$而言，它对应的$01$序列是确定的，也就是说尽管一个$v$可以对应多个$p$，但是这些$p$中至多只有一个合法。</p>
<p>所以我们不妨直接统计有多少个$v$对应的$01$序列形如$111\cdots 111000\cdots 000$。</p>
<p>为了方便处理，我们令$a_0 = + \infty, a_{n+1} = -\infty$</p>
<p>用线段树维护对每一个$v$维护它对应的$01$序列中相邻的$10$对的数量，以及$v$是否作为序列中的某个元素出现。由于$10$对的数量至少有一个，所以维护最小值以及最小值的数量，即可得到合法的$v$的数量。</p>
<p><a href="https://codeforces.com/contest/1270/submission/68155123" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>Contests</tag>
      </tags>
  </entry>
  <entry>
    <title>一类序列上的最短路问题-倍增</title>
    <url>/2020/01/27/%E4%B8%80%E7%B1%BB%E5%BA%8F%E5%88%97%E4%B8%8A%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98-%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<h2 id="CF1246F-Cursor-Distance"><a href="#CF1246F-Cursor-Distance" class="headerlink" title="CF1246F Cursor Distance"></a>CF1246F Cursor Distance</h2><p>考虑对于每一个$i$，求出至多走$k$步就能够到达它的位置所构成的区间$[L_{i,k},R_{i,k}]$。我们只要对每个$i$分别求出$\sum_k L_{i,k},\sum_k R_{i,k}$就能得到答案。</p>
<p>最短路不一定是单向的（比如对于baaaaac，从b走到最后一个a），所以$L,R$可能不独立，不能直接倍增计算$L,R$的和。</p>
<p>进一步观察，$R_{i,k+2}$的取值与$[L_{i,k+1},L_{i,k})$中的位置有关的必要条件是$[L_{i,k+1},R_{i,k+1}]$的字符集大于$[L_{i,k},R_{i,k}]$的字符集；如果$[L_{i,k+1},R_{i,k+1}],[L_{i,k},R_{i,k}]$字符集相同，则$R_{i,k+2}$就只与$R_{i,k+1}$和$[L_{i,k},R_{i,k}]$的字符集大小有关。</p>
<p>对于每个$i$，当$k$从$0$取到$+\infty$的时候，$[L_{i,k},R_{i,k}]$的字符集大小只会变化$|\Sigma|$次（$|\Sigma|$表示字符集大小）。故而，我们可以枚举当前这些区间的字符集大小，这时候$L,R$是独立的，可以直接倍增求出它们的和。</p>
<p>实现细节上，在最外层枚举区间的字符集大小$t$，然后对每个位置$i$处理出$fl_i$——表示当$L$为某个满足$[L,i]$字符集大小为$t$的位置，$R=i$的时候，跳一步能够把$R$扩展到哪里；以及类似定义的$fr_i$。预处理出$fl_i,fr_i$倍增的结果。然后对每个$i$从大到小枚举$j$，然后看它现在的区间端点扩展$2^j$次以后，区间内是否仍然只有$t$种字符。</p>
<p><a href="https://codeforces.com/contest/1246/submission/69554739" target="_blank" rel="noopener">Code</a></p>
<hr>
<h2 id="LOJ6435-「PKUSC2018」星际穿越"><a href="#LOJ6435-「PKUSC2018」星际穿越" class="headerlink" title="LOJ6435 「PKUSC2018」星际穿越"></a>LOJ6435 「PKUSC2018」星际穿越</h2><p><a href="https://www.cnblogs.com/HocRiser/p/9166459.html" target="_blank" rel="noopener">参考这篇blog</a></p>
<p>设$f_{i,k}$为从$i$出发，走$k$步能够到达的最靠左的点。则有$f_{i,k+1} &lt; f_{i,k}$。</p>
<p>显然$f_{i,1} = l_i$。</p>
<p>然后是$f_{i,2} = \min_{j \ge l_i} \{l_j\}$：</p>
<ul>
<li>对于$j\in [l_i,i)$，$i$可以在第一步走到$j$；</li>
<li>对于$j&gt;i$，如果$l_j\le i$我们可以选择在第一步走到$j$，否则$l_j &gt; i$，$l_j$一定不会被$\min_{x\ge l_i}\{l_x\}$取到。</li>
</ul>
<p>对于$f_{i,k} (k &gt; 2)$，有$f_{i,k} = \min_{j\in [f_{i,k-1},f_{i,k-2})} \{ l_j \} = \min_{j\in [f_{i,k-1},i)} \{ l_j \}$。由于显然$f_{i,k} &lt; f_{i,2} \le \min_{j\ge i} \{l_j\}(k &gt; 2)$，所以也可以写作$f_{i,k} = \min_{j\in [f_{i,k-1},n]} \{ l_j \}$。这个式子中$f_{i,k}$的取值与$i$无关而只与$f_{i,k-1}$有关，所以可以倍增求出$k=2^j$时的$f_{i,k}$和$\sum_{x\in [1,k]}f_{i,x}$。</p>
<p>实现上，可以强制先走$k=1$的第一步$f_{i,1} = l_i$，这样的话之后的每一步的转移都满足$f_{i,k} = \min_{j\ge f_{i,k-1}} \{ l_j\}$</p>
<p><a href="https://loj.ac/submission/730991" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划练习题</title>
    <url>/2020/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="TopCoder14929-MaxSquare"><a href="#TopCoder14929-MaxSquare" class="headerlink" title="TopCoder14929 MaxSquare"></a>TopCoder14929 MaxSquare</h2><p><a href="https://www.topcoder.com/single-round-match-735-editorials/" target="_blank" rel="noopener">official editorial</a></p>
<p>设$s_i$表示$B$的前缀和。</p>
<script type="math/tex; mode=display">
Ans = \max_{r_1-l_1=r_2-l_2} \{(r_1-l_1)(s_{r_2}-s_{l_2}) +(r_2-l_2)(s_{r_1}-s_{l_1})\}</script><p>显然最优的时候$r_2=r_1,l_2=l_1$，所以</p>
<script type="math/tex; mode=display">
Ans = 2 \max_{l,r} \{ (r-l)(s_r-s_l) \}</script><p>想象成平面上有$n$个点$(i,s_i)$，那么上式等价于：选择两个点作为矩形的两个相对的顶点，矩形的面积的最大值。</p>
<p>我们先考虑一个点作为左下角的点，另一个点作为右上角的点的情况（一个点作为左上角，另一个作为右下角是同理的）。</p>
<p>显然对于作为左下角的那些点来说，如果$i &lt; j\wedge s_i &lt; s_j$，那么$(i,s_i)$是没有用的。右上角同理。</p>
<p>所以有用的点会形成这样的分布：</p>
<p><img src="https://i.loli.net/2020/01/20/aDlrPFwYMVf6nTN.png" alt="TopCoder14929_1_.png"></p>
<p>然后对于每个右上角的点，考虑矩形面积在左下角的哪一个点取到最大值。观察下图：</p>
<p><img src="https://i.loli.net/2020/01/20/LXA8iwFR3cjnDvJ.png" alt="TopCoder14929_2_.png"></p>
<p>可以得到结论：如果对于$p_1$，$q_2$比$q_1$优，那么对于$p_2$，$q_2$一定比$q_1$优秀。</p>
<p>证明：考虑反证</p>
<script type="math/tex; mode=display">
S_{p_1,q_1} < S_{p_1,q_2},S_{p_2,q_1} > S_{p_2,q_2}\\
\Rightarrow S_{p_1,q_1} + S_{p_2,q_2} < S_{p_1,q_2} +S_{p_2,q_1}\\
\Rightarrow S_{p_1,q_1} + S_{p_2,q_2} - S_{p_1,q_2} - S_{p_2,q_1} < 0\\</script><p>也就是上图中绿色标出的部分，其面积要小于$0$，推出了矛盾。</p>
<p>用经典的决策单调性的分治算法，就可以在$O(n\log n)$的时间内解决问题。</p>
<h2 id="CF908H-New-Year-and-Boolean-Bridges"><a href="#CF908H-New-Year-and-Boolean-Bridges" class="headerlink" title="CF908H New Year and Boolean Bridges"></a>CF908H New Year and Boolean Bridges</h2><p>$f(i,j) \operatorname{AND} f(j,i) =1$的肯定在同一个SCC里面，而$f(i,j) \operatorname{XOR} f(j,i) =1$的肯定不在同一个SCC里面。而由于$f(i,j) \operatorname{AND} f(j,i) =1,f(i,j) \operatorname{XOR} f(j,i) =1$中都蕴含着$f(i,j) \operatorname{OR} f(j,i) =1$，所以我们必须把所有的SCC都连成一条链。由于要让边数尽可能少，所以每个SCC一定都是单独一个点或者一个环。我们只要最小化点数大于$1$的SCC的数量就可以了。</p>
<p>$f(i,j) \operatorname{AND} f(j,i) =1$的点可以直接缩起来。缩完点之后，在原图中的点数为$1$的都不需要考虑；对于剩下的点，对所有的$f(i,j) \operatorname{XOR} f(j,i) =1$在$i,j$之间建一条边，问题转化成求最小的$k$，使得在这张图中可以将这些点划分成$k$个独立集。</p>
<p>注意到在原图中对应的点数大于$1$的点的数量不超过$\lfloor{n\over 2}\rfloor = 23$。</p>
<p>直接子集$dp$的复杂度是$O(3^{n\over 2})$或者$O(n^22^{n\over 2})$。</p>
<p>先枚举$k$，在判断的时候我们把条件放松一些：我们只要求能够选出$k$个独立集，它们的并是全集就可以了。</p>
<p>设$f_S$表示$S$的子集中是独立集的数量，通过容斥就可以得到：</p>
<script type="math/tex; mode=display">
Ans = \sum_{T\in V} (-1)^{|V|-|T|}f_T^k</script><p>这个$Ans$会很大，但是我们只关心$Ans$是否为$0$，用取模或者直接溢出后的结果判断就可以了。</p>
<p>时间复杂度$O(n2^{n\over 2})$。</p>
<p><a href="https://codeforces.com/contest/908/submission/69094070" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2292-「THUSC-2016」成绩单"><a href="#LOJ2292-「THUSC-2016」成绩单" class="headerlink" title="LOJ2292 「THUSC 2016」成绩单"></a>LOJ2292 「THUSC 2016」成绩单</h2><p>设$f_{i,j,l,r}$表示区间$[i,j]$已经删掉若干，剩下的那些元素中的最大值为$r$，最小值为$l$，删掉那若干个元素的最小代价；$g_{i,j}$表示将区间$[i,j]$全部删完的最小代价。</p>
<p>对于$f_{i,j,l,r}$，考虑$j$这个元素是否被删掉了：</p>
<ul>
<li>如果它已经被删掉，我们枚举它是和哪些元素一起删掉的，就有：<script type="math/tex; mode=display">
f_{i,k,l,r} + g_{k+1,j} \to f_{i,j,l,r}</script></li>
<li>否则，$j$没有被删掉，则得到<script type="math/tex; mode=display">
f_{i,j-1,l,r} \to f_{i,j,\min\{l,w_j\},\max\{r,w_j\}}</script></li>
</ul>
<p>对于$g$，考虑我们是否对$[i,j]$整体进行过操作：</p>
<ul>
<li>如果没有，则<script type="math/tex; mode=display">
g_{i,k} + g_{k+1,j}\to g_{i,j}</script></li>
<li>否则<script type="math/tex; mode=display">
f_{i,j,l,r} + a + b(r-l)^2 \to g_{i,j}</script></li>
</ul>
<p>复杂度$O(n^5)$。</p>
<p><a href="https://loj.ac/submission/726342" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>图论练习题</title>
    <url>/2020/01/19/%E5%9B%BE%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="LOJ2146-「SHOI2017」寿司餐厅"><a href="#LOJ2146-「SHOI2017」寿司餐厅" class="headerlink" title="LOJ2146 「SHOI2017」寿司餐厅"></a>LOJ2146 「SHOI2017」寿司餐厅</h2><p>把$mx^2 + cx$拆一下就是：只要吃的寿司里面有代号为$x$的就要付出$mx^2$的代价；每吃一种代号为$x$的寿司就要付出$x$的代价。直接令$d_{i,i}$减掉$a_i$，就可以不再考虑$cx$这部分。</p>
<p>对每个区间$[l,r]$建一个点，权值为$d_{l,r}$；对每个代号建一个点，权值为$-mx^2$。如果选了$d_{l,r}$就必须选$d_{l,r-1}$和$d_{l+1,r}$，如果选了$d_{i,i}$就必须选$ma_i^2$。求出这张图的最大权闭合子图即可。</p>
<p><a href="https://loj.ac/submission/723604" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2100-「TJOI2015」线性代数"><a href="#LOJ2100-「TJOI2015」线性代数" class="headerlink" title="LOJ2100 「TJOI2015」线性代数"></a>LOJ2100 「TJOI2015」线性代数</h2><p>把$A$想象成$\{1,2,\cdots n\}$的一个子集，$0$表示不选，$1$表示选。则：</p>
<script type="math/tex; mode=display">
val(A) = \sum_{i\in A\wedge j\in A} B_{i,j} - \sum_{i\in A} C_i</script><p>对每个$B_{i,j}$和$C_i$建一个点，权值分别为$B_{i,j},-C_i$，要求如果选了$B_{i,j}$则必须选$-C_i$和$-C_j$。求出这张图的最大权闭合子图即可。</p>
<p><a href="https://loj.ac/submission/723647" target="_blank" rel="noopener">Code</a></p>
<h2 id="UOJ41-【清华集训2014】矩阵变换"><a href="#UOJ41-【清华集训2014】矩阵变换" class="headerlink" title="UOJ41 【清华集训2014】矩阵变换"></a>UOJ41 【清华集训2014】矩阵变换</h2><p>考虑什么样的方案是不合法的：第$x$行选择了$y$，并且存在另一行$x’$，$y$在$x’$行的出现的列编号大于$y$在$x$行出现的列编号，且$x’$行选择的那个数字的列编号在$y$之后。</p>
<p>可以转化成稳定婚姻问题：由于要求每列中每个数至多出现一次，所以每一行选择的数显然是不同的，所以可以把问题看作求行和数字的匹配。对于每一行，在那一行出现的列编号越小的数字越好；对于每一个数字，它在其中出现的位置越靠后的行越好。这样求出的解显然能够规避上面说的不合法情况。</p>
<p><a href="http://uoj.ac/submission/380077" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2052-「HNOI2016」矿区"><a href="#LOJ2052-「HNOI2016」矿区" class="headerlink" title="LOJ2052 「HNOI2016」矿区"></a>LOJ2052 「HNOI2016」矿区</h2><p>分母很容易算，考虑怎么求分子。</p>
<p>将平面图转化成对偶图之后，以无穷域为根，求出一棵dfs树，并处理出子树内的块的矿量和。</p>
<p>考虑给出的开发区域的每一条边：如果它在对偶图中是非树边则不管它；如果它是树边，且它连接的两个点中，开发区域外的点是父亲，那么就让总和加上区域内的那个子树的权值；如果它是树边，且它连接的两个点中，区域里的点是父亲，那么就让总和减去区域外的那个子树的权值。</p>
<p>注意对偶图中可能是有重边的。</p>
<p><a href="https://loj.ac/submission/725254" target="_blank" rel="noopener">Code</a></p>
<h2 id="TopCoder14750-HeroicSchedule"><a href="#TopCoder14750-HeroicSchedule" class="headerlink" title="TopCoder14750 HeroicSchedule"></a>TopCoder14750 HeroicSchedule</h2><p><a href="https://vjudge.net/problem/TopCoder-14750" target="_blank" rel="noopener">可以在vjudge上提交</a> </p>
<p>下面用$n$表示点数，$m$表示边数。</p>
<p>由费用流的过程可以知道，将所有的任务按照收益从大到小排序之后，依次考虑每个任务，能够加入则加入，则一定能够得到最优的解。</p>
<p>尝试加入的过程就是求匹配的过程，考虑用匈牙利算法来实现这一部分。直接做的复杂度是$O(n^2m^2)$的。</p>
<p>发现尽管边数很大，但是遍历边集的时候我们实际上是在一个区间内的点中找到一个vis不为$0$的点，用set就可以在$O(\log m)$的时间内完成。复杂度优化到$O(n(\log m + m\log m))$。</p>
<p>更进一步观察发现，只要当前已经求出的匹配没有变化，就没有清空vis的必要。而匹配的大小只会从$1$变到至多$m$，也意味着匹配至多会改变$m$次。所以我们的等到匹配改变的时候才清空vis，就能把复杂度做到$O(n\log m + m^2 \log m)$。</p>
<p><a href="https://vjudge.net/solution/23740620" target="_blank" rel="noopener">Code</a></p>
<h2 id="HDU6431-NewNippori"><a href="#HDU6431-NewNippori" class="headerlink" title="HDU6431 NewNippori"></a>HDU6431 NewNippori</h2><p>分别求出$maxflow(x,y)$为1,2的点对的数量，就可以算出答案。</p>
<p>$maxflow(x,y)=1$的点对即不在同一个边双连通分量的点对。</p>
<p>$maxflow(x,y)=2$的点对一定在同一个边双连通分量且可以通过割掉两条边使它们不连通。</p>
<p>对每个边双连通分量分别考虑。首先求出一棵dfs树。考虑割掉哪些边能够把这个边双分成不连通的两个部分：</p>
<ul>
<li>割一条树边和一条非树边。我们称一条非树边覆盖了一条树边，当且仅当非树边的两个端点在树上的最短路包含了那条树边。由于这是一个边双，所以每条树边至少被一条非树边覆盖；又由于我们只能割一条非树边，而覆盖了我们割的那条树边的非树边必须全部被割掉，所以我们割的树边一定恰好只有一条非树边覆盖了它。把那条树边和覆盖它的非树边割掉，可以把dfs树上树边两侧的部分割开。</li>
<li><p>割两条树边。考虑这两条树边割开之后树边将dfs树分成了三部分：<br><img src="https://i.loli.net/2020/01/18/28qR5MKJlmvCa3w.png" alt="hdu6431.png"><br>其中黑色的圈表示树上的连通块，黑色的虚线表示割掉的树边，1，2，3分别表示在这三个连通块之间的非树边。</p>
<ul>
<li>如果1存在，由于每条树边都至少有一条非树边覆盖了它，所以2和3至少有一条边存在，所以这时三个块仍然连通。2存在同理。</li>
<li>如果这三种边中，只有3这种边存在，发现割了两条树边之后，A和B组成的连通块和C之间没有边。</li>
</ul>
<p>所以，割的两条树边一定满足：所有的非树边要么同时覆盖这两条边，要么同时不覆盖这两条边。</p>
</li>
</ul>
<p>如何判断覆盖了两条树边的非树边集合是否相同：可以用与<a href="http://uoj.ac/problem/207" target="_blank" rel="noopener">uoj207</a>那道题一样的方法，给每一条非树边随机一个$[0,2^{64})$的权值，设每个点的权值为所有以它作为一端的非树边的权值的异或和。则当两个点的子树内所有点的权值的异或和相同的时候，我们认为这两个点到它们的父亲的那两条边被非树边覆盖的情况相同；当某个点子树内点的权值异或和为某条非树边的权值，我们就认为这个点到父亲的那条边只被那条非树边覆盖。</p>
<p>首先统计跨越了只被一条非树边覆盖了的树边的点对的贡献，然后把这些树边都断开。下面考虑的是断开了这些边之后的每个连通块。</p>
<p>对每个点$x$，统计出满足下面条件的点的数量：存在一对树边，割开之后能够把$x$和这个点隔开，且$x$位于与两条树边都相邻的那个连通块里面（上图中的连通块C）。</p>
<p>由于我们求的是dfs树，所有的非树边都是返祖边，不存在横叉边。所以，被覆盖情况相同的两条树边也一定是祖孙关系。</p>
<p>考虑把$x$夹在了中间的那些可以割掉的树边对：</p>
<p><img src="https://i.loli.net/2020/01/18/8cZQa4xRTtLAPCl.jpg" width="40%" height="100%" ></p>
<p>观察到：</p>
<ul>
<li>对于某条树边，能够和它配对的边显然都在一条祖孙链上。</li>
<li>不可能存在两对树边$(u,v),(x,y)$，满足$dep_u &lt; dep_x &lt; dep_v &lt; dep_y$。</li>
</ul>
<p>所以，对于某个$x$，把它夹在了中间的树边对一定满足：假设这些树边对按照在$x$的上面的那条边的深度升序排序得到的序列是$w_1,w_2,\cdots w_k$，那么按照在$x$的下面的那条边的深度升序排序得到的序列就是$w_k,w_{k-1},\cdots w_1$。我们只需要找出$w_k$：$w_k$把整棵树分成三部分中不包含$x$的那两部分的大小，就是能够通过割两条树边与$x$隔开的点数。</p>
<p>对连通块进行dfs，到达某个点$u$的时候，先递归处理$u$的子树内的点，然后再处理$u$到它的父亲之间的这条边与$u$的子树内的边配对所能够产生的贡献。</p>
<p>找出最后一次访问到的与$e(u,fa_u)$的覆盖情况相同的边$e’$，如果这条边不在$u$的子树内说明$e(u,fa_u)$无法与子树内的边配对；否则，我们只需要考虑$e(u,fa_u)$与$e’$配对就可以了（因为对每个$x$我们只关心包含了它且离它最近的边对，$e(u,fa_u)$和其它的边配对显然不满足这个条件）。我们找出$e’,e(u,fa_u)$之间还没有找到最近的树边对的点，统计它们的贡献，并把它们标记为已经找到了最近的树边对的点。实现上可以用一个数组$ex[u]$来记录每个点的子树内还没有找到最近树边对的点数；由于$e(u,fa_u)$已经和$e’$配对了，所以$e(u,fa_u)$上方的边不可能与$e(u,fa_u)$和$e’$之间的边配对，因此我们不需要维护$e(u,fa_u),e’$之间的点的$ex$，只对$ex[u]$做出相应的更新就可以了。</p>
<p>总复杂度$O(n+m)$或者$O(n\log n + m)$（取决于使用map还是hash_table）</p>
<p>下面是我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> RNG &#123;</span><br><span class="line">    ull seed=<span class="number">13244074693642402u</span>ll;</span><br><span class="line">    <span class="function">ull <span class="title">rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seed^=seed&lt;&lt;<span class="number">13</span>,seed^=seed&gt;&gt;<span class="number">7</span>,seed^=seed&lt;&lt;<span class="number">17</span>;</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> RNG::rnd;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span> &#123;</span> <span class="keyword">int</span> to,id; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;ed&gt; G[N];</span><br><span class="line">ll ans0,ans1;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">namespace</span> tree &#123;</span><br><span class="line">    <span class="keyword">int</span> In[N],vis[N];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line">    <span class="built_in">set</span>&lt;ull&gt; val;</span><br><span class="line">    ull xi[N];</span><br><span class="line">    <span class="keyword">int</span> vise[M];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) <span class="keyword">if</span>(!vise[G[u][i].id]&amp;&amp;In[G[u][i].to]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[u][i].to; vise[G[u][i].id]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]) &#123;</span><br><span class="line">                ull tmp=rnd();</span><br><span class="line">                val.insert(tmp),xi[u]^=tmp,xi[v]^=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> son[u].PB(v),dfs1(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;ull,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> _size,__size;</span><br><span class="line">    <span class="keyword">int</span> ex[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        ex[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre_c=mp.count(xi[u])?mp[xi[u]]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[u].size();++i)</span><br><span class="line">            <span class="keyword">if</span>(vis[son[u][i]]!=<span class="number">2</span>) dfs3(son[u][i]),ex[u]+=ex[son[u][i]];</span><br><span class="line">        <span class="keyword">int</span> c=mp.count(xi[u])?mp[xi[u]]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c&amp;&amp;c!=pre_c) &#123;</span><br><span class="line">            ans1+=<span class="number">2l</span>l*(ex[u]-ex[c])*(ll)(_size-(ex[u]-ex[c]));</span><br><span class="line">            _size-=ex[u]-ex[c];</span><br><span class="line">            ex[u]=ex[c];</span><br><span class="line">        &#125;</span><br><span class="line">        mp[xi[u]]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[u].size();++i)</span><br><span class="line">            tot+=dfs2(son[u][i]),xi[u]^=xi[son[u][i]];</span><br><span class="line">        <span class="keyword">if</span>(val.count(xi[u])) &#123;</span><br><span class="line">            ans1+=tot*(ll)(__size-tot);</span><br><span class="line">            mp.clear(),_size=tot,dfs3(u);</span><br><span class="line">            vis[u]=<span class="number">2</span>,tot=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        __size=a.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();++i) In[a[i]]=<span class="number">1</span>;</span><br><span class="line">        dfs1(a[<span class="number">0</span>]); val.insert(<span class="number">0</span>);</span><br><span class="line">        dfs2(a[<span class="number">0</span>]);</span><br><span class="line">        val.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();++i) In[a[i]]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) xi[i]=vis[i]=<span class="number">0</span>,son[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) vise[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N],top;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],id;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> lasteid)</span> </span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++id,st[++top]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) <span class="keyword">if</span>(G[u][i].id!=lasteid) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[u][i].to;</span><br><span class="line">        <span class="keyword">if</span>(dfn[v]) low[u]=min(low[u],dfn[v]);</span><br><span class="line">        <span class="keyword">else</span> tarjan(v,G[u][i].id),low[u]=min(low[u],low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u]) &#123;</span><br><span class="line">        <span class="keyword">do</span> a.PB(st[top]); <span class="keyword">while</span>(st[top--]!=u);</span><br><span class="line">        tree::sol(a),ans0+=a.size()*(n-a.size());</span><br><span class="line">        a.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; rd(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        rd(n),rd(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i) &#123;</span><br><span class="line">            rd(x),rd(y);</span><br><span class="line">            G[x].PB((ed)&#123;y,i&#125;),G[y].PB((ed)&#123;x,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        ans0/=<span class="number">2</span>,ans1/=<span class="number">2</span>;</span><br><span class="line">        ll ans2=n*(ll)(n<span class="number">-1</span>)/<span class="number">2</span>-ans0-ans1;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans0+ans1*<span class="number">2</span>+ans2*<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) G[i].clear(),dfn[i]=<span class="number">0</span>; id=top=<span class="number">0</span>;</span><br><span class="line">        ans0=ans1=<span class="number">0</span>;</span><br><span class="line">        tree::init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>组合计数练习题</title>
    <url>/2020/01/15/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="UOJ422-小z的礼物"><a href="#UOJ422-小z的礼物" class="headerlink" title="UOJ422 小z的礼物"></a>UOJ422 小z的礼物</h2><p>考虑min-max容斥：</p>
<script type="math/tex; mode=display">
\max (S) = \sum_{T\subseteq S} (-1)^{|T|+1} \min (T)</script><p>对希望得到的物品的每一个子集，求出期望最早什么时候子集里至少有一个物品被拿到了，就能算出答案。</p>
<p>设包含了至少一个这个子集内的物品的相邻的格子对的数量是$a$，所有的相邻的格子对的数量是$b$，那么这个期望值就是$b\over a$。$a$是一个定值；$b$则可以看做（子集内每一个物品包含它的相邻格子对数量的和）-（同时包含了子集内的两个物品的相邻格子对的数量）。</p>
<p>设$f_{S,t}$表示上一列选了的格子的集合是$S$，之前选过的格子的（子集内每一个物品包含它的相邻格子对数量的和）-（同时包含了子集内的两个物品的相邻格子对的数量）为$t$，所有方案的容斥系数的和。用类似轮廓线dp的方法转移，就可以做到$O(2^n n^2m^2)$的复杂度。</p>
<p><a href="http://uoj.ac/submission/379524" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2320「清华集训-2017」生成树计数"><a href="#LOJ2320「清华集训-2017」生成树计数" class="headerlink" title="LOJ2320「清华集训 2017」生成树计数"></a>LOJ2320「清华集训 2017」生成树计数</h2><p>把原题的式子换一个表达的方式：把每个连通块看做一个点，设$d_i$为每个点的度数，则</p>
<script type="math/tex; mode=display">
val (T) = (\sum_{i=1}^n d_i^m) (\prod_{i=1}^n d_i^m )(\prod_{i=1}^n a_i^{d_i})</script><p>因为式子里面有度数，所以考虑用prufer序列来计数。枚举每一个点在prufer序列中出现的次数$k_i$，得到</p>
<script type="math/tex; mode=display">
Ans = \sum_{k_1+k_2+\cdots +k_n=n-2} {(n-2)!\over k_1!k_2!\cdots k_n!} \cdot \sum_{i=1}^n (k_i+1)^{2m}a_i^{k_i+1} \prod_{j\neq i} (k_j+1)^ma_j^{k_j+1}</script><p>设</p>
<script type="math/tex; mode=display">
A_i(x) = \sum_{k=0}^\infty {a_i^{k+1}(k+1)^m\over k!} x^k\\
B_i(x) = \sum_{k=0}^\infty {a_i^{k+1}(k+1)^{2m} \over k!}x^k</script><p>则</p>
<script type="math/tex; mode=display">
Ans= (n-2)!\sum_{i=1}^n (B_i(x)\prod_{j\neq i} A_j(x) )[x^{n-2}]</script><p>因为$A_i(x)$里面有指数为$k+1$，还有$x^k \over k!$，所以尝试对$A_i(x)$积分得到$T(x)$：</p>
<script type="math/tex; mode=display">
T(x) = \sum_{k=0}^\infty {a_i^{k+1}(k+1)^m \over (k+1)!} x^{k+1}\\
=\sum_{k=1}^\infty {a_i^kk^m\over k!}x^k</script><p>将$k^m$展开：</p>
<script type="math/tex; mode=display">
T(x) = \sum_{k=1}^\infty {a_i^k \over k!} x^k \sum_{j=0}^{\min\{m,k\}} \begin{Bmatrix}m\\ j\end{Bmatrix} {k\choose j} j!</script><p>把${k\choose j}j!$与前面的$k!$抵消，得到</p>
<script type="math/tex; mode=display">
T(x) = \sum_{k=1}^\infty a_i^k x^k \sum_{j=0}^{\min\{m,k\}} {1\over (k-j)!}\begin{Bmatrix}m\\ j\end{Bmatrix}</script><p>把$j$提前</p>
<script type="math/tex; mode=display">
T(x) = \sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} \sum_{k=j}^\infty {a_ix^k\over (k-j)!}\\
=\sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} a_i^jx^j \sum_{k=0}^\infty {a_i^kx^k\over k!}\\
=\sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} a_i^jx^j e^{a_ix}</script><p>然后对$T(x)$求导得到$A_i(x)$</p>
<script type="math/tex; mode=display">
A_i(x) = T'(x)\\
=\sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} (j \cdot a_i^jx^{j-1} e^{a_ix} + a_i \cdot a_i^jx^j e^{a_ix}) \\
=\sum_{j=0}^{m} \begin{Bmatrix}m\\ j+1\end{Bmatrix} (j+1)( a_i^{j+1}x^je^{a_ix}) + \sum_{j=0}^{m} \begin{Bmatrix}m\\ j\end{Bmatrix} (a_i^{j+1} x^j e^{a_ix}) \\
= \sum_{j=0}^{m}(\begin{Bmatrix}m\\ j+1\end{Bmatrix} (j+1)+\begin{Bmatrix}m\\ j\end{Bmatrix} ) a_i^{j+1}x^je^{a_ix}\\
= e^{a_ix}\sum_{j=0}^{m}\begin{Bmatrix}m+1\\ j+1\end{Bmatrix} a_i^{j+1}x^j\\</script><p>对$B_i(x)$同理，得到</p>
<script type="math/tex; mode=display">
B_i(x) = e^{a_ix}\sum_{j=0}^{2m}\begin{Bmatrix}2m+1\\ j+1\end{Bmatrix} a_i^{j+1}x^j\\</script><p>所以</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n B_i(x)\prod_{j\neq i} A_i(x)\\
= e^s \sum_{i=1}^n (\sum_{j=0}^{2m}\begin{Bmatrix}2m+1\\ j+1\end{Bmatrix} a_i^{j+1}x^j) \prod_{k\neq i}(\sum_{j=0}^{m}\begin{Bmatrix}m+1\\ j+1\end{Bmatrix} a_k^{j+1}x^j)\\</script><p>上式可以分治NTT求出。</p>
<p><a href="https://loj.ac/submission/719326" target="_blank" rel="noopener">Code</a></p>
<h2 id="ARC062D-Painting-Graphs-with-AtCoDeer"><a href="#ARC062D-Painting-Graphs-with-AtCoDeer" class="headerlink" title="ARC062D Painting Graphs with AtCoDeer"></a>ARC062D Painting Graphs with AtCoDeer</h2><p>每一个边双连通分量显然是独立的。所有边双的本质不同的染色方案数的乘积即是答案。</p>
<p>如果一个边双只包含一条边，那么答案显然是$K$。</p>
<p>如果一个边双恰好只有一个简单环，则是一个经典的Polya（有$K$种颜色的珠子，问有多少种旋转置换下本质不同的项链）。</p>
<p>而如果一个边双包含多于一个环，则从下面的图（来自<a href="http://arc062.contest.atcoder.jp/data/arc/062/editorial.pdf" target="_blank" rel="noopener">官方题解</a>）可以看出，通过若干次操作我们可以交换一对相邻的边（下图中交换了绿色和蓝色的边）。故而两个给这个边双染色的方案是本质不同的，当且仅当它们染成某种颜色的边的数量不同。所以方案数为${K+C-1\choose K-1}$，其中$C$为这个边双内的边数。</p>
<p><img src="https://i.loli.net/2020/01/15/gPTJSesGaVAMH6E.png" alt="image.png"></p>
<p><a href="https://atcoder.jp/contests/arc062/submissions/9511619" target="_blank" rel="noopener">Code</a></p>
<h2 id="HDU6402-Boolean-3-Array"><a href="#HDU6402-Boolean-3-Array" class="headerlink" title="HDU6402 Boolean 3-Array"></a>HDU6402 Boolean 3-Array</h2><p>可以参考<a href="https://projecteuler.net/problem=626" target="_blank" rel="noopener">PE626</a>，它是这道题的低维情形。</p>
<p>下文中的$A,B,C$表示原题中每一维的大小。</p>
<p>考虑简化题目中的置换：令$p_a,p_b,p_c$为三个长度分别为$A,B,C$的排列，每个排列的第$i$个元素表示这个维度上的swap操作使得最初的第$i$层到了哪个位置，令$a_i,b_i,c_i$分别表示每一维的第$i$层进行的翻转操作次数的奇偶性。我们规定先进行$p_a,p_b,p_c$的操作，再进行$a,b,c$的操作。那么原题中的一系列操作的结果将唯一对应到一组$(p_a,p_b,p_c,a,b,c)$。</p>
<p>利用Burnside lemma，数每一个置换的不动点数目。</p>
<p>先只考虑swap操作。枚举$p_a,p_b,p_c$的循环节，假设当前枚举到的循环节长度分别为$la,lb,lc$，考虑循环节中的方块对应的那个$la\times lb\times lc$的正方体。将每个点$(x,y,z)$与$({p_a}_x,{p_b}_y,{p_c}_z)$连边，则这些方块恰好会分裂成$la\cdot lb\cdot lc\over \operatorname{lcm}\{la,lb,lc\}$个连通块（并且每个连通块都是一个环）。显然每个连通块内的格子必须填同一个数，不同连通块的格子没有影响。</p>
<p>考虑flip操作对每一个连通块的影响：记$d_{x,y,z} = (a_x+b_y+c_z) \bmod 2$，则如果连通块内所有点的$\sum d_{x,y,z}$为奇数，则不存在不动点；否则，如下图，环上打了叉的点表示$d_{x,y,z}=1$的点，箭头表示置换的方向：</p>
<p><img src="https://i.loli.net/2020/01/15/iVUJvFXzDeO653Y.jpg" alt="1.jpg"></p>
<p>那么显然只有两种填数方案是不动点：</p>
<p><img src="https://i.loli.net/2020/01/15/hxeA8qLUlyd9QFX.jpg" alt="2.jpg"><br><img src="https://i.loli.net/2020/01/15/dRp3DWlBGZsJjEV.jpg" alt="3.jpg"></p>
<p>首先枚举$p_a,p_b,p_c$的每种长度的循环节的出现次数（设$k_i,l_i$表示长度为$l_i$的循环节出现了$k_i$次，那么对应的排列数是$n!\over \prod l_i^{k_i} k_i!$），然后求出对于每一组循环节的每一个连通块都满足$\sum d_{x,y,z} \equiv 0 \pmod 2$的$a,b,c$的数量，就能够快速统计贡献。</p>
<p>我们考虑某一组循环节（那个$la\times lb\times lc$的正方体）的某一个连通块对$a,b,c$的限制，设循环节包含的每个维度的下标集合为$a’,b’,c’$，则限制为</p>
<script type="math/tex; mode=display">
\sum_{x\in a'} a_x \operatorname{lcm}{\{la,lb,lc\}\over la} +\sum_{x\in b'} b_x \operatorname{lcm}{\{la,lb,lc\}\over lb} + \sum_{x\in c'} c_x {\operatorname{lcm}\{la,lb,lc\}\over lc} \equiv 0 \pmod 2</script><p>现在将每一个$a_x,b_x,c_x$看做未知数，则问题转化成求方程的解数，是一个经典的线性基问题。</p>
<p>由于数据范围很小，可以直接打表。</p>
<p>下面是我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;x=x*(ll)x%mod,y&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*(ll)x%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lcm[<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">20</span>],inv[<span class="number">20</span>],ipw[<span class="number">8000</span>],pw[<span class="number">8000</span>];</span><br><span class="line"><span class="keyword">int</span> Inv[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;PII&gt; &gt; g[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">namespace</span> Mat &#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;39&gt; f[<span class="number">39</span>],b;</span><br><span class="line">    <span class="keyword">int</span> m,cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) f[i].reset(); m=len,cnt=<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;r;++i) b[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"INS:"; for(int i=0;i&lt;m;++i) cout&lt;&lt;(b[i]==1); cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="keyword">if</span>(b[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][i]) b^=f[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i]=b,cnt++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cnt; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i,<span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) <span class="built_in">cout</span>&lt;&lt;(f[i][j]==<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> predo_calc &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b?gcd(b,a%b):a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCM</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a/gcd(a,b)*b; &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; s;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tot==cur) &#123; g[cur].PB(s); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot+u&gt;cur) <span class="keyword">return</span>;</span><br><span class="line">        dfs(u+<span class="number">1</span>,tot);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;tot+j*u&lt;=cur;++j) &#123;</span><br><span class="line">            s.PB(MP(u,j));</span><br><span class="line">            dfs(u+<span class="number">1</span>,tot+j*u);</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getpw</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        pw[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">2l</span>l%mod;</span><br><span class="line">        ipw[n]=Pow(pw[n],mod<span class="number">-2</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) ipw[i<span class="number">-1</span>]=ipw[i]*<span class="number">2l</span>l%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">predo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) Inv[i]=Pow(i,mod<span class="number">-2</span>);</span><br><span class="line">        fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=fac[i<span class="number">-1</span>]*(ll)i%mod;</span><br><span class="line">        inv[n]=Pow(fac[n],mod<span class="number">-2</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) inv[i<span class="number">-1</span>]=inv[i]*(ll)i%mod;</span><br><span class="line">        getpw(n*n*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">                    lcm[i][j][k]=LCM(LCM(i,j),k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cur=i,dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> A,<span class="keyword">int</span> B,<span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa=<span class="number">0</span>;pa&lt;g[A].size();++pa)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pb=<span class="number">0</span>;pb&lt;g[B].size();++pb)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pc=<span class="number">0</span>;pc&lt;g[C].size();++pc) &#123;</span><br><span class="line">        <span class="keyword">int</span> tans=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;PII&gt; &amp;pA=g[A][pa],&amp;pB=g[B][pb],&amp;pC=g[C][pc];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pA.size();++j) tans=tans*(ll)inv[pA[j].SEC]%mod*Pow(Inv[pA[j].FIR],pA[j].SEC)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pB.size();++j) tans=tans*(ll)inv[pB[j].SEC]%mod*Pow(Inv[pB[j].FIR],pB[j].SEC)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pC.size();++j) tans=tans*(ll)inv[pC[j].SEC]%mod*Pow(Inv[pC[j].FIR],pC[j].SEC)%mod;</span><br><span class="line">        Mat::init(A+B+C);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> iA=<span class="number">0</span>,tA=<span class="number">0</span>;iA&lt;pA.size();++iA)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> jA=<span class="number">0</span>;jA&lt;pA[iA].SEC;++jA,tA+=pA[iA].FIR)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> iB=<span class="number">0</span>,tB=A;iB&lt;pB.size();++iB)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> jB=<span class="number">0</span>;jB&lt;pB[iB].SEC;++jB,tB+=pB[iB].FIR)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> iC=<span class="number">0</span>,tC=A+B;iC&lt;pC.size();++iC)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> jC=<span class="number">0</span>;jC&lt;pC[iC].SEC;++jC,tC+=pC[iC].FIR) &#123;</span><br><span class="line">                    <span class="keyword">int</span> a=pA[iA].FIR,b=pB[iB].FIR,c=pC[iC].FIR;</span><br><span class="line">                    tans=tans*(ll)pw[a*b*c/lcm[a][b][c]]%mod;</span><br><span class="line">                    Mat::ins(tA,tA+pA[iA].FIR,lcm[a][b][c]/a);</span><br><span class="line">                    Mat::ins(tB,tB+pB[iB].FIR,lcm[a][b][c]/b);</span><br><span class="line">                    Mat::ins(tC,tC+pC[iC].FIR,lcm[a][b][c]/c);</span><br><span class="line">                    Mat::Ins();</span><br><span class="line">                &#125;</span><br><span class="line">        tans=tans*(ll)pw[A+B+C-Mat::sol()]%mod;</span><br><span class="line">        <span class="comment">// Mat::Debug();</span></span><br><span class="line">        ans=(ans+tans)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans*(ll)ipw[A+B+C]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    predo_calc::predo(<span class="number">13</span>);</span><br><span class="line">    <span class="keyword">int</span> T; rd(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> A,B,C; rd(A),rd(B),rd(C);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sol(A,B,C)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>单位根反演练习题</title>
    <url>/2020/01/14/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="loj6485-LJJ学二项式定理"><a href="#loj6485-LJJ学二项式定理" class="headerlink" title="loj6485 LJJ学二项式定理"></a>loj6485 LJJ学二项式定理</h2><p>首先枚举$i\pmod 4$的余数$t$，然后转化成对于每一个$t$，求</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n {n\choose i}s^i [ 4\mid (i-t) ]\\</script><p>单位根反演：</p>
<script type="math/tex; mode=display">
= \sum_{i=0}^n {n\choose i}s^i {1\over 4}\sum_{j=0}^3 \omega_{4}^{j(i-t)}\\
= {1\over 4} \sum_{j=0}^3 \omega_{4}^{-jt} \sum_{i=0}^n {n\choose i}s^i w_4^{ij}</script><p>最后面的那一坨东西，由二项式定理知$(1+x)^n = \sum_{i=0}^n {n\choose i}x^i$，所以：</p>
<script type="math/tex; mode=display">
= {1\over 4} \sum_{j=0}^3 \omega_{4}^{-jt} (s\omega_4^j + 1)^n</script><p>直接算就可以了。</p>
<p><a href="https://loj.ac/submission/715070" target="_blank" rel="noopener">Code</a></p>
<h2 id="uoj450【集训队作业2018】复读机"><a href="#uoj450【集训队作业2018】复读机" class="headerlink" title="uoj450【集训队作业2018】复读机"></a>uoj450【集训队作业2018】复读机</h2><p>考虑一个复读机复读次数的生成函数：</p>
<script type="math/tex; mode=display">
F(x) = \sum_{i=0}^{\infty} {x^i\over i!} [d\mid i]</script><p>而我们要算的实际上是$n! \cdot F^k(x) [x^n]$。</p>
<p>对$F(x)$进行单位根反演：</p>
<script type="math/tex; mode=display">
F(x) = {1\over d}\sum_{i=0}^{\infty} {x^i\over i!} \sum_{j=0}^{d-1} \omega^{ij}\\
= {1\over d}\sum_{j=0}^{d-1} \sum_{i=0}^{\infty} {x^iw^{ij}\over i!}\\
= {1\over d} \sum_{j=0}^{d-1} e^{\omega^j x}</script><p>$1\over d$是常数，我们先把它忽视掉，最后再在答案里乘上一个$1\over d^k$。</p>
<p>考虑$F^k(x)$的组合意义，相当于对于这$k$个多项式，从每一个里面选一项相乘，所有的方案得到的乘积的和。枚举$e^{\omega^jx}$被选的次数$p_j$，得到</p>
<script type="math/tex; mode=display">
F^k (x) = \sum_{p_0+p_1\cdots p_{d-1}=k}k!\prod_{j=0}^{d-1} {1\over p_j!}e^{p_j \omega_jx}\\
= \sum_{p_0+p_1\cdots p_{d-1}=k} e^{(\sum_{j=0}^{d-1}p_jw_j)x} \cdot k!\prod_{j=0}^{d-1} {1\over p_j!}</script><p>而</p>
<script type="math/tex; mode=display">
F^k (x) [ x^n ] = \sum_{p_0+p_1\cdots p_{d-1}=k} {(\sum_{j=0}^{d-1}p_jw_j)^n \over n!} \cdot k!\prod_{j=0}^{d-1} {1\over p_j!}</script><p>直接计算，复杂度$O(k^d \log n)$。</p>
<p><a href="http://uoj.ac/submission/376702" target="_blank" rel="noopener">Code</a></p>
<h2 id="bzoj3328-PYXFIB"><a href="#bzoj3328-PYXFIB" class="headerlink" title="bzoj3328 PYXFIB"></a>bzoj3328 PYXFIB</h2><p>设</p>
<script type="math/tex; mode=display">
A = \begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}\\
B = \begin{bmatrix} 1\\1 \end{bmatrix}</script><p>则我们相当于要求出</p>
<script type="math/tex; mode=display">
(\sum_{i=0}^n {n\choose i} A^i [k\mid i] )B</script><p>对前面的那个括号里面的东西单位根反演，得到</p>
<script type="math/tex; mode=display">
{1\over k} \sum_{j=0}^{k-1} \sum_{i=0}^n {n\choose i}A^i\omega^{ij}\\
= {1\over k} \sum_{j=0}^{k-1} (\omega^j\cdot A + E)^n</script><p>其中$E$表示单位矩阵。</p>
<p>直接矩阵快速幂计算，时间复杂度为$O(2^3 \cdot \log n \cdot k)$。</p>
<h2 id="loj3058-「HNOI2019」白兔之舞"><a href="#loj3058-「HNOI2019」白兔之舞" class="headerlink" title="loj3058 「HNOI2019」白兔之舞"></a>loj3058 「HNOI2019」白兔之舞</h2><p>设矩阵$A$是满足$A_{i,j} = w(i,j)$的$n\times n$的矩阵。</p>
<p>走$m$步的方案数为${L\choose m}T_{x,y}$，其中$T=A^m$。</p>
<p>则对于每一个$t$，我们需要求出</p>
<script type="math/tex; mode=display">
\sum_{m=0}^L {L\choose m}A^m [k\mid (t-m)]</script><p>单位根反演之后得到</p>
<script type="math/tex; mode=display">
{1\over k}\sum_{j=0}^{k-1} \omega_k^{-tj}(\omega_k^jA + E)^L</script><p>对于每一个$j$，分别算出$F_j = (\omega_k^j A+ E)^L$，设$f_j$为$F_j$的$x$行$y$列的元素，则$t$的答案就是</p>
<script type="math/tex; mode=display">
Ans_t = {1\over k}\sum_{j=0}^{k-1} f_j \omega_k^{-tj}</script><p>由于$-tj={t\choose 2}+{j\choose 2}-{t+j\choose 2}$，所以</p>
<script type="math/tex; mode=display">
Ans_t = {1\over k}\cdot \omega_k^{t\choose 2} \sum_{j=0}^{k-1} (f_j\cdot \omega_k^{j\choose 2} ) \omega_k^{-{i+j\choose 2}}</script><p>这是一个卷积的形式，用MTT优化一下就可以了。</p>
<p>总时间复杂度$O(kn^3\log L + k\log k)$。</p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望练习题</title>
    <url>/2020/01/14/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="CF963E-Circles-of-Waiting"><a href="#CF963E-Circles-of-Waiting" class="headerlink" title="CF963E Circles of Waiting"></a>CF963E Circles of Waiting</h2><p>圆内的整点形成了一个类似方阵的结构。设$f_{x,y}$为$(x,y)$期望被经过的次数。我们可以对每一个点列出一个方程：</p>
<script type="math/tex; mode=display">
f_{x,y} = {p_0} f_{x+1,y} + p_1 f_{x,y+1} +p_2 f_{x-1,y} + p_3f_{x,y-1} + [(x,y)=(0,0)]</script><p>将每一行最左侧的点设为主元，其它的点都用主元表示。从左往右考虑每一列的点：$f_{x,y}$可以用$f_{x-1,y}$的方程表示出来（因为方程中涉及到的$f_{x-1,y},f_{x-1,y-1},f_{x-1,y+1},f_{x-2,y}$在之前都已经考虑过了，只有$f_{x,y}$是未知的）。</p>
<p>这样过后，每一行最右侧的点对应的方程我们还没有用过，用这些方程一定可以解出主元的值，然后再带回去就可以得到每个点的期望被经过次数。</p>
<p>时间复杂度$O(R^3)$。</p>
<p><a href="https://codeforces.com/contest/963/submission/68692851" target="_blank" rel="noopener">Code</a></p>
<h2 id="CTSC2006-歌唱王国"><a href="#CTSC2006-歌唱王国" class="headerlink" title="CTSC2006 歌唱王国"></a>CTSC2006 歌唱王国</h2><p>题号：luogu4548, bzoj1152</p>
<p>设$f_i$为加入第$i$个字符的时候恰好结束的概率，$g_i$为加入$i$个字符之后还没有结束的概率。设$F(x) = \sum_{i=0}^\infty f_i x^i, G(x) = \sum_{i=0}^\infty g_ix^i$。</p>
<p>则有$G(x)x - F(x) = G(x) - 1$，即：$g_{i-1}-f_i = g_i$。</p>
<p>由$F(x)$的定义我们知道$F(1)=1$，即在每一轮结束的概率的和是$1$。</p>
<p>而我们要求的答案是$F’(1)$。</p>
<p>再设$H(x) = \sum_{i=j}^{m}x^{m-j} ({1\over n})^{m-j} [s_1s_2\cdots s_j\text{is a border of s}]$。</p>
<p>则</p>
<script type="math/tex; mode=display">
G(x) ({1\over n})^mx^m = F(x) H(x)</script><p>这里$F(x)$的意义相当于是枚举了，$G(x)$在末尾加上一个$s$之后，最早在什么位置出现了完整的$s$。</p>
<p>带入$x=1$得到</p>
<script type="math/tex; mode=display">
G(1) ({1\over n})^m = F(1) H(1)\\
G(1) = n^m H(1)</script><p>此外</p>
<script type="math/tex; mode=display">
G(x)x-F(x) = G(x)-1\\</script><p>两边同时求导得到</p>
<script type="math/tex; mode=display">
G(x) + G'(x)x - F'(x) = G'(x)</script><p>带入$x=1$</p>
<script type="math/tex; mode=display">
G(1) + G'(1) - F'(1) = G'(1)\\
G(1) = F'(1)</script><p>所以答案就是$n^m H(1)$。</p>
<h2 id="PE522"><a href="#PE522" class="headerlink" title="PE522"></a><a href="https://projecteuler.net/problem=522" target="_blank" rel="noopener">PE522</a></h2><p>如果所有的连通块都是孤立的环（没有叶子），那么答案是环数。</p>
<p>否则敲定一个不为孤立的环的连通块，对于这个连通块每一个入度为$0$的点，把某个入度大于$1$的点的某一个儿子拿过来接在它的下面（接过来的部分如果还有入度为$0$的点，就重复前面的操作）。</p>
<p>如果图内存在孤立的环，就还必须在上述过程的最后一次操作之前（此时我们敲定的那个连通块内恰好只有一个叶子）对每一个孤立的环进行额外的操作：把环断成链接在叶子的下面。</p>
<p>综上所述，一张图的答案为叶子数+孤立的环数。</p>
<p>叶子数总和为：</p>
<script type="math/tex; mode=display">
n ((n-2)^{n-1} \cdot (n-1))</script><p>也就是每个点成为叶子的方案数。</p>
<p>孤立的环的数量总和为</p>
<script type="math/tex; mode=display">
\sum_{i=2}^n {n\choose i} (i-1)!(n-i-1)^{n-i}</script><p>每一个长度为$i$的环出现的方案数是$(n-i-1)^{n-i}$，而这样的环有${n\choose i} \cdot (i-1)!$个。</p>
<h2 id="CF457D-Bingo"><a href="#CF457D-Bingo" class="headerlink" title="CF457D Bingo!"></a>CF457D Bingo!</h2><p>考虑$2^s$的组合意义，也就是一个大小为$s$的集合的子集数量。所以权值的期望也就是：每一个行、列的子集在最后的矩阵中只包含了那$k$个数的概率的和。</p>
<p>假设某一个子集包含了$t$个格子，那么它只包含了那$k$个数的概率是$f_t = {P_k^t \over P_m^t}$。直接预处理阶乘来计算$f_t$无法用long double存下；推导可得$f_t = f_{t-1} \cdot {k-t+1\over m-t+1}$，由这个递推计算就可以避免上面的问题。</p>
<p>最后的答案就是</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n \sum_{j=0}^n {n\choose i}{n\choose j} f_{(i+j)n-ij}</script><p><a href="https://codeforces.com/contest/457/submission/68708656" target="_blank" rel="noopener">Code</a></p>
<h2 id="UOJ352-新年的五维几何"><a href="#UOJ352-新年的五维几何" class="headerlink" title="UOJ352 新年的五维几何"></a>UOJ352 新年的五维几何</h2><p>对于所有$l_i=r_i$的变量，考虑它们对其它变量的取值范围的影响，然后把这些变量删掉。</p>
<p>不妨将$l_i \le x_i \le r_i$看做$l_i \le x_i &lt; r_i$，两者算出来的答案是一样的。所以$x_i$的整数部分的取值范围是$[l_i,r_i)$。</p>
<p>我们首先枚举$x_i$的小数部分的大小关系，然后暴搜整数部分的合法的取值方案。由于$a_{i,j}$都是整数，所以$x_i - x_j \ge a_{i,j}$是否被满足只取决于$x_i$和$x_j$的整数部分和它们小数部分的大小关系。</p>
<p>时间复杂度$O(n!\prod_i(r_i-l_i))$。</p>
<p><a href="http://uoj.ac/submission/379410" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
</search>
