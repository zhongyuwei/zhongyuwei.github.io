<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>早期的正式比赛的总结&amp;集训笔记&amp;专（杂）题</title>
    <url>/2022/08/01/%E6%97%A9%E6%9C%9F%E7%9A%84%E6%AD%A3%E5%BC%8F%E6%AF%94%E8%B5%9B%E7%9A%84%E6%80%BB%E7%BB%93-%E9%9B%86%E8%AE%AD%E7%AC%94%E8%AE%B0-%E4%B8%93%EF%BC%88%E6%9D%82%EF%BC%89%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://github.com/zhongyuwei/zhongyuwei.github.io/tree/master/files/%E6%97%A9%E6%9C%9F%E7%9A%84%E6%AD%A3%E5%BC%8F%E6%AF%94%E8%B5%9B%E7%9A%84%E6%80%BB%E7%BB%93%26%E9%9B%86%E8%AE%AD%E7%AC%94%E8%AE%B0%26%E4%B8%93%EF%BC%88%E6%9D%82%EF%BC%89%E9%A2%98" target="_blank" rel="noopener">链接</a></p>
<p>这里是其它的早期OI资料。</p>
<p>为了防止hexo出错，所有的.md都是在改成.txt之后上传，可以下载之后自己改回去并渲染。</p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>组合恒等式整理</title>
    <url>/2022/08/01/%E7%BB%84%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<ol>
<li>$\binom{n}{m} = \binom{n}{n-m}$</li>
<li>$\binom{n}{m} + \binom{n}{m+1} = \binom{n+1}{m+1}$</li>
<li>$\sum_{m=r}^n \binom{m}{r} = \binom{n+1}{r+1}$</li>
<li>$\sum_{m=0}^n \binom{n}{m} = 2^n$</li>
<li>$\binom{n}{m} \binom{m}{k} = \binom{n}{k} \binom{n-k}{m-k}$<ol>
<li>$m \binom{n}{m} = n \binom{n-1}{m-1}$</li>
</ol>
</li>
<li>$\sum_{r=0}^k \binom{n}{r} \binom{m}{k-r} = \binom{n+m}{k}$<ol>
<li>$\sum_{i=0}^n \binom{n}{i}^2 = \sum_{i=0}^n \binom{n}{i} \binom{n}{n-i} = \binom{2n}{n}$</li>
</ol>
</li>
</ol>
<p>封闭形式：</p>
<ol>
<li><p>$\frac{1}{(1-x)^{n+1}} = \sum_{k=0}^\infty \binom{n+k}{n} x^k$</p>
<ol>
<li>$\frac{1}{(1-x)^{n+1}} = (1-x)^{-(n+1)} = \sum_{k=0}^\infty \binom{-n-1}{k} (-x)^k = \sum_{k=0}^\infty (-1)^k \binom{k+n}{k} (-x)^k = \sum_{k=0}^\infty \binom{n+k}{n} x^k$</li>
</ol>
</li>
<li><p>$\frac{1}{\sqrt{1-4x}} = \sum_{k=0}^\infty \binom{2k}{k} x^k$</p>
<ol>
<li><script type="math/tex; mode=display">
(1-x)^{-\frac{1}{2}} = \sum_{k=0}^\infty \binom{-\frac{1}{2}}{k} (-x)^k\\
= \sum_{k=0}^\infty \frac{(-1)(-3) \cdots (-(2k-1))}{2^k k!} (-x)^k\\
= \sum_{k=0}^\infty (-1)^k \frac{\frac{(2k)!}{2^k k!}}{2^k k!} (-x)^k\\
= \sum_{k=0}^\infty \binom{2k}{k} 4^{-k} x^k\\
\frac{1}{\sqrt{1-4x}} = (1-4x)^{-\frac{1}{2}} = \sum_{k=0}^\infty \binom{2k}{k} 4^{-k} (4x)^k\\
= \sum_{k=0}^\infty \binom{2k}{k} x^k</script></li>
</ol>
</li>
<li><p>$\frac{1 - \sqrt{1-4x}}{2x} = \sum_{k\ge 0} \frac{1}{k+1} \binom{2k}{k} x^k$</p>
<ol>
<li><script type="math/tex; mode=display">
(1-x)^{\frac{1}{2}}
= \sum_{k=0}^\infty \binom{\frac{1}{2}}{k} (-x)^k\\
= \sum_{k=0}^\infty \frac{1(-1)(-3)(-5)\cdots (-(2k-3))}{2^k k!}(-x)^k\\
= - \sum_{k=0}^\infty \frac{\frac{(2k-2)!}{2^{(k-1)}(k-1)!}}{2^kk!}x^k\\
= - 2 \sum_{k=0}^\infty \frac{1}{k} \cdot\binom{2k-2}{k-1} \cdot 4^{-k} x^k\\
1 - \sqrt{1-4x} = 2 \sum_{k=1}^\infty \frac{1}{k} \cdot\binom{2k-2}{k-1} \cdot 4^{-k} (4x)^k\\
= 2 \sum_{k=1}^\infty \frac{1}{k} \cdot\binom{2k-2}{k-1} \cdot x^k</script></li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>自然数幂和</title>
    <url>/2022/08/01/%E8%87%AA%E7%84%B6%E6%95%B0%E5%B9%82%E5%92%8C/</url>
    <content><![CDATA[<p>给出$n,k$，求$\sum _{i=0}^n i^k$。</p>
<hr>
<h2 id="方法1：递推"><a href="#方法1：递推" class="headerlink" title="方法1：递推"></a>方法1：递推</h2><p>设$s_k(n) = \sum_{i=0}^n i^k$，那么可以推出：</p>
<script type="math/tex; mode=display">
s_k(n) + (n+1)^k = \sum_{i=0}^{n+1} i^k\\
=\sum_{i=0}^n (i+1)^k</script><p>这一步是考虑到$0^k$并不会产生贡献（但是要注意当$k=0$的时候$0^0$要取$1$）。</p>
<script type="math/tex; mode=display">
s_k(n) +(n+1)^k \\
= \sum_{i=0}^n \sum_{j=0}^k {k\choose j}i^j\\
= \sum_{j=0}^k {k\choose j} \sum_{i=0}^n i^j\\
= \sum_{j=0}^k {k\choose j} s_j(n)\\
= \sum_{j=0}^{k-1} {k\choose j} s_j(n) + s_k(n)</script><p>于是推出了</p>
<script type="math/tex; mode=display">
(n+1)^k = \sum_{j=0}^{k-1} {k\choose j} s_j(n)</script><p>考虑把$k-1$这一项拿出来，我们就得到了</p>
<script type="math/tex; mode=display">
(n+1)^k = \sum_{j=0}^{k-2} {k\choose j} s_j(n) + {k\choose k-1} s_{k-1}(n)\\
s_{k-1}(n) = {(n+1)^k - \sum_{j=0}^{k-2} {k\choose j} s_j(n) \over k}</script><p>也就是</p>
<script type="math/tex; mode=display">
s_{k}(n) = {1\over k+1} \left( (n+1)^{k+1} - \sum_{j=0}^{k-1}{k+1\choose j} s_j(n)\right)</script><p>这样，对于某一个给定的$n$，我们可以在$O(k^2)$的时间内算出所有的$s_0(n),s_1(n)\cdots s_k(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(ll n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s[<span class="number">55</span>];</span><br><span class="line">	n%=mod;</span><br><span class="line">	s[<span class="number">0</span>]=n+<span class="number">1</span>; <span class="keyword">int</span> pwn=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;++k) &#123;</span><br><span class="line">		pwn=pwn*(ll)(n+<span class="number">1</span>)%mod;</span><br><span class="line">		s[k]=pwn;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k<span class="number">-1</span>;++j)</span><br><span class="line">			s[k]=(s[k]-C[k+<span class="number">1</span>][j]*(ll)s[j])%mod;</span><br><span class="line">		s[k]=s[k]*(ll)Pow(k+<span class="number">1</span>,mod<span class="number">-2</span>)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法2：拉格朗日插值"><a href="#方法2：拉格朗日插值" class="headerlink" title="方法2：拉格朗日插值"></a>方法2：拉格朗日插值</h2><p>考虑到$\sum_{i=0}^{n}i^m $一定是一个关于$n$的$m+1$次多项式，我们直接把$1,2,\cdots m+2$带入这个多项式，然后插值就可以了。</p>
<p>复杂度$O(m\log mod)$，其中$\log mod$是计算快速幂的复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> ll pre[<span class="number">55</span>],suf[<span class="number">55</span>];</span><br><span class="line">	<span class="keyword">if</span>(n&lt;m+<span class="number">2</span>) &#123;</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">			ans=(ans+Pow(i,m))%mod;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	n%=mod;</span><br><span class="line">	ll yi=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	pre[<span class="number">0</span>]=suf[m+<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">2</span>;++i) pre[i]=pre[i<span class="number">-1</span>]*(n-i)%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">2</span>;i&gt;=<span class="number">1</span>;--i) suf[i]=suf[i+<span class="number">1</span>]*(n-i)%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">2</span>;++i) &#123;</span><br><span class="line">		yi=(yi+Pow(i,m))%mod;</span><br><span class="line">		ll tmp=pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>]%mod;</span><br><span class="line">		ll iv=inv[i<span class="number">-1</span>]*inv[m+<span class="number">2</span>-i]%mod*(((m+<span class="number">2</span>-i)&amp;<span class="number">1</span>)?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">		ans=(ans+tmp*iv%mod*yi)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ans%mod+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="方法3：伯努利数"><a href="#方法3：伯努利数" class="headerlink" title="方法3：伯努利数"></a>方法3：伯努利数</h2><p>定义伯努利数$B_0 = 1$，且对于任意的$n&gt;0$，我们有$\sum_{i=0}^n B_i{n+1\choose i} = 0$。通过递推可以在$O(n^2)$的时间内得到每一项。</p>
<p>伯努利数的指数生成函数$B(x)$是$x\over e^x-1$。考虑</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n-1} B_i{n\choose i } =0</script><p>这个式子对任意$n&gt;1$成立。注意$B_0=0,B_1=-{1\over 2}$。</p>
<p>上面的式子变形：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n B_i{n\choose i} = B_n \\
\sum_{i=0}^n {B_i\over i!}{1\over (n-i)!} = {B_n\over n!}</script><p>也就是说$[x^i]B(x) =[x^i] B(x)*e^x$对于任意$i&gt;1$成立。而$B(x)e^x$的$0$次项的系数是$1$，一次项的系数是$1\over 2$，所以我们得到了$B(x) = B(x)e^x - x$，也就是$B(x)= {x\over e^x - 1}$。</p>
<p>而对于某一个确定的$n$，我们考虑答案关于$k$的指数生成函数：</p>
<script type="math/tex; mode=display">
G(x) = \sum_{i=0}^{\infty} {S_i(n)\over i!}x^i \\
=\sum_{i=0}^{\infty} \sum_{j=0}^n {j^ix^i \over i!}\\
=\sum_{j=0}^{n} e^{jx}\\
={e^{x(n+1)}-1\over e^x-1}</script><p>把$B(x)$带入：</p>
<script type="math/tex; mode=display">
G(x)= B(x){e^{x(n+1)}-1\over x}</script><p>把右边那一项泰勒展开得到的是</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{\infty}{(n+1)^{i+1}\over (i+1)!} x^i</script><p>然后暴力带回$G(x)$就可以得到</p>
<script type="math/tex; mode=display">
S_i(n) =i!\cdot  \sum_{j=0}^i {B_j\over j!}{(n+1)^{i-j+1}\over(i-j+1)! }\\
={1\over i+1}\sum_{j=0}^i B_{i-j}{i+1\choose i-j}(n+1)^{j+1}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_ber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ber[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">		ll tmp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">			tmp=(tmp+ber[j]*(ll)C(i+<span class="number">1</span>,j))%mod;</span><br><span class="line">		ber[i]=(mod-tmp)*(ll)Pow(i+<span class="number">1</span>,mod<span class="number">-2</span>)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	ll pn=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) &#123;</span><br><span class="line">		pn=pn*(ll)(n+<span class="number">1</span>)%mod;</span><br><span class="line">		ans=(ans+C(m+<span class="number">1</span>,m-i)*(ll)ber[m-i]%mod*pn)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=ans*Pow(m+<span class="number">1</span>,mod<span class="number">-2</span>)%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="方法4：斯特林数"><a href="#方法4：斯特林数" class="headerlink" title="方法4：斯特林数"></a>方法4：斯特林数</h2><p>考虑</p>
<script type="math/tex; mode=display">
n^k = \sum_{j=0}^k \begin{Bmatrix} k \\ j \end{Bmatrix} {n\choose j} j!</script><p>咕咕咕。</p>
<hr>
<h2 id="方法-5：生成函数"><a href="#方法-5：生成函数" class="headerlink" title="方法 5：生成函数"></a>方法 5：生成函数</h2><script type="math/tex; mode=display">
F(x) = \sum_{i=0}^\infty \frac{x^i}{i!} \sum_{j=0}^n j^i\\
= \sum_{j=0}^n e^{jx}\\
= \frac{e^{(n+1)x} - 1}{e^x - 1}</script><p>可以对于某个特定的，在 $O(m\log m)$ 的时间里对所有 $k\in [0,m]$ 的答案。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图计数专题练习</title>
    <url>/2022/08/01/%E5%9B%BE%E8%AE%A1%E6%95%B0%E4%B8%93%E9%A2%98%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="带标号的连通图计数-bzoj3456-城市规划"><a href="#带标号的连通图计数-bzoj3456-城市规划" class="headerlink" title="带标号的连通图计数 bzoj3456 城市规划"></a>带标号的连通图计数 bzoj3456 城市规划</h2><p>这是一个非常经典的问题。我们考虑容斥，那么就是图的数量减去不连通图的数量。计算不连通图的数量时，我们考虑枚举$1$号点所在的连通块大小（这样一定不重不漏），那么得到：</p>
<script type="math/tex; mode=display">
f(n) = 2^{C_n^2 } - \sum_{i=1}^{n-1} C_{n-1}^{i-1} f(i) 2^{C_{n-i}^2 }</script><p>拆组合数：</p>
<script type="math/tex; mode=display">
f(n) = 2^{C_n^2} - (n-1)!\sum_{i=1}^{n-1} {f(i)\over (i-1)!}{2^{C_{n-i}^2}\over (n-i)!}</script><p>这是一个卷积的形式，可以分治FFT解决。</p>
<hr>
<h2 id="带标号的强连通竞赛图计数-luogu4233-射命丸文的笔记"><a href="#带标号的强连通竞赛图计数-luogu4233-射命丸文的笔记" class="headerlink" title="带标号的强连通竞赛图计数 luogu4233 射命丸文的笔记"></a>带标号的强连通竞赛图计数 luogu4233 射命丸文的笔记</h2><p>问题：求随机拿出一个有哈密顿回路的竞赛图，图中哈密顿回路数量的期望值。</p>
<p>Sol：问题可以转换成“所有竞赛图中的哈密顿回路的数量的和”除以“包含哈密顿回路的图的数量”。前者非常好算：$(n-1)!2^{C_n^2 - n}$，即枚举每一个哈密顿回路（数量等于圆排列的数量），然后计算它被多少竞赛图包含。有$n$条边已经确定，剩下的$C_n^2 - n$条边，每条边都有两个方向可以选择，所以是$2^{C_n^2 -n}$。</p>
<p>现在的问题是：求包含$n$个点的，存在哈密顿回路的竞赛图的数量。等价于求包含$n$个点的强连通的竞赛图的数量。</p>
<p>那么设$f(n)$表示包含$n$个点的强连通的竞赛图的数量，设$g(n)$表示包含$n$个点的竞赛图的数量。则$g(n) = 2^{C_n^2}$。仍然考虑与前一题类似的容斥。但是，如果我们枚举$1$号点所在的强连通分量的大小，其他的强连通分量可能有边连向这个强连通分量，这个强连通分量也可能有边连出去，可能会导致我们枚举的这个“强连通分量”是图中一个强连通分量的子图，非常麻烦。那么我们可以考虑枚举拓扑序最靠后的那一个强连通分量，即没有出边的那一个。由于这是竞赛图，这样的强连通分量在一个确定的图中一定是唯一的（可以这样想：如果有两个这样的强连通分量，那么它们之间一定有一条边，那么它们中的一个就一定有出度，矛盾）。于是得到：</p>
<script type="math/tex; mode=display">
f(n) = g(n) - \sum_{i=1}^{n-1}C_n^i f(i) g(n-i)\\
f(n) = g(n) - n!\sum_{i=1}^{n-1} {f(i) \over i!} {g(n-i)\over (n-i)!}</script><p>这又是一个卷积了。分治FFT解决。</p>
<hr>
<h2 id="带标号的无根树的计数：prufer序列"><a href="#带标号的无根树的计数：prufer序列" class="headerlink" title="带标号的无根树的计数：prufer序列"></a>带标号的无根树的计数：prufer序列</h2><h3 id="求一棵树的prufer序列"><a href="#求一棵树的prufer序列" class="headerlink" title="求一棵树的prufer序列"></a>求一棵树的prufer序列</h3><p>每一次选择编号最小的叶子，将这个叶子从图中删除，并且将与它相邻的点的编号加入序列。直到图中只剩下两个点为止。</p>
<h3 id="由prufer序列还原一棵树"><a href="#由prufer序列还原一棵树" class="headerlink" title="由prufer序列还原一棵树"></a>由prufer序列还原一棵树</h3><p>找出未在序列中出现的并且未被标记的编号最小的点（树上编号最小的叶子），让它和序列开头的点连边，标记它，然后删掉序列开头的元素。当只剩下两个点<strong>未被标记</strong>的时候就停止，在它们之间连边，就完成了。</p>
<p>可以看出，prufer序列一定是一个长度为$n-2$的，所有点都在$[1,n]$的序列；一个点在prufer序列中出现的次数等于它在树上的度数。</p>
<p>从上面的过程可以看出：带标号的无根树和prufer序列是一一对应的关系。因此，我们可以推出：包含$n$个点的带标号的无根树的数量，等于长度为$n-2$，所有数都在$[1,n]$的序列的数量，等于$n^{n-2}$。</p>
<p>而如果题目给定了每个点的度数，那就等于给定了每个点在prufer序列中出现的次数，那么就是可重排列数。（bzoj 1211 1005）</p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>一类子集dp问题的容斥做法</title>
    <url>/2022/08/01/%C2%96%E4%B8%80%E7%B1%BB%E5%AD%90%E9%9B%86dp%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%B9%E6%96%A5%E5%81%9A%E6%B3%95/</url>
    <content><![CDATA[<h2 id="P1-旅行商问题"><a href="#P1-旅行商问题" class="headerlink" title="P1 旅行商问题"></a>P1 旅行商问题</h2><p>统计哈密顿路径的数量。</p>
<p>对于长度为 $n$ 的路径，如果所有的点都在路径中出现过，那么这条路径就是合法的。</p>
<p>枚举未经过的点的集合（可能是空集），计算此时长度为 $n$ 的路径的数量，然后容斥一下就能得到答案。</p>
<p>时间复杂度 $O(2^n \cdot n^2)$ 。</p>
<h2 id="P2-UOJ185-小星星"><a href="#P2-UOJ185-小星星" class="headerlink" title="P2 UOJ185 小星星"></a>P2 UOJ185 小星星</h2><p>考虑将树上的点映射到图上的某个点。如果图上的每个点都被映射到了，那么这种方案就是合法的。</p>
<p>如果不限制“每个点都被映射到”，这个东西就是个经典的树形 dp。</p>
<p>容斥枚举没有被映射到的点集，然后做树形 dp 即可。</p>
<p>时间复杂度 $O(2^n \cdot n^3)$。</p>
<p><a href="http://uoj.ac/submission/392160" target="_blank" rel="noopener">my submission</a></p>
<h2 id="P3-k染色问题"><a href="#P3-k染色问题" class="headerlink" title="P3 k染色问题"></a>P3 k染色问题</h2><p>题意：给定一个包含 $n$ 个结点的图和 $k$，判断它是否可以 $k$ 染色。$n\le 22$</p>
<p>考虑选取 $k$ 个独立集，如果每个点都被至少一个独立集包含，那么这种染色方案就是合法的。注意如果存在点被多个独立集包含，我们仍然认为方案是合法的，因为我们只关心合法染色方案的存在性（而不是个数）。</p>
<p>枚举没有被独立集包含的点，然后计算从没有包含它们的独立集中选出 $k$ 个的方案数。容斥一下就能得到答案。</p>
<p>不包含某个特定点集的独立集数可以高维前缀和求出。</p>
<p>时间复杂度 $O(2^n\cdot n)$</p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>五边形数定理 - 快速计算划分数</title>
    <url>/2022/08/01/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86-%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E5%88%92%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_33229466/article/details/80359560" target="_blank" rel="noopener">https://blog.csdn.net/qq_33229466/article/details/80359560</a></p>
<hr>
<h2 id="五边形数"><a href="#五边形数" class="headerlink" title="五边形数"></a>五边形数</h2><p><img src="https://i.loli.net/2019/07/08/5d230a36de78a99473.png" alt="五边形数"></p>
<p>如图，定义五边形数的第$i$项为第$i$张图中的点数，$f_i = f_{i-1} + 3(i-1)+1 = {n(3n-1)\over 2}$。</p>
<p>对于i=1,-1,2,-2,……定义广义五边形数，取值依次为：1 2 5 7 12 15 22 26 35 40 51 57 70 77 92 100 117 126 145 155 176 187 210 222 247……</p>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>定义欧拉函数为：</p>
<script type="math/tex; mode=display">
\phi (x) = \prod_{i=1}^{\infty} (1-x^i)</script><h2 id="五边形数定理"><a href="#五边形数定理" class="headerlink" title="五边形数定理"></a>五边形数定理</h2><script type="math/tex; mode=display">
\phi(x) = \sum_{i=-\infty}^{\infty } (-1)^i x^{i(3i-1)\over 2} \\
= 1 + \sum_{i=1}^{\infty}(-1)^i(x^{i(3i-1)\over 2} + x^{i(3i+1)\over 2})</script><h2 id="利用五边形数定理计算划分数"><a href="#利用五边形数定理计算划分数" class="headerlink" title="利用五边形数定理计算划分数"></a>利用五边形数定理计算划分数</h2><p>设$P_i$表示$i$的整数划分数，考虑它的生成函数$F(x)$：</p>
<script type="math/tex; mode=display">
F(x)= \prod_{i=1}^{\infty } (1+x^i + x^{2i} + x^{3i} + \cdots ) \\
=\prod_{i=1}^{\infty } {1\over 1-x^i} \\
={1\over \phi (x)}</script><p>求出$\phi (x) $之后，多项式求逆即可。</p>
<p>如果没有取模的话，也可以把$F(x) \phi(x) = 1$暴力展开得到一个递推式，由于$\phi(x)$只有$\sqrt n$项有值，所以直接递推是$O(n\sqrt n)$的。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Burside Lemma与Polya定理（说人话版本）</title>
    <url>/2022/08/01/Burside-Lemma%E4%B8%8EPolya%E5%AE%9A%E7%90%86%EF%BC%88%E8%AF%B4%E4%BA%BA%E8%AF%9D%E7%89%88%E6%9C%AC%EF%BC%89/</url>
    <content><![CDATA[<p><code>写于2018年冬，当时水平比较菜，留下的一些思考可能对初学Burnside的后辈有启发，所以现在发出来。</code></p>
<p>看不懂证明，所以只好愉快地感性理解结论。证明等我长大了再回来补吧。（啊，那就大概就是永远都不会补了吧。）</p>
<hr>
<h3 id="Burnside-Lemma"><a href="#Burnside-Lemma" class="headerlink" title="Burnside Lemma"></a>Burnside Lemma</h3><blockquote>
<p>一个集合$X$在置换群$G$作用下的等价类的数量，等于$G$中每一个置换的不动点的数量的平均值。（等价类的定义是：如果两个元素可以通过$G$中的置换变得一样，那么它们就属于同一个等价类；置换$g$的不动点的定义是，一个元素经过了$g$这个置换后没有发生变换）</p>
</blockquote>
<p><del>真不是人话</del></p>
<p>那么看看这个例子：你要给一个有$n$个珠子的项链的每个珠子涂色（有$m$中颜色可供选择），其中通过旋转之后变得相同的方案算同一种方案，问你有多少种方案。</p>
<p>那么，每一种涂色的方法（不一定要求本质不同）是$X$中的元素，而$G$就是旋转置换组成的群（当然也包含了旋转0度），“等价类”就是“通过旋转可以变得相同”的涂色方案组成的集合，要求的“方案数”就是等价类的数量。</p>
<p>先把所有方案列出来，然后再考虑求等价类数量（$n=3,m=2$）：</p>
<p>000 001 010 011 100 101 110 111</p>
<p>那么所有的置换就是：<br>1.旋转0个珠子，此时的不动点是：000 001 010 011 100 101 110 111，数量为8。<br>2.旋转1个珠子，此时的不动点是：000 111，数量为2。<br>3.旋转2个珠子，此时的不动点是：000 111，数量为3。<br>旋转3个珠子和旋转0个珠子是等价的，不需要计算在内。旋转4颗珠子和旋转1颗珠子也是等价的……</p>
<p>那么等价类的数量就是${8+2+2\over 3 } = 4$。</p>
<p>再看一个例子。如果是$n=4,m=2$：</p>
<p>0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111</p>
<p>1.旋转0个珠子，不动点是0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111<br>2.旋转1个珠子，不动点是0000 1111<br>3.旋转2个珠子，不动点是0000 1111 1010 0101<br>4.旋转3个珠子，不动点是0000 1111</p>
<p>所以等价类的数量是${16+2+4+2\over 4} = 6$。</p>
<p>至此终于明白了这个定理到底在说什么，感觉它非常优美且正确，尽管我不会证明QAQ。</p>
<hr>
<h3 id="Polya-Enumeration-Theorem"><a href="#Polya-Enumeration-Theorem" class="headerlink" title="Polya Enumeration Theorem"></a>Polya Enumeration Theorem</h3><p>使用Burnside引理解决上面的问题时，需要把$n^m$中方案全部列出来，这样计算是非常慢的。我们能不能通过一些方式加速计算呢？比如说，快速得到在某个置换下的不动点的数量？</p>
<p>答案是肯定的。这就是Polya定理：</p>
<blockquote>
<p>我们设$c(g)$表示$g$这个置换中的循环节数量，那么对于置换$g$，不动点的数量为$m^{c(g)}$；一个置换群$G$作用于集合$X$上，等价类的数量是${1\over {|G|}}\sum_{g\in G} m^{c(g)}$。</p>
</blockquote>
<p><del>再一次觉得这不是人话</del></p>
<p>那么我们还是来看一个例子吧。首先我们把旋转写成置换，那么旋转2颗珠子就是</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
1 & 2 & 3 & 4\\
3 & 4 & 1 & 2
\end{pmatrix}</script><p>这个置换可以写成$(1 3)(2 4)$，它的循环节数是2。</p>
<p>一个元素在这个置换下是一个不动点，条件是循环节内的所有位置，颜色必须一样，否则这个元素就不可能是不动点。</p>
<p>那么相当于对于每个循环节，我们给它规定一个颜色，然后整个元素就确定了。方案数是$m^{c(g)}$。即对于置换$g$，不动点的数量是$m^{c(g)}$。</p>
<p>再看前面项链的例子，当$n=4,m=2$的时候：</p>
<p>1.旋转0个珠子，循环节数是$4$，方案数是$2^4 = 16$。<br>2.旋转1个珠子，循环节数是$1$，方案数是$2^1 = 2$。<br>3.旋转2个珠子，循环节数是$2$，方案数是$2^2 = 4$。<br>4.旋转3个珠子，循环节数是$1$，方案数是$2^1 = 1$。</p>
<p>所以等价类的数量是${16+2+4+2\over 4} = 6$。</p>
<p>至此感觉已经理清楚了这两个定理在说什么。<del>证明什么的反正也不会考，不管了</del></p>
<hr>
<h3 id="Burnside定理成立的条件"><a href="#Burnside定理成立的条件" class="headerlink" title="Burnside定理成立的条件"></a>Burnside定理成立的条件</h3><p>注意，Burnside定理并不是随便拿几个置换来都成立的。它成立的条件是这几个置换构成了一个群，因为它的证明是用到了群的性质的。</p>
<p>群的定义：群是一个二元运算$<em>$下的一个集合$G$，满足以下四个条件：<br>1）封闭性（closure）：对于$G$中任意两个元素$a,b$，满足$a</em>b\in G$。<br>2）结合律（Associativity）：对于$G$中任意三个元素$a,b,c$，满足$(a<em>b)</em>c = a<em>(b</em>c)$。<br>3）单位元（Identity element）：集合中存在一个唯一的元素$e$，满足对于集合中的任意元素$a$，有$a<em>e = e</em>a = a$。<br>4）逆元（Inverse element）：对于$G$中的每一个元素$a$，$G$中存在一个$b$使得$a<em>b = b</em>a = e$。</p>
<p>比如说，如果随便给几个排列作为洗牌的方式，那么不能套用Burnside引理，因为这些置换组成的集合可能不是封闭的；只有保证了给的置换任意组合，得到的都是这个集合中的某一个置换，也就是说保证它们构成一个群，这个时候才能够用Burnside引理。</p>
<hr>
<h3 id="资料-amp-amp-链接"><a href="#资料-amp-amp-链接" class="headerlink" title="资料&amp;&amp;链接"></a>资料&amp;&amp;链接</h3><p><a href="https://tgsteven.github.io/2018/07/10/2018-07-10-polya/" target="_blank" rel="noopener">TGSteven的博客：</a>里面有证明，但是我看不懂qwq。<br>Wikipedia:<a href="https://en.wikipedia.org/wiki/Burnside%27s_lemma" target="_blank" rel="noopener">Burnside lemma</a> and <a href="https://en.wikipedia.org/wiki/P%C3%B3lya_enumeration_theorem" target="_blank" rel="noopener">Polya enumeration theorem</a> 都没怎么看懂……<br>还看了一些关于Group action（群作用）的资料，然后我选择了放弃研究这个定理的证明（我真的不想死得这么年轻QAQ）</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BEST定理</title>
    <url>/2022/08/01/BEST%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>有向图欧拉回路数量计数。</p>
<p>为什么不是 $\prod_u (\deg_u!)$ 呢？因为任意的边排列顺序不一定能构造出对应的方案，比如</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/01/39bfc6ffe2914aeb.jpg" alt=""></p>
<p>每个点的排列是：</p>
<blockquote>
<p>1：红</p>
<p>2：橙</p>
<p>3：黄 粉</p>
<p>4：绿 蓝</p>
<p>5：紫</p>
</blockquote>
<p>从 1 号点出发，发现构造不出合法的方案！</p>
<p>那么什么样的方案合法呢……只要每个点最后走的那条边不形成环就行了吧？</p>
<p>BEST 定理：有向图的欧拉回路数量等于 $t^{root}(G,k) \prod_{v\in V} (\deg_u -1)!$，其中 $t^{root}(G,k)$ 表示以 $k$ 为根的内向生成树的个数。</p>
<p>证明我参考了<a href="https://blog.csdn.net/PoPoQQQ/article/details/77017325" target="_blank" rel="noopener">这个博客</a>。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举border集合</title>
    <url>/2022/08/01/%E6%9E%9A%E4%B8%BEborder%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>例题：CF gym100958 I</p>
<p>按照从小到大确定每种长度的前缀是否是一个 border，同时对于当前已经确定的 border $l_0,l_1,\cdots l_k$，统计长度为 $l_k$ 且以 $\{l_0,l_1,\cdots l_k\}$ 为 border 的字符串数。</p>
<p>新加入的一个 border $l_{k+1}$ 的时候，分如下情况讨论：</p>
<ul>
<li>$2l_k \le l_{k+1}$<ul>
<li>方案数为 $A^{l_{k+1}-2l_k}$，然后再减去大于 $l_k$ 的最小 border 不是 $l_{k+1}$、但是的 border 集合包含了 $l_{k+1}$ 的字符串数</li>
</ul>
</li>
<li>$2l_k &gt; l_{k+1}$<ul>
<li>此时长度为 $l_k$ 的前缀和后缀会有重复的部分</li>
<li>显然对于任意的 $2v &gt; l_{k+1}$，如果 $v$ 是一个 border 那么 $2v-l_{k+1}$ 肯定也是</li>
<li>而如果任意 border $v$，$2v-l_{k+1}$ 也是 border，那么长度为 $v$ 的前缀和后缀的重合部分显然是相同的</li>
<li>所以如果对于任意的 $2v &gt; l_{k+1}$，$v$ 是 border，都有 $2v-l_{k+1}$ 也是 border，方案数就是确定长度为 $l_k$ 的前缀的方案数；否则方案数为 $0$</li>
<li>然后此时得到的方案数还要减去大于 $l_k$ 的最小 border 不是 $l_{k+1}$、但是的 border 集合包含了 $l_{k+1}$ 的字符串数</li>
</ul>
</li>
</ul>
<p>这个“大于 $l_k$ 的最小 border 不是 $l_{k+1}$、但是的 border 集合包含了 $l_{k+1}$ 的字符串数”可以通过从小到大枚举下一个 border 的长度来提前算得。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S 的每一位分别表示长度为 i 的前缀是否为 border</span></span><br><span class="line"><span class="comment">ways 表示长度为 l_k 且以 &#123;l_0,l_1, ... l_k&#125; 为 border 的串的数量</span></span><br><span class="line"><span class="comment">R[i] 表示以 S 为 border 集合的前缀的、大于 L 的第一个 border 长度小于 x 的、长度为 x 的串的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getborder</span><span class="params">(ll S,<span class="keyword">int</span> ways)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L=m; <span class="keyword">while</span>(L&amp;&amp;!(S&gt;&gt;L<span class="number">-1</span>&amp;<span class="number">1</span>)) L--;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">R</span><span class="params">(m+<span class="number">1</span>)</span></span>;</span><br><span class="line">	R[L]=ways;</span><br><span class="line">	<span class="keyword">if</span>(L==m) <span class="keyword">return</span> (ans=(ans+<span class="number">1l</span>l*ways*DP(S))%mod,R);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=L+<span class="number">1</span>;x&lt;=m;++x) &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp=ways;</span><br><span class="line">		<span class="keyword">if</span>(L*<span class="number">2</span>&gt;x) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=L;j*<span class="number">2</span>&gt;x&amp;&amp;tmp;--j)</span><br><span class="line">				<span class="keyword">if</span>((S&gt;&gt;j<span class="number">-1</span>&amp;<span class="number">1</span>)&amp;&amp;(!(S&gt;&gt;j*<span class="number">2</span>-x<span class="number">-1</span>&amp;<span class="number">1</span>)))</span><br><span class="line">					tmp=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> tmp=<span class="number">1l</span>l*tmp*pw[x<span class="number">-2</span>*L]%mod;</span><br><span class="line">		<span class="keyword">if</span>(!tmp||!(tmp=(tmp-R[x]+mod)%mod)) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y=getborder(S|<span class="number">1l</span>l&lt;&lt;x<span class="number">-1</span>,tmp);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=m;++i)</span><br><span class="line">			R[i]=(R[i]+y[i])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回文子串划分</title>
    <url>/2022/08/01/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>这篇总结基本上就是<a href="https://codeforces.com/blog/entry/19193" target="_blank" rel="noopener">这篇文章</a>的翻译。</p>
<p>这是一种算法，可以在$O(n)$空间、$O(n\log n)$的时间内求出将一个字符串划分成若干个为回文的子串，最少需要的划分次数。</p>
<p>这个算法魔改一下，还可以求一个字符串划分成若干个回文子串的方案数。（就是<a href="https://codeforces.com/problemset/problem/932/G" target="_blank" rel="noopener">CF932G</a>）</p>
<hr>
<p>这个算法是基于回文树的，沿用了回文树中的一些数组的定义。</p>
<h3 id="算法中的一些定义"><a href="#算法中的一些定义" class="headerlink" title="算法中的一些定义"></a>算法中的一些定义</h3><p>1.$diff$表示$i$和节点$fail[i]$表示的字符串的长度之差$diff[i]=len[i]-len[fail[i]]$<br>2.$fa$表示$fail$树上，从$i$到根的路径上深度最大的满足$diff[x]!=diff[i]$的$x$。</p>
<p>即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">diff[now]=len[now]-len[fail[now]];</span><br><span class="line">fa[now]=(diff[now]==diff[fail[now]])?fa[fail[now]]:fail[now];</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="原理-amp-amp-过程"><a href="#原理-amp-amp-过程" class="headerlink" title="原理&amp;&amp;过程"></a>原理&amp;&amp;过程</h3><p>引理1：$fa[i]$构成了一颗深度不超过$\log n$的树</p>
<p><del>这个引理是正确的，但是我不会证明</del>  这里有一篇<a href="https://arxiv.org/pdf/1506.04862v1.pdf" target="_blank" rel="noopener">论文</a>~~</p>
<p>引理2：加入插入了前$i$个字符，考虑回文树上的节点$last$的一个祖先$v$，假设它满足$fa[v]\not =fail[v]$。首先，$fail[v]$这个串一定在$[i-len[v]+1\cdots i-(len[v]-len[fail[v]])]$出现过，并且由于$diff[v]=diff[fail[v]]=\cdots $（构成了一个等差数列），转移$dp[i]$的时候，需要考虑的是$dp[i-len[v]],dp[i-len[fail[v]]],dp[i-len[fail[fail[v]]]]\cdots $，那么考虑第一段等差数列，除了$dp[i-len[fa[v]]-diff[v]]$之外，其他的位置都会在$dp[i-(len[v]-len[fail[v]])]$中被考虑过了。设$g[v]$表示回文树上节点$v$上一次被枚举到的时候贡献的答案，那么就有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">	PT.insert(str[i]-<span class="string">'a'</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v=last;v;v=fa[v])</span><br><span class="line">	&#123;</span><br><span class="line">		g[v]=dp[i-len[fa[v]]-diff[v]];</span><br><span class="line">		<span class="keyword">if</span>(diff[v]==diff[fail[v]]) g[v]=min(g[v]+g[fail[v]]);</span><br><span class="line">		dp[i]=min(dp[i],g[v]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要求划分方案数的话魔改一下，把min改成累加就可以了。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回文树</title>
    <url>/2022/08/01/%E5%9B%9E%E6%96%87%E6%A0%91/</url>
    <content><![CDATA[<h3 id="关于算法名称"><a href="#关于算法名称" class="headerlink" title="关于算法名称"></a>关于算法名称</h3><p>强调一下，虽然说它又叫回文自动机，但是它不是自动机！！！</p>
<p>1.它有多个初始状态。<br>2.它不能够“接受一个字符串”。</p>
<hr>
<h3 id="算法中的一些定义"><a href="#算法中的一些定义" class="headerlink" title="算法中的一些定义"></a>算法中的一些定义</h3><p>回文自动机上，每个节点代表了一个回文子串。对每个节点记一个$len$，代表这个节点表示的回文子串的长度。</p>
<p>每个节点有一个转移集（边），边上有一个字符，指向这个节点表示的回文子串，在两边都加上这个字符后形成的回文子串。</p>
<p>每个节点有一个$fail$指针，这个节点表示的回文子串，最长的且在字符串中出现过的回文后缀，类似AC自动机失配指针，在构造的时候用于解决“失配”的问题。</p>
<p>回文树有两个初始状态，状态$0$和状态$1$。状态$0$表示长度为偶数的回文串的中心，也就是说，所有长度为2的回文串，都由$0$节点转移过来。因此有$len[0]=0$。状态$1$是为了方便构造长度为奇数的状态设计的，所有长度为1的回文串，都由状态1转移过来。因此$len[1]=-1$。显然还有$fail[0]=1$。因为如果加入一个字符，不能够形成长度为2的回文子串，那么就只能（并且一定能）形成长度为1的回文子串。</p>
<p>一些经常用来辅助解决问题的量：一个节点在$fail$树上的深度，就是这个串包含的回文串的个数；在插入一个字符的时候，对新到达的状态$sz++$，最后在$fail$树上，将一个点的儿子的$sz$累加起来，就是这个点表示的回文在字符串中出现的次数。</p>
<hr>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>首先初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ncnt=<span class="number">1</span>,n=<span class="number">0</span>; last=<span class="number">0</span>;</span><br><span class="line">	len[<span class="number">1</span>]=<span class="number">-1</span>,len[<span class="number">0</span>]=<span class="number">0</span>,S[<span class="number">0</span>]=<span class="number">-1</span>,fail[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，$S$是在回文自动机内部存储下的插入的字符串，，$n$表示已经插入的字符串的长度。将$S[0]$设为一个不会出现的东西可以减少特判。$last$表示上一次插入字符到达的状态，初始设为$0$或者$1$都可以。</p>
<p>插入一个新字符$c$时，在$last$的$fail$树上找到深度最深的一个位置，使得这个位置表示的回文串可以通过加入$c$形成新的回文串。即这个串是$last$的回文后缀，并且满足这个串前面的第一个字符等于$c$，也就是$S[n-len[u]-1]==S[n]$。设这个位置为$cur$。如果这个节点都不存在新插入字符的转移，说明出现了新的本质不同的回文串，那么就需要新建节点。新节点的$len$等于$len[cur]+2$，新节点$fail$则是$fail$树上$cur$的祖先中第一个满足$S[n-len[u]-1]==S[n]$的节点<strong>的$c$字符的转移</strong>。如果没有这个转移，那么$fail$应该置为0。注意要先找$fail$，然后再在$cur$节点插入$c$的转移。因为对于$1$号节点的后继，节点的$fail$应该指向$0$。找到的第一个满足$S[n-len[u]-1]==S[n]$的$cur$的祖先是$1$，如果先插入转移，那么新节点的$fail$就会指向自己。先找$fail$，再插入从$cur$到$now$的转移可以避开这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">26</span>],fail[N],len[N],last;</span><br><span class="line">    <span class="keyword">char</span> S[N];</span><br><span class="line">    <span class="keyword">int</span> ncnt,n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=<span class="number">0</span>; S[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        ncnt=last=<span class="number">1</span>;</span><br><span class="line">        fail[<span class="number">1</span>]=<span class="number">0</span>,fail[<span class="number">0</span>]=<span class="number">1</span>,len[<span class="number">0</span>]=<span class="number">0</span>,len[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="keyword">while</span>(S[n-len[u]<span class="number">-1</span>]!=S[n]) u=fail[u]; <span class="keyword">return</span> u;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        S[++n]=c; <span class="keyword">int</span> cur=get(last);</span><br><span class="line">        <span class="keyword">if</span>(!ch[cur][c])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now=++ncnt; len[now]=len[cur]+<span class="number">2</span>;</span><br><span class="line">            fail[now]=ch[get(fail[cur])][c],ch[cur][c]=now;</span><br><span class="line">        &#125;</span><br><span class="line">        last=ch[cur][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;PT;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>设势能函数$\phi(i)$表示，插入前$i$个字符之后，已经插入的最长回文后缀的长度。</p>
<p>插入一个字符的时候$\phi(i)$最多+1，跳一次fail$\phi(i)$至少会-1，$\phi(i)$至多是$n$，所以构造的复杂度是$O(n)$。</p>
<hr>
<h3 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h3><p>回文树上节点的数量 - 2 = 字符串中本质不同的回文串的数量。<br>一个节点在$fail$树上的深度 = 这个节点表示的回文串的回文后缀的数量。<br>得到一个回文串在字符串中出现的次数：$insert$的时候，在走到的那个节点（即这一步结束后的$last$）上令$sz++$，这是一个差分，意思是上$sz$到根的路径上的所有点$sz+=1$。最后将差分前缀和回去，即跑一遍$sz[fail[u]]+=sz[u]$即可得到每个节点表示的回文子串在原字符串中出现的次数。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从kmp算法的正确性到rank_kmp</title>
    <url>/2022/08/01/%E4%BB%8Ekmp%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%E5%88%B0rank-kmp/</url>
    <content><![CDATA[<h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p=nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(~p&amp;&amp;str[p+<span class="number">1</span>]!=str[i]) p=nxt[p];</span><br><span class="line">    nxt[i]=++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kmp 算法的正确性基于：</p>
<ul>
<li>字符串相等具有传递性，即 $A=B,B=C\Rightarrow A=C$</li>
<li>两个字符串不相等，那么在后面加上一个字符后，两个串仍然不相等，即 $A\neq B \Rightarrow Ac\neq Bc$</li>
</ul>
<p>而复杂度的瓶颈则是：</p>
<ul>
<li>已知 $A=B$ ，判断 $Ac=Bc$ 是否成立</li>
</ul>
<h2 id="RANK-KMP"><a href="#RANK-KMP" class="headerlink" title="RANK-KMP"></a>RANK-KMP</h2><h3 id="问题-CEOI2011-Matching"><a href="#问题-CEOI2011-Matching" class="headerlink" title="问题 (CEOI2011 Matching)"></a>问题 (CEOI2011 Matching)</h3><p>定义两个长度为$N$的序列$A$和$B$相似，当且仅当对于任意$i,j$，有$[ A_i &lt; A_j ] = [ B_i &lt; B_j ]$。给定序列$X,Y$，求$X$中有几个长度为$|Y|$的连续子序列和$Y$相似。$|X|,|Y|\le 10^6$。</p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>对于一个字符串 $S$ ，定义 $fail_i$ 为 最大的 $x$ 使得 $S_{1\cdots x}$ 与 $S_{i-x+1\cdots i}$ 相似。</p>
<p>无论是求出 $fail$ 的过程，还是利用 $fail$ 进行字符串匹配的过程，我们实际上只需要解决这样一个问题：已知 $A$ 和 $B$ 相似，试判断 $Ac$ 和 $Bc$ 是否相似。</p>
<p>观察发现，只要 $c$ 在 $A$ 中的排名与 $c$ 在 $B$ 中的排名相同，$Ac$ 和 $Bc$ 就相似。可以随便用数据结构维护。</p>
<p>利用 $p$ 变化量线性的性质，可以得到一种优美的解法。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Lyndon word 与 Duval 算法</title>
    <url>/2022/08/01/Lyndon-word-%E4%B8%8E-Duval-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>下文中的字符串大小比较都是字典序的比较。</p>
<h2 id="Lyndon-word"><a href="#Lyndon-word" class="headerlink" title="Lyndon word"></a>Lyndon word</h2><p>对于一个字符串$s$，$s$小于$s$的所有后缀，那么$s$就是一个Lyndon word。</p>
<p>显然此时$s$也小于$s$的所有循环移位。</p>
<h3 id="Lemma-1"><a href="#Lemma-1" class="headerlink" title="Lemma 1"></a>Lemma 1</h3><p>对于两个Lyndon word$u,v$满足$u&lt;v$，那么$uv$也是一个Lyndon word。</p>
<h3 id="Lemma-2"><a href="#Lemma-2" class="headerlink" title="Lemma 2"></a>Lemma 2</h3><p>如果一个Lyndon word$s$后面接一个字符$c$得到的字符串$sc$是某个Lyndon word的前缀（即满足$s$小于等于所有的后缀），那么对于任意一个$x&gt;c$，$sx$是Lyndon word。</p>
<h2 id="Lyndon-划分"><a href="#Lyndon-划分" class="headerlink" title="Lyndon 划分"></a>Lyndon 划分</h2><p>定义字符串$s$的Lyndon划分为：$s=t_1t_2t_3\cdots t_m$，其中$t_i$均为Lyndon word且有$t_i \ge t_{i+1}$。</p>
<p>一个字符串的Lyndon word存在且唯一。</p>
<h3 id="存在性证明"><a href="#存在性证明" class="headerlink" title="存在性证明"></a>存在性证明</h3><p>首先把$s$的每个字符单独划为一段，此时显然每一段都是Lyndon word。</p>
<p>如果相邻的两段满足$t_i&lt;t_{i+1}$，那么把这两段合并起来仍然得到Lyndon word。</p>
<p>一直合并直到对于所有$i$都有$t_i \ge t_{i+1}$，此时我们就得到了一个Lyndon划分。</p>
<h3 id="唯一性证明"><a href="#唯一性证明" class="headerlink" title="唯一性证明"></a>唯一性证明</h3><p>设$s$的两个Lyndon划分分别为$t_1t_2\cdots t_m$和$t’_1t’_2\cdots t’_{m’}$，设第一个$i$为最小的满足$t_i \not=t’_i$的下标。设$|t_i|\le |t’_i|$，那么$t_i$一定是$t’_i$的前缀。设$t’_i$去掉$t_i$的那一段后缀为$x$，则因为$t$是Lyndon划分，所以$t_i \ge x$，又因为$t’$是Lyndon划分，所以$t’_i &lt; x$，则得到$t_i \ge x &gt; t’_i &gt; t_i$，矛盾。所以一个串的Lyndon划分是唯一的。</p>
<h2 id="Duval-算法"><a href="#Duval-算法" class="headerlink" title="Duval 算法"></a>Duval 算法</h2><p>一种线性构造Lydon划分的算法，本质上是用类似单调栈的思想模拟合并的过程。</p>
<p>维护三个指针$i,j,k$，其中$s[1\cdots i-1]$的Lyndon划分已经确定，$s[i\cdots k]$的形式为$t^m v$，其中$t$为Lyndon串，$v$是$t$的一个前缀，$j=k-|t|$。</p>
<p>考虑$k+1$这个字符：</p>
<pre><code>1. s[k+1] = s[j+1] 让j,k自增1即可
2. s[k+1] &gt; s[j+1] 此时s[i……k+1]是一个Lyndon串，让j=i，k自增1即可
3. s[k+1] &lt; s[j+1] 此时s[i……k-|v|]无法再合并，这一段中的每一个t就是这一段的Lyndon划分。记录下这个划分，令i=k-|v|+1,j=i,k=i+1
</code></pre><p>模板：loj129</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>); n=<span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>,j,k;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=n) &#123;</span><br><span class="line">		j=i,k=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(k&lt;=n&amp;&amp;str[k]&gt;=str[j]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(str[k]==str[j]) ++k,++j;</span><br><span class="line">			<span class="keyword">else</span> j=i,++k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=j) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,i+(k-j)<span class="number">-1</span>);</span><br><span class="line">			i+=k-j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Berlekamp-Massey算法</title>
    <url>/2022/07/15/Berlekamp-Massey%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果现在你有一个序列，你知道他们满足$m$阶的</p>
<p>递推关系，而你需要通过这个序列中的数解出这个序列的递推式。这就是BM算法解决的问题。</p>
<p>形式化地来说，有一个序列$a$，你需要找出一组$\{ r_1,r_2,r_3\cdots r_m \} $，满足$\forall i&gt;m ,a_i = \sum_{1\le j\le m} a_{i-j}r_j$。</p>
<hr>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>BM算法利用了增量法。我们先求出一个对于前$i$项成立的$R_c=\{r_1,r_2,\cdots r_m \}$，然后把第$i+1$项带入。如果此时递推关系仍然成立，我们就继续去看$i+2$项；否则，我们就通过一系列调整，得到一个$R_{c+1}$，对于前$i+1$项都成立，然后我们再去看后面的项。</p>
<p>记我们得到的第$c$个递推关系式为$R_c$，记第$c$个递推关系式第一次不成立的位置为$fail_c$。初始的时候递推关系为空。</p>
<p>现在我们解决如何调整$R$使得递推关系对第$i$项成立。我们记$delta_i = a_i - \sum_{j=1}^m r_j a_{i-j}$。考虑另构造一个递推关系$R’$满足得到的序列在前$i-1$项取值为$0$，在第$i$项取值为$1$，这样一个对前$i$项成立的就可以是$R_c + delta_{i}\cdot R’$。</p>
<p>考虑利用我们之前的修正。对于$R_{d}$这个递推关系式，它满足在前$fail_d-1$项的取值与$a$相同，在第$fail_d$这一项的取值是$delta_{fail_d}$。那么我们可以构造一个递推关系$R’=\{ 0,0,0,\cdots 0,1,-R_d\} $，这个递推关系的前$i-fail_d-1$项是$0$，然后的一项是$1$，接下来是整个$R_d$取反。这个递推关系的长度是$i-fail_d + |R_d|$的。我们构造出来的这个$R’$，对于前$i-1$个位置中的任意一个位置$x$，取值是$a_{x-(i-fail_d)}- \sum_j r_j a_{x-(i-fail_d)-j} = delta_{x-(i-fail_d)}$。由于$x&lt;i$，所以$x-(i-fail_d)&lt;fail_d$，所以这个递推式在$x$处的取值是$0$。考虑这个递推式在第$i$项的取值：$a_{i-(i-fail_d)} -\sum_j r_j a_{i-(i-fail_d)} = delta_{fail_d}$。我们只需要把这个递推式的每一项的系数再除以$delta_{fail_d}$就可以得到一个在第$i$项取值为$1$，在其他项取值为$0$的递推关系式。</p>
<p>概括一下我们调整的方法：</p>
<ul>
<li>在$R_1,R_2,\cdots R_{c-1}$中选出一个$R_d$。然后构造出$R’ = \{ 0,0,0\cdots 1,-R_{d}\}$。</li>
<li>将$R_{c+1}$调整为$R_c + {delta_i\over delta_{fail_d}} R’$。</li>
<li>调整后，递推关系的长度是$\max \{ |R_c|, i-fail_d+|R_d|\}$。</li>
</ul>
<p>这里关于$d$的选择，有些资料里面是直接选择$c-1$，也有的地方说应该选择$i-fail_d +|R_d|$，我也没有搞清楚哪种写法是正确的；很多地方都说BM算法解出的是最短线性递推式，然而我也没有弄懂它为什么是最短的。等以后弄懂了再回来补充吧。</p>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>如果要解出一个$m$阶的递推式，我们至少需要$2m$项。我们每一次调整的时候，我们需要修改$m$个位置。所以总复杂度大约是$O(m^2)$的。</p>
<hr>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>bzoj1494生成树计数<br>一种做法就是暴力行列式求解打表 + 解线性递推式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BM &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[N];</span><br><span class="line">	<span class="keyword">int</span> delta[N],fail[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">			delta[i]=a[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b[cnt].size();++j)</span><br><span class="line">				Dec(delta[i],b[cnt][j]*(ll)a[i-j<span class="number">-1</span>]%mod);</span><br><span class="line">			<span class="keyword">if</span>(delta[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			fail[cnt++]=i;</span><br><span class="line">			<span class="keyword">if</span>(cnt==<span class="number">1</span>) &#123; b[cnt].resize(i); <span class="keyword">continue</span>; &#125;</span><br><span class="line">			<span class="keyword">int</span> id=<span class="number">0</span>,len=<span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;cnt<span class="number">-1</span>;++k)</span><br><span class="line">				<span class="keyword">if</span>(i-fail[k]+(<span class="keyword">int</span>)b[k].size()&lt;len)</span><br><span class="line">					id=k,len=i-fail[k]+(<span class="keyword">int</span>)b[k].size();</span><br><span class="line">			<span class="keyword">int</span> tmp=delta[i]*(ll)Pow(delta[fail[id]],mod<span class="number">-2</span>)%mod;</span><br><span class="line">			b[cnt].resize(i-fail[id]<span class="number">-1</span>); b[cnt].PB(tmp);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b[id].size();++j)</span><br><span class="line">				b[cnt].PB(b[id][j]*(ll)(mod-tmp)%mod);</span><br><span class="line">			<span class="keyword">if</span>(b[cnt].size()&lt;b[cnt<span class="number">-1</span>].size()) b[cnt].resize(b[cnt<span class="number">-1</span>].size());</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b[cnt<span class="number">-1</span>].size();++j)</span><br><span class="line">				Add(b[cnt][j],b[cnt<span class="number">-1</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		c=b[cnt];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Upd 2020.5.7</p>
<p>参考资料：zzq2019集训队论文</p>
<p>对于有限数列 $\{a_0,a_1,\cdots a_{n-1} \}$，设前缀 $\{a_0,a_1,\cdots a_i\}$ 的最短递推式为 $r^{(i)} = \{r^{(i)}_1,r^{(i)}_2,\cdots \mid a_j = \sum_{k=1}^{|r^{(i)}|} r^{(i)}_k a_{j-k}, j\le i\}$，设 $l_i = |r^{(i)}|$。显然有 $l_{i-1} \le l_i$。</p>
<h3 id="lemma-1-1"><a href="#lemma-1-1" class="headerlink" title="lemma 1.1"></a>lemma 1.1</h3><p>如果 $r^{(i-1)}$ 不是 $\{a_0,a_1,\cdots a_{i-1}\}$ 的最短递推式，那么 $l_i \ge \max\{l_{i-1},i+1-l_{i-1}\}$。</p>
<p>证明：假设 $l_i \le i-l_{i-1}$，$p = r^{(i-1)}, q=r^{(i)}$则</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{j=1}^{l_{i-1}} p_ja_{i-j}\\
= \sum_{j=1}^{l_{i-1}} p_j \sum_{k=1}^{l_i} q_ka_{i-j-k}
\end{gathered}</script><p>这一步是因为 $i-j \ge i-l_{i-1} \ge l_i$。</p>
<script type="math/tex; mode=display">
= \sum_{k=1}^{l_i} q_k \sum_{j=1}^{l_{i-1}} p_j a_{i-j-k}\\
 = \sum_{k=1}^{l_i} q_k a_{i-k}</script><p>这一步是因为 $i-k \ge i-l_i \ge l_{i-1}$。</p>
<script type="math/tex; mode=display">
= a_i</script><p>则 $r^{(i-1)}$ 对 $\{a_0,a_1,\cdots a_i\}$ 也成立，与已知矛盾。</p>
<p>这个引理告诉了我们最短递推式长度的下界，而这个下界是可以用 Berlekamp-Massey 算法达到的。</p>
<p>Berlekamp-Massey 算法的过程：</p>
<p>将 $i$ 从 $1$ 枚举到 $n$：</p>
<ul>
<li>如果 $r^{(i-1)}$ 对 $\{a_0,a_1,\cdots a_i\}$ 仍然成立，令 $r^{(i)} = r^{(i-1)}$ 即可</li>
<li>否则，用上一次 $r^{(p-1)}$ 对 $\{a_0,a_1,\cdots a_{p}\}$ 不再成立的 $r^{(p-1)}$ 来调整 $r^{(i-1)}$ 以得到 $r^{(i)}$</li>
</ul>
<p>归纳证明其达到了下界：</p>
<ul>
<li>假设 $l_1,l_2,\cdots l_{i-1}$ 均已达到了下界，而 $r^{(i)} \neq r^{(i-1)}$</li>
<li>由算法流程可知和归纳假设可知，$l_{i-1} = l_p, l_i = i-p+l_{p-1}, l_p = p+1 - l_{p-1}$</li>
<li>则 $l_i = i - p + l_{p-1} = i + 1 - l_{p} = i+1-l_{i-1}$</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常系数齐次线性递推 - O(k log k log n) 求第n项</title>
    <url>/2022/07/15/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8-O-k-log-k-log-n-%E6%B1%82%E7%AC%ACn%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于一个数列$h_0,h_1\cdots h_n,\cdots $，称这个数列满足<strong>k阶线性递推关系</strong>是指存在量$a_1,a_2,\cdots a_k (a_k \not= 0 )$和量$b_n$（$a_1,a_2,\cdots a_k,b_n$都可能以来于$n$），使得$h_n = a_1h_{n-1} + a_2h_{n-2} \cdots a_k h_{n-k} + b_n(n\ge k)$成立。</p>
<p>如果$b_n$是常数$0$，我们称这个线性递推关系式齐次的。</p>
<p>如果$a_1,a_2\cdots a_k$都是常量，我们称这个线性递推关系式常系数的。</p>
<hr>
<h4 id="1）"><a href="#1）" class="headerlink" title="1）"></a>1）</h4><p>可以用矩阵表示是常系数线性递推关系（以$k=4$为例）：</p>
<script type="math/tex; mode=display">
\begin {bmatrix}
a_1 & a_2 & a_3 & a_4 \\
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 
\end {bmatrix}
\cdot 
\begin {bmatrix}
f_{i+3} \\
f_{i+2} \\
f_{i+1} \\
f_{i} 
\end {bmatrix}
= \begin {bmatrix}
f_{i+4} \\
f_{i+3} \\
f_{i+2} \\
f_{i+1}
\end {bmatrix}</script><p>设上面的那个$k\times k$的矩阵为$A$。</p>
<p>求数列的第$n$项等价于求$A^n \cdot<br>\begin {bmatrix}<br>f_3 \\<br>f_2 \\<br>f_1 \\<br>f_0<br>\end {bmatrix}$。</p>
<p>利用矩阵乘法的结合律，可以用矩阵快速幂在$O(k^3 \log n)$的时间内解决。</p>
<h4 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h4><p>对于一个矩阵$A$，我们定义它的特征多项式为：</p>
<script type="math/tex; mode=display">
P(\lambda) = \det ( \lambda E - A)</script><p>可以证明$P(A)=0$（也就是Cayley-Hamilton定理），其中$0$表示$0$矩阵。</p>
<p>对于一个$k$阶常系数线性递推关系，它的矩阵的特征多项式是：</p>
<script type="math/tex; mode=display">
P(\lambda )=\lambda ^k - \sum_{i=1}^k a_i \lambda ^{k-i}</script><p>可以直接展开行列式就得到。</p>
<p>考虑矩阵$\lambda E - A$的行列式：</p>
<script type="math/tex; mode=display">
\begin {bmatrix}
\lambda - a_1 & -a_2 & -a_3 & -a_4 \\
-1 & \lambda & 0 & 0 \\
0 & -1 & \lambda & 0 \\
0 & 0 & -1 & \lambda
\end {bmatrix}</script><p>如果确定了哪一列选择第一行，那么容易发现其他的列选择的行都是唯一确定的。如果是第$i$列选了第一行，那么$i$之前的列$j$一定会选择第$j+1$行，$i$之后的列$j$一定会选择第$j$行。故而，这个矩阵的行列式就是：</p>
<script type="math/tex; mode=display">
(-1)^0(\lambda - a_1 )\lambda ^3 (-1)^0 \\
+ (-1)^{1}(-a_2)\lambda^2 (-1)^1 \\
+ (-1)^2 (-a_3 ) \lambda^1(-1)^2 \\
+ (-1)^3 (-a_4) (-1)^3 \\
= \lambda^4 - a_1 \lambda^3  - a_2 \lambda^2 - a_3 \lambda -a_4</script><p>其中，第一个$-1$是这一列之前的所有的列的选择，然后$\lambda$是这一列之后的列的选择，最后还要乘$-1$是因为考虑逆序对的数量。</p>
<p>所以$A$的特征多项式是$P(\lambda) = \det ( \lambda E - A)$。</p>
<p>3）</p>
<p>也就是说，我们得到了</p>
<script type="math/tex; mode=display">
P(A) = A^k - \sum_{i=1}^k a_i A^{k-i} = 0 \\
A^k = \sum_{i=1}^k a_i A^{k-i}</script><p>这意味着，对于任意一个$n\ge k$，$A^n$都可以用$A^0,A^1,\cdots A^{k-1}$的线性组合表示出来。</p>
<p>考虑计算两个矩阵的乘积：设$A^x = \sum_{i=0}^{k-1} a_i A^i ,A^y = \sum_{i=0}^{k-1}b_iA^i $，那么：</p>
<script type="math/tex; mode=display">
A^{x+y} = (A^x)\cdot(A^y)\\
=(\sum_{i=0}^{k-1} a_i A^i ) (\sum_{j=0}^{k-1} b_jA^j)\\
=\sum_{i+j=x} a_ib_jA^x</script><p>这是一个卷积的形式。卷积完之后，为了保证项数小于等于$k$，还要做一次多项式取模。</p>
<p>也就是说我们现在有了一个在$O(k^2)$或者$O(k\log k)$计算两个矩阵的乘积的方法。矩阵快速幂的复杂度被优化到$O(k^2\log n)$或者$O(k\log k \log n)$。</p>
<p>4）</p>
<p>但是，直接用这样的结果来计算答案复杂度大约是$k^4$的。</p>
<p>设$B_i$是$k\times 1$的向量$ \begin {bmatrix} f_{i+k-1} \ \vdots \ f_{i+2} \ f_{i+1} \ f_{i} \end {bmatrix} $。</p>
<p>我们要求的就是$A^n \cdot B_0 = (\sum_{i=0}^{k-1} a_i A^i) B_0 $，它等于：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{k-1} a_iA^i B_0 \\
=\sum_{i=0}^{k-1} a_iB_i \\
= \begin {bmatrix}
\sum_{i=0}^{k-1} a_i f_{k-1+i}\\
\sum_{i=0}^{k-1} a_i f_{k-2+i} \\
\vdots \\
\sum_{i=0}^{k-1} a_i f_i
\end {bmatrix}</script><p>也就是说$f_n = \sum_{i=0}^{k-1} a_if_i$。这一步的计算在$O(k)$的时间内就可以完成。</p>
<p>综上，我们可以在$O(k\log k\log n)$的时间内算出一个满足线性齐次递推关系的数列的第$n$项。</p>
<hr>
<h3 id="模板-amp-例题"><a href="#模板-amp-例题" class="headerlink" title="模板 &amp; 例题"></a>模板 &amp; 例题</h3><p>luogu P4723 模板 线性递推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123; x+=y; <span class="keyword">if</span>(x&gt;=mod) x-=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123; x-=y; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x&gt;=mod?x-mod:x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x&lt;<span class="number">0</span>?x+mod:x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*(ll)x%mod;</span><br><span class="line">        x=x*(ll)x%mod,y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> G[N],Q[N],InvQ[N],m;</span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> wn[<span class="number">2</span>][N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getwn</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;l);i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> w0=Pow(<span class="number">3</span>,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> w1=Pow(<span class="number">3</span>,mod<span class="number">-1</span>-(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">            wn[<span class="number">0</span>][i]=wn[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j) &#123;</span><br><span class="line">                wn[<span class="number">0</span>][i+j]=wn[<span class="number">0</span>][i+j<span class="number">-1</span>]*(ll)w0%mod;</span><br><span class="line">                wn[<span class="number">1</span>][i+j]=wn[<span class="number">1</span>][i+j<span class="number">-1</span>]*(ll)w1%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rev[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;l);++i) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;l<span class="number">-1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> len,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) <span class="keyword">if</span>(rev[i]&lt;i) swap(A[i],A[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=l&lt;&lt;<span class="number">1</span>,i=<span class="number">0</span>;i&lt;len;i+=p)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;l;++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t1=A[i+j],t2=A[i+l+j]*(ll)wn[f][l+j]%mod;</span><br><span class="line">                    A[i+j]=Add(t1+t2);</span><br><span class="line">                    A[i+l+j]=Dec(t1-t2);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ilen=Pow(len,mod<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[i]=A[i]*(ll)ilen%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span>  *C,<span class="keyword">int</span> l1,<span class="keyword">int</span> l2,<span class="keyword">int</span> l3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a[N],b[N];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>,cnt=<span class="number">0</span>; <span class="keyword">while</span>(len&lt;=max(l1<span class="number">-1</span>+l2<span class="number">-1</span>,l3<span class="number">-1</span>)) len&lt;&lt;=<span class="number">1</span>,cnt++; getr(cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=b[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1;++i) a[i]=A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l2;++i) b[i]=B[i];</span><br><span class="line">        FFT(a,len,<span class="number">0</span>),FFT(b,len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=a[i]*(ll)b[i]%mod;</span><br><span class="line">        FFT(a,len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l3;++i) C[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> C[N],P[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(B[<span class="number">0</span>]=Pow(A[<span class="number">0</span>],mod<span class="number">-2</span>));</span><br><span class="line">        <span class="keyword">int</span> l=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>; Inv(A,B,l);</span><br><span class="line">        Mul(B,B,C,l,l,n);</span><br><span class="line">        Mul(C,A,C,n,n,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;n;++i) B[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            B[i]=(<span class="number">2l</span>l*B[i]-C[i]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) B[i]=A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n-i&lt;=i) <span class="keyword">break</span>;</span><br><span class="line">            swap(B[i],B[n-i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> *F,<span class="keyword">int</span> *B,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N],D[N];</span><br><span class="line">        Rev(F,P,n);</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;=n-m;++i) printf("%d ",Q[i]); puts("");</span></span><br><span class="line"><span class="comment">//		Inv(Q,D,n-m+1);</span></span><br><span class="line">        Mul(InvQ,P,A,n-m+<span class="number">1</span>,n-m+<span class="number">1</span>,n-m+<span class="number">1</span>);</span><br><span class="line">        Rev(A,A,n-m);</span><br><span class="line">        Mul(A,G,D,n-m+<span class="number">1</span>,m+<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) B[i]=(F[i]-D[i]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">predoG</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Rev(G,Q,m);</span><br><span class="line">        Inv(Q,InvQ,n-m+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Poly::Mul;</span><br><span class="line"><span class="keyword">using</span> Poly::Div;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span> &#123;</span></span><br><span class="line"> 	<span class="keyword">int</span> a[N];</span><br><span class="line"> 	Mat () &#123; <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a)); &#125;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> a[i]; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mat <span class="keyword">operator</span> *(Mat A,Mat B) &#123;</span><br><span class="line">        Mat C;</span><br><span class="line">        Mul(A.a,B.a,C.a,m,m,<span class="number">2</span>*m<span class="number">-1</span>);</span><br><span class="line">        Div(C.a,C.a,<span class="number">2</span>*m<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Mat <span class="title">Pow</span><span class="params">(Mat x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Mat res; res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">        x=x*x,y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Poly::getwn(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">int</span> n; rd(n),rd(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; rd(x); x=(x%mod+mod)%mod;</span><br><span class="line">        G[m-i]=(mod-x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    G[m]=<span class="number">1</span>;</span><br><span class="line">    Poly::predoG(<span class="number">2</span>*m<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) rd(h[i]),h[i]=(h[i]%mod+mod)%mod;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h[n]); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h[<span class="number">0</span>]*(ll)Pow((mod-G[<span class="number">0</span>])%mod,n)%mod); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    Mat A; A[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    A=Pow(A,n);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) Add(ans,A[i]*(ll)h[i]%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loj </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123; x+=y; <span class="keyword">if</span>(x&gt;=mod) x-=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123; x-=y; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*(ll)x%mod;</span><br><span class="line">		x=x*(ll)x%mod,y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> g[N][N],f[N][N],h[N],n,m,q,p,invq;</span><br><span class="line"><span class="keyword">int</span> pw[N];</span><br><span class="line"><span class="keyword">int</span> G[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[N];</span><br><span class="line">	Mat() &#123; <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a)); &#125;</span><br><span class="line">	<span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> a[i]; &#125;</span><br><span class="line">	<span class="keyword">friend</span> Mat <span class="keyword">operator</span> *(Mat A,Mat B) &#123;</span><br><span class="line">		Mat C;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">				Add(C[i+j],A[i]*(ll)B[j]%mod);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m*<span class="number">2</span><span class="number">-2</span>;i&gt;=m;--i) <span class="keyword">if</span>(C[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) Dec(C[i-m+j],C[i]*(ll)G[j]%mod);</span><br><span class="line">			C[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span>(h));</span><br><span class="line">	<span class="built_in">memset</span>(G,<span class="number">0</span>,<span class="keyword">sizeof</span>(G));</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;=m;++i) printf("%d ",pw[i]); printf(" - %d\n",q); puts("");</span></span><br><span class="line">	f[m+<span class="number">1</span>][<span class="number">0</span>]=g[m+<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;<span class="number">0</span>;--j) &#123;</span><br><span class="line">		g[j][<span class="number">0</span>]=f[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*j&lt;=m;++i) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;++k)</span><br><span class="line">				Add(f[j][i],g[j+<span class="number">1</span>][k<span class="number">-1</span>]*(ll)g[j][i-k]%mod*pw[j]%mod*q%mod);</span><br><span class="line">			g[j][i]=(g[j+<span class="number">1</span>][i]+f[j][i])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	h[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+<span class="number">1</span>&lt;=i&amp;&amp;j&lt;=m;++j)</span><br><span class="line">			h[i]=(h[i]+h[i-j<span class="number">-1</span>]*(ll)g[<span class="number">1</span>][j]%mod*q)%mod;</span><br><span class="line">	<span class="keyword">if</span>(n+<span class="number">1</span>&lt;=m+<span class="number">1</span>) <span class="keyword">return</span> h[n+<span class="number">1</span>]*(ll)invq%mod;		</span><br><span class="line">	G[m+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) G[m-i]=(mod-g[<span class="number">1</span>][i]*(ll)q%mod)%mod;</span><br><span class="line">	m++;</span><br><span class="line">	Mat x,res; x[<span class="number">1</span>]=<span class="number">1</span>,res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> y=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">		x=x*x,y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) Add(ans,res[i]*(ll)h[i]%mod);</span><br><span class="line">	<span class="keyword">return</span> ans*(ll)invq%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> _m,x,y;</span><br><span class="line">	rd(n),rd(_m),rd(x),rd(y);</span><br><span class="line">	p=x*(ll)Pow(y,mod<span class="number">-2</span>)%mod;</span><br><span class="line">	q=(<span class="number">1l</span>l-p+mod)%mod; invq=Pow(q,mod<span class="number">-2</span>);</span><br><span class="line">	pw[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=_m;++i) pw[i]=pw[i<span class="number">-1</span>]*(ll)p%mod;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	m=_m; ans=sol();</span><br><span class="line">	m=_m<span class="number">-1</span>; Dec(ans,sol());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.cnblogs.com/Troywar/p/9078013.html" target="_blank" rel="noopener">https://www.cnblogs.com/Troywar/p/9078013.html</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单纯性算法的正确性证明</title>
    <url>/2022/07/15/%E5%8D%95%E7%BA%AF%E6%80%A7%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h2 id="一个引理"><a href="#一个引理" class="headerlink" title="一个引理"></a>一个引理</h2><p>设$I$是一个下标集合。对于每一个$j\in I$，设$\alpha_j$和$\beta_j$是实数，并且令$x_j$是一个实数变量。设$\gamma$是一个实数。</p>
<p>如果对于变量$x_j$的任意设置，我们都有$\sum_{j\in I} \alpha_j x_j  = \gamma + \sum_{j\in I} \beta_jx_j$。那么可以推出对于任意的$j\in I$有$\alpha_j = \beta_j$并且$\gamma =0$。</p>
<p>证明：</p>
<p>我们可以令所有的$x_j$都等于$0$，这样就可以推出$\gamma =0$。</p>
<p>对于某一个$j\in I$，我们令$x_j=1$且对于所有的$k\not =j$令$x_k = 0$，就可以得到$\alpha_j = \beta_j $。</p>
<hr>
<h2 id="线性规划弱对偶性"><a href="#线性规划弱对偶性" class="headerlink" title="线性规划弱对偶性"></a>线性规划弱对偶性</h2><p>设$\overline x$为原始线性规划问题的一个任意一个可行解，$\overline y$为对偶问题的任意一个可行解，那么有$\sum_{j=1}^n c_j\overline{x}_j\le \sum_{i=1}^m b_i\overline y_i$。</p>
<p>证明：</p>
<script type="math/tex; mode=display">
\sum_{j=1}^n c_j\overline x_j \le \sum_{j=1}^n (\sum_{i=1}^m a_{i,j}\overline y_i)\overline x_j\\
=\sum_{i=1}^m (\sum_{j=1}^n a_{i,j}\overline x_j ) \overline y_i\\
\le \sum_{i=1}^m b_i\overline y_i</script><p>因此，原问题的一组解$\overline x $和对偶问题的一组解$\overline y$如果满足$\sum_{j=1}^n c_j x_j = \sum_{i=1}^m b_i x_i$，那么这个两组解分别是原问题和对偶问题的最优解。</p>
<hr>
<h2 id="线性规划对偶性-amp-amp-单纯性算法的正确性证明"><a href="#线性规划对偶性-amp-amp-单纯性算法的正确性证明" class="headerlink" title="线性规划对偶性 &amp;&amp; 单纯性算法的正确性证明"></a>线性规划对偶性 &amp;&amp; 单纯性算法的正确性证明</h2><p>首先给出，如何通过单纯性算法最终返回的$z= v’+\sum_{j\in N}c_j’x_j$和$x_i = b_i’-\sum_{j\in N} a’_{i,j}x_j$构造出对应的$y$（其中我们用$N$表示非基变量的集合，$B$表示基变量的集合，$z$是我们要最大化的目标函数）：</p>
<script type="math/tex; mode=display">
\overline y _i = \begin{cases}
-c'_{n+i} & \text {if } (n+i)\in N\\
0 & otherwise
\end{cases}</script><p>我们定义对于所有的$j\in B$有$c’_j = 0$。</p>
<p>那么</p>
<script type="math/tex; mode=display">
z = v+\sum_{j=1}^n c_j x_j\\
=v'+\sum_{j\in N}c'_j\overline x_j\\
=v'+\sum_{j\in N} c'_j \overline x_j + \sum_{j\in B} c'_j\overline x_j \\
=v'+\sum_{j\in N} c'_j \overline x_j + \sum_{j\in B} (-\overline y_j)\overline x_{n+i}\\
=v'+\sum_{j\in N} c'_j \overline x_j + \sum_{j\in B} (-\overline y_j )(b_j - \sum_{i=1}^n a_{j,i} \overline x_i )\\
=(v'-\sum_{j\in B }b_j\overline y_j) +(\sum_{j\in N} (c'_j + \sum_{i=1}^n a_{j,i}\overline y_j)\overline x_j</script><p>上式对于任意一组可行解都成立。因此，我们可以得到：</p>
<script type="math/tex; mode=display">
v'-\sum_{j\in B} b_j\overline y_j =0\\
\forall j\in B,c'_j +\sum_{i=1}^n a_{j,i}\overline y_j = c_j\\
\because c'_j \le 0\\
\therefore a_{j,i}\overline y_j \ge c_j</script><p> 因此我们的对偶解是一组可行解。因此我们通过单纯性算法得到的就是最优解。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵乘法结合律、分配律的证明</title>
    <url>/2022/07/15/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%BB%93%E5%90%88%E5%BE%8B%E3%80%81%E5%88%86%E9%85%8D%E5%BE%8B%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h3 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h3><p>矩阵乘法满足结合律，即$(AB)C=A(BC)$。</p>
<p>证明：设最后得到的结果为$D,AB=E,BC=F$。</p>
<p>左边：</p>
<script type="math/tex; mode=display">
D_{i,j}=\sum E_{i,k}C_{k,j}\\
=\sum (\sum A_{i,l}B_{l,k})C_{k,j}\\
=\sum A_{i,l}B_{l,k}C_{k,j}</script><p>右边：</p>
<script type="math/tex; mode=display">
D_{i,j}=\sum A_{i,l} F_{l,j}\\
=\sum A_{i,l}(\sum B_{l,k}C_{k,j})\\
=\sum A_{i,l}B_{l,k}C_{k,j}</script><p>所以矩阵乘法满足结合律。</p>
<p>同时还可以看出，矩阵乘法一般不满足交换律。</p>
<h3 id="分配律"><a href="#分配律" class="headerlink" title="分配律"></a>分配律</h3><p>矩阵乘法对矩阵加法满足分配律，即$A(B+C)=AB+AC,(B+C)A=BA+CA$，注意矩阵的左右顺序不能够改变。</p>
<p>证明：设得到的矩阵为$D$</p>
<p>左边：</p>
<script type="math/tex; mode=display">
D_{i,j}=\sum A_{i,k}(B_{k,j}+C_{k,j})\\
=\sum A_{i,k}B_{k,j} + \sum A_{i,k}C_{k,j}</script><p>右边：</p>
<script type="math/tex; mode=display">
D_{i,j}=\sum A_{i,k}B_{k,j} + \sum A_{i,k}C_{k,j}</script><p>因此矩阵乘法对加法满足分配律。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>上三角矩阵高斯消元的优化</title>
    <url>/2022/07/15/%E4%B8%8A%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="P4457-BJOI2018-治疗之雨"><a href="#P4457-BJOI2018-治疗之雨" class="headerlink" title="P4457 [BJOI2018]治疗之雨"></a>P4457 [BJOI2018]治疗之雨</h3><p>$n\le 1500$，不能直接$n^3$高斯消元。然而这道题需要高斯消元的那个矩阵很特殊，近似上三角矩阵，大概长这样（$1$表示值不为$0$）：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 1 & 0 & 0 & 0 & \cdots & 0 \\
1 & 1 & 1 & 0 & 0 & \cdots & 0 \\
1 & 1 & 1 & 1 & 0 & \cdots & 0 \\
1 & 1 & 1 & 1 & 1 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots  & \ddots & \vdots \\
\end{bmatrix}</script><p>如果我们从第一行开始消，那么消完第一行后，矩阵就变成这样的了：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 1 & 0 & 0 & 0 & \cdots & 0 \\
0 & 1 & 1 & 0 & 0 & \cdots & 0 \\
0 & 1 & 1 & 1 & 0 & \cdots & 0 \\
0 & 1 & 1 & 1 & 1 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots  & \ddots & \vdots \\
\end{bmatrix}</script><p>这个时候我们再用第二行去消：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & \cdots & 0 \\
0 & 1 & 1 & 0 & 0 & \cdots & 0 \\
0 & 0 & 1 & 1 & 0 & \cdots & 0 \\
0 & 0 & 1 & 1 & 1 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots  & \ddots & \vdots \\
\end{bmatrix}</script><p>然后是第三行：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & \cdots & 0 \\
0 & 1 & 0 & 0 & 0 & \cdots & 0 \\
0 & 0 & 1 & 1 & 0 & \cdots & 0 \\
0 & 0 & 0 & 1 & 1 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots  & \ddots & \vdots \\
\end{bmatrix}</script><p>这个时候轮到第四行……我们发现，我们拿去消元的那一行，总是只有两个元素不为$0$（算上常数项就是$3$个）。我们只用不为$0$的元素去消元，每次消一行的时间就从$O(n)$降到了$O(1)$的，总复杂度降到$O(n^2)$。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划</title>
    <url>/2022/07/15/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><h4 id="线性函数、线性约束、线性规划问题"><a href="#线性函数、线性约束、线性规划问题" class="headerlink" title="线性函数、线性约束、线性规划问题"></a>线性函数、线性约束、线性规划问题</h4><p>已知一组实数$a_1,a_2\cdots a_n$和一组变量$x_1,x_2,\cdots x_n$，在这些变量上的一个线性函数定义为$f(x) = \sum a_ix_i$。</p>
<p>$f(x_1,x_2,\cdots x_n)=b$、$f(x_1,x_2\cdots x_n)\le b$、$f(x_1,x_2\cdots x_n)\ge  b$统称为线性约束。</p>
<p>线性规划问题要求最小化或者最大化一个受限于一组有限的线性约束的线性函数。</p>
<h4 id="解"><a href="#解" class="headerlink" title="解"></a>解</h4><p>称满足所有限制条件的解$x_1,x_2,\cdots x_n$为可行解，称使目标函数达到最优的解为最优解，称所有可行解构成的区域为解空间。</p>
<p>考虑我们的解空间，它是若干个限制的解空间的交。由于每一个限制的解空间都是一个凸形区域，所以我们的解空间也一定是一个凸形区域。因此，局部最优解只有一个，我们可以用类似爬山的贪心法来求解最优解。</p>
<hr>
<h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><h4 id="标准型"><a href="#标准型" class="headerlink" title="标准型"></a>标准型</h4><p>要求最大化$f(x_1,x_2\cdots x_n) = \sum_{i=1}^n c_i x_i$<br>约束为$\forall i\in [1,m], \sum_{j=1}^n a_{i,j} x_j \le b_i $<br>且要求$\forall i\in [1,n], x_i \ge 0$</p>
<p>所有的线性规划都可以用标准型描述。</p>
<ul>
<li>如果取值范围是$(-\infty,+\infty)$，可以把$x$拆成两个取值范围为$[0,+\infty)$的变量$a,b$，令$x=a-b$。</li>
<li>如果限制中是大于等于，或者目标函数要求最小化，可以把所有的系数全部取反。</li>
<li>如果限制中有等式，可以拆成大于等于和小于等于。</li>
</ul>
<p>标准型也可以用矩阵描述：</p>
<p>最大化$c^Tx$<br>约束为$A^Tx\le b$且$x\ge 0$</p>
<p>其中向量$x\le y$当且仅当对于每一维都有$x_i \le y_i$</p>
<h4 id="松弛型"><a href="#松弛型" class="headerlink" title="松弛型"></a>松弛型</h4><p>主要是为了避免系数为负的时候，不等式变号的问题。</p>
<p>要求最大化$f(x_1,x_2\cdots x_n)= \sum_{i=1}^n c_i x_i$<br>约束为$\forall i\in [1,m], x_{i+n} = b_i - \sum_{j=1}^n a_{i,j}x_j$<br>且要求$\forall i\in [1,n+m],x_i\ge 0$</p>
<p>相当于我们强行设了一个大于等于$0$的变量，令它等于$b_i - \sum_{j=1}^n a_{i,j}x_j$。</p>
<hr>
<h3 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h3><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p>1）找到一个基本解（如果找不到则无解）。<br>2）进行转轴操作，使其向解空间内使目标函数增大的方向移动。重复这个步骤直到最优解。</p>
<h4 id="一些定义-1"><a href="#一些定义-1" class="headerlink" title="一些定义"></a>一些定义</h4><p>松弛型左边的变量称为基变量，右边的变量称为非基变量。初始的时候，$x_1,x_2\cdots x_n$为非基变量，$x_{n+1},x_{n+2},\cdots x_{n+m}$为基变量。</p>
<p>一组基本解的定义是，我们通过一些操作使得所有限制中等式右边的常量都大于等于$0$，这样所有的非基变量取$0$，所有的基变量取右边的常量，就是一组基本解。</p>
<h4 id="转轴操作"><a href="#转轴操作" class="headerlink" title="转轴操作"></a>转轴操作</h4><p>转轴操作的本质是，我们增大这个函数中某一个非基变量的值，让它取到它可以取的值的上界。这就要求我们必须把这个变量变成基变量。</p>
<p>首先我们选择这个非基变量，选择的方法是从$c_i&gt;0$的所有的$i$中选择下标最小的$x_i$（如果不强制选择的这个位置的下标最小似乎会死循环？）。如果此时已经没有大于$0$的$c_i$了，这就说明所有的非基变量取$0$是最优的，此时直接返回目标函数的常数项就可以了。</p>
<p>然后我们考虑它最大能够取到多大。我们考虑所有$a_{j,i}&gt;0$的限制，这个上界就应该是$\min \{ {b_j\over a_{j,i}} \}$。如果所有的限制的$a_{j,i}$都小于等于$0$，那么答案是无限大。</p>
<p>设这个式子在$j$处取到最小值。</p>
<p>原先我们有</p>
<script type="math/tex; mode=display">
x_{j+n} = b_j - \sum_{k=1,k\not=i}^n a_{j,k}x_k - a_{j,i}x_i</script><p>移项、除系数：</p>
<script type="math/tex; mode=display">
x_i = {b_j\over a_{j,i}} - \sum_{k=1,k\not = i }^n {a_{j,k}\over a_{j,i}}x_k - {1\over a_{j,i} }x_{j+n}</script><p>然后我们再把这个式子带入其它的等式。显然由于我们选择了$b_j\over a_{j,i}$最小的$j$，所以带入过后所有的等式的常数项仍然是非负的。</p>
<p>整个操作相当于交换$x_i$和$x_{j+n}$这两个变量，使得$x_{j+n}$变成了非基变量，而$x_i$变成了基变量。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>如果当前还有常数项小于$0$，我们从中随意选择一个等式，然后随机选择这个等式中$a_{i,j}$小于$0$的一个变量，然后对它进行转轴操作。重复这个操作直到所有限制中的常量都非负。</p>
<p>如果我们选择的这个等式中不存在任何一个$a_{i,j}$小于$0$的变量，则无解。</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>进行一次转轴操作的复杂度是$O(nm)$的。</p>
<p>而理论上进行转轴操作的上限是${n+m\choose n}$，可以理解为我们决定哪些变量作为基变量、哪些变量作为非基变量的方案数是${n+m\choose n}$。但是通常这个复杂度是远远达不到的。ZJK说期望复杂度大约是在$O(n^2m)$或者$O(nm^2)$左右（？）。</p>
<p>模板 uoj179</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> db eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="function">db <span class="title">fabs</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> x&gt;<span class="number">0</span>?x:-x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> x&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>; &#125;</span><br><span class="line">db a[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,id[N&lt;&lt;<span class="number">1</span>],pos[N&lt;&lt;<span class="number">1</span>],is_inf;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	swap(id[r+n],id[c]);</span><br><span class="line">	db fr=-a[r][c]; a[r][c]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i) a[r][i]/=fr;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;++i) <span class="keyword">if</span>(i!=r) &#123;</span><br><span class="line">		db xi=a[i][c]; <span class="keyword">if</span>(<span class="built_in">fabs</span>(xi)&lt;eps) <span class="keyword">continue</span>; </span><br><span class="line">		a[i][c]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;++j) a[i][j]+=a[r][j]*xi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function">db <span class="title">LP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">			<span class="keyword">if</span>(dcmp(a[m+<span class="number">1</span>][i])&gt;<span class="number">0</span>) &#123; p=i; <span class="keyword">break</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> a[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">		db mi=<span class="number">1e24</span>; <span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">			<span class="keyword">if</span>(dcmp(a[i][p])&gt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(a[i][n+<span class="number">1</span>]/(-a[i][p])&lt;mi) mi=a[i][n+<span class="number">1</span>]/(-a[i][p]),q=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(q==<span class="number">0</span>) &#123; is_inf=<span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">		pivot(q,p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> r=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="keyword">if</span>(dcmp(a[i][n+<span class="number">1</span>])&lt;<span class="number">0</span>&amp;&amp;(!r||rand()&amp;<span class="number">1</span>)) r=i;</span><br><span class="line">		<span class="keyword">if</span>(!r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(dcmp(a[r][i])&gt;<span class="number">0</span>&amp;&amp;(!c||rand()&amp;<span class="number">1</span>)) c=i;</span><br><span class="line">		<span class="keyword">if</span>(!c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pivot(r,c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> ty; rd(n),rd(m),rd(ty);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%Lf"</span>,&amp;a[m+<span class="number">1</span>][i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;++j) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%Lf"</span>,&amp;a[i][j]);</span><br><span class="line">			<span class="keyword">if</span>(j!=n+<span class="number">1</span>) a[i][j]=-a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;++i) id[i]=i;</span><br><span class="line">	<span class="keyword">if</span>(!init()) <span class="built_in">printf</span>(<span class="string">"Infeasible"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		db Ans=LP();</span><br><span class="line">		<span class="keyword">if</span>(is_inf) <span class="built_in">printf</span>(<span class="string">"Unbounded"</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%.8Lf\n"</span>,Ans);</span><br><span class="line">			<span class="keyword">if</span>(ty==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;++i) pos[id[i]]=i;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">				<span class="keyword">if</span>(pos[i]&lt;=n) <span class="built_in">printf</span>(<span class="string">"0.0000000 "</span>);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.8Lf "</span>,a[pos[i]-n][n+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><p>要求最大化$f(x_1,x_2\cdots x_n) = \sum_{i=1}^n c_i x_i$<br>约束为$\forall i\in [1,m], \sum_{j=1}^n a_{i,j} x_j \le b_i $<br>且要求$\forall i\in [1,n] x_i \ge 0$</p>
<p>它的对偶问题是：</p>
<p>要求最小化$f(y_1,y_2\cdots y_n) = \sum_{i=1}^m b_i y_i$<br>约束为$\forall i\in [1,n], \sum_{j=1}^m a_{j,i} y_j \ge c_i $<br>且要求$\forall i\in [1,m], y_i \ge 0$</p>
<h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>原问题的最优解等于对偶问题的最优解。</p>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>若$X,Y$分别是原问题和对偶问题的可行解，那么它们都是最优解当且仅当</p>
<p>$\forall i\in [1,n]$，满足$x_i = 0 $或者$\sum a_{j,i}y_j = c_i$。<br>$\forall i\in [1,m]$，满足$y_i = 0$或者$\sum a_{i,j}x_j = b_i$。</p>
<hr>
<h3 id="全幺模矩阵"><a href="#全幺模矩阵" class="headerlink" title="全幺模矩阵"></a>全幺模矩阵</h3><p>定义：定义一个矩阵为全幺模矩阵，当且仅当它的任意一个子方阵的行列式都是$\pm 1$或者$0$。</p>
<p>如果$A$是全幺模矩阵且$b$中的元素都是整数，那么这个线性规划的最优解，必定可以通过一组整数解达到。</p>
<hr>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>codechef FLYDIST<br>poj3689 Equations<br>BZOJ3118 Orz the MST<br>codechef CHEFBOOK</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束系统</title>
    <url>/2022/07/15/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>问题：有 $n$ 个变量 $x_1,x_2,\cdots x_n$，以及一系列限制 $x_{v_i} - x_{u_i}\le w_i$（$w_i$ 可以为任意实数）。求出一组合法解或判定无解。</p>
<p>回顾最短路的概念：</p>
<blockquote>
<p>对于一张包含 $n$ 个点的有向图，设 $dis_i$ 表示从 $1$ 到 $i$ 的最短路长度，令 $dis_1 = 0$。则对于每条边 $(u_i,v_i,w_i)$，显然会有 $dis_{v_i} \le dis_{u_i} + w_i$，也就是 $dis_{v_i} - dis_{u_i} \le w_i$。</p>
</blockquote>
<p>注意到 $dis_{v_i} - dis_{u_i} \le w_i$ 与 $x_{v_i} - x_{u_i} \le w_i$ 形式十分相似。此外，如果 $\{x_1,x_2,\cdots x_n\}$ 是差分约束系统的一组解，那么 $\{x_1+d,x_2+d\cdots x_n+d\}$ 也是差分约束系统的一组解。</p>
<p>建一张包含 $n$ 个的结点的有向图，对于一个限制 $x_{v_i} - x_{u_i} \le w_i$，连一条从 $u_i$ 到 $v_i$ 边权为 $w_i$ 的边。令 $dis_1 = 0$，求出 $1$ 到图中每个点的最短路。如果图中没有负环，那么 $\{ x_i = dis_i \}$ 为该差分约束系统的一组解；否则，该差分约束系统无解（可以将负环上的限制加起来，得到一个 $x_i - x_i \le c(c&lt;0)$ 的限制）。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一种树形背包的复杂度证明</title>
    <url>/2022/07/15/%E4%B8%80%E7%A7%8D%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>有一类树上背包（例如 CF1097G Vladislav and a Great Legend），第二维表示子树内选的点数且限制第二维不超过$m$，其总复杂度可证明为$O(nm)$。</p>
<p>它们的代码一般长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">	sz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// initialize dp[u]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=head[u];k;k=e[k].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[k].to; <span class="keyword">if</span>(v==last) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=min(m,sz[u]);++j)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=min(m-j,sz[v]);++k)</span><br><span class="line">				<span class="comment">// dp[u][j] * dp[v][k] -&gt; dp[u][j+k]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免混淆，用$sz$表示已经每个点已经合并上来过的点数，$size$表示每个点的子树大小。</p>
<p>主要的时间开销是在合并$u$和$v$两个点的背包上。分四种情况来讨论：</p>
<ul>
<li>$sz[u] \ge m, size[v] \ge m$<br>一次合并的复杂度为$O(m^2)$。考虑所有的极小的$size \ge m$的子树（即它里面的所有子树的$size$都小于$m$），显然它们两两不相交，所以至多有$\frac{n}{m}$个。此外，这种情况会出现，当且仅当：$u$已经合并过的儿子里有极小的子树，并且$v$里面有极小的子树。故而合并的次数为极小的子树个数 - 1。故而这一部分的复杂度是$O(m^2 \cdot \frac{n}{m}) = O(nm)$</li>
<li>$sz[u] \ge m, size[v] &lt; m$<br>这种情况的复杂度是$O(m\cdot size[v])$，我们考虑求$\sum size[v]$的上界。对于每一个点考虑，它的祖先中，满足$size[x] &lt; m \wedge size[fa_x] \ge m$的点至多只有一个，所以会出现这种情况的$(u,v)$至多只有一个，所以$\sum size[v] = O(n)$，所以这种情况的总复杂度是$O(nm)$。</li>
<li>$sz[u] &lt; m, size[v] \ge m$<br>类似地我们考虑求$\sum sz[u]$的上界。对于$sz[u]$中的每个点考虑，它的祖先中出现这种情况的$u$也至多有一个、并且每个$u$只会出现至多一次这种情况，所以$\sum sz[u] = O(n)$。</li>
<li>$sz[u] &lt; m, size[v] &lt; m$<br>这个时候就是普通的树形背包，对于一整棵大小为$x$的树我们知道这样的复杂度是$O(x^2)$。考虑所有的、极大的$size &lt; m$的子树（即满足$size[fa_x] \ge m$），每一个这样的子树的复杂度是$O(m^2)$，而这样的子树两两不相交，所以至多有$n\over m$个，所以总复杂度为$O(m^2 \cdot \frac{n}{m})$。</li>
</ul>
<p>综上所述，时间复杂度为$O(nm)$。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Stoer-Wagner 算法</title>
    <url>/2022/07/15/Stoer-Wagner-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>求一个任意的无向图的全局最小割。即，定义$\lambda(x,y)$表示$x,y$两点之间的最小割，给出一张任意的无向图，你需要求出$\min_{x\neq y}\lambda(x,y)$。</p>
<h2 id="Stoer-Wagner-算法"><a href="#Stoer-Wagner-算法" class="headerlink" title="Stoer-Wagner 算法"></a>Stoer-Wagner 算法</h2><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>用$w(x,y)$表示$x,y$之间的边权。用$c(X,Y)$表示$\sum_{x\in X,y\in Y} w(x,y)$，其中$X,Y$是图中点集的两个子集。</p>
<p>定义<code>contract(x,y)</code>表示将$x,y$两个点缩起来，具体来说就是新建一个点$u$，对于任意$v\neq x,v\neq y$，令$w(u,v) = w(v,x) + w(v,y)$，然后将$x,y$从原图中删去。</p>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>如果两个点在全局最小割的异侧，那么它们之间的最小割就是全局最小割；否则，将它们缩起来对全局最小割没有影响。</p>
<p>Stoer-Wagner算法的过程是：每一次求出两个点的最小割，然后把它们缩起来。整个算法过程中求出过的最小割的最小值就是全局最小割。</p>
<p>但是这样还是要求$n-1$次最小割。</p>
<h3 id="优化：MinimumCutPhase"><a href="#优化：MinimumCutPhase" class="headerlink" title="优化：MinimumCutPhase"></a>优化：MinimumCutPhase</h3><p>我们并不是需要求某两个点之间的最小割，只要我们求出的是<strong>某两个点</strong>之间的最小割就可以了。</p>
<p>MinimumCutPhase可以在$O(n^2)$的时间内求出某两个点之间的最小割，以下是它的过程：</p>
<ol>
<li>首先随便选择一个点$a$，令$A=\{a\}$。</li>
<li>然后选择一个点不在$A$中的点$x$，使得$c(A,\{x\})$最大，然后将$x$加入$A$。</li>
<li>重复2.直到$A$以外只剩下一个点。则我们最后加入$A$的那个点和剩下的那个点（设为$z$）之间的最小割就是$c(A,\{z\})$。</li>
</ol>
<p>正确性：实际上可以证明，假设加入$A$的点依次为$v_1=a,v_2\cdots v_{n-1}$，令最后剩下的那个点为$v_n$，那么对于任意的$i\ge 2$，在只考虑$v_1,v_2\cdots v_i$以及它们之间的边的时候，$v_i$和$v_{i-1}$之间的最小割是$c(\{v_1,v_2,\cdots v_{i-1}\},\{v_i\})$。</p>
<p>由于$v_i,v_{i-1}$的任意一个割都会删掉$(v_i,v_{i-1})$这条边，所以$\lambda(v_i,v_{i-1})$等于将$(v_i,v_{i-1})$删掉之后求得的最小割$\lambda’(v_i,v_{i-1})$加上$w(v_i,v_{i-1})$。所以接下来只考虑将$(v_i,v_{i-1})$删掉后的图。</p>
<p>首先证明在只考虑$v_1,v_2,\cdots v_i$以及它们之间的边的时候，$c(\{v_1,v_2,\cdots v_{i-1}\},\{v_i\})\le \lambda(v_{i-1},v_{i-2})$。用归纳法。对于$i=2$显然成立。对于$i&gt;2$：</p>
<ul>
<li>将$v_i$以及与$v_i$相邻的所有边从图中删掉，此时$v_{i-1}$和$v_{i-2}$的最小割是$(\{v_1,v_2,\cdots v_{i-2}\},\{v_{i-1}\})$（归纳假设）。</li>
<li>由MinimumCutPhase的过程可以知道<script type="math/tex; mode=display">
c(\{v_1,v_2\cdots v_{i-2}\},\{v_i\}) \le c(\{v_1,v_2,\cdots v_{i-2} \},\{v_{i-1}\}) \tag{1}</script></li>
<li>由于$v_i$和$v_{i-1}$之间没有边，所以<script type="math/tex; mode=display">
c(\{v_1,v_2,\cdots v_{i-2}\},\{v_{i-1}\}) = c( \{v_1,v_2,\cdots v_{i-2},v_i\},\{v_{i-1}\})\\
c(\{v_1,v_2\cdots v_{i-2}\},\{v_i\})= c(\{v_1,v_2\cdots v_{i-2},v_{i-1}\},\{v_i\})</script></li>
<li>将上面的两个式子带入(1)，可以得到<script type="math/tex; mode=display">
c(\{v_1,v_2\cdots v_{i-2},v_{i-1}\},\{v_i\}) \le c(\{v_1,v_2,\cdots v_{i-2},v_i \},\{v_{i-1}\})</script></li>
<li>由于$c(\{v_1,v_2,\cdots v_{i-2},v_i \},\{v_{i-1}\})$等于加入$v_i$这个点之前图中的$v_{i-1},v_{i-2}$的最小割，并且在加入$v_i$之后两个点的最小割不可能变得比加入之前更小，所以$c(\{v_1,v_2,\cdots v_{i-2},v_i \},\{v_{i-1}\})=\lambda(v_{i-1},v_{i-2})$。所以我们得到了<script type="math/tex; mode=display">
c(\{v_1,v_2\cdots v_{i-2},v_{i-1}\},\{v_i\}) \le \lambda(v_{i-1},v_{i-2})</script></li>
</ul>
<p>然后我们将证明，只考虑$v_1,v_2,\cdots v_i$以及它们之间的边的时候，$c(\{v_1,v_2,\cdots v_{i-1}\},\{v_i\})\le \lambda(v_{i},v_{i-2})$。用归纳法。对于$i=2$显然成立。对于$i&gt;2$：</p>
<ul>
<li>删去$v_{i-1}$以及原图中与它相邻的边。对得到的图重新进行MinimumCutPhase，最后加入$A$的点是$v_{i-2}$，剩下的点是$v_i$。</li>
<li>此时$v_i,v_{i-2}$之间的最小割是$c(\{v_1,v_2,\cdots v_{i-2}\},\{v_i\})$。</li>
<li>把$v_{i-1}$加回去之后的图中，得到$\lambda(v_i,v_{i-2}) = c(\{v_1,v_2,\cdots v_{i-2},v_{i-1},v_i\})$。</li>
</ul>
<p>综合以上两个结论：</p>
<script type="math/tex; mode=display">
c(\{v_1,v_2,\cdots v_{i-2},v_{i-1}\},\{v_i\})=\lambda(v_i,v_{i-2})\\
c(\{v_1,v_2\cdots v_{i-2},v_{i-1}\},\{v_i\}) \le \lambda(v_{i-1},v_{i-2}) \\
\Longrightarrow c(\{v_1,v_2,\cdots v_{i-1}\},\{v_i\})\le \min\{\lambda(v_i,v_{i-1}),\lambda(v_{i-1},v_{i-2}\}</script><p>以及</p>
<script type="math/tex; mode=display">
\lambda(x,y) \ge \min \{ \lambda(y,z),\lambda(x,z)\}</script><p>以及</p>
<script type="math/tex; mode=display">
c(\{v_1,v_2,\cdots v_{i-1}\},\{v_i\}) \ge \lambda(v_i,v_{i-1})</script><p>可以得到</p>
<script type="math/tex; mode=display">
c(\{v_1,v_2,\cdots v_{i-1}\},\{v_i\}) = \lambda(v_i,v_{i-1})</script>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Gomory-Hu Tree （最小割树）</title>
    <url>/2022/07/15/Gomory-Hu-Tree-%EF%BC%88%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><h3 id="割-cut"><a href="#割-cut" class="headerlink" title="割 cut"></a>割 cut</h3><p>对于一张带权无向图$G=(V,E)$，定义一个<strong>割 (cut)</strong>为两个集合$S,T\in V$，满足$S\cap T = \emptyset, S\cup T = V$。定义一条边为<strong>割边 (cut edge)</strong>当且仅当它的两个端点分别在$S$集合和$T$集合内。定义一个<strong>割的容量 (capacity of a cut)</strong>为所有的割边的边权的和。</p>
<p>定义<strong>$s-t$割 (s-t cut)</strong>为满足$s\in S,t\in T$的割。</p>
<h3 id="流-flow"><a href="#流-flow" class="headerlink" title="流 flow"></a>流 flow</h3><p>对于一张满足所有的边的容量$c(u,v)$（即$u$到$v$这条边的边权）非负的带权有向图$G=(V,E)$，指定一个<strong>源点 (source)</strong>和<strong>汇点 (sink)</strong>，则定义它的一个<strong>流网络 (flow network)</strong>为一个映射$f:V\times V \to R$，满足以下三个性质：</p>
<ol>
<li>$f(u,v)\le c(u,v)$</li>
<li>$f(u,v)=-f(v,u)$</li>
<li>对于任意$u\not= s, u\not = t$，满足$\sum_{x\in V}f(x,u) = \sum_{x\in V} f(u,x)$</li>
</ol>
<p>最大流问题：找出一个从源点到汇点的可行流，使得该可行流的流量最大。</p>
<h3 id="最大流最小割定理-max-flow-min-cut-theorem"><a href="#最大流最小割定理-max-flow-min-cut-theorem" class="headerlink" title="最大流最小割定理 max-flow min-cut theorem"></a>最大流最小割定理 max-flow min-cut theorem</h3><p>最大流的流量等于最小割的容量。</p>
<h2 id="符号-amp-约定"><a href="#符号-amp-约定" class="headerlink" title="符号 &amp; 约定"></a>符号 &amp; 约定</h2><p>对于$G=(V,E)$，令$W$为$V$的一个子集，$\delta(W)$表示所有恰好有一个端点在$W$以内的的边构成的集合。</p>
<p>则我们也可以用一个满足$s\in W, t\not\in W$的$\delta (W)$来表示一个$s-t$割。我们用$c(W)$表示这个割的容量。</p>
<p>下文中均用$f(u,v)$表示$u,v$的最大流流量（也是最小割容量）。</p>
<h2 id="一些引理"><a href="#一些引理" class="headerlink" title="一些引理"></a>一些引理</h2><h3 id="a"><a href="#a" class="headerlink" title="a)"></a>a)</h3><p>设对于某一张带权图$G$，用$f(u,v)$表示从$u$到$v$的最大流（也等于最小割），则有：$f(u,v) \ge \min \{ f(u,w),f(v,w) \}$。</p>
<h3 id="b-symmetry"><a href="#b-symmetry" class="headerlink" title="b) symmetry"></a>b) symmetry</h3><p>对于任意$W\subseteq V$，有$c(W) = c(\complement_VW)$。</p>
<h3 id="c-submodularity"><a href="#c-submodularity" class="headerlink" title="c) submodularity"></a>c) submodularity</h3><p>对于任意的$A\subseteq V, B \subseteq A, v\in V$，有$c(A \cup \{ v\}) - c(A) \ge c(B\cup\{v\}) - c(B)$。</p>
<p>推广：</p>
<ol>
<li>令$X \subseteq \complement_V A$，则有$ c(A\cup X) -c(A) \ge c(B\cup X)-c(B)$。</li>
<li>对于任意$A,B\subseteq V$，有$c(A) + c(B) \ge c(A\cup B) + c(A\cap B)$。证明：移项得到$c(A) - c(A\cap B) \ge c(A\cup B)- c(B)$，令$U=A\cap B, V=B,X=A\cap \complement_VB$，套用推广1可以得证。</li>
</ol>
<h3 id="d-posimodularity"><a href="#d-posimodularity" class="headerlink" title="d) posimodularity"></a>d) posimodularity</h3><p>对于任意$A\subseteq V,B\subseteq V$，有$c(A) + c(B) \ge c(A - B) +c(B- A)$，这里的$A-B$定义为$A \cap ( \complement_V B)$。</p>
<p>证明：</p>
<script type="math/tex; mode=display">
c(A) +c(B) \\
= c(A) +c(\complement_V B) \\
\ge c(A\cup \complement_VB) + c(A\cap \complement_VB) \\
= c(B \cap \complement_V A ) + c(A-B) \\
= c(B-A) +c(A-B)</script><h3 id="e"><a href="#e" class="headerlink" title="e)"></a>e)</h3><p>令$\delta (W)$为一个$s,t$的最小割，则对于任意$u,v\in W$，存在一个$u,v$最小割$\delta (X)$满足$X\subseteq W$。</p>
<p>证明：</p>
<p>假设$\delta(X)$为一个满足$X,W$有交且不包含的$u,v$最小割。下面不失一般性地只考虑$s\in W,s\in X,u\in X$的情况，因为其它情况都可以通过交换$u,v$或者将$X$变成$\complement_V X$的方式变成$s\in W,s\in X,u\in X$的情况。</p>
<p>情况1：$t\not \in X$。则有$c(W) + c(X) \ge c(W\cup X) + c(W\cap X)$。由于$u\in X,u\in W$而$v\not \in X$，所以$W\cap X$是一个$u,v$割，所以$c(W\cap X) \ge c(X)$。而由于$t\not\in X,t\not \in W$，所以$W\cup X$是一个$s,t$割，所以$c(W\cup X) \ge c(W)$。由此可得$c(W) + c(X) \le c(W\cup X) + c(W\cap X)$，故而$c(W) = c(W\cup X),c(X)=c(W\cap X)$，所以$X\cap W$也是$u,v$的最小割。</p>
<p>情况2：$t\in X$。则有$c(W) + c(X) \ge c(W-X) + c(X-W)$。因为$X-W$是一个$s,t$割，所以$c(X-W) \ge c(W)$；又因为$W-X$是一个$u,v$割，所以$c(W-X) \ge c(X)$。故而得到$c(W-X) = c(X),c(X-W) = c(W)$，所以$W-X$也是$u,v$的最小割。</p>
<p>证毕。    </p>
<h2 id="Gomory-Hu-Tree"><a href="#Gomory-Hu-Tree" class="headerlink" title="Gomory-Hu Tree"></a>Gomory-Hu Tree</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于任意一张图$G$，它的Gomory-Hu tree是一棵生成树$T$，满足$T$中每条边$(u,v)$，设割掉这条边之后得到的其中一个连通块是$P$，则$(u,v)$的边权为$c(P)$，并且$G$中$(u,v)$的最小割为$\delta(P)$。</p>
<h3 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h3><h4 id="a-1"><a href="#a-1" class="headerlink" title="a)"></a>a)</h4><p>我们维护$V$的一个划分$\{ S_1,S_2\cdots S_m\}$和一棵以$\{ S_1,S_2\cdots S_m\}$作为点集的生成树$T$，并用$w’(S_i,S_j)$描述$T$中连接$S_i,S_j$的边的边权。我们要使$T$始终满足：对于任意一条边$(S_i,S_j)$，存在$a\in S_i,b\in S_j$满足$f(a,b) = w’(S_i,S_j)$，并且所对应的最小割割开了$T$上由$(S_i,S_j)$分开的两个子树中的点构成的两个点集。</p>
<p>最初，我们令划分为$\{V\}$。</p>
<p>找出一个$|S_i|\ge 2$的集合，从这个集合中任取两个点$x,y$，求出$x,y$的最小割。考虑这个最小割中包含$x$的点集$X$与包含$y$的点集$Y$，将$S_i$划分成$S_i^x = S_i \cap X$和$S_i^y = S_i\cap Y$，然后考虑原来的$T$中与$S_i$相邻的点集$S_j$，如果$S_j \subseteq X$则让$S_j$与$S_i^x$连边，否则若$S_j \subseteq Y$，就让$S_j$与$S_i^y$连边；根据前面的引理e)，一定存在一个最小割使得$S_j$只与$X,Y$中的一个有交；边的边权为原来的$T$中的$w’(S_i,S_j)$。</p>
<p>实现上，求最小割的时候，考虑$T$中删掉了$S_i$之后得到的那些子树，把每个子树缩成一个点，对于某个点$x$与某个子树，$x$与这棵子树缩成的点之间的边权为$x$与这棵子树的所有点之间的边权的和，这样就可以得到一个满足$S_j$只与$X,Y$中的一个有交的最小割。</p>
<p>这样迭代$n-1$次就可以求出Gomory-Hu Tree。</p>
<h4 id="b"><a href="#b" class="headerlink" title="b)"></a>b)</h4><p>假设现在要求$S$这个点集的Gomory-Hu tree。任意选择两个点$x,y\in S$，求出$x,y$的最小割$\delta(X)$。在$x,y$之间建边权为$c(X)$的边，然后将$S$分为$X$和$\complement_S X$，递归下去求解即可。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>考虑$x,y$两个点以及它们在$T$上的路径经过的点$\{p_1,p_2\cdots p_k\}$。</p>
<p>由于引理a)，我们有$f(x,y) \ge \min \{ f(x,p_1),f(p_1,p_2) \cdots f(p_{k-1},p_k),f(p_k,y)\}$，也即是说$f(x,y)$大于等于它们在$T$的路径上的边权最小值。</p>
<p>另一方面，根据定义，$T$上将$T$的点集分成$P$和$\complement_V P$两部分的那条边，其边权等于$c(P)$。所以，$x$到$y$的路径上的每一条边所对应的割都是$x-y$割，所以$x,y$的最小割可以达到$\min\{ f(x,p_1),f(p_1,p_2) \cdots f(p_{k-1},p_k),f(p_k,y)\}$。</p>
<p>故而，$G$中任意两点的最小割等于它们在$T$之间的路径上的边权最小值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.corelab.ntua.gr/seminar/material/2008-2009/2008.10.20.Gomory-Hu%20trees%20and%20applications.slides.pdf" target="_blank" rel="noopener">1</a> <a href="https://courses.engr.illinois.edu/cs598csc/sp2010/Lectures/Lecture6.pdf" target="_blank" rel="noopener">2</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dinic算法的复杂度分析</title>
    <url>/2022/07/15/Dinic%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一般图"><a href="#一般图" class="headerlink" title="一般图"></a>一般图</h2><p>复杂度主要取决于dfs增广的过程。</p>
<p>将dfs部分的复杂度分成两部分来分析：1）修改增广路上边的流量。至多会增广$m$次，一条增广路的长度至多是$n$，所以这一部分的复杂度是$O(nm)$。2）dfs遍历时找增广路失败时经过的边。由于一旦从某条边出发找最短路失败了，我们就不会再走那条边（当前弧优化），所以这一部分的复杂度是$O(m)$的。故而dfs增广的复杂度是$O(nm)$。</p>
<p>而由于每一次重新建分层图，残余网络上$s$到$t$的最短路长度一定会增加，所以至多重建$n-1$次图。</p>
<p>故dinic的运行时间上界为$O(n^2m)$。</p>
<h2 id="单位图-unit-graph"><a href="#单位图-unit-graph" class="headerlink" title="单位图 (unit graph)"></a>单位图 (unit graph)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>单位图(unit graph)</strong> 是指，所有的边的容量都是整数，且每一个不是$s$或$t$的点，要么出度为$1$，连出去的边容量为$1$，要么入度为$1$，连进来的边容量为$1$。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>在单位图上，至多进行$2\lceil \sqrt {n-2}\rceil$次dfs增广。</p>
<p>考虑某一次dfs增广时，现在已经得到了的流为$f$，最大流为$f^<em>$，$R$为$f$的残留网络。则$f^</em> - f$是$R$上的一个流，并且$R$是单位图。我们必然可以将$f^<em> - f$上容量为$1$的边划分成$|f^</em>| - |f|$条从$s$到$t$的路径（可能还有一些环）。由于$R$是单位图，所以除了$s,t$以外的任意一个点至多属于一条路径，所以最短路径的长度至多为${n-2\over |f^*|-|f|} + 1$。</p>
<p>经过$\lceil\sqrt {n-2}\rceil$次dfs增广之后，最短路的长度至少是$\sqrt{n-2} + 1$，所以$\sqrt{n-2} + 1 \le {n-2\over |f^<em>|-|f|} + 1$，所以$|f</em>| - |f| \le \sqrt{n-2}$，所以至多再进行$\sqrt{n-2}$次增广就可以结束算法。</p>
<p>所以单位图上Dinic的复杂度为$O(nm\sqrt n)$。</p>
<p>参考资料：Tarjan, R.E. Data structures and network algorithms. 1983. Page 102.</p>
<h2 id="边的容量为-1-的图"><a href="#边的容量为-1-的图" class="headerlink" title="边的容量为$1$的图"></a>边的容量为$1$的图</h2><p>对于边的容量为$1$的图，Dinic至多进行$O(\min\{n^{2\over 3},m^{1\over 2}\})$次dfs增广。</p>
<h3 id="a-dfs增广次数不超过-O-n-2-over-3"><a href="#a-dfs增广次数不超过-O-n-2-over-3" class="headerlink" title="a) dfs增广次数不超过$O(n^{2\over 3})$"></a>a) dfs增广次数不超过$O(n^{2\over 3})$</h3><blockquote>
<p>Lemma 3：给出一张边容量为$1$的图，设最大流为$M$，则残余网络的从$s$到$t$的最短路的长度至多是$2n\over \sqrt M$。<br>证明：设最短路的长度为$l$，从$s$到它的最短路长度为$i$的点集是$V_i$，则$|V_i| \cdot |V_{i+1}| \ge M$，所以$|V_i|\ge \sqrt M$或者$|V_{i+1}| \ge \sqrt M$。又因为$\sum |V_i| = n$，所以$\lfloor {l+1\over 2}\rfloor \cdot \sqrt M \le n$。所以有$l \le {2n\over \sqrt M}$。</p>
</blockquote>
<p>Dinic算法的过程中，当已经得到的流量$F$其大小不到$M - n^{2\over 3}$时，残余网络的最大流至少为$M-F=n^{2\over 3}$，残余网络的最短路的长度$l\le {2n \over \sqrt{n^{2\over 3}}} = 2n^{2\over 3}$。所以在$F\le M-n^{2\over 3}$的时候至多进行$O(n^{2\over 3})$次dfs增广。当$F&gt;M-n^{2\over 3}$的时候，残余网络的最大流不超过$n^{2\over 3}$，至多进行$n^{2\over 3}$次dfs增广。故进行dfs增广的次数上界是$O(n^{2\over 3})$。</p>
<h3 id="b-dfs增广次数不超过-O-m-1-over-2"><a href="#b-dfs增广次数不超过-O-m-1-over-2" class="headerlink" title="b) dfs增广次数不超过$O(m^{1\over 2})$"></a>b) dfs增广次数不超过$O(m^{1\over 2})$</h3><p>与前面单位图的证明类似，可以将$f^<em> - f$中的边划分成$|f^</em>|-|f|$条不相交的路径，由于每条边至多属于一条路径，所以路径长度的最小值不大于$m\over |f^<em>|-|f|$。经过$\sqrt m$次Dinic增广以后，路径的长度不小于$\sqrt m$，所以$\sqrt m \le {m\over |f^</em>| - |f|}$，所以$|f^*|-|f|\le \sqrt m$，所以至多再增广$\sqrt m$次就可以结束。</p>
<p>所以在边的容量为$1$的图中，Dinic算法的复杂度为$O(\min\{n^{2\over 3},m^{1\over 2} \}\cdot nm)$</p>
<p>参考资料：Even, Shimon; Tarjan, R. Endre. Network Flow and Testing Graph Connectivity. SIAM Journal on Computing. 1975, 4 (4): 507–518</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>稳定婚姻问题</title>
    <url>/2022/07/15/%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有$n$个男生和$n$个女生，有$2n$个排列$p_1,p_2\cdots p_n,q_1,q_2\cdots q_n$，$p_i$代表第$i$个男生的喜好（$p_{i,1}$表示他最喜欢的女生，$p_{i,2}$是他第二喜欢的，以此类推），$q_i$代表第$i$个女生的喜好。</p>
<p>稳定婚姻问题即，求一个男生和女生的完美匹配$M$，使得不存在$(x,y)\not\in M$，$x$对$y$的好感高于$x$现在的配偶且$y$对$x$的好感高于$y$现在的配偶。</p>
<h2 id="Gale–Shapley算法"><a href="#Gale–Shapley算法" class="headerlink" title="Gale–Shapley算法"></a>Gale–Shapley算法</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>迭代进行以下过程$n$次：</p>
<ul>
<li>对于每一个没有订婚的男生，让他向他<strong>目前还没有求爱过</strong>的女生中他最喜欢的那个求爱（不管那个女生是否已经订婚）。然后，每一个女生在这一轮向她求爱的男生以及她原来的配偶中，选择一个她最有好感的，作为她现在的配偶。可能会出现女生和原来配偶撕约的情况，但是被撕约了的男生将加入下一轮的求爱。</li>
</ul>
<h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>求出来的肯定是一个匹配，并且是完美匹配，因为只要一个女生被求过爱，之后就不可能单身了。</p>
<p>整个过程中，女生的配偶会越来越好，而男生的配偶会越来越差。所以当算法结束的时候，对于每个男生，比他现在的配偶更好的女生的配偶一定都比他好。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>迭代$n$次，每次复杂度$O(n)$，总时间复杂度$O(n^2)$。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦纳树</title>
    <url>/2022/07/15/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>有一张无向图$(V,E)$，指定了一个$V$的子集$S$，需要求出一个边集$E’$，使得：</p>
<ul>
<li>对于任意两个点$x,y\in S$，存在一条从$x$到$y$的、由$E’$中的边组成的路径（路径可以经过不在$S$中的点）。</li>
<li>在此基础上，最小化$E’$中所有的边的边权和。</li>
</ul>
<p>显然$E’$会组成一棵树。称这棵树为斯坦纳树。</p>
<h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><p>考虑状态压缩$dp$：$f[u][s]$表示$s$集合中的点和$u$点已经连通，所需要的最小的花费。其中$u$是$V$中的任意一个点，而$s$是$S$的子集。</p>
<p>更新有两种：</p>
<ul>
<li>将和$u$连通的两个连通块合并起来：$f[u][s] =  \min \{ f[u][t] + f[u][s-t]\}$</li>
<li>扩展到另一个不在$S$中的点：$f[v][s] = \min \{ f[u][s] + e[u][v] \}$</li>
</ul>
<p>首先从小到大枚举$s$，然后对于每个$s$计算所有的$f[u][s]$。先枚举第一种转移（用更小的$s$来更新当前的$s$）；然后考虑第二种转移：实际上是最短路的形式，可以用spfa或者dijkstra解决。</p>
<p>时间复杂度$O( n 3^{|S|} + nm2^{|S|} )$。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>hdu4085</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> d[N][N],n,m,K;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">1</span>&lt;&lt;<span class="number">10</span>],g[<span class="number">1</span>&lt;&lt;<span class="number">10</span>],vid[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u=que.front(); que.pop(),vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;++v)</span><br><span class="line">			<span class="keyword">if</span>(f[v][c]&gt;f[u][c]+d[u][v]) &#123;</span><br><span class="line">				f[v][c]=f[u][c]+d[u][v];</span><br><span class="line">				<span class="keyword">if</span>(!vis[v]) que.push(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T; rd(T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		rd(n),rd(m),rd(K);</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x,y,w,i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">			rd(x),rd(y),rd(w);</span><br><span class="line">			d[x][y]=min(d[x][y],w);</span><br><span class="line">			d[y][x]=min(d[y][x],w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(vid,<span class="number">0</span>,<span class="keyword">sizeof</span>(vid));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;++i) vid[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n-K+<span class="number">1</span>;i&lt;=n;++i) vid[i]=K+(n-i+<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vid[i]) f[i][<span class="number">1</span>&lt;&lt;vid[i]<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">			f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;(K*<span class="number">2</span>));++s) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> t=s&amp;(s<span class="number">-1</span>);t;t=(t<span class="number">-1</span>)&amp;s)</span><br><span class="line">					f[i][s]=min(f[i][s],f[i][t]+f[i][s^t]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">				<span class="keyword">if</span>(f[i][s]&lt;<span class="number">1e7</span>) que.push(i),vis[i]=<span class="number">1</span>;</span><br><span class="line">			spfa(s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;(K*<span class="number">2</span>));++s) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;++i) <span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)) cnt1++;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=K+<span class="number">1</span>;i&lt;=<span class="number">2</span>*K;++i) <span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)) cnt2++;</span><br><span class="line">			<span class="keyword">if</span>(cnt1!=cnt2) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) g[s]=min(g[s],f[i][s]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*K));++s)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> t=s&amp;(s<span class="number">-1</span>);t;t=(t<span class="number">-1</span>)&amp;s)</span><br><span class="line">				g[s]=min(g[s],g[t]+g[s^t]);</span><br><span class="line">		<span class="keyword">int</span> ans=g[(<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*K))<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(ans&gt;<span class="number">1e7</span>) <span class="built_in">printf</span>(<span class="string">"No solution\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hall&#39;s marriage theorem</title>
    <url>/2022/07/15/Hall-s-marriage-theorem/</url>
    <content><![CDATA[<h2 id="Hall’s-marriage-theorem"><a href="#Hall’s-marriage-theorem" class="headerlink" title="Hall’s marriage theorem"></a>Hall’s marriage theorem</h2><h3 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h3><p>这个定理是说，对于任意一个二分图$G=\{ X+Y,E\}$，都有：<br>$\forall W \subset X, |W|\le |N_G(W)| \Longleftrightarrow |M|=|X|$<br>其中，$N_G(W)$表示$Y$中与$W$中的点相邻的点的集合，$M$表示最大匹配。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>（来自wikipedia）：<br><img src="https://i.loli.net/2019/08/21/REMjOf96rWxuy3Z.png" alt="捕获.PNG"></p>
<p>必要性：如果存在一个$W\subset X$满足$|W|&gt;|N_G(W)|$，那么由于$W$中的每一个点都必须和$N_G(W)$中的点匹配，每个点又至多和一个点匹配，所以一定不存在完备匹配。</p>
<p>充分性：证明其充分性，只需要证明不存在一个张二分图$G(X+Y,E)$，$G$不存在完备匹配并且满足$\forall W\subset X, |W|\le |N_G(W)|$。考虑某个不在最大匹配中的点$u$，找出一条从它出发的交错路，记交错路上在$X$中的集合中的点组成的集合为$W$，记交错路上在$Y$集合的点组成的集合为$Z$。显然交错路是以一个$X$中的点结尾的，否则这就是一条增广路，与$u$不在最大匹配中矛盾。所以，$|W| = |Z|+1$，并且$W$中除了$u$以外的任意一个点，在$Z$中都有它的匹配。并且，$W$中没有点与$Y$中不在最大匹配中的点相邻，因为如果有的话，就可以继续增广，与$u$不在最大匹配中矛盾。所以$Z=N_G(W)$，所以$|W|&gt;|N_G(W)|$。充分性得证。</p>
<h2 id="一个推论"><a href="#一个推论" class="headerlink" title="一个推论"></a>一个推论</h2><h3 id="推论内容"><a href="#推论内容" class="headerlink" title="推论内容"></a>推论内容</h3><p>二分图的最大匹配$|M|=|X|-\max\{|W|-|N_G(W)|\}$。</p>
<h3 id="推论证明"><a href="#推论证明" class="headerlink" title="推论证明"></a>推论证明</h3><p>记$|W|-|N_G(W)|$取到最大值的$W$为$W_0$。</p>
<p>1）证明$|M|\le |X| - \max \{ |W| - |N_G(W)|\} $</p>
<p>$W_0$中至少有$|W_0|-|N_G(W_0)|$个点不能在最大匹配中，得证。</p>
<p>2）证明$|M|\ge |X| - \max \{ |W| - |N_G(W)| \} $</p>
<p>考虑新建$|W_0|-|N_G(W_0)|$个点，这些点都属于$Y$集合，与$X$中的每个点之间都有边相连，记此时的图为$G’$。$G’$显然满足$\forall W\subset X,|W|\le |N_G(W)|$，所以$G’$存在完备匹配。把新加入的点和它们在$X$中对应的点去掉，就得到了$G$的一个大小为$|X|- (|W_0|-|N_G(W_0)|$的匹配。所以$|M|\ge |X| - \max \{ |W| - |N_G(W)| \}$。</p>
<p>3）综上所述，我们有$|M| = |X| - \max \{|W| - |N_G(W)|\}$</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>arc076F Exhausted?<br>agc037D Sort a grid</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/cly-none/p/Hall_Theorem.html" target="_blank" rel="noopener">一篇博客</a><br><a href="https://en.wikipedia.org/wiki/Hall%27s_marriage_theorem" target="_blank" rel="noopener">wiki</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>三元环计数和四元环计数</title>
    <url>/2022/07/15/%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="三元环计数"><a href="#三元环计数" class="headerlink" title="三元环计数"></a>三元环计数</h2><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><pre><code>1.将无向边改成有向边，令度数大的点指向度数小的点；如果度数相同，就让编号大的点指向编号小的点。（这一步也可以是，度数小的点指向度数大的点；度数相同比较编号）
2.枚举一个点u。
3.标记所有u的出边可以到达的点。
4.枚举一个u的出边可以到达的点v，然后再枚举一个v的出边可以到达的点w，如果w被标记过，说明u,v,w构成三元环，ans++
</code></pre><h3 id="正确性-amp-复杂度"><a href="#正确性-amp-复杂度" class="headerlink" title="正确性 &amp; 复杂度"></a>正确性 &amp; 复杂度</h3><p>改成有向边之后，这一定是一个拓扑图，每个三元环的边一定形如 a-&gt;b, b-&gt;c, c-&gt;a ，所以每一个三元环会被恰好统计一次。</p>
<p>现在考虑复杂度。</p>
<p>度数大的点连向度数小的点的那种方法我不会证明复杂度，听说是$O(m\sqrt m)$。</p>
<p>度数小的连向度数大的那种方法是$O(m\sqrt m)$，因为我们可以证明每个点的出度是$O(\sqrt m)$的。下面我们称度数大于$\sqrt m$的为大度点，度数小于$\sqrt m$的为小度点。大度点显然不超过$\sqrt m$个，大度点的出边只能够连向大度点，所以大度点的出度至多是$\sqrt m$的；小度点在原图中的度不超过$\sqrt m$，所以给边定向后出度一定不超过$\sqrt m$。综上，所有的点的出度都是$O(\sqrt m)$的。在上面的算法中，我们先要枚举$u\to v$（也就是枚举一条边），然后枚举$v$的出度，这样的复杂度是$O(m\sqrt m)$的。</p>
<p>此外我们的算法过程中<strong>枚举到了</strong>每一个三元环，因此可以得到所有的三元环对应的点和边。</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>hdu6184</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span> &#123;</span> <span class="keyword">int</span> x,y,id; &#125;e[M];</span><br><span class="line"><span class="built_in">vector</span>&lt;ed&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> n,m,vis[N],ans[M];</span><br><span class="line"><span class="keyword">int</span> du[N];</span><br><span class="line"><span class="function">ll <span class="title">id</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">if</span>(x&gt;y) swap(x,y); <span class="keyword">return</span> (x<span class="number">-1</span>)*n+y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x,y; rd(x),rd(y);</span><br><span class="line">			e[i].x=x,e[i].y=y,e[i].id=i;</span><br><span class="line">			du[x]++,du[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x=e[i].x,y=e[i].y;</span><br><span class="line">			<span class="keyword">if</span>(du[x]&lt;du[y]||(du[x]==du[y]&amp;&amp;x&lt;y)) swap(e[i].x,e[i].y),swap(x,y);</span><br><span class="line">			G[x].PB(e[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;++u) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) vis[G[u][i].y]=G[u][i].id;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) &#123;</span><br><span class="line">				<span class="keyword">int</span> v=G[u][i].y;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G[v].size();++j) &#123;</span><br><span class="line">					<span class="keyword">int</span> w=G[v][j].y;</span><br><span class="line">					<span class="keyword">int</span> k=vis[w];</span><br><span class="line">					<span class="keyword">if</span>(k) &#123;</span><br><span class="line">						ans[k]++;</span><br><span class="line">						ans[G[u][i].id]++;</span><br><span class="line">						ans[G[v][j].id]++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) vis[G[u][i].y]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) tot+=ans[i]*(ll)(ans[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tot);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) G[i].clear(),du[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) ans[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四元环计数"><a href="#四元环计数" class="headerlink" title="四元环计数"></a>四元环计数</h2><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><pre><code>1.枚举一个u作为四元环中编号最大的点。
2.依次枚举与u相邻的一个点v，然后枚举一个与v相邻的点w。我们记cnt[w]表示在v之前w被访问过多少次。那么每一次访问到w的时候，就ans+=cnt[w],cnt[w]++。
3.枚举完这个u之后，把所有的cnt[w]清零。注意w,v的编号必须小于u。这里，如果我们把所有的点按照度数重新标号之后，可以证明复杂度是 O(m\sqrt m) 的。
</code></pre><p>重新标号可以是度数越大编号越小，也可以是度数越小编号越小。</p>
<p>复杂度证明不会。</p>
<p>和三元环计数不同的是，我们并没有枚举出四元环上的每一个点。</p>
<h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><p>jzoj6199</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u=id[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;E[u].size();++j) &#123;</span><br><span class="line">			<span class="keyword">int</span> v=E[u][j];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;E[v].size();++k) &#123;</span><br><span class="line">				<span class="keyword">int</span> w=E[v][k]; <span class="keyword">if</span>(w==u) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//				printf("%d %d %d %d\n",u,v,w,vis[w]);</span></span><br><span class="line">				ans3+=vis[w],vis[w]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;E[u].size();++j) &#123;</span><br><span class="line">			<span class="keyword">int</span> v=E[u][j];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;E[v].size();++k) &#123;</span><br><span class="line">				<span class="keyword">int</span> w=E[v][k]; <span class="keyword">if</span>(w==u) <span class="keyword">continue</span>;</span><br><span class="line">				vis[w]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=head[u];~k;k=e[k].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> v=e[k].to;</span><br><span class="line">			E[v].PB(u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树上路径的交</title>
    <url>/2022/07/15/%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BA%A4/</url>
    <content><![CDATA[<p>两条路径$u_1\to v_1,u_2\to v_2$的交这样计算：</p>
<ul>
<li>首先计算出$x_1=lca(u_1,u_2),x_2=lca(v_1,v_2),x_3=lca(u_1,v_2),x_4=lca(v_1,u_2)$，然后取这四个点中深度最大的两个点$y_1,y_2$。</li>
<li>若$y_1=y_2$，且$y_1$的深度大于了$lca(u_1,v_1)$或者$lca(u_2,v_2)$的深度，那么交不存在；否则，交就是$y_1$到$y_2$之间的路径。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Road中的t：t=0表示空集，t=-1表示全集，t=1表示u到v的路径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Road</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,t;</span><br><span class="line">	Road(<span class="keyword">int</span> u=<span class="number">0</span>,<span class="keyword">int</span> v=<span class="number">0</span>,<span class="keyword">int</span> t=<span class="number">-1</span>): u(u),v(v),t(t)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_dep</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dep[x]&gt;dep[y]; &#125;</span><br><span class="line"><span class="function">Road <span class="title">Inter</span><span class="params">(Road A,Road B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.t==<span class="number">0</span>||B.t==<span class="number">0</span>) <span class="keyword">return</span> Road(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(A.t==<span class="number">-1</span>) <span class="keyword">return</span> B;</span><br><span class="line">	<span class="keyword">if</span>(B.t==<span class="number">-1</span>) <span class="keyword">return</span> A;</span><br><span class="line">	<span class="keyword">int</span> tmp[<span class="number">4</span>]=&#123;LCA(A.v,B.v),LCA(A.u,B.u),LCA(A.v,B.u),LCA(A.u,B.v)&#125;;</span><br><span class="line">	sort(tmp,tmp+<span class="number">4</span>,cmp_dep);</span><br><span class="line">	<span class="keyword">if</span>(tmp[<span class="number">0</span>]==tmp[<span class="number">1</span>]&amp;&amp;(dep[tmp[<span class="number">0</span>]]&lt;dep[LCA(A.u,A.v)]||dep[tmp[<span class="number">0</span>]]&lt;dep[LCA(B.u,B.v)]))</span><br><span class="line">		<span class="keyword">return</span> Road(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> Road(tmp[<span class="number">0</span>],tmp[<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Onchain</span><span class="params">(Road A,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.t==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(A.t==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(A.t==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp[<span class="number">2</span>]=&#123;LCA(A.u,x),LCA(A.v,x)&#125;;</span><br><span class="line">	<span class="keyword">if</span>(dep[tmp[<span class="number">0</span>]]&lt;dep[tmp[<span class="number">1</span>]]) swap(tmp[<span class="number">0</span>],tmp[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span>(tmp[<span class="number">0</span>]==x&amp;&amp;tmp[<span class="number">1</span>]==LCA(A.u,A.v)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>朱刘算法</title>
    <url>/2022/07/15/%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>这个算法用于求解有向图的最小树形图问题。</p>
<p>树形图：图中有一个点作为根，除了根以外，每个点的入度恰好为$1$，并且从根出发可以到达整个图中的任意一个点。</p>
<p>最小树形图就是所有边的边权和最小的树形图。</p>
<hr>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>1）对于图中所有的不为根的点，我们钦定图中连向它的、边权最小的边，作为它的入边。设由所有点以及我们钦定的入边构成的图为$G’$。<br>2）如果$G’$中不存在环，那么$G’$就是我们要的最小树形图。否则，我们直接把环上的点缩成一个点。把$G’$中，所有边的边权修改为：这条边原来的边权 - 我们在第一步中给这条边的终点钦定的边的边权（这一步相当于是给这个贪心一个反悔的机会）。然后重复1），直到图中没有环。</p>
<p>我们最后得到的那个最小树形图，上面的边一定都在原图的最小树形图中。我们找出这张图上我们缩的点，把他们展开，并保留与终点在最终的图中没有入度的边。这样就可以得到原图的最小树形图。</p>
<hr>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>每一次执行2）的时候，我们至少会让图中的点数$-1$，因此我们至多会执行$n$次1）2）。考虑到1）2)的复杂度是$O(n+m)$的，其中$m$大于$n$，所以我们的总复杂度是$O(nm)$的。</p>
<hr>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>poj3164</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">	db x,y;</span><br><span class="line">	Point(db x=<span class="number">0</span>,db y=<span class="number">0</span>): x(x),y(y) &#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> Point <span class="keyword">operator</span> -(Point A,Point B) &#123; <span class="keyword">return</span> Point(A.x-B.x,A.y-B.y); &#125;</span><br><span class="line">	<span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y); &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span><span class="keyword">int</span> u,v; db w;&#125;E[M];</span><br><span class="line"><span class="keyword">int</span> vis[N],pre[N],bel[N],n,m,rt;</span><br><span class="line">db cost[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMST</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	db ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) vis[i]=<span class="number">0</span>,pre[i]=<span class="number">-1</span>,cost[i]=<span class="number">1e100</span>,bel[i]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">			<span class="keyword">if</span>(E[i].v==rt) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(E[i].u==E[i].v) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(cost[E[i].v]&gt;E[i].w)</span><br><span class="line">				cost[E[i].v]=E[i].w,pre[E[i].v]=E[i].u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==rt) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(pre[i]==<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"poor snoopy\n"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans+=cost[i];</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;rt&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		for(int i=1;i&lt;=n;++i) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;pre[i]&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,v,x;i&lt;=n;++i) <span class="keyword">if</span>(i!=rt&amp;&amp;!vis[i]) &#123;</span><br><span class="line">			vis[i]=i;</span><br><span class="line">			<span class="keyword">for</span>(v=pre[i];!vis[v]&amp;&amp;v!=rt;v=pre[v])</span><br><span class="line">				vis[v]=i;</span><br><span class="line">			<span class="keyword">if</span>(vis[v]!=i) <span class="keyword">continue</span>;</span><br><span class="line">			++cnt; bel[v]=cnt;</span><br><span class="line">			<span class="keyword">for</span>(x=pre[v];x!=v;x=pre[x]) bel[x]=cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(bel[i]==<span class="number">-1</span>) bel[i]=++cnt;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">			<span class="keyword">while</span>(i&lt;=m&amp;&amp;bel[E[i].u]==bel[E[i].v]) &#123;</span><br><span class="line">				swap(E[i],E[m]),m--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;m) <span class="keyword">break</span>;</span><br><span class="line">			E[i].w-=cost[E[i].v];</span><br><span class="line">			E[i].u=bel[E[i].u],E[i].v=bel[E[i].v];</span><br><span class="line">		&#125;</span><br><span class="line">		n=cnt,rt=bel[rt];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2Lf\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">		rt=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%Lf%Lf"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;E[i].u,&amp;E[i].v);</span><br><span class="line">			E[i].w=(p[E[i].u]-p[E[i].v]).dis();</span><br><span class="line">		&#125;</span><br><span class="line">		DMST(n,m,rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理 CRT</title>
    <url>/2022/07/15/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-CRT/</url>
    <content><![CDATA[<p>问题：有$n$个这样形式的方程组：$x\equiv c_i\mod m_i$。求通解和最小解。</p>
<h2 id="一般的做法"><a href="#一般的做法" class="headerlink" title="一般的做法"></a>一般的做法</h2><p>考虑如何合并</p>
<script type="math/tex; mode=display">
\begin{cases}
x \equiv c_1\mod m_1\\
x \equiv c_2 \mod m_2\\
\end{cases}</script><p>我们设</p>
<script type="math/tex; mode=display">
x=c_1+k_1m_1 = c_2 + k_2m_2</script><p>即</p>
<script type="math/tex; mode=display">
k_1m_1-k_2m_2  = c_2 - c_1</script><p>用扩展欧几里得解出$k_1$即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRT</span><span class="params">(ll *c,ll *m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ll x,y,g=exgcd(m[<span class="number">0</span>],m[i],x,y);</span><br><span class="line">		ll tmp=m[i]/g,M=lcm(m[<span class="number">0</span>],m[i]);</span><br><span class="line">		x=(Mul(x,(c[i]-c[<span class="number">0</span>])/g,tmp)+tmp)%tmp;</span><br><span class="line">		c[<span class="number">0</span>]=(c[<span class="number">0</span>]+Mul(x,m[<span class="number">0</span>],M))%M,m[<span class="number">0</span>]=M;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，扩展欧几里得通解的最小间隔是$m_2\over gcd(m_1,m_2)$。</p>
<hr>
<h2 id="m-i-两两互质或者可以预处理欧拉函数"><a href="#m-i-两两互质或者可以预处理欧拉函数" class="headerlink" title="$m_i$两两互质或者可以预处理欧拉函数"></a>$m_i$两两互质或者可以预处理欧拉函数</h2><p>以下两种做法，仅适用于$m_i$两两互质或者可以预处理欧拉函数的情况：</p>
<h3 id="一个比较通用的方法"><a href="#一个比较通用的方法" class="headerlink" title="一个比较通用的方法"></a>一个比较通用的方法</h3><p>考虑将两个方程$x\equiv b_1\mod m_1$与$x\equiv b_2 \mod m_2$合并。</p>
<p>由欧拉定理得</p>
<script type="math/tex; mode=display">
m_2^{\varphi (m_1)}\equiv 1 \ mod \ m_1\\
\therefore b_1m_2^{\varphi(m_1)}\equiv b_1\ mod\ m_1\\
\because m_1\equiv 0 \ mod \ m_1\\
\therefore b_2m_1^{\varphi(m_2)}\equiv 0\ mod \ m_1\\
\therefore b_1m_2^{\varphi(m_1)}+b_2m_1^{\varphi(m_2)}\equiv b_1\ mod \ m_1</script><p>同理可证</p>
<script type="math/tex; mode=display">b_1m_2^{\varphi(m_1)}+b_2m_1^{\varphi(m_2)}\equiv b_2\ mod \ m_2</script><p><del>发现这两个方程长的像原来的方程组</del></p>
<p>得到：</p>
<script type="math/tex; mode=display">x\equiv b_1m_2^{\varphi(m_1)}+b_2m_1^{\varphi(m_2)}\ mod \ ( lcm(m_1,m_2))</script><p>将所有的方程组依次合并即可。</p>
<h3 id="一个只适用于-prod-m-i-不会超出unsigned-long-long-范围的方法"><a href="#一个只适用于-prod-m-i-不会超出unsigned-long-long-范围的方法" class="headerlink" title="一个只适用于$\prod m_i$不会超出unsigned long long 范围的方法"></a>一个只适用于$\prod m_i$不会超出unsigned long long 范围的方法</h3><p>我们如果把所有的方程组合并完，可以得到：</p>
<script type="math/tex; mode=display">
M=\prod m_i\\
x= \sum c_i\times ({M\over m_i})^{\varphi(m_i)}</script><p>模数自然是$lcm(m_1,m_2,\dots m_n)$</p>
<p>这样合并的话，考虑将合并过后的结果带回原来的方程组，对于$c_i$的这一项，当模数是$m_i$时，$({M\over m_i})^{\varphi(m_i)}\equiv 1$；当模数不为$m_i$的时候$({M\over m_i})^{\varphi(m_i)}\equiv 0$。那么这个通解的正确性也是显然的了。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>其实求$x^{\varphi(m_i)}$的过程相当于求$x$与$x$在模$m_i$意义下的逆元的乘积，所以我们可以把这个计算过程换成扩展欧几里得。但是，这样做的前提是，$m_i$两两互质。</p>
<hr>
<h3 id="为什么模数是-lcm-m-1-m-2-cdots-m-n"><a href="#为什么模数是-lcm-m-1-m-2-cdots-m-n" class="headerlink" title="为什么模数是$lcm(m_1,m_2\cdots m_n)$"></a>为什么模数是$lcm(m_1,m_2\cdots m_n)$</h3><p>证明通解一定是$x\equiv c\mod lcm(m_1,m_2\cdots m_n)$的形式，本质就是要证明：相邻的两个解之间的差恰好为$lcm(m_1,m_2\cdots m_n)$。</p>
<p>考虑只有两个模数的情况（其他可以类似推出），若$x\equiv c_1\mod m_1$，那么$\cdots c_1-m_1,c_1,c_1+m_1,c_1+2m_1\cdots $对第一个方程来说，都是可行的$x$。因此对第一个方程可行的$x$恰好每$m_1$个数中就有一个，即解之间的间隔为$m_1$。而第二个方程的解的间隔是$m_2$。假若合并得到的是$x\equiv c$，那么$c$一定既是第一个方程的可行解，又是第二个方程的可行解。假设另一个解是$x’$，那么一定有$m_1|x-x’$并且$m_2|x-x’$，也就是说解的间隔是$m_1,m_2$的公倍数，所以解之间的最小间隔就是$lcm(m_1,m_2)$。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>原根 primitive root</title>
    <url>/2022/07/15/%E5%8E%9F%E6%A0%B9-primitive-root/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于某一个$g\in [0,p)$，如果对于$\{0,1,\cdots p-1\}$中每一个与$p$互质的数$x$，都存在一个$k$使得$g^k \equiv x \mod p$，那么就称$g$是$p$的一个原根。也就是说，$g^0,g^1,\cdots g^{\varphi (n) - 1}$在模$n$的意义下两两不同。</p>
<hr>
<h3 id="检测一个数是否为-p-的原根"><a href="#检测一个数是否为-p-的原根" class="headerlink" title="检测一个数是否为$p$的原根"></a>检测一个数是否为$p$的原根</h3><p>现在还没有快速的计算一个数的原根的算法。但是，我们有一种比较快的检测一个数是否为$p$的原根的方法。</p>
<h4 id="阶-multiplicative-order"><a href="#阶-multiplicative-order" class="headerlink" title="阶 multiplicative order"></a>阶 multiplicative order</h4><p>在模$p$的意义下，定义某个满足$gcd(a,p) = 1$的$a$的阶为，满足$a^k \equiv 1\mod p$的最小正整数$k$，记为$\delta_p(a)$。</p>
<p>阶有一些性质：<br>1）如果$a^N \equiv 1 \mod p$，那么$N$一定是$a$的阶的倍数。并且，根据欧拉定理，$N$一定是$\varphi(p)$的因数。<br>2）原根的阶等于$\varphi(p)$。</p>
<p>容易推出，对于一个$x$，如果它不是$p$的原根，那么他的阶一定小于$\varphi(p)$并且是$\varphi(p)$的因数。我们只需要对于$\varphi(p)$的每一个因数$d$，判断$x^d \equiv 1\mod p$是否成立就好了。实际上，由于阶的性质，我们处理出$\varphi(p)$的所有质因子$pr_1,pr_2\cdots pr_k$，然后判断$x^{\varphi (p)\over pr_i}\equiv 1\mod p$是否成立，就可以判断$x$是不是原根。因为如果$x$的阶小于$\varphi(p)$，那么${\varphi(p)\over pr_i}$中，至少有一个是$\delta_p (x) $的倍数。</p>
<p>这个检测的复杂度应该是$O(\sqrt p \log p)$的。</p>
<hr>
<h3 id="求最小原根"><a href="#求最小原根" class="headerlink" title="求最小原根"></a>求最小原根</h3><p>求最小原根的算法：从2开始依次枚举，依次检验每一个枚举到的数，当检验出一个数为原根的时候就退出。这个算法的复杂度是与最小原根的大小相关的。呃，一个数最小原根的大小大概也许一般是比较小的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">32010</span>;</span><br><span class="line"><span class="keyword">int</span> pri[N],num,flg[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">predo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;<span class="keyword">if</span>(!flg[i])pri[num++]=i; <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num&amp;&amp;pri[j]*i&lt;=n;++j)&#123;flg[i*pri[j]]=<span class="number">1</span>; <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">int</span> d[N],tot,mod;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">int</span> res=<span class="number">1</span>;<span class="keyword">while</span>(y)&#123;<span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*(ll)x%mod; x=x*(ll)x%mod,y&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;tot=<span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num&amp;&amp;pri[j]*pri[j]&lt;=p;++j)&#123;<span class="keyword">if</span>(p%pri[j]==<span class="number">0</span>)&#123;d[++tot]=pri[j]; <span class="keyword">while</span>(p%pri[j]==<span class="number">0</span>) p/=pri[j]; &#125;&#125; <span class="keyword">if</span>(p&gt;<span class="number">1</span>) d[++tot]=p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">che</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">if</span>(gcd(x,mod)!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i) <span class="keyword">if</span>(Pow(x,(mod<span class="number">-1</span>)/d[i])==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	predo(N<span class="number">-10</span>); read(mod),get(mod<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;mod;++i)</span><br><span class="line">	<span class="keyword">if</span>(che(i))&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,i); <span class="keyword">break</span>;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="原根数量-amp-amp-求一个数所有的原根"><a href="#原根数量-amp-amp-求一个数所有的原根" class="headerlink" title="原根数量&amp;&amp;求一个数所有的原根"></a>原根数量&amp;&amp;求一个数所有的原根</h3><p>对于一个$p$，如果它的原根存在，那么它的原根的数量是$\varphi(\varphi(p))$。</p>
<p>假设$g$是$p$的原根，并且$gcd(i,\varphi(p))=1$，那么$g^i$也是$p$的一个原根。原因是当$gcd(i,\varphi(p))=1$，$i$的$k$倍可以遍历$\varphi(p)$的剩余集，也就是说，$g^i$的幂次可以取遍$[0,p)$中，所有与$p$互质的数。</p>
<p>因此，对于一个数$p$，如果它的原根存在，那么一定有$\varphi(\varphi(p))$个。</p>
<p>由此，我们可以得到求一个数所有的原根的算法：先求出最小原根，然后取所有与$\varphi(p)$互质的$i$，就可以得到所有的原根了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> pri[N],num,flg[N],phi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">predo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!flg[i])pri[num++]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num&amp;&amp;pri[j]*i&lt;=n;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			flg[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) &#123;phi[i*pri[j]]=phi[i]*pri[j]; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span> phi[i*pri[j]]=phi[i]*phi[pri[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[N],tot,mod;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">int</span> res=<span class="number">1</span>;<span class="keyword">while</span>(y)&#123;<span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*(ll)x%mod; x=x*(ll)x%mod,y&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;tot=<span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num&amp;&amp;pri[j]*pri[j]&lt;=p;++j)&#123;<span class="keyword">if</span>(p%pri[j]==<span class="number">0</span>)&#123;d[++tot]=pri[j]; <span class="keyword">while</span>(p%pri[j]==<span class="number">0</span>) p/=pri[j]; &#125;&#125; <span class="keyword">if</span>(p&gt;<span class="number">1</span>) d[++tot]=p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">che</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">if</span>(gcd(x,mod)!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i) <span class="keyword">if</span>(Pow(x,phi[mod]/d[i])==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">()</span></span>&#123;get(phi[mod]);<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;mod;++i) <span class="keyword">if</span>(che(i)) <span class="keyword">return</span> i;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="number">2</span>||p==<span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>) p/=<span class="number">2</span>; <span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;pri[j]*pri[j]&lt;=p&amp;&amp;j&lt;num;++j) <span class="keyword">if</span>(p%pri[j]==<span class="number">0</span>)&#123;<span class="keyword">while</span>(p%pri[j]==<span class="number">0</span>) p/=pri[j]; <span class="keyword">return</span> p==<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!check(mod))&#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(mod==<span class="number">2</span>) &#123;<span class="built_in">puts</span>(<span class="string">"1"</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> g=Get(),k=g; ans.clear();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;phi[mod];++i)&#123;<span class="keyword">if</span>(gcd(i,phi[mod])==<span class="number">1</span>) ans.PB(k); k=k*(ll)g%mod;&#125;</span><br><span class="line">	sort(ans.begin(),ans.end());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,ans[i],i==ans.size()<span class="number">-1</span>?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//	freopen("out.txt","w",stdout);</span></span><br><span class="line">	predo(N<span class="number">-10</span>);</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;mod)) solve();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="原根存在的条件"><a href="#原根存在的条件" class="headerlink" title="原根存在的条件"></a>原根存在的条件</h3><p>丢一个结论在这里：一个数$m$存在原根，当且仅当$m=2,4,p^a,2\times p^a$，其中$p$为<strong>奇</strong>质数，$a$为正整数。</p>
<p>所以把判断一个数是否有原根的函数放在这里。代码中，pri数组下标从0开始，$pri[0]=2,pri[1]=3$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="number">2</span>||p==<span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>) p/=<span class="number">2</span>; <span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;pri[j]*pri[j]&lt;=p&amp;&amp;j&lt;num;++j) <span class="keyword">if</span>(p%pri[j]==<span class="number">0</span>)&#123;<span class="keyword">while</span>(p%pri[j]==<span class="number">0</span>) p/=pri[j]; <span class="keyword">return</span> p==<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性求逆元</title>
    <url>/2022/07/15/%E7%BA%BF%E6%80%A7%E6%B1%82%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<h3 id="公式-amp-amp-食用方法"><a href="#公式-amp-amp-食用方法" class="headerlink" title="公式 &amp;&amp; 食用方法"></a>公式 &amp;&amp; 食用方法</h3><p>设$Inv(i)$表示$i$在模$M$意义下的逆元，则有：<br>$Inv(i) \equiv (-\lfloor{M\over i}\rfloor ) \times Inv(M \mod i)\mod M$<br>由于$(M\mod i )&lt; i$，所以可以利用这个公式线性预处理出逆元。</p>
<p>当模数比较小的时候，可以预处理出$[0,M)$的所有数的逆元，然后算法的复杂度就可以少一个$\log M$~</p>
<hr>
<h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p>设$t=\lfloor{M\over i}\rfloor,k=M\mod i$。</p>
<p>则</p>
<script type="math/tex; mode=display">
t\times i +k \equiv 0 \mod M</script><p>即</p>
<script type="math/tex; mode=display">
- t\times i \equiv k \mod M</script><p>让左右两边同时除以一个$i\times k$：</p>
<script type="math/tex; mode=display">
- t\times Inv(k) \equiv Inv(i) \mod M</script><p>就得到了前面的公式</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;mod;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>类欧几里得</title>
    <url>/2022/07/15/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://oi-wiki.org/math/euclidean/" target="_blank" rel="noopener">OI-wiki</a></p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>设</p>
<script type="math/tex; mode=display">
f(a,b,c,n) = \sum_{i=0}^n \lfloor {\frac{ai+b}{c}}\rfloor</script><p>其中$a,b,c,n$都是常数，需要一个$O(\log n)$的算法。</p>
<p>如果$a\ge c$或者$b\ge c$，可以将$a,b$对$c$取模以化简，即</p>
<script type="math/tex; mode=display">
f(a,b,c,n) = \lfloor \frac{a}{c} \rfloor \frac{n(n+1)}{2} + \lfloor \frac{b}{c} \rfloor (n+1) + f(a\bmod c,b\bmod c,c,n)</script><p>然后考虑$a&lt;c,b&lt;c$的情况：</p>
<script type="math/tex; mode=display">
f(a,b,c,n) = \sum_{i=0}^n \lfloor {\frac{ai+b}{c}}\rfloor\\
= \sum_{i=0}^n \sum_{j=0}^{\lfloor\frac{ai+b}{c} \rfloor - 1} 1\\
= \sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor - 1} \sum_{i=0}^n [j < \lfloor \frac{ai+b}{c} \rfloor]\\
= \sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor - 1} \sum_{i=0}^n [j < \frac{ai+b-c+1}{c}]\\
= \sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor - 1} \sum_{i=0}^n [\frac{jc-b + c - 1}{a} < i]\\
= \sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor - 1} n - \lfloor \frac{jc-b+c-1}{a}\rfloor\\
= \lfloor \frac{an+b}{c}\rfloor n - \sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor -1} \lfloor \frac{jc-b+c-1}{a}\rfloor\\
= \lfloor \frac{an+b}{c}\rfloor n - f(c,c-b-1,a,\lfloor \frac{an+b}{c}\rfloor -1)</script><p>这样就又变成了$a\ge c$的问题，递归解决即可。复杂度为$O(\log n)$。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><script type="math/tex; mode=display">
g(a,b,c,n) = \sum_{i=0}^n i \lfloor \frac{ai+b}{c} \rfloor\\
h(a,b,c,n) = \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor ^2</script><p>首先，让$a,b$对$c$取模。</p>
<script type="math/tex; mode=display">
g(a,b,c,n) = g(a\bmod c, b\bmod c, c, n) + \lfloor\frac{a}{c}\rfloor \frac{n(n+1)(2n+1)}{6} + \lfloor \frac{b}{c} \rfloor \frac{n(n+1)}{2}\\
h(a,b,c,n) = h(a\bmod c, b\bmod c, c, n) +  2 \lfloor \frac{a}{c}\rfloor g(a\bmod c, b\bmod c, c, n) + 2\lfloor \frac{b}{c}\rfloor f(a\bmod c, b\bmod c, c, n)\\
+\lfloor \frac{a}{c} \rfloor^2 \frac{n(n+1)(2n+1)}{6}+2\lfloor\frac{a}{c}\rfloor \lfloor\frac{b}{c}\rfloor \frac{n(n+1)}{2} + \lfloor\frac{b}{c}\rfloor^2(n+1)</script><p>然后进行类似的推导</p>
<script type="math/tex; mode=display">
g(a,b,c,n) = \sum_{i=0}^n i \sum_{j=0}^{\lfloor \frac{ai+b}{c}\rfloor -1} 1\\
= \sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor - 1} \sum_{i=0}^n i [\frac{jc-b + c - 1}{a} < i]\\
= \sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor - 1} \frac{n(n+1)}{2} - \frac{1}{2}\lfloor \frac{jc-b+c-1}{a}\rfloor(\lfloor \frac{jc-b+c-1}{a}\rfloor + 1)\\
= \lfloor \frac{an+b}{c}\rfloor \frac{n(n+1)}{2} - {1\over 2}h(c,c-b-1,a,\lfloor \frac{an+b}{c}\rfloor -1) - {1\over 2}f(c,c-b-1,a,\lfloor \frac{an+b}{c}\rfloor -1)</script><script type="math/tex; mode=display">
h(a,b,c,n) = 2(\sum_{i=0}^n \sum_{j=0}^{\lfloor \frac{ai+b}{c}\rfloor -1} (j+1)) - f(a,b,c,n)\\</script><p>考虑前面那部分</p>
<script type="math/tex; mode=display">
= \sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor - 1} (j+1) \sum_{i=0}^n [\frac{jc-b + c - 1}{a} < i]\\
= \sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor - 1} (j+1)n - (j+1)\lfloor \frac{jc-b+c-1}{a}\rfloor\\
= \frac{1}{2}(\lfloor \frac{an+b}{c}\rfloor + 1)\lfloor \frac{an+b}{c}\rfloor n - g(c,c-b-1,a,\lfloor \frac{an+b}{c}\rfloor -1) - f(c,c-b-1,a,\lfloor \frac{an+b}{c}\rfloor -1)</script><p>模板：<a href="https://www.luogu.com.cn/record/30158874" target="_blank" rel="noopener">luoguP5170</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二次剩余</title>
    <url>/2022/07/15/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</url>
    <content><![CDATA[<h3 id="勒让德记号"><a href="#勒让德记号" class="headerlink" title="勒让德记号"></a>勒让德记号</h3><p>定义勒让德记号：</p>
<script type="math/tex; mode=display">
\begin{pmatrix} a\over p \end{pmatrix} = 
\begin{cases}
0 & a=0 \\
+1 & a^{(p-1)\over 2} \equiv 1 \pmod p,此时a在模p的意义下有二次剩余 \\
-1 & a^{(p-1)\over 2} \equiv -1 \pmod p ,此时a在模p意义下没有二次剩余 \\
\end{cases}</script><hr>
<h3 id="求二次剩余"><a href="#求二次剩余" class="headerlink" title="求二次剩余"></a>求二次剩余</h3><p>解方程$x^2\equiv n \pmod p$ （$p$为奇质数）<br>随机选取一个数$a$，令$w=a^2-n$<br>当$w$不是$p$的二次剩余时（概率为0.5）<br>有$x=(a+\sqrt{w})^{p+1\over 2}$<br>证明：</p>
<script type="math/tex; mode=display">(a+\sqrt{w})^p=C_{p}^{0}a^p+C_{p-1}^{2}a^{p-1}\sqrt{w}...+C_{p}^{p}\sqrt{w}^p</script><p>由于对于$C_{p}^{i}$，分母中不含有$p$，所以分子中的$p$一定不会被约掉<br>所以第$2$项至第$p$项在模$p$的意义下均为$0$</p>
<script type="math/tex; mode=display">\therefore(a+\sqrt{w})^p\equiv a^p+\sqrt{w}^p(mod\ p)</script><p>由费马小定理得<script type="math/tex">a^{p-1}\equiv 1\\
\therefore a^p\equiv a\\
\because w^{p-1\over 2}\equiv -1\\
\therefore \sqrt{w}^{p-1}\equiv -1\\
\therefore \sqrt{w}^p\equiv -\sqrt{w}\\
\therefore (a+\sqrt{w})^p\equiv a^p+\sqrt{w}^p\equiv a-\sqrt{w}\\
\therefore x^2\equiv ((a+\sqrt{w})^{p+1\over 2})^2\\
\equiv (a+\sqrt{w})^{p+1}\\
\equiv (a+\sqrt{w})(a+\sqrt{w})^p\\
\equiv (a+\sqrt{w})(a-\sqrt{w})\\
\equiv a^2-w\\
\equiv a^2-(a^2-n)\\
\equiv n</script><br>证毕</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*(ll)x%mod;</span><br><span class="line">		x=x*(ll)x%mod,y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _w;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	node(<span class="keyword">int</span> x=<span class="number">0</span>,<span class="keyword">int</span> y=<span class="number">0</span>): x(x),y(y) &#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> node <span class="keyword">operator</span> * (node A,node B) &#123; <span class="keyword">return</span> node((A.x*(ll)B.x+A.y*(ll)B.y%mod*_w)%mod,(A.x*(ll)B.y+A.y*(ll)B.x)%mod); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">Pow</span><span class="params">(node x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	node res=node(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(y) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">		x=x*x; y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;mod,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(!n) &#123; <span class="built_in">printf</span>(<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span>(mod==<span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">"1"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span>(Pow(n,(mod<span class="number">-1</span>)/<span class="number">2</span>)==mod<span class="number">-1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> a=(rand()|((rand()*<span class="number">1l</span>l)&lt;&lt;<span class="number">16</span>))%mod; _w=((a*(ll)a-n)%mod+mod)%mod;</span><br><span class="line">		<span class="keyword">if</span>(Pow(_w,(mod<span class="number">-1</span>)/<span class="number">2</span>)==mod<span class="number">-1</span>) &#123;</span><br><span class="line">			node ans=Pow(node(a,<span class="number">1</span>),(mod+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">int</span> x1=ans.x,x2=mod-ans.x;</span><br><span class="line">			<span class="keyword">if</span>(x1&gt;x2) swap(x1,x2);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,x1);</span><br><span class="line">			<span class="keyword">if</span>(x1!=x2) <span class="built_in">printf</span>(<span class="string">"%d"</span>,x2);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>upd 2020.2.29</p>
<p>勒让德记号相关证明：</p>
<p>因为 $(a^{\frac{p-1}{2}})^2 \equiv 1(p\nmid a)$ ，所以 $a^{\frac{p-1}{2}} \equiv \pm 1$ 。</p>
<p>$a^{\frac{p-1}{2}}\equiv 1$：用 $g$ 表示 $p$ 的一个原根，$a\equiv g^k$ ，那么 $g^{k\frac{p-1}{2}} \equiv 1$，所以 $k \frac{p-1}{2} \mid p-1$ ，所以 $2 \mid k$ ，$\pm g^{\frac{k}{2}}$ 为 $a$ 的二次剩余。</p>
<p>$a^{\frac{p-1}{2}}\equiv -1$：若存在 $x$ 满足 $x^2 \equiv a$，那么 $a^{\frac{p-1}{2}} = x^{p-1} = -1$，矛盾。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>杜教筛优化</title>
    <url>/2022/07/15/%E6%9D%9C%E6%95%99%E7%AD%9B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>杜教筛是要记忆化的。但是$map$的常数非常大，亲测$Hash Table$也很难跑过现在luogu上的杜教筛模板。怎么办呢？如果我们能够预处理出所有会被用到的数，给他们分配好空间，那么不仅可以避开$map$的常数，还可以从小到大依次枚举这些数进行处理，从而避免递归。</p>
<p>观察$S(n)=h(n)-\sum_{i=2}^n S(\lfloor{n\over i}\rfloor)$，可知会被取到的数可以分为两类：</p>
<p>1.小于$\sqrt n$的所有自然数<br>2.一个大于$\sqrt n$的数$x$，并且存在一个小于$\sqrt n$的数，使$\lfloor {n\over i}\rfloor = x$成立。</p>
<p>由此也可以看出来，可能被取的数只有$2\cdot \sqrt n$个。</p>
<p>那么可以一次性处理出来所有要计算的$n$。从小到大枚举$i$，当$\lfloor {n\over i}\rfloor$大于$2e6$（就是最初线筛出来的一部分前缀和，取$n^{2\over 3}$时最优秀）退出。</p>
<p>还有一个问题，我们在进行杜教筛的时候，怎么知道$n$在数组中对应的位置呢？</p>
<p>有一个结论，是$[1,\sqrt n]$中的每一个数$i$，$\lfloor{n\over i}\rfloor$唯一地映射到了一个大于$\sqrt n$的数；每一个大于$\sqrt n$、并且可以被$\lfloor{n\over i}\rfloor$映射到的数$x$，$\lfloor {n\over x} \rfloor $会映射到$i$，并且对于所有的会被映射到的数$x$，只有一个数的$\lfloor {n\over x}\rfloor$会等于$i$。</p>
<p>因此，从小到大枚举$i$，并且按照$i$的大小顺序将$\lfloor {n\over i}\rfloor$存入数组，那么对于大于$\sqrt n$的$x$数组中的第$n\over x$个位置就是这个数所在的位置。</p>
<p>然后就可以愉快地杜教筛啦~~</p>
<p>下面是luogu杜教筛模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> flg[N],pri[N],num,m;</span><br><span class="line">ll mu[N],phi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">predo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m=<span class="number">2e6</span>;</span><br><span class="line">	phi[<span class="number">1</span>]=<span class="number">1</span>,mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!flg[i]) pri[num++]=i,phi[i]=i<span class="number">-1</span>,mu[i]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num&amp;&amp;pri[j]*i&lt;=m;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			flg[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]) mu[i*pri[j]]=-mu[i],phi[i*pri[j]]=phi[i]*(pri[j]<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">else</span>&#123; phi[i*pri[j]]=phi[i]*pri[j]; <span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) phi[i]+=phi[i<span class="number">-1</span>],mu[i]+=mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ll Mu[N],Phi[N];</span><br><span class="line"><span class="keyword">int</span> v[N],top,n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qphi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;=m?phi[x]:Phi[n/x];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qmu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;=m?mu[x]:Mu[n/x];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T; read(T); predo();</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		read(n); top=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((n/i)&lt;=m) <span class="keyword">break</span>; </span><br><span class="line">			v[++top]=n/i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=top;i;--i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> t=v[i];</span><br><span class="line">			ll ap=t*(ll)(t+<span class="number">1</span>)/<span class="number">2</span>,am=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>,r=<span class="number">1</span>;r&lt;t;l=r+<span class="number">1</span>) r=t/(t/l),ap-=qphi(t/l)*(r-l+<span class="number">1</span>),am-=qmu(t/l)*(r-l+<span class="number">1</span>);</span><br><span class="line">			Phi[i]=ap,Mu[i]=am;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,qphi(n),qmu(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单位根反演</title>
    <url>/2022/07/15/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><script type="math/tex; mode=display">
[ d \mid n ] = {1\over d} \sum_{i=0}^{d-1} \omega_d^{in}</script><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="loj6485-LJJ学二项式定理"><a href="#loj6485-LJJ学二项式定理" class="headerlink" title="loj6485 LJJ学二项式定理"></a>loj6485 LJJ学二项式定理</h3><p>首先枚举$i\pmod 4$的余数$t$，然后转化成对于每一个$t$，求</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n {n\choose i}s^i [ 4\mid (i-t) ] \\</script><p>单位根反演：</p>
<script type="math/tex; mode=display">
= \sum_{i=0}^n {n\choose i}s^i {1\over 4}\sum_{j=0}^3 \omega_{4}^{j(i-t)} \\
= {1\over 4} \sum_{j=0}^3 \omega_{4}^{-jt} \sum_{i=0}^n {n\choose i}s^i w_4^{ij}</script><p>最后面的那一坨东西，由二项式定理知$(1+x)^n = \sum_{i=0}^n {n\choose i}x^i$，所以：</p>
<script type="math/tex; mode=display">
= {1\over 4} \sum_{j=0}^3 \omega_{4}^{-jt} (s\omega_4^j + 1)^n</script><p>直接算就可以了。</p>
<p><a href="https://loj.ac/submission/715070" target="_blank" rel="noopener">Code</a></p>
<h3 id="uoj450【集训队作业2018】复读机"><a href="#uoj450【集训队作业2018】复读机" class="headerlink" title="uoj450【集训队作业2018】复读机"></a>uoj450【集训队作业2018】复读机</h3><p>考虑一个复读机复读次数的生成函数：</p>
<script type="math/tex; mode=display">
F(x) = \sum_{i=0}^{\infty} {x^i\over i!} [d\mid i]</script><p>而我们要算的实际上是$n! \cdot F^k(x) [x^n]$。</p>
<p>对$F(x)$进行单位根反演：</p>
<script type="math/tex; mode=display">
F(x) = {1\over d}\sum_{i=0}^{\infty} {x^i\over i!} \sum_{j=0}^{d-1} \omega^{ij}\\
= {1\over d}\sum_{j=0}^{d-1} \sum_{i=0}^{\infty} {x^iw^{ij}\over i!}\\
= {1\over d} \sum_{j=0}^{d-1} e^{\omega^j x}</script><p>$1\over d$是常数，我们先把它忽视掉，最后再在答案里乘上一个$1\over d^k$。</p>
<p>考虑$F^k(x)$的组合意义，相当于对于这$k$个多项式，从每一个里面选一项相乘，所有的方案得到的乘积的和。枚举$e^{\omega^jx}$被选的次数$p_j$，得到</p>
<script type="math/tex; mode=display">
F^k (x) = \sum_{p_0+p_1\cdots p_{d-1}=k}k!\prod_{j=0}^{d-1} {1\over p_j!}e^{p_j \omega_jx}\\
= \sum_{p_0+p_1\cdots p_{d-1}=k} e^{(\sum_{j=0}^{d-1}p_jw_j)x} \cdot k!\prod_{j=0}^{d-1} {1\over p_j!}</script><p>而</p>
<script type="math/tex; mode=display">
F^k (x) [ x^n ] = \sum_{p_0+p_1\cdots p_{d-1}=k} {(\sum_{j=0}^{d-1}p_jw_j)^n \over n!} \cdot k!\prod_{j=0}^{d-1} {1\over p_j!}</script><p>直接计算，复杂度$O(k^d \log n)$。</p>
<p><a href="http://uoj.ac/submission/376702" target="_blank" rel="noopener">Code</a></p>
<h3 id="bzoj3328-PYXFIB"><a href="#bzoj3328-PYXFIB" class="headerlink" title="bzoj3328 PYXFIB"></a>bzoj3328 PYXFIB</h3><p>设</p>
<script type="math/tex; mode=display">
A = \begin{bmatrix}1 & 0 \\ 1 & 1\end{bmatrix}\\
B = \begin{bmatrix} 1 \\ 1 \end{bmatrix}</script><p>则我们相当于要求出</p>
<script type="math/tex; mode=display">
(\sum_{i=0}^n {n\choose i} A^i [k\mid i] )B</script><p>对前面的那个括号里面的东西单位根反演，得到</p>
<script type="math/tex; mode=display">
{1\over k} \sum_{j=0}^{k-1} \sum_{i=0}^n {n\choose i}A^i\omega^{ij} \\
= {1\over k} \sum_{j=0}^{k-1} (\omega^j\cdot A + E)^n</script><p>其中$E$表示单位矩阵。</p>
<p>直接矩阵快速幂计算，时间复杂度为$O(2^3 \cdot \log n \cdot k)$。</p>
<h3 id="loj3058-「HNOI2019」白兔之舞"><a href="#loj3058-「HNOI2019」白兔之舞" class="headerlink" title="loj3058 「HNOI2019」白兔之舞"></a>loj3058 「HNOI2019」白兔之舞</h3><p>设矩阵$A$是满足$A_{i,j} = w(i,j)$的$n\times n$的矩阵。</p>
<p>走$m$步的方案数为${L\choose m}T_{x,y}$，其中$T=A^m$。</p>
<p>则对于每一个$t$，我们需要求出</p>
<script type="math/tex; mode=display">
\sum_{m=0}^L {L\choose m}A^m [k\mid (t-m)]</script><p>单位根反演之后得到</p>
<script type="math/tex; mode=display">
{1\over k}\sum_{j=0}^{k-1} \omega_k^{-tj}(\omega_k^jA + E)^L</script><p>对于每一个$j$，分别算出$F_j = (\omega_k^j A+ E)^L$，设$f_j$为$F_j$的$x$行$y$列的元素，则$t$的答案就是</p>
<script type="math/tex; mode=display">
Ans_t = {1\over k}\sum_{j=0}^{k-1} f_j \omega_k^{-tj}</script><p>由于$-tj={t\choose 2}+{j\choose 2}-{t+j\choose 2}$，所以</p>
<script type="math/tex; mode=display">
Ans_t = {1\over k}\cdot \omega_k^{t\choose 2} \sum_{j=0}^{k-1} (f_j\cdot \omega_k^{j\choose 2} ) \omega_k^{-{i+j\choose 2}}</script><p>这是一个卷积的形式，用MTT优化一下就可以了。</p>
<p>总时间复杂度$O(kn^3\log L + k\log k)$。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Stern-Brocot树与Farey序列</title>
    <url>/2022/07/15/Stern-Brocot%E6%A0%91%E4%B8%8EFarey%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://oi-wiki.org/misc/stern-brocot/" target="_blank" rel="noopener">OI-wiki</a></p>
<p><a href="https://cp-algorithms.com/others/stern_brocot_tree_farey_sequences.html" target="_blank" rel="noopener">另外一篇资料</a></p>
<h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><p>每一行的分数是单调递增的。考虑归纳：</p>
<script type="math/tex; mode=display">
\frac{a}{b}\le \frac{c}{d}\\
\Rightarrow ad \le bc\\
\Rightarrow ad + ab\le bc + ab\\
\Rightarrow \frac{a}{b} \le \frac{a+c}{b+d}</script><p>同理可证 $\frac{a+c}{b+d} \le \frac{c}{d}$ 。</p>
<h2 id="最简性"><a href="#最简性" class="headerlink" title="最简性"></a>最简性</h2><p>即序列中所有分数都是最简分数。</p>
<p>首先证明 $bc-ad=1$ ，仍然使用归纳法：</p>
<script type="math/tex; mode=display">
bc-ad=1 \\
\Rightarrow b(a+c)-a(b+d)=1</script><p>另一半同理。</p>
<p>而 $bc-ad=1$ 即意味着 $\gcd(a,c)= \gcd(b,d)=1$（裴蜀定理）</p>
<h2 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h2><p>考虑 $\frac{x}{y}$ 如果在某一层没有出现过，则这一层一定有两个数 $\frac{a}{b}, \frac{c}{d}$ 满足 $\frac{a}{b} \le \frac{x}{y} \le \frac{c}{d}$ 。</p>
<p>也就是</p>
<script type="math/tex; mode=display">
bx - ay > 0, cy - dx > 0\\
\Rightarrow bx - ay \ge 1, cy - dx \ge 1</script><p>同乘上 $(a+b), (c+d)$ ：</p>
<script type="math/tex; mode=display">
\Rightarrow \begin{cases}
(c+d)(bx-ay)\ge c+d\\
(a+b)(cy-dx) \ge a+b
\end{cases}
\\
\Rightarrow \begin{cases}
bcx-acy+bdx-ady\ge c+d\\
acy-adx+bcy-bdx\ge a+b
\end{cases}\\
\Rightarrow (bc-ad)x+(bc-ad)y\ge a+b+c+d</script><p>因为 $bc-ad=1$ ，所以 $x+y\ge a+b+c+d$ 。而因为每一次向更深的层走，$a+b+c+d$ 会增加，所以至多在 $x+y$ 层 $\frac{x}{y}$ 就会出现。</p>
<p>并且 $x+y$ 已经是最紧的界了，因为分数 $\frac{1}{n}$ 出现在 $n+1$ 层。</p>
<h2 id="Farey-序列"><a href="#Farey-序列" class="headerlink" title="Farey 序列"></a>Farey 序列</h2><p>参考 OI-wiki</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Pollard&#39;s Rho Algorithm</title>
    <url>/2022/07/15/Pollard-s-Rho-Algorithm/</url>
    <content><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://files-cdn.cnblogs.com/files/Doggu/Pollard-rho%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">一篇tutorial</a><br>算法导论 31.9</p>
<hr>
<h3 id="关于质因数分解与随机算法"><a href="#关于质因数分解与随机算法" class="headerlink" title="关于质因数分解与随机算法"></a>关于质因数分解与随机算法</h3><p>我们假设要分解的数$n=pq$，其中$p\le q$，且$p$，$q$都为质数。这是最坏的情况。</p>
<p>肯定不能够$O(\sqrt n)$地去枚举$p$啦，这样的复杂度是无法承受的。我们考虑一下随机算法。我们随机一个小于$n$的数，它等于$p$（为$n$的某个约数）的概率为$1\over n$。那么，我们随机$n$次，期望会有$1$次，随机出来数是$p$。欸怎么好像还不如$O(\sqrt n)$……</p>
<p>那我们换个随机方式，随机$k$个数出来，把这$k$个数两两做差，看它们的差值是否为$p$（即是否为$n$的约数）。根据生日悖论，当$k$是$O(\sqrt n)$级别的时候，这$k$个数两两差值中，$p$的期望出现次数为$1$。但是把$O(\sqrt n)$个数拿来两两做差，复杂度是$O(n)$的，还是不如$O(\sqrt n)$的朴素算法。</p>
<p>“等于$p$”这个条件太严苛了，我们考虑放宽一点。假如随机出一个数$x$，我们只要$gcd(x,n)\not = 1$，就可以找到$n$的一个非平凡约数了（也就是这个$gcd$）。换言之，我们只需要得到一个$p$的倍数就可以了。那么根据生日悖论，当$k$达到$O(\sqrt p)$的时候，我们得到的这$k$个数中，期望有一对数，它们的差为$p$的倍数。但是这样检查的复杂度是$O(p)$的，对于$p=\sqrt n$（如果$n=10^{18}$，那么$p$将达到$10^9$）的情况仍然不够快，而且空间开销很大。</p>
<hr>
<h3 id="Pollard’s-Rho-algorithm"><a href="#Pollard’s-Rho-algorithm" class="headerlink" title="Pollard’s Rho algorithm"></a>Pollard’s Rho algorithm</h3><p>先看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll get(ll n,ll a)</span><br><span class="line">&#123;</span><br><span class="line">	ll i&#x3D;1,k&#x3D;2,x&#x3D;Rand()%n,y&#x3D;x;&#x2F;&#x2F; 这里不要取 Rand()%(n-1)+1 啥的，在n&#x3D;4的时候会挂</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		++i,x&#x3D;(Mul(x,x,n)+a)%n;</span><br><span class="line">		ll d&#x3D;gcd(Abs(y-x),n);</span><br><span class="line">		if(d&gt;1&amp;&amp;d&lt;n) return d;</span><br><span class="line">		if(x&#x3D;&#x3D;y) return n;</span><br><span class="line">		if(i&#x3D;&#x3D;k) y&#x3D;x,k&lt;&lt;&#x3D;1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们选择了一个伪随机数生成函数来生成一个随机数列，即$x_i = x_{i-1}^2 +a\mod n$。这里的$a$可以随意选取（不过算导说，$a=0,-2$应该被避免）。这个数列的取值，一定会陷入一个$\rho $形的环，即从某个位置开始，后面的元素的值是循环出现的。</p>
<p>我们发现，这个数列模$p$过后得到的数列，具有相同的递推式，即$x_i = x_{i-1}^2 + a\mod p$。那么相似地，这个模$p$意义下的序列也会陷入循环。现在我们的任务，是找到两个数$x_i,x_j$，使得它们在模$p$的意义下相等（也就是说，它们的差为$p$的倍数）并且它们在模$n$的意义下不相等。我们考虑在模$n$的这个数列的循环节上，固定一个位置，然后检查这个位置后面的$2^k$个位置，如果没有找到与它模$p$意义下相等的数——这个条件等价于没有找到一个数，它们的差与$n$的最大公约数不为$1$，也等价于没有找到一个数，它们在模$p$的那个数列的循环节上处于同一个位置——那么就让$k++$。如果在模$n$的这个数列的循环节上已经遍历完了一圈，这个时候仍然没有找到模$p$意义下与$y$相等的数，就直接返回，然后换一个种子或者换一个$a$重新计算。</p>
<p>这个算法的期望时间复杂度是$O(\sqrt {\sqrt n})$的，空间则是$O(1)$的。当然，前提是我们必须先判定，$n$不是素数，是可以分解的。这就需要Miller-Rabin素数测试啦。</p>
<p>上面只是找出一个约数的算法，要把一个大合数分解质因数，在外面套一个dfs就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pollard's rho algorithm</span></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="function">ll <span class="title">Abs</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> x&gt;<span class="number">0</span>?x:-x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll n,ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll i=<span class="number">1</span>,k=<span class="number">2</span>,x=Rand()%n,y=x;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++i,x=(Mul(x,x,n)+a)%n;</span><br><span class="line">		ll d=gcd(Abs(y-x),n);</span><br><span class="line">		<span class="keyword">if</span>(d&gt;<span class="number">1</span>&amp;&amp;d&lt;n) <span class="keyword">return</span> d;</span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> n;</span><br><span class="line">		<span class="keyword">if</span>(i==k) y=x,k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; fac;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Isprime(n))&#123;fac.PB(n); <span class="keyword">return</span>;&#125;</span><br><span class="line">	ll p=n;</span><br><span class="line">	<span class="keyword">while</span>(p==n) p=get(n,Rand()%n);</span><br><span class="line">	dfs(p),dfs(n/p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有生成64位随机数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ull <span class="title">Rand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	seed^=seed&lt;&lt;<span class="number">13</span>,seed^=seed&gt;&gt;<span class="number">7</span>,seed^=seed&lt;&lt;<span class="number">17</span>;</span><br><span class="line">	<span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板：poj1811</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Min_25筛</title>
    <url>/2022/07/15/Min-25%E7%AD%9B/</url>
    <content><![CDATA[<h2 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h2><p>用于求<strong>积性函数</strong>的前$n$项的和，$n$通常在$10^{10}$左右。它要求这个函数必须是积性函数，并且<strong>对于质数</strong>，这个函数的取值可以表示成一个可以<strong>快速算前缀和</strong>并且<strong>完全积性</strong>的东西（比如低阶多项式），对于<strong>质数的k次方</strong>，这个函数大约可以在$O(1)$的时间内查询。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>以计算$[1,n]$的质数个数为例，即定义$f(x) = [x\in \text{Prime}]$，要求$\sum_{i=1}^n f(i)$。</p>
<p>用$p_j$表示第$j$个质数，定义$g(n,j)$表示$[2,n]$中所有的质数以及最小质因子大于$p_j$的数的函数值和（注意没有包含$1$）。我们将按照$j$从小到大的顺序依次计算$g(n,j),g(\lfloor {n\over 2 } \rfloor ,j),g(\lfloor {n\over 3} \rfloor ,j)\cdots $。这相当于是在模拟埃氏筛的过程。</p>
<p>最初我们有$g(n,0)=n-1$。</p>
<p>考虑从$g(n,j-1)$到$g(n,j)$，我们将会减去一些最小质因子为$p_j$的数的函数值。这些数必然会包含$p_j$这个因子，因此要减去的就是$f(p_j)$乘以$[2,\lfloor {n\over p_j}\rfloor ]$中最小质因子大于等于$p_j$的数的函数值的和。设$s_j$表示$\sum_{i=1}^j f(p_i)$，那么要减去的就是$f(p_j) \cdot (g(\lfloor {n\over p_j}\rfloor ,j-1) - s_{j-1})$。</p>
<p>考虑这一步的复杂度：首先由于我们只需要用到$\lfloor {n\over p}\rfloor $，所以我们只需要存储$\lfloor {n\over 1}\rfloor,\lfloor {n\over 2}\rfloor,\lfloor {n\over 3}\rfloor\cdots $这些点的取值，共$O(\sqrt n)$个；$j$这一维可以滚动；所以空间复杂度是$O(\sqrt n)$的。注意滚动之后，我们需要在进行计算的时候从大到小枚举$n$。时间复杂度被证明是$O({n^{3\over 4 }\over \ln n})$的。</p>
<p>然后我们考虑计算答案。我们设$h(n,j)$表示$[2,n]$所有最小质因子大于等于$p_j$的数（包括最小质因子大于等于$p_j$的合数以及大于等于$p_j$的质数）的$f$的取值的和，那么有：</p>
<script type="math/tex; mode=display">
h(n,j) =g(n,\max j)-s_{j-1}+\sum_{k\ge 1,{n\over p_j^k}>p_j}f(p_j^k)\cdot h(\lfloor{ n\over p_j^k }\rfloor ,j+1) + \sum_{k\ge 2}f(p_j^k)</script><p>第一个$\sum$中的限制是为了让$\lfloor{ n\over p_j^k }\rfloor &gt;p_j$，否则$\lfloor{ n\over p_j^k }\rfloor  - s_j$会出错。它等于</p>
<script type="math/tex; mode=display">
h(n,j) = g(n,j) -s_{j-1}+ \sum_{k\ge 1 ,{n\over p_j^k }\ge p_j} f(p_j^k)h(\lfloor{ n\over p_j^k }\rfloor ,j+1)+f(p_j^{k+1})</script><p>直接递归下去计算即可。由于几乎不会访问到相同的$(j,n)$，所以不需要记忆化（这个可以通过打表看出来）。时间复杂度据说是$O({n^{3\over 4 }\over \ln n})$？反正跑得很快就对了。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h4 id="loj6053-简单的函数"><a href="#loj6053-简单的函数" class="headerlink" title="loj6053 简单的函数"></a>loj6053 简单的函数</h4><p>定义一个积性函数$f(x)$，对于质数的$k$次方满足$p^k$满足$f(p^k) =p\text{ xor }k$。求$\sum_{i=1}^n f(i) \bmod {10^9+7}$。$n\le 10^{10}$</p>
<p>Solution：</p>
<p>对于除了$2$以外的任何一个素数都是奇数，所以它们异或$1$得到自己$-1$，即对于大于$2$的素数我们有$f(p)=p-1$，套板子计算出质数的和、质数的个数就可以了。主意最后还要特殊考虑$2$的贡献。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">int</span> lim0,lim1;</span><br><span class="line"><span class="keyword">int</span> id0[N],id1[N];</span><br><span class="line">ll w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ID</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x&lt;=lim0?id0[x]:id1[n/x]; &#125;</span><br><span class="line"><span class="keyword">int</span> f[N],g[N],h[N];</span><br><span class="line"><span class="keyword">int</span> sump[N];</span><br><span class="line"><span class="keyword">int</span> pri[N],num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpri</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s[N];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!s[i]) pri[s[i]=++num]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s[i];++j)</span><br><span class="line">			<span class="keyword">if</span>(pri[j]*(ll)i&lt;=n) s[i*pri[j]]=j;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(ll n,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pri[i]&gt;n||n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> p=ID(n);</span><br><span class="line">	ll ans=(g[p]-h[p]-(sump[i<span class="number">-1</span>]-(i<span class="number">-1</span>)))%mod; <span class="keyword">if</span>(i==<span class="number">1</span>) ans=(ans+<span class="number">2</span>)%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=num&amp;&amp;pri[j]*(ll)pri[j]&lt;=n;++j) &#123;</span><br><span class="line">		ll l=pri[j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> e=<span class="number">1</span>;l*(ll)pri[j]&lt;=n;++e,l*=pri[j]) &#123;</span><br><span class="line">			ans=(ans+(pri[j]^e)*(ll)calc(n/l,j+<span class="number">1</span>)+(pri[j]^(e+<span class="number">1</span>)))%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ans%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">	lim0=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">	getpri(lim0);</span><br><span class="line">	<span class="keyword">int</span> _tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">		r=n/(n/l);</span><br><span class="line">		ll v=n/l;</span><br><span class="line">		(v&lt;=lim0?id0[v]:id1[n/v])=++_tot;</span><br><span class="line">		w[_tot]=v;</span><br><span class="line">		g[_tot]=(v%mod+<span class="number">2</span>)*(ll)(v%mod<span class="number">-2</span>+<span class="number">1</span>)%mod*((mod+<span class="number">1</span>)/<span class="number">2</span>)%mod;</span><br><span class="line">		h[_tot]=(v<span class="number">-1</span>)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i) &#123;</span><br><span class="line">		sump[i]=(sump[i<span class="number">-1</span>]+pri[i])%mod;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=_tot;++j) &#123;</span><br><span class="line">			<span class="keyword">if</span>(pri[i]*(ll)pri[i]&gt;w[j]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> k=ID(w[j]/pri[i]);</span><br><span class="line">			g[j]=(g[j]-pri[i]*(ll)(g[k]-sump[i<span class="number">-1</span>])%mod)%mod;</span><br><span class="line">			h[j]=(h[j]-(h[k]-(i<span class="number">-1</span>)))%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(calc(n,<span class="number">1</span>)+<span class="number">1</span>)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="luogu-P5325"><a href="#luogu-P5325" class="headerlink" title="luogu P5325"></a>luogu P5325</h4><p>定义一个积性函数$f(x)$，对于质数的$k$次方$p^k$满足$f(p^k) = p^k(p^k -1)$，求$\sum_{i=1}^n f(i)\bmod {10^9+7}$。$n\le 10^{10}$</p>
<p>Solution：</p>
<p>对于质数这个函数满足$f(x) = x(x-1) = x^2 - x$，分成$x^2$和$x$两部分分别计算就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*(ll)x%mod;</span><br><span class="line">        x=x*(ll)x%mod,y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2=(mod+<span class="number">1</span>)/<span class="number">2</span>,inv6=Pow(<span class="number">6</span>,mod<span class="number">-2</span>);</span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">int</span> lim0,id0[N],id1[N],m;</span><br><span class="line">ll w[N];</span><br><span class="line"><span class="keyword">int</span> g[N],h[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ID</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x&lt;=lim0?id0[x]:id1[n/x]; &#125;</span><br><span class="line"><span class="keyword">int</span> pri[N],num;</span><br><span class="line"><span class="keyword">int</span> sg[N],sh[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpri</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s[i]) pri[s[i]=++num]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s[i];++j)</span><br><span class="line">            <span class="keyword">if</span>(pri[j]*(ll)i&lt;=n) s[pri[j]*i]=j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x%mod*(x%mod<span class="number">-1</span>)%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(ll n,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pri[i]&gt;n||n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x=ID(n),ans=((g[x]-h[x])%mod-(sg[i<span class="number">-1</span>]-sh[i<span class="number">-1</span>])%mod)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=num;++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pri[j]*(ll)pri[j]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        ll l=pri[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e=<span class="number">1</span>;l*(ll)pri[j]&lt;=n;++e,l*=pri[j]) &#123;</span><br><span class="line">            ans=(ans+F(l)*(ll)calc(n/l,j+<span class="number">1</span>)+F(l*pri[j]))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    getpri(lim0=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n)));</span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">        ll v=n/l,z=v%mod; r=n/v;</span><br><span class="line">        (v&lt;=lim0?id0[v]:id1[n/v])=++m;</span><br><span class="line">        w[m]=v;</span><br><span class="line">        g[m]=(z*(z+<span class="number">1</span>)%mod*(<span class="number">2</span>*z+<span class="number">1</span>)%mod*inv6%mod<span class="number">-1</span>)%mod;</span><br><span class="line">        h[m]=(z+<span class="number">2</span>)*(z<span class="number">-2</span>+<span class="number">1</span>)%mod*inv2%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i) &#123;</span><br><span class="line">        sg[i]=(sg[i<span class="number">-1</span>]+pri[i]*(ll)pri[i])%mod;</span><br><span class="line">        sh[i]=(sh[i<span class="number">-1</span>]+pri[i])%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pri[i]*(ll)pri[i]&gt;w[j]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> k=ID(w[j]/pri[i]);</span><br><span class="line">            g[j]=(g[j]-pri[i]*(ll)pri[i]%mod*(g[k]-sg[i<span class="number">-1</span>])%mod)%mod;</span><br><span class="line">            h[j]=(h[j]-pri[i]*(ll)(h[k]-sh[i<span class="number">-1</span>]))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,((calc(n,<span class="number">1</span>)+<span class="number">1</span>)%mod+mod)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jzoj5594-最大真因数"><a href="#jzoj5594-最大真因数" class="headerlink" title="jzoj5594 最大真因数"></a>jzoj5594 最大真因数</h4><p>求$[1,n]$的所有合数的最大真因数的和。</p>
<p>Solution：</p>
<p>一个数的最大真因数等于这个数除以它的最小质因子。</p>
<p>考虑直接枚举这个数的最小质因子以及这个最小质因子的幂次$p^k$，则它对答案的贡献是所有最小质因子大于$p$的数的和乘以$p^{k-1}$。这可以在min_25筛的过程中解决。</p>
<p>可以不用记忆化。因为我们枚举最小质因子及其幂次相当于min_25筛里面的第一层展开来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> pri[N],num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpri</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s[N];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!s[i]) pri[s[i]=++num]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s[i];++j)</span><br><span class="line">			<span class="keyword">if</span>(i*(ll)pri[j]&lt;=n) s[i*pri[j]]=j;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ull g[N],sg[N],Ans;</span><br><span class="line">ll w[N],n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> id0[N],id1[N],lim;</span><br><span class="line"><span class="keyword">namespace</span> Hash &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> pri=<span class="number">1000000</span>,N=pri+<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> head[N];</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt; key;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ull&gt; val;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">		key.clear(),val.clear(),nxt.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">id</span><span class="params">(<span class="keyword">int</span> j,ll n)</span> </span>&#123; <span class="keyword">return</span> n*(num+<span class="number">1</span>)+j; &#125;</span><br><span class="line">	<span class="function">ull <span class="title">query</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[k%pri];~i;i=nxt[i])</span><br><span class="line">			<span class="keyword">if</span>(key[i]==k) <span class="keyword">return</span> val[i];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll k,ull v)</span> </span>&#123;</span><br><span class="line">		key.PB(k),val.PB(v);</span><br><span class="line">		nxt.PB(head[k%pri]),head[k%pri]=nxt.size()<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ull <span class="title">query</span><span class="params">(<span class="keyword">int</span> j,ll n)</span> </span>&#123; <span class="keyword">return</span> query(id(j,n)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> j,ll n,ull v)</span> </span>&#123; insert(id(j,n),v); &#125;</span><br><span class="line">&#125;		</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x&lt;=lim?id0[x]:id1[n/x]; &#125;</span><br><span class="line"><span class="function">ull <span class="title">calc</span><span class="params">(ll n,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;pri[j]||n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	ull t=Hash::query(j,n); if(t!=-1) return t;</span></span><br><span class="line"><span class="comment">//	if(mp[j].count(n)) return mp[j][n];</span></span><br><span class="line">	<span class="keyword">int</span> x=getid(n); ull ans=g[x]-sg[j<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=j;i&lt;=num;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(pri[i]*(ll)pri[i]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">		ll l=pri[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> e=<span class="number">1</span>;l*pri[i]&lt;=n;++e,l*=pri[i]) &#123;</span><br><span class="line">			ull tmp=calc(n/l,i+<span class="number">1</span>);</span><br><span class="line">			ans+=l*(tmp+pri[i]);</span><br><span class="line">		<span class="comment">//	Ans+=l/pri[i]*tmp;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	Hash::insert(j,n,t);</span></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">	<span class="comment">//return mp[j][n]=ans;</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="function">ull <span class="title">solve</span><span class="params">(ll _n)</span> </span>&#123;</span><br><span class="line">	n=_n;</span><br><span class="line">	m=<span class="number">0</span>,Ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*	for(int i=1;i&lt;=num;++i) &#123;</span></span><br><span class="line"><span class="comment">		mp[i].clear();</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	Hash::init();</span><br><span class="line">	lim=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">	<span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">		ull v=n/l; r=n/v;</span><br><span class="line">		(v&lt;=lim?id0[v]:id1[n/v])=++m;</span><br><span class="line">		w[m]=v;</span><br><span class="line">		<span class="keyword">if</span>(v&amp;<span class="number">1</span>) g[m]=(v+<span class="number">2</span>)*((v<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">else</span> g[m]=((v+<span class="number">2</span>)/<span class="number">2</span>)*(v<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	printf("%d\n",m);</span></span><br><span class="line"><span class="comment">//	printf("%llu\n",g[1]);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i) &#123;</span><br><span class="line">		sg[i]=sg[i<span class="number">-1</span>]+pri[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) &#123;</span><br><span class="line">			<span class="keyword">if</span>(pri[i]*(ll)pri[i]&gt;w[j]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> k=getid(w[j]/pri[i]);</span><br><span class="line">			g[j]-=pri[i]*(g[k]-sg[i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(pri[i]*(ll)pri[i]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll l=pri[i];l*pri[i]&lt;=n;l*=pri[i]) &#123;</span><br><span class="line">			Ans+=l/pri[i]*calc(n/l,i+<span class="number">1</span>);</span><br><span class="line">			Ans+=l;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"factor.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"factor.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	getpri(<span class="number">100000</span>);</span><br><span class="line">	ll l,r;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;l,&amp;r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%llu\n"</span>,solve(r)-solve(l<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Miller-Rabin primality test</title>
    <url>/2022/07/15/Miller-Rabin-primality-test/</url>
    <content><![CDATA[<h3 id="Euclid’s-lemma"><a href="#Euclid’s-lemma" class="headerlink" title="Euclid’s lemma"></a>Euclid’s lemma</h3><blockquote>
<p>若素数$p$为$ab$的约数，那么$p$至少是$a$，$b$这两个数中的一个数的约数。也就是说，$p\mid ab,p\not\mid a \Rightarrow p\mid b$。</p>
</blockquote>
<p>它还有一个推广：</p>
<blockquote>
<p>如果$n$为$ab$的约数，并且$n$与$a$互质，那么$n\mid b$。</p>
</blockquote>
<p>一种证明的方法，是用Bézout’s lemma，即，若$x \bot y$，那么一定存在整数$r$，$s$，使得$rx + sy = 1$成立。</p>
<p>那么倘若$a\bot n$（如果$n$是质数，这等价于$n\not\mid a$），那么一定存在这样的$s$，$r$，使得$sa+rn = 1$。</p>
<p>等式两边同时乘$b$，得到$sab + rnb = b$。由于$n\mid ab$，所以$n\mid sab+rnb$，而等式左右两边相等，所以$n\mid b$。定理得证。</p>
<hr>
<h3 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h3><p>对于方程$x^2 \equiv 1 \mod p$，显然无论$p$取何值，这个方程一定有两个解，分别为$1$和$-1$。我们称$\pm 1$为$1$的<strong>平凡平方根（trivial square roots）</strong>。二次探测定理就是说，对于素数$p$，在模$p$的意义下不存在$1$的非平凡平方根。即，若$p$是素数，那么有$x^2 \equiv 1 \mod p \Rightarrow x\equiv 1 \text{ or } x\equiv -1 \mod p$。反之，倘若存在一个$x\not\equiv \pm 1 \mod p$并且$x^2 \equiv 1 \mod p$，那么$p$就不是素数。</p>
<p>证明如下：$x^2 \equiv 1 \mod p$，移项可以得到$x^2 -1 \equiv 0 \mod p$，也就是$(x-1)(x+1) \equiv 0\mod p$。换言之，$p\mid (x-1)(x+1)$。</p>
<p>由前面的Euclid’s lemma得到，$p\mid (x-1)$和$p\mid (x+1)$这两个式子中至少有一个成立。如果第一个成立的话，$x-1\equiv 0 \mod p \Rightarrow x\equiv 1\mod p$，而如果第二个成立，则$x+1\equiv 0\mod p \Rightarrow x\equiv -1 \mod p$。</p>
<p>综上，对于任意素数$p$，在模$p$的意义下不存在$1$的非平凡平方根。</p>
<hr>
<h3 id="Miller-Rabin-primality-test"><a href="#Miller-Rabin-primality-test" class="headerlink" title="Miller-Rabin primality test"></a>Miller-Rabin primality test</h3><p>这个算法就是基于前面的二次探测定理和费马小定理工作的。</p>
<p>过程如下：假设我们要检测的数为$p$。我们选取一个底数$a$，首先判断$a^{p-1}\equiv 1\mod p$是否成立，如果不成立直接返回false。否则，我们把$n-1$表示成$2^s\cdot d$的形式，其中$d$为奇数。如果$a^d\not \equiv 1$并且$[0,s)$中不存在$r$，使得$a^{d\cdot 2^r}\equiv -1 \mod p$成立，那么$p$一定不是质数。此时我们称$a$是$p$的一个 witness；否则，我们称$a$是$p$的一个 strong liar ，$p$是$a$的一个 strong probable prime。</p>
<p>也可以这样描述：选取底数$a$，首先判断$a^{p-1}\equiv 1\mod p$是否成立，不成立返回false。然后我们令$b=p-1$，我们判断$a^{b\over 2}\equiv \pm 1 \mod p$是否成立，不成立返回false。然后看此时的$a^{b\over 2}$，如果为$-1$就返回true（因为检查是否存在$-1$的非平凡平方根是没有意义的qwq），否则就继续检测$a^{b\over 4}\equiv \pm 1 \mod p$是否成立……</p>
<p>据说这样做，选择$k$个数作为底数，出错的概率是$4^{-k}$。</p>
<p>关于底数的选取：最好选择质数。如果选择$2,3,7,61,24251$，那么$10^{16}$以内唯一的强伪素数就是46856248255981。不过很多时候随机就已经够了。</p>
<hr>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Miller-Rabin primality test</span></span><br><span class="line"><span class="keyword">int</span> Test[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">61</span>,<span class="number">24251</span>&#125;,Tim=<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gao</span><span class="params">(ll x,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Pow(x,n<span class="number">-1</span>,n)!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll d=n<span class="number">-1</span>,t;</span><br><span class="line">	<span class="keyword">while</span>(!(d&amp;<span class="number">1</span>)) d&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>((t=Pow(x,d,n))==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(d&lt;=n<span class="number">-1</span>&amp;&amp;t!=<span class="number">1</span>&amp;&amp;t!=n<span class="number">-1</span>) t=Mul(t,t,n),d&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> t==n<span class="number">-1</span>;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Isprime</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Tim;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==Test[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!gao(Test[i],n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有生成64位随机数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ull <span class="title">Rand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	seed^=seed&lt;&lt;<span class="number">13</span>,seed^=seed&gt;&gt;<span class="number">7</span>,seed^=seed&lt;&lt;<span class="number">17</span>;</span><br><span class="line">	<span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test" target="_blank" rel="noopener">wikipedia</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucas定理</title>
    <url>/2022/07/15/Lucas%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>问题：求$C_n^m\mod p$，其中保证$p$为质数。</p>
<p>将$n,m$进行$p$进制展开：</p>
<script type="math/tex; mode=display">
n=\sum_{i=0}^k n_ip^i\\
m=\sum_{i=0}^k m_ip^i\\</script><p>则有</p>
<script type="math/tex; mode=display">
C_n^m \equiv \prod_{i=0}^k C_{n_i}^{m_i} \mod p</script><p>这就是<strong>Lucas定理</strong>。</p>
<p>利用生成函数证明：</p>
<p>首先，易得$\forall 0&lt; i &lt; p,p\mid C_p^i$</p>
<p>$\therefore (1+x)^p\equiv 1+x^p\mod p,(1+x)^{p^i}\equiv 1+x^{p^i}\mod p$</p>
<p>我们的目的是证明：$\sum_{m=0}^n C_n^mx^m=\sum_{m=0}^n(\prod_{i=0}^kC_{n_i}^{m_i})x^m\mod p$</p>
<script type="math/tex; mode=display">
\sum_{m=0}^n C_n^m x^m\\
=(1+x)^n\\
=\prod_{i=0}^k (1+x)^{n_ip^i}\\
=\prod_{i=0}^k ((1+x)^{p^i})^{n_i}\\
=\prod_{i=0}^k (1+x^{p^i})^{n_i}</script><p>这个时候对里面的这一项再进行二项式展开：</p>
<script type="math/tex; mode=display">
\prod_{i=0}^k (1+x^{p^i})^{n_i}\\
=\prod_{i=0}^k (\sum_{m_i=0}^{n_i}C_{n_i}^{m_i} x^{n_i{p^i}})</script><p>由于当$m_i&gt;n_i$时$C_{n_i}^{m_i}=0$，所以上面的式子可以等价地写成：</p>
<script type="math/tex; mode=display">
\prod_{i=0}^k(\sum_{m_i=0}^{p-1}C_{n_i}^{m_i}x^{n_ip^i})</script><p>考虑这个函数的$x^{m’}$次项，由于$m’$的$p$进制展开是唯一的，所以这一项的系数一定恰好等于$\prod C_{n_i}^{m’_i}$，其中$m’_i$为$m’$的$p$进制展开。</p>
<p>也就是说，这个函数等于$\sum_{m=0}^n(\prod_{i=0}^kC_{n_i}^{m_i})x^m$。得证。</p>
<p>另外一种证明方式：设$n=kp+r,m=ap+b$，其中$r&lt; p$，则</p>
<script type="math/tex; mode=display">
(1+x)^n\\
=(1+x)^{kp}(1+x)^r\\
=(1+x^p)^k(1+x)^r\\
=\sum_{i=0}^kC_k^ix^{pi}\sum_{j=0}^rC_r^j x^j\\
=\sum_{i=0}^k\sum_{j=0}^rC_k^iC_r^jx^{pi+j}</script><p>考虑$x^m$项的系数，左边是$C_n^m$，右边是$C_k^aC_r^b$，得证。</p>
<p>实现：<br>上面的定理可以写成：</p>
<script type="math/tex; mode=display">
C_n^m\mod p=C_{\lfloor {n\over p}\rfloor}^{\lfloor {m\over p}\rfloor}\times C_{n\mod p}^{m\mod p}</script><p>对于左边的一部分递归至$m=0$，右边的一部分，预处理阶乘及其逆元，$n,m&lt; p$，直接算就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> frc[n]*Inv[m]%mod*Inv[n-m]%mod;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> cal(n/mod,m/mod)*get(n%mod,m%mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Bell数的指数生成函数</title>
    <url>/2022/07/15/Bell%E6%95%B0%E7%9A%84%E6%8C%87%E6%95%B0%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>我们有$Bell$数的递推式：</p>
<script type="math/tex; mode=display">
b_{n+1} = \sum_{j=0}^n {n\choose j}b_j \\
=\sum_{j=0}^n {n!\over (n-j)!} {b_j \over j!}</script><p>设$B(x)$为它的指数生成函数，也就是$B(x) = \sum_{i=0}^{\infty} {b_i\over i!}x ^i $。</p>
<p>考虑</p>
<script type="math/tex; mode=display">
{b_{n+1}\over (n+1)!} = {1\over n+1} \sum_{j=0}^n {1\over (n-j)!}{b_j\over j!}</script><p>右边的式子相当于$B(x)$和$e^x$卷积，然后整体乘了个$x$并且在每一项的前面除以了这一项的次数加一。这相当于是积分。</p>
<p>于是我们对式子两边同时求导，就得到了</p>
<script type="math/tex; mode=display">
B'(x)= B(x)e^x</script><p>考虑</p>
<script type="math/tex; mode=display">
\ln'(B(x)) ={B'(x)\over B(x)} = e^x</script><p>两边同时积分可得</p>
<script type="math/tex; mode=display">
\ln(B(x)) = e^x +C</script><p>考虑如何解出这个$C$。把$b_0=1$带入，得到$\ln(1) = e^{0} + C$，故而$C=-1$，因此我们有$\ln(B(x)) = e^x-1$，也就是$B(x)= e^{e^x-1}$。</p>
<p>因此，贝尔数的指数生成函数是$e^{e^x-1}$。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树维护单调栈</title>
    <url>/2022/06/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<p>有一个序列，序列中的每一个元素有两个值$h_i$与$val_i$。你需要回答若干次询问，每一次询问针对于一个区间$[l,r]$，设$l\le p_1&lt;p_2\cdots p_k\le r$，其中$p_k$是$[l,r]$中$h_i$最大的位置，$p_{k-1}$是$[l,p_k-1]$中$h_i$最大的位置……你需要回答出这些位置的$val_i$的某些可以区间合并的信息（和/最大最小值……）。</p>
<p>可以对序列中元素的$h_i,val_i$进行修改。</p>
<hr>
<p>序列中一个区间的$p_1,p_2\cdots p_k$（我们暂且称这个东西为单调栈吧），和整个序列的单调栈，相比起来唯一的区别，就是这个区间的单调栈中最左边的若干个元素（甚至有可能是所有的元素），可能在原序列中由于在这个区间的左边有更大的元素而被弹掉了。</p>
<p>设$query(l,r,p)$表示对于区间$[l,r]$，我们在它的单调栈左边加入$p$之后，会得到的单调栈信息。设$mxh(l,r)$表示$[l,r]$中$h_i$的最大值。</p>
<p>1）假设$mxh(l,mid)&lt;p$，那么我们需要的信息是$query(mid+1,r,p)$。<br>2）否则，我们需要的信息是$query(l,mid,p)+query(mid+1,r,mxh(l,mid))$。</p>
<p>注意到这里的$query(mid+1,r,mxh(l,mid))$和$p$并没有任何关系，所以我们在线段树的每个节点上存下来就可以了。这样对线段树上的一个<strong>完整区间</strong>（线段树上有一个节点恰好表示这个区间）查询的复杂度是$T(n）=T(n/2)+O(1)=O(\log n)$的。</p>
<p>然而我们最终要查询的区间不一定是一个完整的区间。它在线段树上会被划分成$O(\log n)$的完整的区间。我们按照从左到右的顺序依次处理这些区间。对于第一个区间我们的$p$取$0$（比所有的$h_i$都要小的值），对于第$i$个区间，我们取第$i-1$个区间我们取的$p$和第$i-1$个区间的$maxh$两者中的较大值。这样查出来的信息的和就是整个区间的单调栈的信息。查询每个完整区间的复杂度是$O(\log n)$，所以查询的总复杂度是$O(log^2 n)$。</p>
<p>对于单点的修改，直接暴力改就可以了。然后我们需要重新计算$O(\log n)$个区间的$query(mid+1,r,mxh(l,mid))$。因此，修改的复杂度是$O(\log ^2 n)$的。</p>
<hr>
<h3 id="模板与例题"><a href="#模板与例题" class="headerlink" title="模板与例题"></a>模板与例题</h3><h4 id="jzoj5402-God-knows"><a href="#jzoj5402-God-knows" class="headerlink" title="jzoj5402 God knows"></a>jzoj5402 God knows</h4><p>有一个$1$到$n$的排列$p_1,p_2\cdots p_n$。平面内有$2n$个点，它们（像二分图一样）排成两排。第一排的点的坐标是$(1,0),(2,0)\cdots (n,0)$，第二排的点的坐标是$(1,1),(2,1),\cdots (n,1)$。第一排的第$i$个点和第二排的第$p_i$个点之间有一条线段。你可以花费$c_i$的代价删除第$i$个点与第$p_i$个点之间的连线，并且删除所有与这条线有交的线段。问最少需要多少的代价，才能够把所有的线段全部删掉。$n\le 10^5$</p>
<p>Solution：</p>
<p>考虑一种$O(n^2)$的$dp$：设$f[i]$表示前$i$条线全部被删除，并且我们选择了第$i$条线的最小代价，那么有</p>
<script type="math/tex; mode=display">
f_i = \min\{ f_j \mid j<i 并且 p_j < i 并且不存在 k\in (j,i),p_j < p_k < p_i \}</script><p>那么，我们对于$i$，我们可行的转移点$j$一定满足对于所有的$p_k\in (p_j,p_i)$，$k$一定都小于$j$。这是一个区间$[1,p_i]$的单调栈，可以用线段树维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,inf=<span class="number">2e9</span>+<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls c&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs c&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">int</span> mx[N&lt;&lt;<span class="number">2</span>],mi[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123; <span class="keyword">return</span> mx[c]&gt;p?mi[c]:inf; &#125; <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;mx[rs]) <span class="keyword">return</span> min(mi[c],query(mid+<span class="number">1</span>,r,rs,p));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(l,mid,ls,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	mx[c]=max(mx[ls],mx[rs]); <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	mi[c]=query(l,mid,ls,mx[rs]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ql,qr,qv,qt,qans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123; mx[c]=qv,mi[c]=qt; <span class="keyword">return</span>; &#125; <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;=mid) update(l,mid,ls,p); <span class="keyword">else</span> update(mid+<span class="number">1</span>,r,rs,p); push_up(c,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) &#123;</span><br><span class="line">		qans=min(qans,query(l,r,c,p));</span><br><span class="line">		p=max(p,mx[c]); <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) Query(mid+<span class="number">1</span>,r,rs,p);</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) Query(l,mid,ls,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N],c[N],f[N],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	qv=x,qt=f[x];</span><br><span class="line">	update(<span class="number">0</span>,n,<span class="number">1</span>,a[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"knows.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"knows.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(c[i]);</span><br><span class="line">	<span class="built_in">memset</span>(mi,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(mi)); <span class="comment">// ?!</span></span><br><span class="line">	<span class="built_in">memset</span>(mx,<span class="number">-1</span>,<span class="keyword">sizeof</span>(mx));</span><br><span class="line">	c[n+<span class="number">1</span>]=<span class="number">0</span>,a[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">	Update(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i) &#123;</span><br><span class="line">		ql=<span class="number">0</span>,qr=a[i]<span class="number">-1</span>,qans=inf;</span><br><span class="line">		<span class="keyword">int</span> tmp=<span class="number">-1</span>; Query(<span class="number">0</span>,n,<span class="number">1</span>,tmp);</span><br><span class="line">		f[i]=qans+c[i];</span><br><span class="line">		<span class="keyword">if</span>(i==n+<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		Update(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[n+<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>练习题：<br><a href="https://www.luogu.org/proablemnew/show/P4425" target="_blank" rel="noopener">HNOI2018 转盘</a><br><a href="https://jzoj.net/senior/#main/show/6172" target="_blank" rel="noopener">排序二叉树</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>析合树</title>
    <url>/2022/06/30/%E6%9E%90%E5%90%88%E6%A0%91/</url>
    <content><![CDATA[<h3 id="定义-amp-结构"><a href="#定义-amp-结构" class="headerlink" title="定义 &amp; 结构"></a>定义 &amp; 结构</h3><h4 id="连续段"><a href="#连续段" class="headerlink" title="连续段"></a>连续段</h4><ul>
<li>对于一个排列$A$，我们定义$[l,r]$是连续段，当且仅当这个区间的值域也是连续的一段。即，不存在$x,y,z$，$x,y\in [l,r]\wedge z\not\in [l,r]\wedge  A_x &lt; A_z &lt; A_y$。也等价于$\max \{ A_k \mid k\in [l,r] \} - \min \{ A_k \mid k\in [l,r] \} = r-l$。</li>
<li>连续段有一个很好的性质：考虑两个相交且不互相包含的连续段$x,y$，总有$x\cup y$、$x\cap y$、$x\setminus (x \cap y)$、$y\setminus (x\cap y)$是连续段。</li>
</ul>
<h4 id="本原连续段"><a href="#本原连续段" class="headerlink" title="本原连续段"></a>本原连续段</h4><ul>
<li>如果对于某一个连续段$[l,r]$，不存在另外任意一个连续段与它有交且不包含，那么我们称这个连续段为本原连续段。</li>
<li>由定义可以看出来，所有的本原连续段构成树形结构，每一个点的父亲是包含它的、长度最短的本原连续段。</li>
</ul>
<h4 id="析点、合点"><a href="#析点、合点" class="headerlink" title="析点、合点"></a>析点、合点</h4><p>考虑某一个本原连续段的儿子集合：</p>
<ul>
<li>合点<ul>
<li>如果这些儿子中某相邻的两个拼起来是连续段，那么这点的任意若干个位置连续的儿子拼起来得到的一定是连续段。我们称这样的点是合点。</li>
<li>合点至少有两个儿子。</li>
<li>一种证明方法是这样的：<ul>
<li>假设儿子序列的长度为$n$，枚举这个序列的非平凡连续段（长度不为 $1$ 或者 $n$），那么所有的连续段的并一定是整个序列，并且序列中的每一个点都作为若干个非平凡连续段的交出现——否则就会出现非平凡本原连续段，这是不符合定义的。</li>
<li>这也就意味着，$[1,n)$的每一个点至少是一个非平凡连续段的左端点，$(1,n]$的每一个点至少是一个非平凡连续段的右端点。</li>
<li>证明 $[l,r]$ 是连续段：把以$l,l+1,l+2\cdots n-1$为左端点的非平凡连续段取并就得到$[l,n]$，把以$r,r-1,\cdots 2$为右端点的非平凡连续段取并得到$[r,1]$，再把$[l,n]$和$[1,r]$取交就可以了。</li>
</ul>
</li>
</ul>
</li>
<li>析点<ul>
<li>任意两个相邻的儿子拼起来都不是连续段。我们称这样的点为析点。</li>
<li>析点至少有四个儿子。</li>
</ul>
</li>
<li>特别地，叶子节点没有儿子，我们认为叶子节点是合点。整棵树一定恰好包含$n$个叶子节点。</li>
</ul>
<p>另外还有一个结论：一个形态合法（包含$n$个叶子节点，点有析点和合点两种，析点至少有四个儿子，合点至少有两个儿子）的析合树唯一对应到一个集合$I$，$I$中所有的区间都是连续段并且不在$I$中的所有区间都不是连续段，并且一定可以构造出一个排列它的连续段集合是$I$。</p>
<hr>
<h3 id="构建方法-0"><a href="#构建方法-0" class="headerlink" title="构建方法 - 0"></a>构建方法 - 0</h3><p>下面是一种空间 $O(n\log n)$，时间 $O(n\log n)$ 的构建方法。</p>
<p>从$[1,n]$开始递归建树。假设当前的区间是$[l,r]$，我们需要找出这个点的儿子是哪些区间，并且还需要判断这个点是析点还是合点。</p>
<p>首先，找出最大的$y\in [l,r)$满足$[l,y]$是连续段，找出最小的$x\in (l,r]$满足$x$是连续段。</p>
<p>如果$x\le y+1$，那么当前点是合点，否则，当前点是析点。</p>
<p>如果当前点是析点：$[l,y]$就是当前点的第一个儿子。然后再找$[y+1,r)$最靠右的$y’$满足$[y+1,y’]$是连续段段，则$[y+1,y’]$是第二个儿子。以此类推可以找出当前点所有的儿子。</p>
<p>如果当前点是合点：$[l,x-1]$是当前点的第一个儿子。然后找$[x’,y+1]$（注意边界不是$r$！）最靠左的$x’$满足$[x’,r]$是连续段，则$[x,x’-1]$是第二个儿子。以此类推。最后一个儿子是$[y+1,r]$。</p>
<p>最后还剩一个问题：如何对于$[l,r]$，找出最靠右的$x$满足$[l,x]$是连续段。</p>
<p>一个区间$[l,r]$是连续段等价于$\sum_{i\in [1,n)} [p_i \in [l,r] \vee p_{i+1} \in [l,r] ] = r-l $，其中$p_i$表示$i$这个值在排列中出现的位置。这个可以提前用扫描线+主席树预处理出来，查询的时候就是查询第$l$棵线段树上$r$左侧的最靠右的$1$的位置。</p>
<p>jzoj6202</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=N*<span class="number">30</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">cmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>,<span class="title">T</span> <span class="title">y</span>) &#123;</span> <span class="keyword">if</span>(y&gt;x) x=y; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">cmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>,<span class="title">T</span> <span class="title">y</span>) &#123;</span> <span class="keyword">if</span>(y&lt;x) x=y; &#125;</span><br><span class="line"><span class="keyword">int</span> A[N&gt;&gt;<span class="number">1</span>],P[N&gt;&gt;<span class="number">1</span>],n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> mi[M],tag[M];</span><br><span class="line">	<span class="keyword">int</span> ls[M],rs[M],ncnt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; mi[<span class="number">0</span>]=<span class="number">1e9</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> t)</span> </span>&#123; mi[c]+=t,tag[c]+=t; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; mi[c]=min(mi[ls[c]],mi[rs[c]])+tag[c]; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">cpy</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u=++ncnt;</span><br><span class="line">		ls[u]=ls[c],rs[u]=rs[c];</span><br><span class="line">		mi[u]=mi[c],tag[u]=tag[c];</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ql,qr,qt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;c)</span> </span>&#123;</span><br><span class="line">		c=++ncnt;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		build(l,mid,ls[c]),build(mid+<span class="number">1</span>,r,rs[c]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c1,<span class="keyword">int</span> &amp;c2)</span> </span>&#123;</span><br><span class="line">		c2=cpy(c1);</span><br><span class="line">		<span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) <span class="keyword">return</span> add(c2,qt);</span><br><span class="line">		<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ql&lt;=mid) update(l,mid,ls[c1],ls[c2]);</span><br><span class="line">		<span class="keyword">if</span>(qr&gt;mid) update(mid+<span class="number">1</span>,r,rs[c1],rs[c2]);</span><br><span class="line">		push_up(c2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> tg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		printf("%d %d\n",mi[c],tg);</span></span><br><span class="line">		<span class="keyword">if</span>(mi[c]+tg&gt;<span class="number">1</span>) <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; tg+=tag[c];</span><br><span class="line">		<span class="keyword">if</span>(mi[ls[c]]+tg&gt;<span class="number">1</span>) <span class="keyword">return</span> query(mid+<span class="number">1</span>,r,rs[c],tg);</span><br><span class="line">		<span class="keyword">return</span> query(l,mid,ls[c],tg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> tg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		printf("%d %d %d\n",l,r,tg);</span></span><br><span class="line">		<span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) <span class="keyword">return</span> query(l,r,c,tg);</span><br><span class="line">		<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=n+<span class="number">1</span>; tg+=tag[c];</span><br><span class="line">		<span class="keyword">if</span>(ql&lt;=mid) cmin(ans,Query(l,mid,ls[c],tg));</span><br><span class="line">		<span class="keyword">if</span>(qr&gt;mid) cmin(ans,Query(mid+<span class="number">1</span>,r,rs[c],tg));</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> rt[N];</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; ql=l,qr=r; <span class="keyword">return</span> Query(<span class="number">1</span>,n,rt[r],<span class="number">0</span>); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">predo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		init();</span><br><span class="line">		build(<span class="number">1</span>,n,rt[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) P[A[i]]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123; <span class="comment">// r=i</span></span><br><span class="line">			ql=<span class="number">1</span>,qr=i,qt=<span class="number">1</span>; update(<span class="number">1</span>,n,rt[i<span class="number">-1</span>],rt[i]);</span><br><span class="line">			<span class="keyword">if</span>(A[i]&gt;<span class="number">1</span>&amp;&amp;P[A[i]<span class="number">-1</span>]&lt;i) ql=<span class="number">1</span>,qr=P[A[i]<span class="number">-1</span>],qt=<span class="number">-1</span>,update(<span class="number">1</span>,n,rt[i],rt[i]);</span><br><span class="line">			<span class="keyword">if</span>(A[i]&lt;n&amp;&amp;P[A[i]+<span class="number">1</span>]&lt;i) ql=<span class="number">1</span>,qr=P[A[i]+<span class="number">1</span>],qt=<span class="number">-1</span>,update(<span class="number">1</span>,n,rt[i],rt[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;trl,trr;</span><br><span class="line"><span class="keyword">int</span> lv[N],rv[N],ty[N],ncnt;</span><br><span class="line"><span class="keyword">int</span> dep[N],p[N][<span class="number">19</span>];</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Q1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">int</span> ans=n+<span class="number">1</span>-trl.Q(n-r+<span class="number">1</span>,n-l+<span class="number">1</span>); <span class="keyword">return</span> ans; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Q2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">int</span> ans=trr.Q(l,r); <span class="keyword">return</span> ans; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c=++ncnt; p[c][<span class="number">0</span>]=f; dep[c]=dep[f]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">18</span>;++j) p[c][j]=p[p[c][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">	lv[c]=l,rv[c]=r;</span><br><span class="line"><span class="comment">//	printf("%d: %d %d  fa = %d\n",c,l,r,f);</span></span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		ty[c]=<span class="number">0</span>; pos[l]=c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> y=Q1(l,r<span class="number">-1</span>),x=Q2(l+<span class="number">1</span>,r); <span class="comment">// [l,y], [x,r]</span></span><br><span class="line"><span class="comment">//	printf(" [l,y]: %d [r,x]: %d %d\n",y,x,y&lt;x-1);</span></span><br><span class="line">	<span class="keyword">if</span>(y&lt;x<span class="number">-1</span>) &#123;</span><br><span class="line">		ty[c]=<span class="number">1</span>; build(l,y,c);</span><br><span class="line">		<span class="keyword">while</span>(y&lt;r) &#123;</span><br><span class="line">			<span class="keyword">int</span> z=Q1(y+<span class="number">1</span>,r); build(y+<span class="number">1</span>,z,c);</span><br><span class="line">			y=z;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ty[c]=<span class="number">0</span>; build(l,x<span class="number">-1</span>,c);</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> z=Q2(x+<span class="number">1</span>,r);</span><br><span class="line">			<span class="keyword">if</span>(z==n+<span class="number">1</span>||z&gt;y+<span class="number">1</span>) &#123; build(x,r,c); <span class="keyword">break</span>; &#125;</span><br><span class="line">			build(x,z<span class="number">-1</span>,c);	x=z;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	seg(<span class="keyword">int</span> l=<span class="number">0</span>,<span class="keyword">int</span> r=<span class="number">0</span>): l(l),r(r) &#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (seg A,seg B) &#123; <span class="keyword">return</span> A.r-A.l&lt;B.r-B.l; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">seg <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> seg(l,r);</span><br><span class="line">	<span class="keyword">int</span> x=pos[l],y=pos[r];</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">18</span>;j&gt;=<span class="number">0</span>;--j) <span class="keyword">if</span>(dep[x]-(<span class="number">1</span>&lt;&lt;j)&gt;=dep[y]) x=p[x][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">18</span>;j&gt;=<span class="number">0</span>;--j) <span class="keyword">if</span>(p[x][j]!=p[y][j]) x=p[x][j],y=p[y][j];</span><br><span class="line">	<span class="keyword">if</span>(ty[p[x][<span class="number">0</span>]]) <span class="keyword">return</span> seg(lv[p[x][<span class="number">0</span>]],rv[p[x][<span class="number">0</span>]]);</span><br><span class="line">	<span class="keyword">return</span> max(seg(lv[y],rv[x]),seg(lv[x],rv[y]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	freopen("interval1.in","r",stdin);</span></span><br><span class="line">	freopen(<span class="string">"c.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"c.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(A[i]);</span><br><span class="line">	trr.predo();</span><br><span class="line">	reverse(A+<span class="number">1</span>,A+n+<span class="number">1</span>);</span><br><span class="line">	trl.predo();</span><br><span class="line"><span class="comment">//	int q; rd(q);</span></span><br><span class="line"><span class="comment">//	while(q--) &#123;</span></span><br><span class="line"><span class="comment">//		int l,r; rd(l),rd(r);</span></span><br><span class="line"><span class="comment">//		printf("mxr = %d  minl =%d\n",Q1(l,r),Q2(l,r));</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	build(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> q,l,r; rd(q);</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		rd(l),rd(r);</span><br><span class="line">		seg ans=Query(l,r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans.l,ans.r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法 - 1"></a>构造方法 - 1</h3><p>参考 <a href="https://oi-wiki.org/ds/divide-combine/#_10" target="_blank" rel="noopener">OI-wiki</a></p>
<p>下面介绍一种空间 $O(n)$，时间 $O(n\log n)$ 的构造方法。</p>
<p>设 $L_i$ 为最小的 $l$ 满足 $[l,i]$ 为连续段。</p>
<p>增量法，用一个栈维护已经处理过的元素构成的析合树森林。具体来说，处理完前 $i$ 个元素之后，栈中存储了 $[L_i,i], [L_{L_i-1}, L_i - 1], [L_{L_{L_{L_i-1}}-1},L_{L_{L_i-1}}-1] \cdots$ 这些区间的析合树。</p>
<p>新加入一个结点（或者一个子树的根），可能的情况有：</p>
<ul>
<li>栈顶元素是合点，并且新加入的结点可以作为栈顶元素的儿子<ul>
<li>弹出栈顶元素，将新加入的点加入栈顶元素的儿子集合，再尝试插入栈顶元素</li>
</ul>
</li>
<li>新加入的结点和栈顶元素构成了合点<ul>
<li>弹出栈顶元素，新建一个合点，把新加入的结点和栈顶元素设置成它的儿子，再尝试插入新建的合点</li>
</ul>
</li>
<li>新加入的元素和栈顶部的若干个元素一起构成了析点<ul>
<li>弹出涉及到的栈中元素，新建一个析点，把新加入的结点和涉及到的栈中元素都设置成它的儿子，再尝试插入新建的析点</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GalaxyOJ 2121. 简单数据结构题 (2020联测#6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pos[N],n,K;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (c&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (c&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">int</span> mxv[N*<span class="number">4</span>],tg[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> t)</span> </span>&#123; mxv[c]+=t,tg[c]+=t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;	<span class="keyword">if</span>(tg[c]) add(ls,tg[c]),add(rs,tg[c]),tg[c]=<span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; mxv[c]=max(mxv[ls],mxv[rs]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="keyword">void</span>)(mxv[c]=l);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(l,mid,ls),build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ql,qr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) <span class="keyword">return</span> add(c,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) upd(l,mid,ls);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) upd(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;"Q:"&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;c&lt;&lt;':'&lt;&lt;mxv[c]&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">if</span>(r&lt;=qr) &#123;</span><br><span class="line">		<span class="keyword">if</span>(mxv[c]&lt;qr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">		<span class="keyword">int</span> tmp=Q(l,mid,ls);</span><br><span class="line">		<span class="keyword">return</span> tmp?tmp:Q(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(qr&lt;=mid) <span class="keyword">return</span> Q(l,mid,ls);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp=Q(l,mid,ls);</span><br><span class="line">		<span class="keyword">return</span> tmp?tmp:Q(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">jud</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mxv[c]&lt;qr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) <span class="keyword">return</span> jud(l,mid,ls);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> jud(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">jud</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	ql=x;</span><br><span class="line">	<span class="keyword">return</span> jud(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addson</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	son[f].PB(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N&lt;&lt;<span class="number">1</span>],top,ncnt;</span><br><span class="line"><span class="keyword">int</span> lv[N&lt;&lt;<span class="number">1</span>],rv[N&lt;&lt;<span class="number">1</span>],typ[N&lt;&lt;<span class="number">1</span>],hp[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">	<span class="comment">//	cerr&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(p[i]&gt;<span class="number">1</span>&amp;&amp;pos[p[i]<span class="number">-1</span>]&lt;i) &#123;</span><br><span class="line">			ql=<span class="number">1</span>,qr=pos[p[i]<span class="number">-1</span>];</span><br><span class="line">			upd(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p[i]&lt;n&amp;&amp;pos[p[i]+<span class="number">1</span>]&lt;i) &#123;</span><br><span class="line">			ql=<span class="number">1</span>,qr=pos[p[i]+<span class="number">1</span>];</span><br><span class="line">			upd(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		qr=i; <span class="keyword">int</span> lb=Q(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> now=++ncnt;</span><br><span class="line">		lv[now]=rv[now]=i,typ[now]=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//	cout&lt;&lt;i&lt;&lt;' '&lt;&lt;lb&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">while</span>(top&amp;&amp;lv[now]&gt;lb) &#123;</span><br><span class="line">		<span class="comment">//while(top&amp;&amp;lv[st[top]]&gt;=lb) &#123;</span></span><br><span class="line">		<span class="comment">//	cout&lt;&lt;now&lt;&lt;' '&lt;&lt;lb&lt;&lt;' '&lt;&lt;top&lt;&lt;endl;</span></span><br><span class="line">			<span class="keyword">if</span>(typ[st[top]]&amp;&amp;jud(hp[st[top]])) &#123;</span><br><span class="line">			<span class="comment">//	cout&lt;&lt;"HERE 1 "&lt;&lt;endl;</span></span><br><span class="line">				rv[st[top]]=i,addson(st[top],now);</span><br><span class="line">				now=st[top--];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(jud(lv[st[top]])) &#123;</span><br><span class="line">			<span class="comment">//	cout&lt;&lt;"HERE 2 "&lt;&lt;endl;</span></span><br><span class="line">				<span class="keyword">int</span> cur=++ncnt;</span><br><span class="line">				typ[cur]=<span class="number">1</span>,addson(cur,st[top]),addson(cur,now);</span><br><span class="line">				lv[cur]=lv[st[top]],rv[cur]=i,hp[cur]=lv[now],</span><br><span class="line">				top--,now=cur;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//	cout&lt;&lt;"HERE 3 "&lt;&lt;endl;</span></span><br><span class="line">				<span class="keyword">int</span> cur=++ncnt;</span><br><span class="line">				addson(cur,now);</span><br><span class="line">				do addson(cur,st[top]),lv[cur]=lv[st[top]];</span><br><span class="line">				<span class="keyword">while</span>(top&amp;&amp;!jud(lv[st[top--]]));</span><br><span class="line">				typ[cur]=<span class="number">0</span>,rv[cur]=i;		</span><br><span class="line">				now=cur;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		st[++top]=now;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> gao &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; len;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; len.PB(x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">-1</span>,tot=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len.size();++i) &#123;</span><br><span class="line">			<span class="keyword">while</span>(j+<span class="number">1</span>&lt;len.size()&amp;&amp;tot&lt;K)</span><br><span class="line">				++j,tot+=len[j];</span><br><span class="line">			ans=(ans+<span class="number">1l</span>l*((<span class="keyword">int</span>)len.size()<span class="number">-1</span>-j)*(len.size()-j)/<span class="number">2</span>%mod*i%mod)%mod;</span><br><span class="line">			tot-=len[i];</span><br><span class="line">		&#125;</span><br><span class="line">		len.clear();</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	freopen("ex_data1.in","r",stdin);</span></span><br><span class="line">	rd(n),rd(K);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(p[i]),pos[p[i]]=i;</span><br><span class="line">	build();</span><br><span class="line"><span class="comment">//	cerr&lt;&lt;"OK"&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=ncnt;++u) <span class="keyword">if</span>(typ[u]) &#123;</span><br><span class="line">		<span class="comment">//printf("%d (%d, %d) : ",u,lv[u],rv[u]);</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;son[u].size();++j) gao::ad(rv[son[u][j]]-lv[son[u][j]]+<span class="number">1</span>); <span class="comment">//,printf("(%d, %d) ",lv[son[u][j]],rv[son[u][j]]);</span></span><br><span class="line">		<span class="comment">//puts("");</span></span><br><span class="line">		ans=(ans+gao::sol())%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="number">2l</span>l*ans%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考：<a href="https://www.cnblogs.com/Mr-Spade/p/10415180.html" target="_blank" rel="noopener">https://www.cnblogs.com/Mr-Spade/p/10415180.html</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树上路径数颜色（树上莫队）</title>
    <url>/2022/06/30/%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84%E6%95%B0%E9%A2%9C%E8%89%B2%EF%BC%88%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%EF%BC%89/</url>
    <content><![CDATA[<p>参考：<a href="https://codeforces.com/blog/entry/43230" target="_blank" rel="noopener">一篇cf上的很好的blog</a></p>
<p>食用方法：树上路径数颜色。</p>
<p>我们构造一棵树的括号序：即，dfs一棵树的时候，在发现一个节点时，记此时的$idx$为这个节点的$In$，然后让$idx++$；结束对一个节点的访问时，记此时的$idx$为这个节点的$Out$，然后让$idx++$。这样，$u$和$v$之间路径，就转化括号序中的区间$[Out_u,In_v]$，其中我们要求区间中出现了$0$次或者$2$次的节点都不计贡献（说白了就是挪指针的时候进行类似异或的操作），即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) ans-=buc[c[u]]==<span class="number">1</span>,buc[c[u]]--;</span><br><span class="line">    <span class="keyword">else</span> ans+=buc[c[u]]==<span class="number">0</span>,buc[c[u]]++;</span><br><span class="line">    vis[u]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们还需要特判LCA，因为LCA的贡献可能没有被计算到。</p>
<p>模板：<a href="https://www.spoj.com/problems/COT2/" target="_blank" rel="noopener">SPOJ Count on a Tree II</a> 树上路径数颜色</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2^16 = 65536</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">40010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> pos[N&lt;&lt;<span class="number">1</span>],vis[N],p[N][<span class="number">17</span>],head[N],dep[N],n,ecnt,c[N],b[N],id;</span><br><span class="line"><span class="keyword">int</span> In[N],Out[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span><span class="keyword">int</span> to,next;&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++ecnt]=(ed)&#123;y,head[x]&#125;; head[x]=ecnt;</span><br><span class="line">	e[++ecnt]=(ed)&#123;x,head[y]&#125;; head[y]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[u]=dep[last]+<span class="number">1</span>,p[u][<span class="number">0</span>]=last,In[u]=++id,pos[id]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">17</span>;++j) p[u][j]=p[p[u][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=head[u];k;k=e[k].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[k].to; <span class="keyword">if</span>(v==last) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	Out[u]=++id,pos[id]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> buc[N],ans,Ans[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u]) ans-=buc[c[u]]==<span class="number">1</span>,buc[c[u]]--;</span><br><span class="line">	<span class="keyword">else</span> ans+=buc[c[u]]==<span class="number">0</span>,buc[c[u]]++;</span><br><span class="line">	vis[u]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Que</span>&#123;</span><span class="keyword">int</span> l,r,id,L;&#125;Q[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">16</span>;j&gt;=<span class="number">0</span>;--j) <span class="keyword">if</span>(dep[x]-(<span class="number">1</span>&lt;&lt;j)&gt;=dep[y]) x=p[x][j]; <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">16</span>;j&gt;=<span class="number">0</span>;--j) <span class="keyword">if</span>(p[x][j]!=p[y][j]) x=p[x][j],y=p[y][j]; <span class="keyword">return</span> p[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Que A,Que B)</span></span>&#123;<span class="keyword">if</span>((A.l+<span class="number">1</span>)/T==(B.l+<span class="number">1</span>)/T) <span class="keyword">return</span> A.r&lt;B.r;<span class="keyword">return</span> A.l&lt;B.l;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) Rev(pos[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m,x,y,tmp; read(n),read(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) read(c[i]),b[i]=c[i];</span><br><span class="line">	sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>); <span class="keyword">int</span> sz=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) c[i]=lower_bound(b+<span class="number">1</span>,b+sz+<span class="number">1</span>,c[i])-b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) read(x),read(y),ad(x,y);</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=2*n;++i) cout&lt;&lt;pos[i]&lt;&lt;' '; cout&lt;&lt;endl;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		read(x),read(y),Q[i].id=i;</span><br><span class="line">		<span class="keyword">int</span> L=LCA(x,y); <span class="keyword">if</span>(In[x]&gt;In[y]) swap(x,y);</span><br><span class="line">		<span class="keyword">if</span>(L==x||L==y) Q[i].l=In[x],Q[i].r=In[y];</span><br><span class="line">		<span class="keyword">else</span> Q[i].l=Out[x],Q[i].r=In[y],Q[i].L=L;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;Q[i].l&lt;&lt;' '&lt;&lt;Q[i].r&lt;&lt;' '&lt;&lt;Q[i].L&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	T=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n*<span class="number">2</span>)); sort(Q+<span class="number">1</span>,Q+m+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">int</span> L=Q[<span class="number">1</span>].l,R=Q[<span class="number">1</span>].r; <span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;=R;++i) Rev(pos[i]);</span><br><span class="line">	<span class="keyword">if</span>(Q[<span class="number">1</span>].L) Rev(Q[<span class="number">1</span>].L); Ans[Q[<span class="number">1</span>].id]=ans; <span class="keyword">if</span>(Q[<span class="number">1</span>].L) Rev(Q[<span class="number">1</span>].L);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Update(L,Q[i].l<span class="number">-1</span>),Update(Q[i].l,L<span class="number">-1</span>);</span><br><span class="line">		Update(Q[i].r+<span class="number">1</span>,R),Update(R+<span class="number">1</span>,Q[i].r);</span><br><span class="line">		<span class="keyword">if</span>(Q[i].L) Rev(Q[i].L);</span><br><span class="line">		Ans[Q[i].id]=ans;</span><br><span class="line">		<span class="keyword">if</span>(Q[i].L) Rev(Q[i].L);</span><br><span class="line">		L=Q[i].l,R=Q[i].r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>treap, 无旋treap(fhq treap)及可持久化</title>
    <url>/2022/06/30/treap-%E6%97%A0%E6%97%8Btreap-fhq-treap-%E5%8F%8A%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="treap"><a href="#treap" class="headerlink" title="treap"></a>treap</h2><p>treap，又叫树堆。我们可以用它去维护一个序列，或者一个集合。裸的带旋的treap可以支持插入，删除，查第$k$大，查排名，以及其他的二叉搜索树的操作；无旋treap可以支持所有splay支持的操作（区间修改，翻转，覆盖，信息合并等等），操作的复杂度是$O(\log n)$的，并且不是均摊的！</p>
<hr>
<h3 id="关于treap的形态"><a href="#关于treap的形态" class="headerlink" title="关于treap的形态"></a>关于treap的形态</h3><p>它是一棵二叉树，并且，从原序列的结构上来看，它是一棵二叉搜索树，中序遍历拖出来可以得到原来的序列；而每个节点还有一个随机的权值$key$，从$key$上来看，整棵树满足堆的性质。（下面我们都假设是小根堆）</p>
<blockquote>
<p>性质1：对于一个序列，每个点的$key$之间的大小关系确定的前提下，这个序列构造出来的treap是唯一的</p>
</blockquote>
<p>（哦对了这个treap也是一个笛卡尔树）</p>
<p>我们考虑这个序列中$key$最小的那个位置，它必须是树的根（因为是堆）。然后它左边的那些位置必须在它的左子树内，右边那些位置则必须在它的右子树内（因为它是二叉搜索树）。并且它左边的、$key$最小的那个位置一定是它的左儿子（因为是堆）……这样下来，我们会发现这棵树形态是唯一确定的。</p>
<blockquote>
<p>性质2：一个随机生成的长度为$n$的序列，它的笛卡尔树的高度期望是$O(\log n)$。</p>
</blockquote>
<p>证明算法导论上面有，可是我太菜了看不懂qwq。</p>
<hr>
<h3 id="关于随机权值"><a href="#关于随机权值" class="headerlink" title="关于随机权值"></a>关于随机权值</h3><p>LYC建议我用xorshift，因为stl自带的rand()值域小而且慢。<br>下面这个写法，循环节是$2^{32}-1$，$seed$初始化为一个非$0$的数就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line">uint seed=<span class="number">19260817</span>;</span><br><span class="line"><span class="function">uint <span class="title">Rand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seed^=seed&lt;&lt;<span class="number">13</span>,seed^=seed&gt;&gt;<span class="number">17</span>,seed^=seed&lt;&lt;<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://en.wikipedia.org/wiki/Xorshift" target="_blank" rel="noopener">wiki上的介绍（点击References处的链接可以下载论文）</a></p>
<hr>
<h3 id="带旋treap"><a href="#带旋treap" class="headerlink" title="带旋treap"></a>带旋treap</h3><p>我没有写过呢，因为感觉它没啥用。</p>
<p>大概的实现原理就是，插入一个数的时候，先把这个数在叶子的位置插入（要保证满足二叉搜索树的性质），然后它的$key$可能就不满足堆的性质了，我们就可以把它向上旋转（和splay类似，旋转后二叉搜索树的性质仍然满足，而该节点和父亲的位置交换了）。删除的时候，先把这个点向下旋转到叶子（选择$key$较小的儿子把它旋上来），然后把这个点删掉。其他操作和二叉搜索树是一样的。</p>
<p>而且这个东西还不能支持区间操作，简直不如 01 Trie。</p>
<p>参考这篇<a href="https://www.luogu.org/blog/zhongyuwei/solution-p5055" target="_blank" rel="noopener">blog</a></p>
<hr>
<h3 id="无旋treap"><a href="#无旋treap" class="headerlink" title="无旋treap"></a>无旋treap</h3><p>（又叫fhq treap）这是个好东西，splay支持的东西（什么区间翻转啊，区间修改啊）它都支持，而且还比splay好写，而且还可以可持久化！</p>
<p>它的操作依赖于两个函数：<br>1.split：<br>1）将树的中序遍历里面的前$k$个节点分离出来，形成两个treap，一个里面是前$k$个节点，另一个里面是后$n-k$个节点。<br>2）（如果这棵树上的节点是对于$val$满足二叉搜索树的性质）将树中$val$小于等于$x$的节点分离到第一棵treap中，将其他的节点分离到第二棵treap当中。<br>2.merge：将两个treap（要求第一个treap的节点的$val$，也就是我们要让它满足二叉搜索树性质的那一维，必须全部小于第二个$treap$的节点的$val$）合并为一个treap。</p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>假设第一个treap的根为$a$，第二个treap的根为$b$，那么分两种情况讨论：<br>1）$a$的$key$小于$b$的$key$，那么$a$应该在$b$的上面，又因为要满足二叉搜索树的性质，所以合并$a$的右儿子与$b$即可。<br>2）否则，合并$b$的左儿子与$a$即可。</p>
<p>我实在是不知道它是怎么想出来的，不过它显然是对的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!a||!b)&#123;r=a+b; <span class="keyword">return</span>;&#125;</span><br><span class="line">	push_down(a),push_down(b);</span><br><span class="line">	<span class="keyword">if</span>(key[a]&lt;=key[b]) merge(ch[r=a][<span class="number">1</span>],ch[a][<span class="number">1</span>],b);</span><br><span class="line">	<span class="keyword">else</span> merge(ch[r=b][<span class="number">0</span>],a,ch[b][<span class="number">0</span>]);</span><br><span class="line">	push_up(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>分离出前$k$个节点：我们考虑根节点属于那一棵treap，这只需要判断它的左儿子的$sz$即可。<br>1）如果左儿子的$sz$大于等于$k$，那么根节点属于第二棵treap，并且它的右儿子全部属于第二棵treap，我们递归分离左子树。<br>2）否则，这个点属于第一棵treap，并且它的左子树全部属于第一棵treap，我们递归分离右子树即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)&#123;a=b=<span class="number">0</span>; <span class="keyword">return</span>;&#125; push_down(x);</span><br><span class="line">	<span class="keyword">if</span>(sz[ch[x][<span class="number">0</span>]]&gt;=k) split(ch[x][<span class="number">0</span>],k,a,ch[b=x][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">else</span> split(ch[x][<span class="number">1</span>],k-sz[ch[x][<span class="number">0</span>]]<span class="number">-1</span>,ch[a=x][<span class="number">1</span>],b);</span><br><span class="line">	push_up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分离出权值小于等于$x$的点：同理，判断根节点属于哪一棵treap即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitv</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v,<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)&#123;a=b=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(val[x]&lt;=v) a=x,splitv(ch[x][<span class="number">1</span>],v,ch[x][<span class="number">1</span>],b);</span><br><span class="line">	<span class="keyword">else</span> b=x,splitv(ch[x][<span class="number">0</span>],v,a,ch[x][<span class="number">0</span>]);</span><br><span class="line">	push_up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面split和merge的实现可以看出来，和两个操作的复杂度与treap的高度是同级的，而由于$key$是随机的，所以树高的期望是$O(\log n)$的，所以这两个操作的复杂度是$O(\log n)$的。</p>
<p>接下来我们来看一些常规的操作：</p>
<h4 id="insert-插入"><a href="#insert-插入" class="headerlink" title="insert 插入"></a>insert 插入</h4><p>假如我们要在第$p$个元素后面插入一个元素，那么把前$p$个元素split出来，然后对将要新加入的元素单独建一棵树（实际上树中只有一个点），把原来的前$p$个元素，新加入的元素，后$n-p$个元素merge在一起就可以了。</p>
<p>而如果是要插入一段区间，我们就需要先把这个区间build成一个treap，利用单调栈维护最右链即可，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u=++ncnt;</span><br><span class="line">	val[u]=v,key[u]=Rand(),push_up(u); <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N],b[N],tot,p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> top; st[top=<span class="number">1</span>]=b[<span class="number">1</span>]=new_node(b[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i]=new_node(b[i]);</span><br><span class="line">		<span class="comment">//单调栈里面维护最右链。新加的点在中序遍历中必须处在末尾，所以前面的节点如果有key比它大的，那么必须作为它的左子树</span></span><br><span class="line">		<span class="keyword">while</span>(top&amp;&amp;key[b[i]]&lt;key[st[top]])</span><br><span class="line">		    ch[b[i]][<span class="number">0</span>]=st[top],push_up(st[top]),top--;</span><br><span class="line">		<span class="comment">//这里push_up的原因是，一个点出栈后，它的子树内的信息就不会再变化了，所以要及时push_up</span></span><br><span class="line">		<span class="keyword">if</span>(top) ch[st[top]][<span class="number">1</span>]=b[i];</span><br><span class="line">		st[++top]=b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(top) push_up(st[top]),top--; r=st[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在第p个位置后面插入b数组中的tot个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,z; split(rt,p,x,z); build(y);</span><br><span class="line">	merge(rt,x,y),merge(rt,rt,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意对新加入的元素单独建树的时候，所有维护区间信息的变量（$sz$，$su m$之类的）要赋初值，因为我们是采取了合并的方式，要保证它是一棵合法的<strong>树</strong>。这一点和splay不一样。</p>
<p>维护$val$满足二叉搜索树性质的也是类似，只不过分离的是所有小于等于$v-1$的节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,c=make(v); splitv(rt,v,x,y);</span><br><span class="line">	merge(rt,x,c),merge(rt,rt,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete 删除"></a>delete 删除</h4><p>假如要删除第$p$个元素，我们就两次split把原树分成三个部分：前$p-1$个，第$p$个，后$n-p$个。然后直接把前$p-1$个和后$n-p$个merge起来就可以了。删除一段区间也是类似的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面的代码删除第p个元素开始的tot个元素，recycle是一个回收子树内所有节点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,z; split(rt,p<span class="number">-1</span>,x,z),split(z,tot,y,z);</span><br><span class="line">	recycle(y); merge(rt,x,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是按照$val$满足二叉搜索树性质，并且可能有多个元素的$val$相同，假设我们现在要删除<strong>一个</strong>$val$等于$v$的元素，那么就把$val$等于$v$的单独分裂出来，把这棵treap根节点的左儿子和右儿子merge起来（本质上就是删掉一个节点），然后再把三棵树merge回去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,z;</span><br><span class="line">	splitv(rt,v,x,y),splitv(x,v<span class="number">-1</span>,x,z);</span><br><span class="line">	merge(z,ch[z][<span class="number">0</span>],ch[z][<span class="number">1</span>]);</span><br><span class="line">	merge(rt,x,z),merge(rt,rt,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间操作"><a href="#区间操作" class="headerlink" title="区间操作"></a>区间操作</h4><p>区间修改：我们把这段区间分离出来，然后打标记就可以啦。<br>区间查询：我们把这段区间分离出来，返回这棵treap的根的子树信息就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区间翻转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;swap(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]),rev[x]^=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,z;</span><br><span class="line">	split(rt,l<span class="number">-1</span>,x,y),split(y,r-l+<span class="number">1</span>,y,z);</span><br><span class="line">	Swap(y);</span><br><span class="line">	merge(rt,x,y),merge(rt,rt,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询从p开始的tot个元素的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,z; split(rt,p<span class="number">-1</span>,x,z),split(z,tot,y,z);</span><br><span class="line">	<span class="keyword">int</span> ans=sum[y].sum; merge(rt,x,y),merge(rt,rt,z);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查排名"><a href="#查排名" class="headerlink" title="查排名"></a>查排名</h4><p>直接将小于等于$v-1$的分离出来，返回第一棵树的$sz+1$即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rnk</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y; splitv(rt,v<span class="number">-1</span>,x,y);</span><br><span class="line">	<span class="keyword">int</span> ans=sz[x]+<span class="number">1</span>; merge(rt,x,y);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查前驱后继"><a href="#查前驱后继" class="headerlink" title="查前驱后继"></a>查前驱后继</h4><p>前驱：将小于等于$v-1$的分离出来，然后返回第一棵树中最大的元素。<br>后继：将小于等于$v$的分离出来，然后返回第二棵树中最小的元素。<br>（当然也可以用二叉搜索树的写法）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回前驱，后继的节点编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,z; splitv(rt,v<span class="number">-1</span>,z,y); x=z;</span><br><span class="line">	<span class="keyword">while</span>(ch[x][<span class="number">1</span>]) x=ch[x][<span class="number">1</span>];</span><br><span class="line">	merge(rt,z,y); <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suf</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,z; splitv(rt,v,y,z); x=z;</span><br><span class="line">	<span class="keyword">while</span>(ch[x][<span class="number">0</span>]) x=ch[x][<span class="number">0</span>];</span><br><span class="line">	merge(rt,y,z); <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p>和splay，二叉搜索树一样的~</p>
<hr>
<h3 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h3><p><a href="https://www.luogu.org/problemnew/show/P3369" target="_blank" rel="noopener">普通平衡树</a> <a href="https://www.luogu.org/recordnew/show/16211628" target="_blank" rel="noopener">我的提交记录</a><br><a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">文艺平衡树</a> <a href="https://www.luogu.org/recordnew/show/16212287" target="_blank" rel="noopener">我的提交记录</a><br><a href="https://www.luogu.org/problemnew/show/P2042" target="_blank" rel="noopener">维护数列</a> <a href="https://www.luogu.org/recordnew/show/16217180" target="_blank" rel="noopener">我的提交记录</a></p>
<h2 id="可持久化Treap"><a href="#可持久化Treap" class="headerlink" title="可持久化Treap"></a>可持久化Treap</h2><h3 id="split-与-merge"><a href="#split-与-merge" class="headerlink" title="split 与 merge"></a>split 与 merge</h3><h4 id="split-1"><a href="#split-1" class="headerlink" title="split"></a>split</h4><p>可持久化意味着我们在操作的时候不能够修改任何的东西。</p>
<p>观察一下split的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)&#123;a=b=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(sz[ch[x][<span class="number">0</span>]]&gt;=k) split(ch[x][<span class="number">0</span>],k,a,ch[b=x][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">else</span> split(ch[x][<span class="number">1</span>],k-sz[ch[x][<span class="number">0</span>]]<span class="number">-1</span>,ch[a=x][<span class="number">1</span>],b);</span><br><span class="line">	push_up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实际上修改了什么？分离完后，第一棵树的最右链上的点的右儿子，以及第二棵树上最左链上的点的左儿子。那么我们把这些最右链和最左链上的点复制一遍，在复制的版本上修改就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)&#123;a=b=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(sz[ch[x][<span class="number">0</span>]]&gt;=k) split(ch[x][<span class="number">0</span>],k,a,ch[b=cpy(x)][<span class="number">0</span>]),push_up(b);</span><br><span class="line">	<span class="keyword">else</span> split(ch[x][<span class="number">1</span>],k-sz[ch[x][<span class="number">0</span>]]<span class="number">-1</span>,ch[a=cpy(x)][<span class="number">1</span>],b),push_up(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="merge-1"><a href="#merge-1" class="headerlink" title="merge"></a>merge</h4><p>还是看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||!b)&#123;r=a+b; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(key[a]&lt;=key[b]) merge(ch[r=a][<span class="number">1</span>],ch[a][<span class="number">1</span>],b);</span><br><span class="line">    <span class="keyword">else</span> merge(ch[r=b][<span class="number">0</span>],a,ch[b][<span class="number">0</span>]);</span><br><span class="line">    push_up(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实际上修改的，是第一棵树的最右链上的点和第二棵树最左链上的点。复制一遍即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||!b)&#123;r=a+b; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(key[a]&lt;=key[b]) r=cpy(a),merge(ch[r][<span class="number">1</span>],ch[a][<span class="number">1</span>],b);</span><br><span class="line">    <span class="keyword">else</span> r=cpy(b),merge(ch[r][<span class="number">0</span>],a,ch[b][<span class="number">0</span>]);</span><br><span class="line">    push_up(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等等，真的需要复制吗？对于许多的题目，我们都是先split，然后再merge，merge的时候第一棵树的最右链和第二棵树的最左链在split的时候都已经复制过了，所以其实可以直接赋值，不再复制节点，即和普通的无旋treap一样的写法。</p>
<hr>
<h3 id="区间操作-1"><a href="#区间操作-1" class="headerlink" title="区间操作"></a>区间操作</h3><p>有了函数式的split和merge，我们就可以可持久化带插入，单点修改，删除的无旋treap了。</p>
<p>但是一旦涉及到区间操作，就涉及到打标记，就很难受了。</p>
<p>看到网上的题解大多数是这样子实现的：下放标记的时候，把儿子节点复制一遍，像这样——</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rev[x])</span><br><span class="line">	&#123;</span><br><span class="line">		swap(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(ch[x][<span class="number">0</span>]) ch[x][<span class="number">0</span>]=cpy(ch[x][<span class="number">0</span>]),rev[ch[x][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ch[x][<span class="number">1</span>]) ch[x][<span class="number">1</span>]=cpy(ch[x][<span class="number">1</span>]),rev[ch[x][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">		rev[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子显然是正确的，但是感觉空间会造成浪费。能不能直接像可持久化线段树那样，把标记永久化了呢？</p>
<p>答案是肯定的！我在这篇<a href="https://www.luogu.org/blog/zhongyuwei/solution-p5055" target="_blank" rel="noopener">题解</a>中介绍了它。空间和时间相对于前面的写法都要优秀一些。</p>
<hr>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度比较显然，单次操作是$O(\log n)$的。</p>
<p>但是空间复杂度，尽管单次操作是$O(\log n)$的，但是每次操作要split和merge好几次，而且本来这个树高也不是严格$\log n$的，所以我觉得TGSteven的话很有道理：数组能开多大开多大！</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Segment Tree Beats专题练习</title>
    <url>/2022/06/30/Segment-Tree-Beats%E4%B8%93%E9%A2%98%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>2016集训队论文集 <a href="http://www.doc88.com/p-6744902151779.html" target="_blank" rel="noopener">吉如一《区间最值操作与历史最值问题》</a></p>
<h2 id="1-hdu5306-Gorgeous-Sequence"><a href="#1-hdu5306-Gorgeous-Sequence" class="headerlink" title="1 hdu5306 Gorgeous Sequence"></a>1 hdu5306 Gorgeous Sequence</h2><p>维护一个长度为$n$的序列，支持以下操作：<br>$0 l r t$：对于所有$i \in [l,r]$，将$a_i$修改为$\min \{ a_i,t\} $。<br>$1 l r$：查询区间$l,r$的最大元素的值。<br>$2 l r$：查询区间$l,r$元素的和。</p>
<p>多组数据，$\sum n, \sum m \le 10^6$。</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>1）在线段树上维护区间内的最大值，最大值的个数，以及严格次大值。<br>2）递归到某个被修改区间完全包含的区间的时候，看这个区间的最大值、次大值和t的关系：</p>
<pre><code>1.如果最大值小于等于t，那么直接返回。
2.如果严格次大值小于等于t，那么这次操作只会影响到区间内的最大值，打上标记之后返回。
3.否则，暴力递归左右子树。
</code></pre><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>在论文中证明了是$O(m\log n)$。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=N*<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=(<span class="number">1l</span>l&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"><span class="keyword">int</span> tag[M];</span><br><span class="line"><span class="keyword">int</span> mx1[M],mx0[M],num[M];</span><br><span class="line">ll sum[M];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls c&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs c&lt;&lt;1|1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd0</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> x)</span> </span>&#123; mx0[c]=max(mx0[c],x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd1</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mx1[c]) &#123;</span><br><span class="line">		mx0[c]=mx1[c];</span><br><span class="line">		mx1[c]=x,num[c]=y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x==mx1[c]) num[c]+=y;</span><br><span class="line">	<span class="keyword">else</span> upd0(c,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	mx1[c]=mx1[ls],num[c]=num[ls],mx0[c]=mx0[ls];</span><br><span class="line">	upd1(c,mx1[rs],num[rs]);</span><br><span class="line">	upd0(c,mx0[rs]);</span><br><span class="line">	sum[c]=sum[ls]+sum[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_tag</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	sum[c]-=(mx1[c]-t)*(ll)num[c];</span><br><span class="line">	mx1[c]=t,tag[c]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tag[c]&lt;mx1[ls]) Add_tag(ls,tag[c]);</span><br><span class="line">	<span class="keyword">if</span>(tag[c]&lt;mx1[rs]) Add_tag(rs,tag[c]);</span><br><span class="line">	tag[c]=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	tag[c]=inf;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		mx1[c]=sum[c]=a[l]; mx0[c]=<span class="number">-1</span>; num[c]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(l,mid,ls),build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ql,qr,qt;</span><br><span class="line"><span class="keyword">int</span> qmx;</span><br><span class="line">ll qsum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) &#123;</span><br><span class="line">		<span class="keyword">if</span>(qt&gt;=mx1[c]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(qt&gt;=mx0[c]) <span class="keyword">return</span> Add_tag(c,qt);</span><br><span class="line">		<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">		update(l,mid,ls),update(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">		push_up(c);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) update(l,mid,ls);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) update(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) &#123;</span><br><span class="line">		qmx=max(qmx,mx1[c]);</span><br><span class="line">		qsum+=sum[c];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) query(l,mid,ls);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) query(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T; rd(T);</span><br><span class="line">	<span class="keyword">int</span> q,op;</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		rd(n),rd(q);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]);</span><br><span class="line">		build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">			rd(op),rd(ql),rd(qr);</span><br><span class="line">			<span class="keyword">if</span>(op==<span class="number">0</span>) &#123;</span><br><span class="line">				rd(qt);</span><br><span class="line">				update(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				qmx=<span class="number">-1</span>,qsum=<span class="number">0</span>;</span><br><span class="line">				query(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qmx);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,qsum);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-Picks-loves-segment-tree"><a href="#2-Picks-loves-segment-tree" class="headerlink" title="2 Picks loves segment tree"></a>2 Picks loves segment tree</h2><p>维护一个长度为$n$的序列$A$，支持以下操作：<br>$1 l r x$：对于所有$i\in [l,r]$，$A_i + = x$。<br>$2 l r x$：对于所有$i\in [l,r]$，$A_i = \min \{ A_i, x\} $。<br>$3 l r$：查询区间$[l,r]$内所有元素的和。<br>$n,m\le 3\times 10^5$</p>
<h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><p>因为有区间加减标记之后区间的最大值、次大值仍然可以维护，所以直接沿用上一道题的做法。</p>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>“可以证明时间复杂度的上界是$O(m\log ^2 n)$，尽管在实际运行过程中表现得更像$O(m\log n)$。”</p>
<hr>
<h2 id="3-AcrossTheSky-loves-segment-tree"><a href="#3-AcrossTheSky-loves-segment-tree" class="headerlink" title="3 AcrossTheSky loves segment tree"></a>3 AcrossTheSky loves segment tree</h2><p>维护一个长度为$n$的序列$A$，支持以下操作：<br>$1 l r x$：对于所有的$i\in [l,r]$，$A_i = \min \{ A_i,x\} $。<br>$2 l r x$：对于所有的$i\in [l,r]$，$A_i = \max\{ A_i,x\} $。<br>$3 l r$：询问$\sum_{i=l}^r A_i$。</p>
<h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><p>维护区间最大值、严格次大值、最小值、严格次小值，然后套用前面的做法。</p>
<h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>“可以沿用上一道题的证明，复杂度上界为$O(m\log n)$。”</p>
<hr>
<h2 id="将区间最值操作转化成区间加减操作"><a href="#将区间最值操作转化成区间加减操作" class="headerlink" title="将区间最值操作转化成区间加减操作"></a>将区间最值操作转化成区间加减操作</h2><p>从上面几道题的做法我们可以发现，我们可以将区间取最值操作转化成对区间最值的加减，分别用两种标记维护对区间内的最值、非最值的修改。这样，我们把区间最值操作转化成了区间加减操作，在此基础上我们将可以维护与区间最值有关的、更加复杂的操作。</p>
<hr>
<h2 id="4-bzoj3064-CPU监控"><a href="#4-bzoj3064-CPU监控" class="headerlink" title="4 bzoj3064 CPU监控"></a>4 bzoj3064 CPU监控</h2><p>维护一个长度为$n$的序列$A$，支持以下操作：<br>$1 l r x$：将区间$[l,r]$的数加上$x$。<br>$2 l r x$：将区间$[l,r]$的数变成$x$。<br>$3 l r$：询问$\min \{ A_i \mid i\in [l,r]\}$。<br>$4 l r$：询问$\min \{ B_i \mid i\in [l,r]\}$。</p>
<p>初始的时候$B_i = A_i$。每一次操作过后，我们都让$B_i = \max \{ B_i,A_i \}$。</p>
<p>$n,m\le 10^5,x\in [-10^9,10^9]$</p>
<h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h3><h4 id="1）"><a href="#1）" class="headerlink" title="1）"></a>1）</h4><p>如果对一个区间赋值后又进行了区间加，可以看做对这个区间进行了两次赋值操作。故而，我们可以将对某个区间的操作分成两个阶段，第一个阶段是区间加，第二个区间是区间赋值，对两个阶段分别维护操作标记的最小值，这样就可以维护区间的历史最小值了。</p>
<h4 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h4><p>其实可以直接将操作归为这样的一个形式：给定参数$a,b$，对于要修改的元素$x$，修改后$x’ = \min \{ x+a,b\}$。</p>
<p>合并两个操作$(a_1,b_1),(a_2,b_2)$：$(a_1+a_2,\min \{ b_1+a_2,b_2\})$。</p>
<p>然后考虑维护区间历史最小值，也可以用一个形式类似的标记$(a,b)$，表示对于一个操作前区间最小值为$x$的区间，操作后区间最小值是$\min \{ x+a,b\}$。假设之前进行过的操作的标记是$(a_1,b_1)$，之前进行过的操作的历史最小标记是$(a_2,b_2)$，现在合并过来的操作的历史最小标记是$(a_3,b_3)$，那么合并后得到的二元组是$(\min \{ a_2 ,a_1+a_3\} ,\min \{ b_2,b_3,b_1+a_3 \}$。</p>
<p>这个做法可以使用于所有的有区间赋值、加、取最值、查询历史最值，并且取最值操作和查询的历史最值类型相同（都是max或者都是min）的题目。</p>
<p>注意代码实现的时候不要把$\infty $设置得过于大，因为合并两个操作的标记的时候会直接累加，必须保证累加过后不会爆long long。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls c&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs c&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>,M=N*<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e12</span>;</span><br><span class="line">ll a[N]; <span class="keyword">int</span> n;</span><br><span class="line">ll mx[M],lmx[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span> &#123;</span></span><br><span class="line">    ll a,b;</span><br><span class="line">    item(ll a=<span class="number">0</span>,ll b=-inf): a(a),b(b) &#123;&#125;</span><br><span class="line">&#125;tag1[M],tag2[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    mx[c]=max(mx[ls],mx[rs]);</span><br><span class="line">    lmx[c]=max(lmx[ls],lmx[rs]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> c,item t1,item t2)</span> </span>&#123;</span><br><span class="line">    lmx[c]=max(lmx[c],max(t2.a+mx[c],t2.b));</span><br><span class="line">    mx[c]=max(t1.a+mx[c],t1.b);</span><br><span class="line">    tag2[c]=item(max(tag1[c].a+t2.a, tag2[c].a),max(tag1[c].b+t2.a,max(tag2[c].b,t2.b)));</span><br><span class="line">    tag1[c]=item(tag1[c].a+t1.a,max(tag1[c].b+t1.a,t1.b));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    Add(ls,tag1[c],tag2[c]);</span><br><span class="line">    Add(rs,tag1[c],tag2[c]);</span><br><span class="line">    tag1[c]=tag2[c]=item(<span class="number">0</span>,-inf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        mx[c]=lmx[c]=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,ls),build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ql,qr;</span><br><span class="line">item qt1;</span><br><span class="line">item qt2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) &#123;</span><br><span class="line">        Add(c,qt1,qt2);</span><br><span class="line"><span class="comment">//		cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;':'&lt;&lt;tag1[c].a&lt;&lt;' '&lt;&lt;tag1[c].b&lt;&lt;' '&lt;&lt;mx[c]&lt;&lt;' '&lt;&lt;lmx[c]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid) update(l,mid,ls);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid) update(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    push_up(c);</span><br><span class="line">&#125;</span><br><span class="line">ll qans1,qans2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) &#123;</span><br><span class="line">        qans1=max(qans1,mx[c]);</span><br><span class="line">        qans2=max(qans2,lmx[c]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid) query(l,mid,ls);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid) query(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rd(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]);</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> q,l,r,t; <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">    rd(q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        rd(ql),rd(qr);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'P'</span>) &#123;</span><br><span class="line">            rd(t);</span><br><span class="line">            qt1=item(t,-inf);</span><br><span class="line">            qt2=item(t,-inf);</span><br><span class="line">            update(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>) &#123;</span><br><span class="line">            rd(t);</span><br><span class="line">            qt1=item(-inf,t);</span><br><span class="line">            qt2=item(-inf,t);</span><br><span class="line">            update(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            qans1=qans2=-inf;</span><br><span class="line">            query(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qans1);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qans2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-元旦老人与数列"><a href="#5-元旦老人与数列" class="headerlink" title="5 元旦老人与数列"></a>5 元旦老人与数列</h2><p>维护一个长度为$n$的序列，支持以下操作：<br>$1 l r x$：对于所有$i\in [l,r]$，将$A_i$变成$A_i+x$。<br>$2 l r x$：对于所有$i\in [l,r]$，将$A_i$变成$\max \{ A_i,x\}$。<br>$3 l r$：查询区间$[l,r]$内元素的最小值。<br>$4 l r$，查询区间$[l,r]$内元素的历史最小值。</p>
<h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法"></a>做法</h3><p>沿用之前处理区间最值操作的那个思路，将操作分成对区间最小值的操作和对区间非最小值的操作。这样就变成了：对区间最小值加，对区间非最小值加，查询区间最小值，查询区间历史最小值。</p>
<p>可以分别对区间最小值和非最小值维护进行的操作，这些标记的和以及标记和的历史最大值。</p>
<p>注意在上传信息、下方标记的时候，儿子的区间最小值可能和父亲不一样。</p>
<p>下面这份代码中分别维护了对最小值和非最小值的标记，以及最小值和非最小值的历史最小值。实际上没有必要分别维护最小值和非最小值的历史最小值，因为我们在更新的时候也不会用到它们，直接记录整个区间的历史最小值就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls c&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs c&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,M=N*<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line">ll hmi1[M],hmi0[M];</span><br><span class="line">ll mi1[M],mi0[M]; <span class="comment">// mi1 &lt; mi0</span></span><br><span class="line">ll tag0[M][<span class="number">2</span>],tag1[M][<span class="number">2</span>]; <span class="comment">// 1-&gt;min  0-&gt;other elements</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">cmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>,<span class="title">T</span> <span class="title">y</span>) &#123;</span> <span class="keyword">if</span>(y&lt;x) x=y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd0</span><span class="params">(<span class="keyword">int</span> c,ll x)</span> </span>&#123; mi0[c]=min(mi0[c],x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd1</span><span class="params">(<span class="keyword">int</span> c,ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;mi1[c]) mi0[c]=mi1[c],mi1[c]=x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x!=mi1[c]) upd0(c,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	mi0[c]=mi0[ls],mi1[c]=mi1[ls];</span><br><span class="line">	upd1(c,mi1[rs]),upd0(c,mi0[rs]);</span><br><span class="line">	hmi1[c]=hmi0[c]=inf;</span><br><span class="line">	cmin((mi1[c]==mi1[ls]?hmi1[c]:hmi0[c]),hmi1[ls]);</span><br><span class="line">	cmin((mi1[c]==mi1[rs]?hmi1[c]:hmi0[c]),hmi1[rs]);</span><br><span class="line">	cmin(hmi0[c],min(hmi0[ls],hmi0[rs]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> c,ll *t0,ll *t1,<span class="keyword">int</span> flg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(flg) &#123;</span><br><span class="line">		hmi1[c]=min(hmi1[c],mi1[c]+t1[<span class="number">1</span>]);</span><br><span class="line">		mi1[c]=mi1[c]+t1[<span class="number">0</span>];</span><br><span class="line">		tag1[c][<span class="number">1</span>]=min(tag1[c][<span class="number">1</span>],tag1[c][<span class="number">0</span>]+t1[<span class="number">1</span>]);</span><br><span class="line">		tag1[c][<span class="number">0</span>]+=t1[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		hmi1[c]=min(hmi1[c],mi1[c]+t0[<span class="number">1</span>]);</span><br><span class="line">		mi1[c]=mi1[c]+t0[<span class="number">0</span>];</span><br><span class="line">		tag1[c][<span class="number">1</span>]=min(tag1[c][<span class="number">1</span>],tag1[c][<span class="number">0</span>]+t0[<span class="number">1</span>]);</span><br><span class="line">		tag1[c][<span class="number">0</span>]+=t0[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	hmi0[c]=min(hmi0[c],mi0[c]+t0[<span class="number">1</span>]);</span><br><span class="line">	mi0[c]=mi0[c]+t0[<span class="number">0</span>];</span><br><span class="line">	tag0[c][<span class="number">1</span>]=min(tag0[c][<span class="number">1</span>],tag0[c][<span class="number">0</span>]+t0[<span class="number">1</span>]);</span><br><span class="line">	tag0[c][<span class="number">0</span>]+=t0[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(tag0[c][<span class="number">0</span>]|tag0[c][<span class="number">1</span>]|tag1[c][<span class="number">0</span>]|tag1[c][<span class="number">1</span>])) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> flg0=mi1[ls]&lt;=mi1[rs],flg1=mi1[rs]&lt;=mi1[ls];</span><br><span class="line">	Add(ls,tag0[c],tag1[c],flg0);</span><br><span class="line">	Add(rs,tag0[c],tag1[c],flg1);</span><br><span class="line">	tag0[c][<span class="number">0</span>]=tag1[c][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	tag0[c][<span class="number">1</span>]=tag1[c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	tag0[c][<span class="number">0</span>]=tag1[c][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	tag0[c][<span class="number">1</span>]=tag1[c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		mi1[c]=hmi1[c]=a[l];</span><br><span class="line">		mi0[c]=hmi0[c]=inf;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(l,mid,ls),build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ql,qr;</span><br><span class="line">ll qt;</span><br><span class="line">ll t0[<span class="number">2</span>],t1[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update0</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) <span class="keyword">return</span> Add(c,t0,t1,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) update0(l,mid,ls);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) update0(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) &#123;</span><br><span class="line">		<span class="keyword">if</span>(mi1[c]&gt;=qt) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(mi0[c]&gt;=qt) &#123;</span><br><span class="line">			ll t0[]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">			ll t1[]=&#123;qt-mi1[c],<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">return</span> Add(c,t0,t1,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">		update1(l,mid,ls),update1(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">		push_up(c);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) update1(l,mid,ls);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) update1(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line">ll ans0,ans1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r) &#123;</span><br><span class="line">		ans0=min(ans0,mi1[c]);</span><br><span class="line">		ans1=min(ans1,min(hmi1[c],hmi0[c]));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) query(l,mid,ls);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) query(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q,x,op; rd(n),rd(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]);</span><br><span class="line">	build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		rd(op),rd(ql),rd(qr);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			rd(x);</span><br><span class="line">			t0[<span class="number">0</span>]=x,t0[<span class="number">1</span>]=min(<span class="number">0</span>,x);</span><br><span class="line">			update0(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			rd(qt);</span><br><span class="line">			update1(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans1=inf,ans0=inf;</span><br><span class="line">			query(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(op==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans0);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Link Cut Tree(LCT)</title>
    <url>/2022/06/30/Link-Cut-Tree-LCT/</url>
    <content><![CDATA[<h1 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LCT用来维护的是森林。它可以支持加边（link)、删边（cut）、链信息修改和查询、子树信息查询。</p>
<h2 id="LCT长啥样"><a href="#LCT长啥样" class="headerlink" title="LCT长啥样"></a>LCT长啥样</h2><p>首先我们对这些树进行实链剖分。我们对树中的每一条实链都用一棵splay维护。splay维护的是实链上的点按照深度从小到大排序后得到的序列。一个点在splay上的前驱和后继是它在实链和它相邻的点。splay中每个点的编号和这个点在树中的编号是相同的。特别的，一条实链的splay的根节点的父亲，是成这条实链的最浅点在树上的父亲。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="isroot-x"><a href="#isroot-x" class="headerlink" title="isroot(x)"></a>isroot(x)</h3><p>这个函数用来判断x这个点是不是它所属的splay的根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]!=x&amp;&amp;ch[fa[x]][<span class="number">1</span>]!=x; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="splay-x"><a href="#splay-x" class="headerlink" title="splay(x)"></a>splay(x)</h3><p>我们用这个函数把x转到x所属的splay的根节点。</p>
<p>注意rotate里面关于x的祖先的判断，要调用isroot(f)，并且要在修改f的父亲之前。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f=fa[x],ff=fa[f],d=get(x);</span><br><span class="line">	fa[x]=ff; <span class="keyword">if</span>(!isroot(f)) ch[ff][ch[ff][<span class="number">1</span>]==f]=x;</span><br><span class="line">	fa[ch[x][d^<span class="number">1</span>]]=f,ch[f][d]=ch[x][d^<span class="number">1</span>];</span><br><span class="line">	fa[f]=x,ch[x][d^<span class="number">1</span>]=f; push_up(f),push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PD</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> stk[N],top;</span><br><span class="line">	stk[top=<span class="number">1</span>]=x;</span><br><span class="line">	<span class="keyword">while</span>(!isroot(x)) stk[++top]=fa[x],x=fa[x];</span><br><span class="line">	<span class="keyword">while</span>(top) push_down(stk[top--]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	PD(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> f=fa[x];!isroot(x);rotate(x),f=fa[x])</span><br><span class="line">		<span class="keyword">if</span>(!isroot(f)) rotate(get(x)==get(f)?f:x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意，如果x自己就是根节点，那么将不会执行到rotate语句，如果把push_down写在rotate里面，标记的下放就会有一些问题。</p>
<h3 id="access-x"><a href="#access-x" class="headerlink" title="access(x)"></a>access(x)</h3><p>利用这个函数我们让x和这棵树的根在同一条实链上，并且恰好是实链的两端。</p>
<p>首先我们把x转到它自己所属的splay的根部，此时它的右儿子部分是它在实链中比它深的点，应该和它断开。考虑x上方的实链，我们应该对fa[x]进行类似的操作（splay到根然后把右儿子和它断开)，并且把x接在它的右儿子的位置。然后对fa[fa[x]]也进行这样的操作，直到x和根在同一条实链上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x])</span><br><span class="line">		splay(x),ch[x][<span class="number">1</span>]=y,push_up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="makeroot-x"><a href="#makeroot-x" class="headerlink" title="makeroot(x)"></a>makeroot(x)</h3><p>利用这个函数我们把x变成全树的根。</p>
<p>首先access(x)，然后我们要让x成为实链上的最浅点。注意到此时x恰好是实链上的最深点，那么我们直接对这个splay进行区间翻转操作就可以达到目的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x),splay(x),Swap(x); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="link-x-y"><a href="#link-x-y" class="headerlink" title="link(x,y)"></a>link(x,y)</h3><p>把x置为根，把x所在的splay的根的父亲设置成y就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	makeroot(x),splay(x),fa[x]=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cut-x-y"><a href="#cut-x-y" class="headerlink" title="cut(x,y)"></a>cut(x,y)</h3><p>把x设为根，然后access(y)，在splay上把两个点断开就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	makeroot(x),access(y),splay(y);</span><br><span class="line">	fa[ch[y][<span class="number">0</span>]]=<span class="number">0</span>,ch[y][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	push_up(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断两个点之间是否有边，makeroot(x),access(y),splay(y)，然后判断<code>ch[x][0]</code> 是否为空。</p>
<h3 id="findroot-x"><a href="#findroot-x" class="headerlink" title="findroot(x)"></a>findroot(x)</h3><p>找出x这个点所在的树的根。</p>
<p>首先access(x)，然后找出x所在实链的最浅点。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="区间修改-查询"><a href="#区间修改-查询" class="headerlink" title="区间修改/查询"></a>区间修改/查询</h3><p>如果要修改/查询从x到y的链信息，先makeroot(x)，然后access(y)，此时我们需要的链恰好就是x，y所属的实链。转化成splay的修改和查询就可以了。</p>
<h3 id="子树信息"><a href="#子树信息" class="headerlink" title="子树信息"></a>子树信息</h3><p>我们对每一个点，记录一个vir[u]，表示它的所有虚儿子的子树信息的和。</p>
<p>我们在splay上维护这个点的splay子树内，所有的点及其虚子树的信息的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sum[u]=sum[ch[u][<span class="number">0</span>]]+sum[ch[u][<span class="number">1</span>]]+vir[u]+val[u];</span><br></pre></td></tr></table></figure>
<p>只有轻重链切换的时候，我们需要考虑vir[u]的修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x]) &#123;</span><br><span class="line">      	splay(x);</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">1</span>]) vir[x]-=sum[ch[x][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">if</span>(y) vir[x]+=sum[y];</span><br><span class="line">        ch[x][<span class="number">1</span>]=y,push_up(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个点的lca"><a href="#求两个点的lca" class="headerlink" title="求两个点的lca"></a>求两个点的lca</h3><p>首先access(x)，然后执行access(y)。注意到lca(x,y)就是我们在access(y)的过程中跳到最后一条实链上，我们跳到的那个点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">for</span>(y=<span class="number">0</span>;x;y=x,x=fa[x]) &#123;</span><br><span class="line">        splay(x),ch[x][<span class="number">1</span>]=y,push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    access(x); <span class="keyword">return</span> access(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，操作是无穷多的，只要你脑洞足够大hhh</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>tree II</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">51061</span>;</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>],fa[N],n;</span><br><span class="line"><span class="keyword">int</span> add[N],mul[N],rev[N];</span><br><span class="line"><span class="keyword">int</span> sum[N],val[N],sz[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]!=x&amp;&amp;ch[fa[x]][<span class="number">1</span>]!=x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> ad,<span class="keyword">int</span> mu)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"add"&lt;&lt;x&lt;&lt;' '&lt;&lt;sz[x]&lt;&lt;':'&lt;&lt;ad&lt;&lt;' '&lt;&lt;mu&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">	sum[x]=sum[x]*(ll)mu%mod,add[x]=add[x]*(ll)mu%mod;</span><br><span class="line">	val[x]=val[x]*(ll)mu%mod,mul[x]=mul[x]*(ll)mu%mod;</span><br><span class="line">	sum[x]=sum[x]+sz[x]*(ll)ad,val[x]=(val[x]+ad)%mod,add[x]=(add[x]+ad)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; swap(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]),rev[x]^=<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rev[x]) Swap(ch[x][<span class="number">0</span>]),Swap(ch[x][<span class="number">1</span>]),rev[x]=<span class="number">0</span>;</span><br><span class="line">	Add(ch[x][<span class="number">0</span>],add[x],mul[x]),Add(ch[x][<span class="number">1</span>],add[x],mul[x]);</span><br><span class="line">	add[x]=<span class="number">0</span>,mul[x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	sum[x]=(sum[ch[x][<span class="number">0</span>]]+sum[ch[x][<span class="number">1</span>]]+val[x])%mod;</span><br><span class="line">	sz[x]=sz[ch[x][<span class="number">0</span>]]+sz[ch[x][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f=fa[x],ff=fa[f],d=get(x);</span><br><span class="line">	fa[x]=ff; <span class="keyword">if</span>(!isroot(f)) ch[ff][ch[ff][<span class="number">1</span>]==f]=x;</span><br><span class="line">	fa[ch[x][d^<span class="number">1</span>]]=f,ch[f][d]=ch[x][d^<span class="number">1</span>];</span><br><span class="line">	fa[f]=x,ch[x][d^<span class="number">1</span>]=f; push_up(f),push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PD</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> stk[N],top;</span><br><span class="line">	stk[top=<span class="number">1</span>]=x;</span><br><span class="line">	<span class="keyword">while</span>(!isroot(x)) stk[++top]=fa[x],x=fa[x];</span><br><span class="line">	<span class="keyword">while</span>(top) push_down(stk[top--]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	PD(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> f=fa[x];!isroot(x);rotate(x),f=fa[x])</span><br><span class="line">		<span class="keyword">if</span>(!isroot(f)) rotate(get(x)==get(f)?f:x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x])</span><br><span class="line">		splay(x),ch[x][<span class="number">1</span>]=y,push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x),splay(x),Swap(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	makeroot(x),access(y),splay(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	makeroot(x),splay(x),fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	makeroot(x),access(y),splay(y);</span><br><span class="line">	fa[ch[y][<span class="number">0</span>]]=<span class="number">0</span>,ch[y][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	push_up(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q,x,y,w,u,v; <span class="keyword">char</span> opt[<span class="number">232</span>];</span><br><span class="line">	rd(n),rd(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) mul[i]=<span class="number">1</span>,val[i]=<span class="number">1</span>,push_up(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) rd(x),rd(y),link(x,y);</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,opt);</span><br><span class="line">		<span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'+'</span>) &#123;</span><br><span class="line">			rd(x),rd(y),rd(w);</span><br><span class="line">			split(x,y); Add(y,w,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'-'</span>) &#123;</span><br><span class="line">			rd(x),rd(y),rd(u),rd(v);</span><br><span class="line">			cut(x,y),link(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'/'</span>) &#123;</span><br><span class="line">			rd(x),rd(y); split(x,y);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum[y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			rd(x),rd(y),rd(w);</span><br><span class="line">			split(x,y); Add(y,<span class="number">0</span>,w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>KD-Tree</title>
    <url>/2022/06/30/KD-Tree/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://oi-wiki.org/ds/kdt/" target="_blank" rel="noopener">OI-wiki</a></li>
<li><a href="https://en.wikipedia.org/wiki/K-d_tree" target="_blank" rel="noopener">wikipedia</a></li>
<li><a href="https://courses.cs.washington.edu/courses/cse373/02au/lectures/lecture22l.pdf" target="_blank" rel="noopener">一份有详细图解的课件</a></li>
</ol>
<h2 id="KD-Tree-是什么"><a href="#KD-Tree-是什么" class="headerlink" title="KD-Tree 是什么"></a>KD-Tree 是什么</h2><p>KD-Tree（k-dimensional tree 的简写）是一种用来维护 $k$ 维的<strong>点集</strong>的数据结构。它是一棵深度为 $O(\log n)$ 的二叉搜索树，每个结点代表了点集中的一个点。</p>
<p>它可以支持以下的操作（设 $n$ 为点集的大小）：</p>
<ol>
<li>插入/删除一个点，时间复杂度为均摊 $O(\log n)$</li>
<li>查询一个边界平行于坐标轴的矩形/超矩形内的点的信息，时间复杂度上界为 $O(n^{1-\frac{1}{k}})$</li>
<li>对一个边界平行于坐标轴的矩形/超矩形内的点进行支持标记合并的修改（维护和线段树类似的标记），时间复杂度上界为 $O(n^{1-\frac{1}{k}})$</li>
<li>查询一个点的最近点/最远点，数据随机的时候时间复杂度期望为 $O(\log n)$ ，最坏复杂度为 $O(n)$ 。</li>
</ol>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>选择一个维度，然后在点集中选择一个这一维的坐标是中位数的点作为根，然后把其它的点按照这一维的坐标和根的大小关系分成左右两棵子树，递归到子树内进行建造。</p>
<p>定义一个结点的<strong>范围</strong>是它子树内的点的坐标范围，也就是一个 $k$ 维的、所有边都平行于坐标轴的超矩形。</p>
<p>注意到：对于某个点，显然它的左右子树的范围的交要么为空，要么只包含了这个点所在的、垂直于这一次所选的维度的坐标轴的一条线段。</p>
<p>以下是二维情形的建树代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">rec[c] 代表 c 结点的范围</span></span><br><span class="line"><span class="comment">tr[c] 表示 c 结点所代表的点的坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> d)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> (<span class="keyword">void</span>)(c=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	nth_element(P+l,P+mid,P+r+<span class="number">1</span>,(d&amp;<span class="number">1</span>?cmpx:cmpy));</span><br><span class="line">	tr[c=newnode()]=P[mid];</span><br><span class="line">	build(l,mid<span class="number">-1</span>,ch[c][<span class="number">0</span>],d+<span class="number">1</span>),build(mid+<span class="number">1</span>,r,ch[c][<span class="number">1</span>],d+<span class="number">1</span>);</span><br><span class="line">	rec[c].lx=min(tr[c].x,min(rec[ch[c][<span class="number">0</span>]].lx,rec[ch[c][<span class="number">1</span>]].lx));</span><br><span class="line">	rec[c].rx=max(tr[c].x,max(rec[ch[c][<span class="number">0</span>]].rx,rec[ch[c][<span class="number">1</span>]].rx));</span><br><span class="line">	rec[c].ly=min(tr[c].y,min(rec[ch[c][<span class="number">0</span>]].ly,rec[ch[c][<span class="number">1</span>]].ly));</span><br><span class="line">	rec[c].ry=max(tr[c].y,max(rec[ch[c][<span class="number">0</span>]].ry,rec[ch[c][<span class="number">1</span>]].ry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入/删除"></a>插入/删除</h2><p>按照 KD-Tree 的子树划分方式递归到相应的位置，然后插入/删除即可。</p>
<p>为了保证平衡，我们要在某个点的某个儿子的子树大小大于这个点的子树大小 $\times \alpha$ 的时候对这个子树进行重构。其中 $\alpha$ 一般取 0.75 左右。</p>
<p>单次插入/删除的时间复杂度是均摊 $O(\log n)$ 的。</p>
<p>以下是二维情形的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(POINT A,POINT B)</span> </span>&#123; <span class="keyword">return</span> A.x&lt;B.x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(POINT A,POINT B)</span> </span>&#123; <span class="keyword">return</span> A.y&lt;B.y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmptx</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> tr[x].x&lt;tr[y].x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpty</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> tr[x].y&lt;tr[y].y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	sum[c]=sum[ch[c][<span class="number">0</span>]]+sum[ch[c][<span class="number">1</span>]]+val[c];</span><br><span class="line">	sz[c]=sz[ch[c][<span class="number">0</span>]]+sz[ch[c][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> (<span class="keyword">void</span>)(c=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	nth_element(b.begin()+l,b.begin()+mid,b.begin()+r+<span class="number">1</span>,(d?cmptx:cmpty));</span><br><span class="line">	c=b[mid];</span><br><span class="line">	rebuild(l,mid<span class="number">-1</span>,ch[c][<span class="number">0</span>],d^<span class="number">1</span>);</span><br><span class="line">	rebuild(mid+<span class="number">1</span>,r,ch[c][<span class="number">1</span>],d^<span class="number">1</span>);</span><br><span class="line">	rec[c].lx=min(tr[c].x,min(rec[ch[c][<span class="number">0</span>]].lx,rec[ch[c][<span class="number">1</span>]].lx));</span><br><span class="line">	rec[c].rx=max(tr[c].x,max(rec[ch[c][<span class="number">0</span>]].rx,rec[ch[c][<span class="number">1</span>]].rx));</span><br><span class="line">	rec[c].ly=min(tr[c].y,min(rec[ch[c][<span class="number">0</span>]].ly,rec[ch[c][<span class="number">1</span>]].ly));</span><br><span class="line">	rec[c].ry=max(tr[c].y,max(rec[ch[c][<span class="number">0</span>]].ry,rec[ch[c][<span class="number">1</span>]].ry));</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!rt) <span class="keyword">return</span>; b.PB(rt);</span><br><span class="line">	recycle(ch[rt][<span class="number">0</span>]),recycle(ch[rt][<span class="number">1</span>]);</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	recycle(rt),rebuild(<span class="number">0</span>,b.size()<span class="number">-1</span>,rt,d),b.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> d,POINT p,<span class="keyword">int</span> v,<span class="keyword">int</span> flg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!c) &#123;</span><br><span class="line">		tr[c=++ncnt]=p,val[c]=v,push_up(c);</span><br><span class="line">		rec[c].lx=rec[c].rx=tr[c].x;</span><br><span class="line">		rec[c].ly=rec[c].ry=tr[c].y;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> lr=(d?cmpx(tr[c],p):cmpy(tr[c],p));</span><br><span class="line">	<span class="keyword">int</span> cur_flg=(sz[c]<span class="number">-1</span>)*alpha&lt;=max(sz[ch[c][lr]]+<span class="number">1</span>,sz[ch[c][lr^<span class="number">1</span>]]);</span><br><span class="line">	ins(ch[c][lr],d^<span class="number">1</span>,p,v,flg|cur_flg);</span><br><span class="line">	rec[c].lx=min(rec[c].lx,p.x);</span><br><span class="line">	rec[c].rx=max(rec[c].rx,p.x);</span><br><span class="line">	rec[c].ly=min(rec[c].ly,p.y);</span><br><span class="line">	rec[c].ry=max(rec[c].ry,p.y);</span><br><span class="line">	push_up(c);</span><br><span class="line">	<span class="keyword">if</span>(!flg&amp;&amp;cur_flg) rebuild(c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩形查询"><a href="#矩形查询" class="headerlink" title="矩形查询"></a>矩形查询</h2><p>从根开始往下递归：</p>
<ol>
<li>如果当前结点的范围与查询的范围没有交，直接退出；</li>
<li>如果当前结点的范围被完全包含在查询的范围内，返回当前结点的子树信息</li>
<li>否则考虑当前结点所代表的点的贡献，并递归到子树内继续查询</li>
</ol>
<p>可以证明，单次操作的时间复杂度上界为 $O(n^{1-\frac{1}{k}})$ 。</p>
<p>以下是二维情形的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,<span class="keyword">int</span> ly,<span class="keyword">int</span> ry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rx&lt;rec[c].lx||lx&gt;rec[c].rx||ry&lt;rec[c].ly||ly&gt;rec[c].ry) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(lx&lt;=rec[c].lx&amp;&amp;rx&gt;=rec[c].rx&amp;&amp;ly&lt;=rec[c].ly&amp;&amp;ry&gt;=rec[c].ry) <span class="keyword">return</span> sum[c];</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(lx&lt;=tr[c].x&amp;&amp;rx&gt;=tr[c].x&amp;&amp;ly&lt;=tr[c].y&amp;&amp;ry&gt;=tr[c].y) tot+=val[c];</span><br><span class="line">	tot+=qry(ch[c][<span class="number">0</span>],d^<span class="number">1</span>,lx,rx,ly,ry);</span><br><span class="line">	tot+=qry(ch[c][<span class="number">1</span>],d^<span class="number">1</span>,lx,rx,ly,ry);</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩形修改"><a href="#矩形修改" class="headerlink" title="矩形修改"></a>矩形修改</h2><p>与矩形查询是类似的。</p>
<p>从根开始往下递归：</p>
<ol>
<li>如果当前结点的范围与查询的范围没有交，直接退出；</li>
<li>如果当前结点的范围被完全包含在查询的范围内，对当前结点打子树修改标记</li>
<li>否则考虑修改对当前结点代表的点的贡献，并递归到当前结点的子树内继续以上过程</li>
</ol>
<p>单次操作的时间复杂度上界是 $O(n^{1-\frac{1}{k}})$ 。</p>
<p>以下是二维情形的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,<span class="keyword">int</span> ly,<span class="keyword">int</span> ry,<span class="keyword">int</span> op,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rec[c].lx&gt;rx||rec[c].rx&lt;lx||rec[c].ly&gt;ry||rec[c].ry&lt;ly) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(rec[c].lx&gt;=lx&amp;&amp;rec[c].rx&lt;=rx&amp;&amp;rec[c].ly&gt;=ly&amp;&amp;rec[c].ry&lt;=ry) <span class="keyword">return</span> (<span class="keyword">void</span>)(op==<span class="number">1</span>?add(c,v):mul(c,v));</span><br><span class="line">	push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(lx&lt;=tr[c].x&amp;&amp;rx&gt;=tr[c].x&amp;&amp;ly&lt;=tr[c].y&amp;&amp;ry&gt;=tr[c].y) val[c]=(op==<span class="number">1</span>?(val[c]+v)%mod:<span class="number">1l</span>l*val[c]*v%mod);</span><br><span class="line">	upd(ch[c][<span class="number">0</span>],lx,rx,ly,ry,op,v);</span><br><span class="line">	upd(ch[c][<span class="number">1</span>],lx,rx,ly,ry,op,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询一个点的最近-最远点"><a href="#查询一个点的最近-最远点" class="headerlink" title="查询一个点的最近/最远点"></a>查询一个点的最近/最远点</h2><p>本质上是对暴力搜索的剪枝。</p>
<p>剪枝 1 ：如果一个结点的范围内的所有点到查询点的距离都不如现在的最优答案优秀，那么直接退出。</p>
<p>剪枝 2 ：在决定先往左子树走还是往右子树走的时候，走范围边界上最优的那个点更优的那个子树。</p>
<p>可以证明，随机数据的时候单次查询的期望复杂度为 $O(\log n)$ ，最坏情况下的时间复杂度为 $O(n)$ 。</p>
<h3 id="拓展：查询一个点的第-k-近-远的点"><a href="#拓展：查询一个点的第-k-近-远的点" class="headerlink" title="拓展：查询一个点的第 $k$ 近/远的点"></a>拓展：查询一个点的第 $k$ 近/远的点</h3><p>用优先队列维护现在已经搜到的答案最优的 $k$ 个，搜索的过程中进行和前面同理的剪枝；复杂度和上面最近/最远点的复杂度是相同的。</p>
<p>二维 $k$ 远点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">db <span class="title">Sqr</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="function">db <span class="title">dis_to_rec</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!c) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> max(Sqr(rec[c].lx-qx),Sqr(rec[c].rx-qx))+max(Sqr(rec[c].ly-qy),Sqr(rec[c].ry-qy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> Sqr(tr[c].x-qx)+Sqr(tr[c].y-qy); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!c) <span class="keyword">return</span>;</span><br><span class="line">	item tmp=(item)&#123;tr[c].id,dis(c)&#125;;</span><br><span class="line">	<span class="keyword">if</span>(tmp&lt;Q.top()) Q.pop(),Q.push(tmp);</span><br><span class="line">	db d[<span class="number">2</span>]=&#123;dis_to_rec(ch[c][<span class="number">0</span>]),dis_to_rec(ch[c][<span class="number">1</span>])&#125;;</span><br><span class="line">	<span class="keyword">int</span> lr=(d[<span class="number">1</span>]&gt;d[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span>(sgn(d[lr]-Q.top().d)&gt;=<span class="number">0</span>) qry(ch[c][lr]);</span><br><span class="line">	<span class="keyword">if</span>(sgn(d[lr^<span class="number">1</span>]-Q.top().d)&gt;=<span class="number">0</span>) qry(ch[c][lr^<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题表"><a href="#题表" class="headerlink" title="题表"></a>题表</h2><ul>
<li>luogu P2093 【国家集训队】JZPFAR</li>
<li>luogu P3710 方方方的数据结构</li>
<li>luogu P3710 方方方的数据结构</li>
<li>luogu P4148 简单题</li>
<li>luogu P4357 【CQOI2016】K远点对</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Euler Tour Tree(ETT)</title>
    <url>/2022/06/30/Euler-Tour-Tree-ETT/</url>
    <content><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>ETT是一种动态树，它可以支持link，cut，子树修改，子树信息查询，链信息查询。似乎还可以支持换根（？），但是我不会。</p>
<hr>
<h2 id="ETT的基本工作原理"><a href="#ETT的基本工作原理" class="headerlink" title="ETT的基本工作原理"></a>ETT的基本工作原理</h2><h3 id="一棵有根树的括号序列"><a href="#一棵有根树的括号序列" class="headerlink" title="一棵有根树的括号序列"></a>一棵有根树的括号序列</h3><p>就是说，一个点进栈的时候我们把它push_back到序列里面，出栈的时候也把它push_back到序列里面。</p>
<p>比如说，一棵树，其中fa[2]=1,fa[3]=2,fa[4]=2，那么它的括号序就是：1 2 3 3 4 4 2 1</p>
<p>显然一个括号序列可以确定一个有根树。而一个有根树可能对应到多个不同的括号序列。</p>
<h3 id="ETT的工作原理"><a href="#ETT的工作原理" class="headerlink" title="ETT的工作原理"></a>ETT的工作原理</h3><p>ETT就是用平衡树维护整个括号序列。</p>
<h4 id="子树信息查询"><a href="#子树信息查询" class="headerlink" title="子树信息查询"></a>子树信息查询</h4><p>就是括号序中，一段区间内的左括号的信息的和。</p>
<h4 id="链信息查询"><a href="#链信息查询" class="headerlink" title="链信息查询"></a>链信息查询</h4><p>首先通过差分转化成一个点到根的路径上的信息。然后，我们令一个点$x$入栈时加入序列中的那个点的权值取$val_x$，令$x$出栈时加入序列中的那个点的权值取$-val_x$，这样，序列中某个点入栈时的点左侧的所有点的$val$的和，就是这个点到根的路径上的所有点的$val$的和。</p>
<h4 id="子树信息修改"><a href="#子树信息修改" class="headerlink" title="子树信息修改"></a>子树信息修改</h4><p>直接把对序列进行区间修改即可。</p>
<h4 id="link和cut"><a href="#link和cut" class="headerlink" title="link和cut"></a>link和cut</h4><p>考虑对于一棵有根树，link和cut的本质是把从它的父亲那里剪下来，然后接到另一个点的下面。这对应到括号序列上就是区间平移。直接用平衡树实现就可以了。</p>
<hr>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h4 id="bzoj3786"><a href="#bzoj3786" class="headerlink" title="bzoj3786"></a>bzoj3786</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> xi[M],fi[M];</span><br><span class="line">ll val[M],sum[M],tag[M];</span><br><span class="line"><span class="keyword">int</span> ch[M][<span class="number">2</span>],fa[M],rt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	fi[x]=fi[ch[x][<span class="number">0</span>]]+fi[ch[x][<span class="number">1</span>]]+xi[x];</span><br><span class="line">	sum[x]=sum[ch[x][<span class="number">0</span>]]+sum[ch[x][<span class="number">1</span>]]+val[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,ll d)</span> </span>&#123;</span><br><span class="line">	sum[x]+=fi[x]*d,val[x]+=xi[x]*d;</span><br><span class="line">	tag[x]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!tag[x]) <span class="keyword">return</span>;</span><br><span class="line">	Add(ch[x][<span class="number">0</span>],tag[x]),Add(ch[x][<span class="number">1</span>],tag[x]);</span><br><span class="line">	tag[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Debug</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x) <span class="keyword">return</span>; push_down(x);</span><br><span class="line">	Debug(ch[x][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;val[x]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">	Debug(ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PD</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> stk[M],top;</span><br><span class="line">	stk[top=<span class="number">1</span>]=x;</span><br><span class="line">	<span class="keyword">while</span>(fa[x]) stk[++top]=fa[x],x=fa[x];</span><br><span class="line">	<span class="keyword">while</span>(top) push_down(stk[top--]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	printf("rotate: %d\n",x);</span></span><br><span class="line">	<span class="keyword">int</span> f=fa[x],ff=fa[f],d=get(x);</span><br><span class="line">	fa[x]=ff; <span class="keyword">if</span>(ff) ch[ff][ch[ff][<span class="number">1</span>]==f]=x;</span><br><span class="line">	fa[ch[x][d^<span class="number">1</span>]]=f,ch[f][d]=ch[x][d^<span class="number">1</span>];</span><br><span class="line">	fa[f]=x,ch[x][d^<span class="number">1</span>]=f; push_up(f),push_up(x);</span><br><span class="line"><span class="comment">//	Debug(rt);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> gl)</span> </span>&#123;</span><br><span class="line">	PD(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> f=fa[x];f!=gl;rotate(x),f=fa[x])</span><br><span class="line">		<span class="keyword">if</span>(fa[f]!=gl) rotate(get(x)==get(f)?f:x);</span><br><span class="line">	<span class="keyword">if</span>(!gl) rt=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	splay(x,<span class="number">0</span>); <span class="keyword">int</span> t=ch[x][d]; push_down(t);</span><br><span class="line">	<span class="keyword">while</span>(ch[t][d^<span class="number">1</span>]) t=ch[t][d^<span class="number">1</span>],push_down(t);</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lx[N],rx[N],n,id;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	lx[u]=++id;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[u].size();++i)</span><br><span class="line">		dfs(son[u][i]);</span><br><span class="line">	rx[u]=++id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) &#123; c=<span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; c=mid,fa[c]=f;</span><br><span class="line">	build(l,mid<span class="number">-1</span>,ch[c][<span class="number">0</span>],c),build(mid+<span class="number">1</span>,r,ch[c][<span class="number">1</span>],c);</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pr=find(l,<span class="number">0</span>),sf=find(r,<span class="number">1</span>);</span><br><span class="line">	splay(pr,<span class="number">0</span>),splay(sf,rt);</span><br><span class="line">	push_down(rt),push_down(sf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_val</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	split(lx[x],rx[x]);</span><br><span class="line">	Add(ch[ch[rt][<span class="number">1</span>]][<span class="number">0</span>],d);</span><br><span class="line">	push_up(ch[rt][<span class="number">1</span>]),push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_ed</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	split(lx[x],rx[x]);</span><br><span class="line">	<span class="keyword">int</span> f1=ch[rt][<span class="number">1</span>],t=ch[f1][<span class="number">0</span>];</span><br><span class="line">	ch[f1][<span class="number">0</span>]=<span class="number">0</span>,fa[t]=<span class="number">0</span>; push_up(f1),push_up(rt);</span><br><span class="line">	<span class="keyword">int</span> sf=find(lx[y],<span class="number">1</span>);</span><br><span class="line">	splay(lx[y],<span class="number">0</span>),splay(sf,rt);</span><br><span class="line">	push_down(rt),push_down(sf);</span><br><span class="line">	<span class="keyword">int</span> f2=ch[rt][<span class="number">1</span>];</span><br><span class="line">	ch[f2][<span class="number">0</span>]=t,fa[t]=f2; push_up(f2),push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q,x,y; <span class="keyword">char</span> ty[<span class="number">11</span>];</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) rd(x),son[x].PB(i);</span><br><span class="line">	++id;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	++id;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">		rd(x);</span><br><span class="line">		val[lx[i]]=x,xi[lx[i]]=<span class="number">1</span>;</span><br><span class="line">		val[rx[i]]=-x,xi[rx[i]]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	build(<span class="number">1</span>,id,rt,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//	Debug(rt);</span></span><br><span class="line">	rd(q);</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,ty);</span><br><span class="line">		<span class="keyword">if</span>(ty[<span class="number">0</span>]==<span class="string">'Q'</span>) &#123;</span><br><span class="line">			rd(x);</span><br><span class="line">			splay(lx[x],<span class="number">0</span>); push_down(lx[x]);</span><br><span class="line"><span class="comment">//			Debug(rt);</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum[lx[x]]-sum[ch[lx[x]][<span class="number">1</span>]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ty[<span class="number">0</span>]==<span class="string">'F'</span>) &#123;</span><br><span class="line">			rd(x),rd(y);</span><br><span class="line">			update_val(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			rd(x),rd(y);</span><br><span class="line">			update_ed(x,y);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		Debug(rt);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>P问题，NP问题，NPC问题，NPH问题</title>
    <url>/2022/06/30/P%E9%97%AE%E9%A2%98%EF%BC%8CNP%E9%97%AE%E9%A2%98%EF%BC%8CNPC%E9%97%AE%E9%A2%98%EF%BC%8CNPH%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="P问题"><a href="#P问题" class="headerlink" title="P问题"></a>P问题</h3><p>可以在多项式时间内求解的问题。</p>
<p>“P”  代表 “polynomial time” 。</p>
<h3 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h3><p>可以在多项式时间内检查解是否合法的问题。</p>
<p>“NP” 代表 “nondeterministic polynomial time” 。</p>
<p>显然有$P\subseteq NP$</p>
<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>对于两个问题A和B，如果能够在多项式时间内对A的输入进行转化，使得解决B的算法能够得到A问题的输出，那么就称A可以归约为B。一个例子是A为求解形式为$ax=b$的方程，而B为求解形式为$ax^2+bx+c=0$的方程。</p>
<h3 id="NPC问题（NP完全问题，NP-Complete问题）"><a href="#NPC问题（NP完全问题，NP-Complete问题）" class="headerlink" title="NPC问题（NP完全问题，NP-Complete问题）"></a>NPC问题（NP完全问题，NP-Complete问题）</h3><p>对于一个NP问题，如果所有的NP问题都可以归约为它，那么称之为NPC问题。</p>
<h3 id="NPH问题（NP-Hard问题）"><a href="#NPH问题（NP-Hard问题）" class="headerlink" title="NPH问题（NP-Hard问题）"></a>NPH问题（NP-Hard问题）</h3><p>对于一个问题，如果所有的NP问题都可以归约为它，那么称之为NPH问题。</p>
<h3 id="关于3-sat问题"><a href="#关于3-sat问题" class="headerlink" title="关于3-sat问题"></a>关于3-sat问题</h3><h4 id="3-sat问题"><a href="#3-sat问题" class="headerlink" title="3-sat问题"></a>3-sat问题</h4><p>有若干个布尔型的变量(variable)。</p>
<p>定义文字(literal)为，一个variable(称为positive literal)或者它的取反(称为negative literal)。</p>
<p>定义子句(clause)为，若干个文字（可能是一个）的或。</p>
<p>定义3-sat问题为：给出一个布尔表达式，这个表达式由若干个子句的与构成，每个子句恰好为三个文字的或，问是否存在一种给变量赋值的方式，使得表达式的值为真。</p>
<h4 id="3-sat问题相关的归约"><a href="#3-sat问题相关的归约" class="headerlink" title="3-sat问题相关的归约"></a>3-sat问题相关的归约</h4><p>（下面的例子来自维基百科）</p>
<p>表达式$l_1 \vee l_2\vee l_3\cdots\vee l_n$可以归约为3-sat的形式：</p>
<script type="math/tex; mode=display">
(l_1 \vee l_2\vee \ x_2) \wedge \\
(\neg x_2 \vee l_3 \vee x_3) \wedge \\
(\neg x_3 \vee l_4 \vee x_4) \wedge \cdots \wedge \\
(\neg x_{n-3} \vee l_{n-2} \vee x_{n-2}) \wedge\\
(\neg x_{n-2} \vee l_{n-1} \vee l_n)</script><p>已经被证明的重要结论：<strong>任意一个NP问题都可以归约为一个3-sat问题。</strong></p>
<p>所以，<strong>如果要证明一个问题是NPC问题，则只需要证明它是NP问题且可以由某一个已知为NPC的问题归约到它就可以了。</strong></p>
<h3 id="P-NP"><a href="#P-NP" class="headerlink" title="P=NP?"></a>P=NP?</h3><p>到目前为止还没有找到在多项式时间内求解NPC问题的算法，也无法将这个命题证明或者证伪。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Order theory and Dilworth&#39;s theorem</title>
    <url>/2022/06/30/Order-theory-and-Dilworth-s-theorem/</url>
    <content><![CDATA[<h1 id="English-Version"><a href="#English-Version" class="headerlink" title="English Version"></a>English Version</h1><h2 id="Order-theory"><a href="#Order-theory" class="headerlink" title="Order theory"></a>Order theory</h2><h3 id="partial-order"><a href="#partial-order" class="headerlink" title="partial order"></a>partial order</h3><p><strong>Partial orders</strong> are special binary relations that satisfy :</p>
<ol>
<li>a ≤ a (reflexivity) 自反性</li>
<li>if a ≤ b and b ≤ a then a = b (antisymmetry) 非对称性</li>
<li>if a ≤ b and b ≤ c then a ≤ c (transitivity). 传递性</li>
</ol>
<h3 id="partial-ordered-set"><a href="#partial-ordered-set" class="headerlink" title="partial ordered set"></a>partial ordered set</h3><p>Defined as <em>a set with a partial order</em>.</p>
<p>Also called <strong>poset</strong>, and <strong>ordered set</strong> if the intended meaning is clear.</p>
<h3 id="comparable"><a href="#comparable" class="headerlink" title="comparable"></a>comparable</h3><p>For some pair of elements $a,b$, if $a \le b\vee b\le a$ holds, then we say $a$ and $b$ are <strong>comparable</strong>.  Otherwise they are <strong>incomparable</strong>.</p>
<h3 id="connexity"><a href="#connexity" class="headerlink" title="connexity"></a>connexity</h3><p>(adj. connex)</p>
<p>If a relation is <strong>connex</strong> or satisfies the property of <strong>connexity</strong>, then it relates all pairs of elements in some way (or to say that every pair of elements are comparable).</p>
<p>i.e. $\forall x,y\in X$，either $x\le y$ or $y \le x$ is true, where $\le$ is the relation we defined with partial ordered set.</p>
<h3 id="total-order"><a href="#total-order" class="headerlink" title="total order"></a>total order</h3><p>A connex partial order is called <strong>a total order, a linear order</strong> or <strong>a chain</strong>.</p>
<p>Additionally, a subset of a poset in which no two elements are comparable is an <strong>anti-chain</strong>.</p>
<h2 id="Dilworth’s-theorem"><a href="#Dilworth’s-theorem" class="headerlink" title="Dilworth’s theorem"></a>Dilworth’s theorem</h2><h3 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h3><p>Dilworth’s theorem states that, in any finite partially ordered set, the largest anti-chain has the same size (where the size is defined as the number of elements in it) as the smallest chain decomposition (where the size is defined as the number of sets we have decomposited the elements into so that every set forms a chain).</p>
<p>Meanwhile, the <strong>width</strong> of a partially ordered set is defined as a size, that can be the size of some anti-chain and can also be that of some chain decomposition. And from the statements above, we know that the width of a given partially ordered set is unique.</p>
<h3 id="proof"><a href="#proof" class="headerlink" title="proof"></a>proof</h3><p>Here is the proof via Kőnig’s theorem.</p>
<p>For a partial ordered set $S$, construct a bipartite graph $G=(U,V,E)$, where $U=V=S$ and edge $(x,y)$ is in $E$ if $x \le y\wedge x\not=y$ holds (where $\le$ stands for the partial order).</p>
<p>Suppose that one of the maximum matching for $G$ is $M$, and $C$ is one of the smallest vertex cover that every vetex in $C$ has a neighbouring edge in $M$.  And we know $|C|=|M|=m$ by Kőnig’s theorem.</p>
<p>Imagine we start from one vertex $x_V$ in $V$ with a neighbouring edge in $M$, then go to its matching vertex $y_U$, then start again from $y_U$’s corresponding vertex on the other side of the graph $y_V$, then to the vertex that matches $y_V$, and so on.  Since no two elements in $S$ are the same, we will never return to $x_V$. That is to say, our path never forms a circle. And from the definition of matching we know that the indegree of every element we passed through (e.g. $x$) is at most $1$ and so is outdegree.</p>
<p>So a matching can refer to a set of disjoint paths (also chains by the definition above) , and when the size of the matching is growing, we add more edges to these paths, and the number of paths is decreasing.</p>
<p>This leads to a conclusion that the size of the smallest chain decomposition is equal to $|S|-m$。</p>
<p>On the other hand, we consider a set $A$ of elements in $S$ that do not correspond to any vertices in $C$. Then the size of $A$ is at least $|S|-m$, since there might be two vertices in $C$ from different side of $G$ and corresponding to the same element in $S$.  And obviously, $|A|$ is an antichain. But $|A|$ can not be larger than $|S|-m$ since if $|A|$ is larger than the size of the smallest chain decomposition, at least two elements in $A$ will be in the same chain, which meets a contradiction.</p>
<h1 id="中文版本"><a href="#中文版本" class="headerlink" title="中文版本"></a>中文版本</h1><h2 id="Order-theory-1"><a href="#Order-theory-1" class="headerlink" title="Order theory"></a>Order theory</h2><h3 id="partial-order-1"><a href="#partial-order-1" class="headerlink" title="partial order"></a>partial order</h3><p><strong>偏序关系 (partial order) </strong>定义为满足下列条件的二元关系：</p>
<ol>
<li>自反性 (reflexivity)，即$a\le a$</li>
<li>非对称性 (antisymmetry)，即$a\le b \wedge b\le a \Rightarrow a=b$</li>
<li>传递性 (transitivity)，即$a\le b \wedge b\le c \Rightarrow a\le c$</li>
</ol>
<h3 id="partial-ordered-set-1"><a href="#partial-ordered-set-1" class="headerlink" title="partial ordered set"></a>partial ordered set</h3><p><strong>偏序集合 (partial ordered set) </strong>定义为<em>配备了偏序关系的集合</em>；或一个二元组$(S,R)$，其中$R$是定义在$S$中的元素上的偏序关系。</p>
<h3 id="comparable-1"><a href="#comparable-1" class="headerlink" title="comparable"></a>comparable</h3><p>对于某一对元素$a,b$，如果满足$a\le b \vee b\le a$（其中$\le$是一种偏序关系），那么称它们为<strong>可比较的 (comparable) </strong>；否则称它们为<strong>不可比较的 (incomparable) </strong>。</p>
<h3 id="connexity-1"><a href="#connexity-1" class="headerlink" title="connexity"></a>connexity</h3><p>如果一个偏序关系满足任意一对元素都是可比较的，则称这个关系满足<strong>完全性条件 (connexity) </strong>或者说这个关系是<strong> 完全的 (connex) </strong>。</p>
<h3 id="total-order-1"><a href="#total-order-1" class="headerlink" title="total order"></a>total order</h3><p><strong>全序关系 (total order) </strong>即满足完全性的偏序关系。</p>
<p>满足全序关系的集合又叫做<strong>全序性集合、线性序集合、简单序集合或者链 (chain)</strong>。链也常用于描述偏序集合的满足完全性的子集。</p>
<p>此外，偏序集合的任意两个元素都不可比较的子集称为<strong>反链 (anti-chain) </strong>。</p>
<h2 id="Dilworth’s-theorem-1"><a href="#Dilworth’s-theorem-1" class="headerlink" title="Dilworth’s theorem"></a>Dilworth’s theorem</h2><h3 id="statement-1"><a href="#statement-1" class="headerlink" title="statement"></a>statement</h3><p>定义一个偏序集合的<strong>链划分 (chain decomposition) </strong>为一个由链组成的集合，满足任意两条链没有公共点，且集合中的链的并集为全集；定义其大小为集合中的链的条数。定义反链的大小为其中的元素数量。</p>
<p>Dilworth’s theorem 则是说，<strong>一个偏序集合的最小链划分与最长反链的大小相同。</strong>这个大小也被称为这个偏序集合的<strong>宽度 (width) </strong>。</p>
<h3 id="proof-1"><a href="#proof-1" class="headerlink" title="proof"></a>proof</h3><p>下面的证明借助于<strong>Kőnig’s theorem</strong>（即二分图的最大匹配大小等于最小顶点覆盖）。</p>
<p>对于一个偏序集$S$，构造一个二分图$G=(U,V,E)$，使得$U=V=S$，而边$(x,y)$（从$U$的$x$连到$V$的$y$）存在，当且仅当$x\le y\wedge x\not=y$（$\le$代表偏序关系     ）。求出这个图的一个最大匹配$M$和一个最小顶点覆盖$C$，使得$C$中的任意一个点都有一条邻边在$M$中。令$m=|C|=|M|$。</p>
<p>想象现在从某个在$M$中的点$x_V$（表示$V$这一侧的点$x$）开始，走到它匹配的那个点$y_U$，然后到$y_U$所对应的另一侧的点$y_V$，接下来走到$y_V$所匹配的点……由于$S$中的元素互不相同，而偏序关系具有传递性，所以我们不会走回$x_U$，也就是说我们走过的点不成环。将我们走过的点在$S$中对应的元素拿出来：$x\to y\to \cdots $，恰好会对应一条链，因为匹配的定义保证了每个点的入度至多是$1$，每个点的出度也至多是$1$。</p>
<p>进一步地，一个匹配$M’$实际上对应了一个链划分，由于每往匹配中加一条边相当于合并了两条链，所以这个匹配对应的链划分的大小为$|S| - |M’|$。故而$S$的最小链划分的大小为$|S|-m$。</p>
<p>此外，考虑由$S$没有对应到$C$中的任何一个点的元素构成的集合，设为$A$。$A$显然是反链。那么$|A|\ge |S|-|C|=|S|-m$，因为可能会存在一个元素在$U,V$中对应的点都属于$C$。而从另一个角度考虑，$|A|\le |S|-m$，因为如果$|A|$大于了最小链划分的大小，则至少会有两个$A$中的元素属于最小链划分中的同一条链，与定义矛盾。故而我们有$|A|=|S|-m$。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>坐标轴的旋转变换</title>
    <url>/2022/06/30/%E5%9D%90%E6%A0%87%E8%BD%B4%E7%9A%84%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>将$(x_1,y_1)$和$(x_2,y_2)$分别作为$ x$轴和$ y$轴（即将坐标轴旋转，使得$x$轴与$(x_1,y_1)$平行，$y$轴与$(x_2,y_2)$平行，也就是将$(x_1,y_1)$，$(x_2,y_2)$作为单位向量），需要求出其他的点在旋转后的坐标系里的坐标。</p>
<p>如何实现？考虑原来的向量$(x,y)$表示的向量实际上是$xi+yj$，也就是单位向量$i$的$x$倍 + 单位向量$j$的$y$倍。因此，可以设这个点变化后的坐标为$(x’,y’)$，则：</p>
<script type="math/tex; mode=display">
\begin{cases}
x=x'\cdot x_1 + y' \cdot x_2\\
y=x'\cdot y_1 + y' \cdot y_2\\
\end {cases}</script><p>解得</p>
<script type="math/tex; mode=display">
\begin{cases}
x'={xy_2-x_2y\over x_1y_2-x_2y_1}\\
y'={x_1y-xy_1\over x_1y_2-x_2y_1}
\end{cases}</script><p>看起来就是叉乘的乘积——可是为什么呢？</p>
<p>让我们来看一幅图：</p>
<p><img src="https://i.loli.net/2019/09/13/Hx8rZiCo9LTBVhw.png" alt="q.png"></p>
<p>设$P(x,y)$为我们要计算的点，$OM,ON$分别为两个“单位向量”，过$P$作单位向量的平行线$PA//OM,PB//ON$，则$x’={OB\over OM},y’={OA\over ON}$。</p>
<p>现在要证明的就是：</p>
<script type="math/tex; mode=display">
\begin{cases}
{S_{\triangle OPN}\over S_{\triangle MON}}={OB\over OM}\\
{S_{\triangle OPM}\over S_{\triangle MON}}={OA\over ON}\\
\end{cases}</script><p>第一个式子等价于${S_{\triangle OPN}\over AP}={S_{\triangle MON}\over OM}$。</p>
<p>过$N,O$分别作$AP$的垂线交AP于$H_1,H_2$，则$S_{\triangle OPN}={1\over 2} AP \cdot (OH_2+NH_1)$，$S_{\triangle MON} ={1\over 2}OM\cdot (OH_2+NH_1)$，上式得证。同理可以证明第二个式子。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何基础</title>
    <url>/2022/06/30/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="计算几何基础"><a href="#计算几何基础" class="headerlink" title="计算几何基础"></a>计算几何基础</h1><p>标签（空格分隔）： 计算几何</p>
<hr>
<h3 id="三角函数、平面向量"><a href="#三角函数、平面向量" class="headerlink" title="三角函数、平面向量"></a>三角函数、平面向量</h3><p><a href="https://www.guokr.com/question/510522/" target="_blank" rel="noopener">高维向量积</a></p>
<hr>
<h3 id="判断线段相交"><a href="#判断线段相交" class="headerlink" title="判断线段相交"></a>判断线段相交</h3><p>如果判断两条线段是否是规范相交（恰有一个不是端点的公共点），做跨立实验即可。比如对于$p_1,p_2$所组成的线段与$p_3,p_4$所组成的线段，判断$p_1,p_2$是否在直线$p_3,p_4$的异侧，再判断$p_3,p_4$是否在直线$p_1,p_2$的异侧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Online</span><span class="params">(Point a[],Point b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dump(Cross(a[<span class="number">0</span>]-b[<span class="number">0</span>],b[<span class="number">1</span>]-b[<span class="number">0</span>]))*dump(Cross(a[<span class="number">1</span>]-b[<span class="number">0</span>],b[<span class="number">1</span>]-b[<span class="number">0</span>]))&gt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(dump(Cross(b[<span class="number">0</span>]-a[<span class="number">0</span>],a[<span class="number">1</span>]-a[<span class="number">0</span>]))*dump(Cross(b[<span class="number">1</span>]-a[<span class="number">0</span>],a[<span class="number">1</span>]-a[<span class="number">0</span>]))&gt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要让作为公共部分也返回 1 ，那么就必须特判，直接将大于等于改成大于是错误的写法，因为有可能在做第一个跨立实验时，叉乘选择的起始点恰好是那个在直线$p_2,p_3$上但却不在线段$p_2,p_3$上的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Onseg</span><span class="params">(Point r,Point l,Point a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.x&lt;min(l.x,r.x)||a.x&gt;max(l.x,r.x)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(a.y&lt;min(l.y,r.y)||a.y&gt;max(l.y,r.y)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Inter</span><span class="params">(Point a0,Point a1,Point b0,Point b1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> d1=dump(Cross(a0-b0,b1-b0)),d2=dump(Cross(a1-b0,b1-b0));</span><br><span class="line">	<span class="keyword">double</span> d3=dump(Cross(b0-a0,a1-a0)),d4=dump(Cross(b1-a0,a1-a0));</span><br><span class="line">	<span class="keyword">if</span>(d1*d2&lt;<span class="number">0</span>&amp;&amp;d3*d4&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d1==<span class="number">0</span>&amp;&amp;Onseg(b1,b0,a0)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d2==<span class="number">0</span>&amp;&amp;Onseg(b1,b0,a1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d3==<span class="number">0</span>&amp;&amp;Onseg(a1,a0,b0)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d4==<span class="number">0</span>&amp;&amp;Onseg(a1,a0,b1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="计算两条直线的交点"><a href="#计算两条直线的交点" class="headerlink" title="计算两条直线的交点"></a>计算两条直线的交点</h3><p>第一条直线经过$p_1,p_2$，第二条直线经过$p_3,p_4$，那么我们可以以三角形$p_1p_2p_3$和三角形$p_1p_2p_4$的<strong>有向</strong>面积的比值（强调有向是为了避免关于几个点的相对位置的讨论），对$p_3,p_4$的坐标进行放缩，具体如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">get</span><span class="params">(Point p1,Point p2,Point s1,Point s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> t1=Cross(s1-p1,p2-p1),t2=Cross(p2-p1,s2-p1);</span><br><span class="line">	Point p;</span><br><span class="line">	p.x=(s1.x*t2+s2.x*t1)/(t1+t2);</span><br><span class="line">	p.y=(s1.y*t2+s2.y*t1)/(t1+t2);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在利用类似的思想进行放缩的时候，要格外注意分母是否可能为 0 。</p>
<hr>
<h3 id="角度相关的数学函数"><a href="#角度相关的数学函数" class="headerlink" title="角度相关的数学函数"></a>角度相关的数学函数</h3><p>sin cos tan：传入弧度制的角度，返回对应的函数值<br>asin acos atan：传入函数值，返回弧度制的角度</p>
<p>特别特别重要的：<br>atan2(y,x)：如果点$(x,y)$在一二象限，则返回有$x$的正半轴逆时针转到原点与$(y,x)$所连的射线扫过的角的大小（返回值为正）；否则，返回顺时针转到原点与$(y,x)$所连的射线扫过的角，返回值为负。返回值为弧度制，且绝对值小于$\pi$。<br>利用三角函数得到$\pi$：acos（-1.0）如果写 1 ，使用C++编译器提交的时候可能会CE。</p>
<hr>
<h3 id="多边形相关"><a href="#多边形相关" class="headerlink" title="多边形相关"></a>多边形相关</h3><h4 id="计算多边形面积"><a href="#计算多边形面积" class="headerlink" title="计算多边形面积"></a>计算多边形面积</h4><p>任取一个点，这个点与多边形的每一条边组成的三角形的有向面积之和的绝对值等于多边形面积。</p>
<h4 id="判断多边形是否是凸多边形"><a href="#判断多边形是否是凸多边形" class="headerlink" title="判断多边形是否是凸多边形"></a>判断多边形是否是凸多边形</h4><p>1.判断每一条边的拐向是否与第一条边的拐向相同。<br>2.求一遍凸包，判断凸包上是否有$n$个点</p>
<h4 id="判断点是否在多边形内"><a href="#判断点是否在多边形内" class="headerlink" title="判断点是否在多边形内"></a>判断点是否在多边形内</h4><p>1.从点出发向左画一条水平的射线，计算射线与多边形的交点次数。对于线段的端点，我们取每一条线段靠下的端点，不取每一条线段靠上的端点（如果是水平的线段，那么我们取左端点，不取右端点）。这相当于是把点向下平移了$eps$的距离。如果次数为奇数，则在多边形内，否则在多边形外。<br>2.这个点与多边形的每一条边叉乘的结果，先取绝对值再求和，比较得到的值是否等于面积。如果相等，则在多边形内，否则不在。</p>
<hr>
<h3 id="皮克定理"><a href="#皮克定理" class="headerlink" title="皮克定理"></a>皮克定理</h3><p>皮克定理：整点构成的多边形，内部的点数为$I$，边上的点数为$E$，面积为$S$，则$S=I+{E\over 2}-1$</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态加点的凸包</title>
    <url>/2022/06/30/%E5%8A%A8%E6%80%81%E5%8A%A0%E7%82%B9%E7%9A%84%E5%87%B8%E5%8C%85/</url>
    <content><![CDATA[<p>有一个二维平面上的点构成的点集。有两种操作：1）加入一个点。2）询问一个点是否在这个点集的凸包内。</p>
<h2 id="方法1：分别维护上凸壳和下凸壳"><a href="#方法1：分别维护上凸壳和下凸壳" class="headerlink" title="方法1：分别维护上凸壳和下凸壳"></a>方法1：分别维护上凸壳和下凸壳</h2><p>对于每个凸壳，用一个$set$存下凸壳上的点，把这些点按照横坐标排好序。新加入点的时候，找出横坐标与新加入点最接近的、凸壳上的点，判断是否需要弹掉。查询的时候二分找出对应的位置。</p>
<p>注意一个问题：最开始的时候，我的代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;Point&gt;::iterator pre=s1.upper_bound(A),suf=s1.lower_bound(A);</span><br><span class="line"><span class="comment">// 弹掉横坐标小于等于A的不需要的点</span></span><br></pre></td></tr></table></figure>
<p>这样可能$suf$指向的元素，在弹横坐标大于等于$A$的点的时候，已经被删掉了。</p>
<p>zlx告诉我，实际上不需要单独写上下凸壳的加入、查询函数，因为上凸壳按照$x$轴对称之后就是个下凸壳，可以只写维护下凸壳的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">	ll x,y;</span><br><span class="line">	Point (ll x=<span class="number">0</span>,ll y=<span class="number">0</span>): x(x),y(y) &#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> Point <span class="keyword">operator</span> +(Point A,Point B) &#123; <span class="keyword">return</span> Point(A.x+B.x,A.y+B.y); &#125;</span><br><span class="line">	<span class="keyword">friend</span> Point <span class="keyword">operator</span> -(Point A,Point B) &#123; <span class="keyword">return</span> Point(A.x-B.x,A.y-B.y); &#125;</span><br><span class="line">	<span class="keyword">friend</span> Point <span class="keyword">operator</span> *(Point A,ll B) &#123; <span class="keyword">return</span> Point(A.x*B,A.y*B); &#125;</span><br><span class="line">	<span class="keyword">friend</span> Point <span class="keyword">operator</span> /(Point A,ll B) &#123; <span class="keyword">return</span> Point(A.x/B,A.y/B); &#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Point A,Point B) &#123; <span class="keyword">return</span> A.x&lt;B.x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ll <span class="title">Cross</span><span class="params">(Point A,Point B)</span> </span>&#123; <span class="keyword">return</span> A.x*B.y-A.y*B.x; &#125;</span><br><span class="line"><span class="built_in">set</span>&lt;Point&gt; s1,s2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">be_under</span><span class="params">(Point A)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;Point&gt;::iterator it1=s1.lower_bound(A),it2;</span><br><span class="line">	<span class="keyword">if</span>(it1==s1.end()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((*it1).x==A.x) <span class="keyword">return</span> (*it1).y&gt;=A.y;</span><br><span class="line">	<span class="keyword">if</span>(it1==s1.begin()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	it2=it1,it2--;</span><br><span class="line">	<span class="keyword">return</span> Cross(A-(*it2),(*it1)-(*it2))&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">be_upper</span><span class="params">(Point A)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;Point&gt;::iterator it1=s2.lower_bound(A),it2;</span><br><span class="line">	<span class="keyword">if</span>(it1==s2.end()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((*it1).x==A.x) <span class="keyword">return</span> (*it1).y&lt;=A.y;</span><br><span class="line">	<span class="keyword">if</span>(it1==s2.begin()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	it2=it1,it2--;</span><br><span class="line">	<span class="keyword">return</span> Cross((*it1)-(*it2),A-(*it2))&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_down</span><span class="params">(Point A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s2.empty()) &#123; s2.insert(A); <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;Point&gt;::iterator pre=s2.upper_bound(A),ppre;</span><br><span class="line">	<span class="keyword">if</span>(pre!=s2.begin()) &#123;</span><br><span class="line">		pre--;</span><br><span class="line">		<span class="keyword">while</span>(pre!=s2.begin()) &#123;</span><br><span class="line">			ppre=pre,--ppre;</span><br><span class="line">			<span class="keyword">if</span>(Cross((*pre)-(*ppre),A-(*ppre))&lt;=<span class="number">0</span>) s2.erase(*pre),pre=ppre;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pre==s2.begin())</span><br><span class="line">			<span class="keyword">if</span>((*pre).x==A.x) s2.erase(*pre);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;Point&gt;::iterator suf=s2.lower_bound(A),ssuf;</span><br><span class="line">	<span class="keyword">if</span>(suf!=s2.end()) &#123;</span><br><span class="line">		ssuf=suf,++ssuf;</span><br><span class="line">		<span class="keyword">while</span>(ssuf!=s2.end()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Cross((*suf)-A,(*ssuf)-A)&lt;=<span class="number">0</span>) s2.erase(*suf),suf=ssuf;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			++ssuf;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ssuf==s2.end())</span><br><span class="line">			<span class="keyword">if</span>((*suf).x==A.x) s2.erase(*suf); </span><br><span class="line">	&#125;</span><br><span class="line">	s2.insert(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_up</span><span class="params">(Point A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1.empty()) &#123; s1.insert(A); <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;Point&gt;::iterator pre=s1.upper_bound(A),ppre;</span><br><span class="line">	<span class="keyword">if</span>(pre!=s1.begin()) &#123;</span><br><span class="line">		pre--;</span><br><span class="line">		<span class="keyword">while</span>(pre!=s1.begin()) &#123;</span><br><span class="line">			ppre=pre,--ppre;</span><br><span class="line">			<span class="keyword">if</span>(Cross((*pre)-(*ppre),A-(*ppre))&gt;=<span class="number">0</span>) s1.erase(*pre),pre=ppre;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pre==s1.begin())</span><br><span class="line">			<span class="keyword">if</span>((*pre).x==A.x) s1.erase(*pre);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;Point&gt;::iterator suf=s1.lower_bound(A),ssuf;</span><br><span class="line">	<span class="keyword">if</span>(suf!=s1.end()) &#123;</span><br><span class="line">		ssuf=suf,++ssuf;</span><br><span class="line">		<span class="keyword">while</span>(ssuf!=s1.end()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Cross((*suf)-A,(*ssuf)-A)&gt;=<span class="number">0</span>) s1.erase(*suf);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			suf=ssuf,++ssuf;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ssuf==s1.end())</span><br><span class="line">			<span class="keyword">if</span>((*suf).x==A.x) s1.erase(*suf); </span><br><span class="line">	&#125;</span><br><span class="line">	s1.insert(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"upper:"</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">set</span>&lt;Point&gt;::iterator it=s1.begin();it!=s1.end();++it) <span class="built_in">printf</span>(<span class="string">"%lld %lld  "</span>,it-&gt;x,it-&gt;y);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"lower:"</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">set</span>&lt;Point&gt;::iterator it=s2.begin();it!=s2.end();++it) <span class="built_in">printf</span>(<span class="string">"%lld %lld  "</span>,it-&gt;x,it-&gt;y);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q,ty; Point p;</span><br><span class="line">	rd(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;++i,q--) &#123;</span><br><span class="line">		rd(ty),rd(p.x),rd(p.y);</span><br><span class="line">		insert_down(p),insert_up(p);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	Debug();</span></span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		rd(ty),rd(p.x),rd(p.y);</span><br><span class="line">		<span class="keyword">if</span>(ty==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!be_under(p)) insert_up(p);</span><br><span class="line">			<span class="keyword">if</span>(!be_upper(p)) insert_down(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(be_under(p)&amp;&amp;be_upper(p)) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		Debug();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法2：维护极角序"><a href="#方法2：维护极角序" class="headerlink" title="方法2：维护极角序"></a>方法2：维护极角序</h2><p>首先找出头三个加入的点组成的凸包的内部的一个点，这个点在之后的任意时刻一定都在凸包内，我们就把它作为原点，按照极角序维护凸包上的点。加入一个点的时候，判断与这个点极角序相邻的点是否需要被弹掉就可以了。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Minkowski Sum 闵可夫斯基和</title>
    <url>/2022/06/30/Minkowski-Sum-%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>这是一种对两个向量集合定义的运算。对于两个集合$A,B\in R^n$，它们的Minkowski Sum定义为：</p>
<script type="math/tex; mode=display">
A + B=\{ a+b : a\in A,b\in B\}</script><hr>
<h3 id="一个重要的性质"><a href="#一个重要的性质" class="headerlink" title="一个重要的性质"></a>一个重要的性质</h3><p>如果我们把凸多边形的顶点看做向量，用$Conv(S)$表示点集$S$内的点的凸包，那么有一个性质：</p>
<script type="math/tex; mode=display">
Conv(A+B)=Conv(Conv(A)+Conv(B))</script><p>证明如下：<br>首先，设$Conv(A)=\{ v_1,v_2\cdots v_n\}$，则任何一个$Conv(A)$内的点可以用它们的凸组合（convex combination）表示，即：</p>
<p>对于一个点集$S=\{ x_1,x_2,\cdots x_n\}$，一个形如$\alpha_1 x_1 + \alpha_2x_2 + \alpha_3 v_3\cdots \alpha_nv_n$且满足$\alpha_1+\alpha_2 +\alpha_3 + \cdots +\alpha_n =1$并且$\forall i\in [1,n],0\le \alpha_i\le 1$的点，称为$S$的一个凸组合。显然一个点集所有的凸组合等于这个点集的凸包内部的点（可以这样去理解：首先，对于只有两个点，它们的凸组合是它们之间的线段上的点；如果再加一个点，三角形内的点可以看做一条边上的一点与和这条边的相对的顶点的凸组合，以此类推）。</p>
<p>设$v=\sum \alpha_i\cdot v_i,w=\sum \beta_i\cdot w_i$，即$v,w$分别是$A,B$的两个凸组合，则</p>
<script type="math/tex; mode=display">
v+w=\sum \alpha_iv_i+ \sum \beta_j w_j\\
=\sum \alpha_i \beta_j (v_i+w_j)</script><p>即$v+w$为$A+B$的凸组合。</p>
<hr>
<h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>假如现在有两个凸多边形，要计算它们的Minkowski Sum。按照逆时针方向，令两个凸多边形的边为从它的一个端点指向下一个端点的向量（“下一个”是指凸多边形上按照逆时针方向的下一个），然后对所有的这些向量进行极角排序。选择两个凸多边形最靠左的两个顶点，显然这两个顶点相加一定在$Conv(A+B)$上，然后从这两个顶点相加得到的点开始，将排好序的向量依次拿出来接在上一个顶点的后面，最后将得到一个凸多边形，这个凸多边形就是$Conv(A+B)$。</p>
<hr>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="JSOI-2018-部落战争"><a href="#JSOI-2018-部落战争" class="headerlink" title="JSOI 2018 部落战争"></a>JSOI 2018 部落战争</h4><p>题意：给两个点集，设这两个点的凸包分别为$A$和$B$，每次询问给一个向量，判断$A$中是否存在一个点，这个点加上这个向量过后得到的点在$B$内。</p>
<p>Solution：要求$a+d=b$，也就是求$d=a-b$。将$B$中所有向量取反，与$A$做Minkowski Sum，判断询问是否在Minkowski Sum中即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	ll x,y; <span class="keyword">double</span> ag;</span><br><span class="line">	Point(ll x=<span class="number">0</span>,ll y=<span class="number">0</span>,<span class="keyword">double</span> ag=<span class="number">0</span>): x(x),y(y),ag(ag) &#123;&#125;;</span><br><span class="line">	<span class="keyword">friend</span> Point <span class="keyword">operator</span> +(Point a,Point b)&#123;<span class="keyword">return</span> Point (a.x+b.x,a.y+b.y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> Point <span class="keyword">operator</span> -(Point a,Point b)&#123;<span class="keyword">return</span> Point (a.x-b.x,a.y-b.y);&#125;</span><br><span class="line">&#125;st[N];</span><br><span class="line"><span class="function">ll <span class="title">Cross</span><span class="params">(Point a,Point b)</span></span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>(x)&lt;eps?<span class="number">0</span>:(x&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dis</span><span class="params">(Point a)</span></span>&#123;<span class="keyword">return</span> <span class="number">1.0</span>*a.x*a.x+<span class="number">1.0</span>*a.y*a.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Point a,Point b)</span></span>&#123;<span class="keyword">return</span> dcmp(a.ag-b.ag)==<span class="number">0</span>?Dis(a)&lt;Dis(b):a.ag&lt;b.ag;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(Point *p,<span class="keyword">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="keyword">if</span>(p[i].x&lt;p[<span class="number">1</span>].x||(p[i].x-p[<span class="number">1</span>].x==<span class="number">0</span>&amp;&amp;p[i].y&lt;p[<span class="number">1</span>].y)) swap(p[<span class="number">1</span>],p[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) p[i]=p[i]-p[<span class="number">1</span>],p[i].ag=<span class="built_in">atan2</span>(p[i].y,p[i].x);</span><br><span class="line">	sort(p+<span class="number">2</span>,p+n+<span class="number">1</span>,cmp);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> top=<span class="number">0</span>; st[++top]=Point(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;Cross(st[top]-st[top<span class="number">-1</span>],p[i]-st[top<span class="number">-1</span>])&lt;=<span class="number">0</span>) top--;</span><br><span class="line">		st[++top]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++) p[i]=st[i]+p[<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	n=top;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">Point p1[N],p2[N],pt[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l1=<span class="number">1</span>,l2=<span class="number">1</span>; pt[++tot]=p1[<span class="number">1</span>]+p2[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(l1&lt;=n||l2&lt;=m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(l1&lt;=n&amp;&amp;Cross(p1[l1%n+<span class="number">1</span>]-p1[l1],p2[l2%m+<span class="number">1</span>]-p2[l2])&gt;<span class="number">0</span>)</span><br><span class="line">			tot++,pt[tot]=pt[tot<span class="number">-1</span>]+(p1[l1%n+<span class="number">1</span>]-p1[l1]),l1++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(l2&lt;=m) tot++,pt[tot]=pt[tot<span class="number">-1</span>]+(p2[l2%m+<span class="number">1</span>]-p2[l2]),l2++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	get(pt,tot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">che</span><span class="params">(Point Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Cross(Q-pt[<span class="number">1</span>],pt[<span class="number">2</span>]-pt[<span class="number">1</span>])&gt;<span class="number">0</span>||Cross(Q-pt[<span class="number">1</span>],pt[tot]-pt[<span class="number">1</span>])&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>,r=tot,ans=l;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(Cross(pt[mid]-pt[<span class="number">1</span>],Q-pt[<span class="number">1</span>])&gt;=<span class="number">0</span>) ans=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Cross(pt[ans%tot+<span class="number">1</span>]-pt[ans],Q-pt[ans])&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q; read(n),read(m),read(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) read(p1[i].x),read(p1[i].y); get(p1,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) read(p2[i].x),read(p2[i].y),p2[i]=Point(<span class="number">0</span>,<span class="number">0</span>)-p2[i]; get(p2,m);</span><br><span class="line">	cal();</span><br><span class="line">	<span class="keyword">while</span>(q--)</span><br><span class="line">	&#123;</span><br><span class="line">		Point Q; read(Q.x),read(Q.y);</span><br><span class="line">		<span class="keyword">if</span>(che(Q)) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="正睿OI-省选模拟-Nagisa"><a href="#正睿OI-省选模拟-Nagisa" class="headerlink" title="正睿OI 省选模拟 Nagisa"></a>正睿OI 省选模拟 Nagisa</h4><p>题意：给你三个凸多边形，有$m$次询问，每次给出一个点的坐标，询问以这个点作为重心且三个顶点分别位于三个凸多边形内的三角形是否存在。</p>
<p>题解：可行区域就是三个凸包的Minkowki Sum。</p>
<hr>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>几篇证明：<a href="https://www.quora.com/How-can-I-show-that-the-Minkowski-sum-of-2-convex-polygons-is-equal-to-the-convex-hull-of-the-Minkowski-sum-of-the-set-of-vertices-of-each-polygon" target="_blank" rel="noopener">1</a> <a href="https://math.stackexchange.com/questions/587162/prove-convex-hull-of-minkowski-sum" target="_blank" rel="noopener">2</a><br>维基百科：<a href="https://en.wikipedia.org/wiki/Minkowski_addition" target="_blank" rel="noopener">Minkowski Sum</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Euler Line 欧拉线</title>
    <url>/2022/06/30/Euler-Line-%E6%AC%A7%E6%8B%89%E7%BA%BF/</url>
    <content><![CDATA[<p>定理：三角形的垂心(orthocenter)、重心(centroid)、外心(circumcenter)共线，且重心到垂心的距离等于重心到外心的距离的两倍。过三角形的垂心、重心、外心的直线称为<strong>欧拉线(Euler line)</strong>。</p>
<p>可以在<a href="https://www.geogebra.org/graphing/fm4wchdg" target="_blank" rel="noopener">这里</a>感受一下。</p>
<p>证明：</p>
<p>令$\triangle_{ABC}$的垂心，重心，外心分别为$O_1,O_2,O_3$</p>
<p>分别作$AB,BC,CA$的中点$E,F,D$，则$EF,ED,FD$是$\triangle_{ABC}$的中位线，$\triangle_{ABC}\sim \triangle_{FDE}$且相似比为$2:1$。</p>
<p>由重心的性质得$BD$过$O_2$且$\frac{BO_2}{DO_2} = 2$。</p>
<p>由垂心的定义得$O_1B\perp AC$。</p>
<p>由于外心是边的垂直平分线的交点，且$D$是$AC$的中点，所以$O_3D\perp AC$。所以有$O_1B \parallel O_2D$。</p>
<p><img src="https://i.loli.net/2020/01/09/XGcbhrj5I2iSel1.png" alt="Euler_line.png"></p>
<p>由于$EF\parallel AC, O_3D\perp AC$，所以$O_3D\perp EF$。同理可以证明，$O_3F\perp ED,O_3E\perp FD$。所以$\triangle_{ABC}$的外心和$\triangle_{DEF}$的垂心重合。</p>
<p>由$\triangle_{ABC}\sim \triangle_{FDE}$知$B$到$\triangle_{ABC}$的垂心的距离等于$D$到$\triangle_{DEF}$的垂心的距离的两倍，也就是说$2DO_3=BO_1$。又因为$2DO_2 = BO_2,\angle O_1BO_2 = \angle O_2DO_3$，所以$\triangle_{BO_2O_1}\sim \triangle_{DO_2O_3}$。</p>
<p>由$\triangle_{BO_2O_1}\sim \triangle_{DO_2O_3}$知$\frac{O_1O_2}{O_2O_3} = \frac{BO_2}{DO_2} = 2$，$\angle BO_2O_1 = \angle DO_2O_3$。又因为$B,O_2,D$共线，所以$O_1,O_2,O_3$共线。</p>
<p>证毕。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>子集卷积与bitcount</title>
    <url>/2022/06/30/%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF%E4%B8%8Ebitcount/</url>
    <content><![CDATA[<p>如果一个卷积长这样：</p>
<script type="math/tex; mode=display">
f(S) = \sum_{X\cup Y=S,X\cap Y = \emptyset} g(X)\times h(Y)</script><p>好像不能够直接用FWT做了呢。但是我们观察，$X\cup Y=S,X\cap Y=\emptyset$等价于：</p>
<script type="math/tex; mode=display">
\begin{cases}
X\cup Y=S\\
|X|+|Y|=|S|
\end{cases}</script><p>正确性显然。那么，我们可以枚举集合的大小，然后做或卷积。可以先对所有的进行FWT，然后枚举大小、求和，最后再变换回去。时间复杂度$2^n n^2$，$n$表示元素的数量。</p>
<p>其实这也是对付某些位运算关系特别复杂的题的一种套路吧。尽量用$bitcount$取代替式子中的位运算条件，最后按$bitcount$分组算FWT卷积。</p>
<p>例题：<br>WC2018 州区划分<br>hdu6057 Kanade’s convolution</p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数与字符串匹配</title>
    <url>/2022/06/30/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>主要都是用来解决有“通配符”、“模糊匹配”等的问题（如果没有这些东西直接kmp多好）。并且这些题目中，“通配符”能够代表的字符数量是一定的，否则就没有办法卷积了。</p>
<hr>
<h2 id="字符集较小：对每个字符单独考虑是否匹配"><a href="#字符集较小：对每个字符单独考虑是否匹配" class="headerlink" title="字符集较小：对每个字符单独考虑是否匹配"></a>字符集较小：对每个字符单独考虑是否匹配</h2><h3 id="CF528D-Fuzzy-Search"><a href="#CF528D-Fuzzy-Search" class="headerlink" title="CF528D Fuzzy Search"></a>CF528D Fuzzy Search</h3><p>有两个只包含$A,C,G,T$的字符串$S$和$T$，长度分别为$n,m$。给定一个限制宽度$K$。定义字符串$T$在$S$的$i$位置上匹配，当且仅当：$\forall j\in [1,m],\exists p\in [max((i+j-1)-K,1),min((i+j-1)+K,n)]$，使得$S[p]=T[j]$。问$T$在哪些位置上匹配。$1\le m\le n\le 200000,K\le 200000$。</p>
<p>Solution：可以考虑单独计算$match(i,c)$，表示$[i,i+m-1]$这个子串与$T$中的字符$c$的匹配数量。那么一个位置匹配的条件是$\sum match(i,c) =m$。</p>
<p>我们先枚举字符。那么我们设$f(i)=[S[i-K,i+K]中存在字符c]$，$g(i) = [T[i]=c] $。那么我们需要求的就是$h(i)=\sum_{j=1}^m g(j)\times f(i+j-1)$。把$g$翻一下用FFT算即可。</p>
<h3 id="bzoj-3160-万径人踪灭"><a href="#bzoj-3160-万径人踪灭" class="headerlink" title="bzoj 3160 万径人踪灭"></a>bzoj 3160 万径人踪灭</h3><p>在一个只包含$a,b$的字符串中选取一个子序列，使得：<br>1.位置和字符都关于某条对称轴对称对称。<br>2.不能是连续的一段。<br>问方案数对$1000000007$取模的值。</p>
<p>Solution：等价于“位置和字符都对称的子序列数量”减去“连续的回文子串数量”，后者可以用manacher求出。</p>
<p>对于前者，我们考虑计算每个对称轴的贡献。假设有$x$个字符关于这个对称轴对称，那么这个对称轴的贡献就是$2^x-1$。两个位置关于$mid$对称等价于两个位置下标的和等于$mid\times 2$。我们枚举$mid\times 2$，分开计算两种字符各有多少个位置关于它对称。加入当前枚举的是$c$，设$f(x)=\sum_{i=1}^n [S_i=c]x^i$，那么我们要求的就是这个函数的平方。</p>
<p>注意，在卷积中，两个不同的位置$i,j$对$i+j$的贡献会被计算两次（第一个多项式选$i$，第二个多项式选$j$和第一个多项式选$j$，第二个多项式选$i$），而两个相同位置的贡献只会被算一次。</p>
<hr>
<h2 id="字符集较大：玄学构造比较函数"><a href="#字符集较大：玄学构造比较函数" class="headerlink" title="字符集较大：玄学构造比较函数"></a>字符集较大：<del>玄学</del>构造比较函数</h2><h3 id="bzoj4259-残缺的字符串"><a href="#bzoj4259-残缺的字符串" class="headerlink" title="bzoj4259 残缺的字符串"></a>bzoj4259 残缺的字符串</h3><p>有两个仅包含小写字母和<em>的字符串$A$和$B$，其中 </em> 作为通配符，可以匹配任意一个字符。问$A$在$B$的哪些位置出现过。$1\le |A|\le |B| \le 300000$</p>
<p>Solution：</p>
<p>假设$|A|=m,|B|=n$。</p>
<p>如果我们定义一个函数$f(x,y)=A[x]-B[y]$，那么这个函数在$A[x]=B[y]$的时候就会返回$0$，否则就不会返回$0$。我们似乎可以通过判断$\sum_{i=1}^m A[i]-B[p+i-1]$是否为$0$来判断$p$这个位置是否可以与$A$匹配。但是这样是错误的，因为$f$的返回值有正有负，可能会出现正负数互相抵消的情况。</p>
<p>那么<del>经过前人无数挣扎发现</del>可以定义$f(x,y)=(A[x]-B[y])^2$作为比较函数。这样有两个好处：<br>1.$(A[x]-B[y])^2=A[x]^2+B[y]^2-2A[x]B[y]$，这个东西用FFT优化，可以在$n\log n$的时间内求出所有的$\sum_{i=1}^m (A[i]-B[p+i-1])^2$。<br>2.函数值均为非负数。因此如果有一个位置的函数值不为$0$，那么求和的结果就不为$0$。</p>
<p>现在考虑怎么做这道题：构造一个函数，当$A[x]=B[y]$或者$A[x],B[y]$中有一个为 * 的时候，$f(x,y)$为$0$；否则为一个正数。</p>
<p>如果令 * 的值为$0$，其他字符$c$的值为$c-‘a’+1$，那么构造$f(x,y)=(A[x]-B[y])^2 A[x]B[y]$恰好可以满足这个条件。</p>
<p>考虑怎么优化：</p>
<script type="math/tex; mode=display">
\sum (A[x]-B[y])^2 A[x]B[y]\\
=\sum A[x]^3 B[y] +A[x]B[y]^3 -2A[x]^2 B[y]^2</script><p>这玩意也可以用FFT优化，做三次卷积就可以了，只是常数略大QAQ。</p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>任意模数NTT(NTT+CRT,MTT的优化)</title>
    <url>/2022/06/30/%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0NTT-NTT-CRT-MTT%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>问题：给出两个多项式，以及模数$P$，计算它们的卷积，不保证$P$是$t\cdot 2^k + 1$的形式的质数。</p>
<p>模数不支持NTT，那么我们肯定只能通过某种方式算出精确值，然后再取模。然而，两个这样的多项式相乘，每一项的系数最大是$n\cdot P^2$，大约$10^{23}$，FFT会爆精度，也不可能单模数NTT……</p>
<hr>
<h2 id="方法一：三模数NTT-CRT"><a href="#方法一：三模数NTT-CRT" class="headerlink" title="方法一：三模数NTT + CRT"></a>方法一：三模数NTT + CRT</h2><p>我们选三个乘积大于了$n\cdot P^2$的、可以NTT的质数，算出系数模它们的余数，再将得到的余数利用中国剩余定理合并。然而粘板子是不行的，因为会爆long long。</p>
<p>假设现在有三个方程：</p>
<script type="math/tex; mode=display">
\begin{cases}
x\equiv c_0\mod m_0\\
x\equiv c_1\mod m_1\\
x\equiv c_2\mod m_2\\
\end{cases}</script><p>其中$m_1,m_2,m_3$都是$10^9$级别的。我们先中国剩余定理合并前面两个，得到：</p>
<script type="math/tex; mode=display">
\begin{cases}
x\equiv c\mod m\\
x\equiv c_2\mod m_2\\
\end{cases}</script><p>其中$m=m_1\cdot m_2$。设$x=c+k_1m=c_2+k_2m_2$，则$k_1m-k_2m_2=c_2-c$，可以直接用扩展欧几里得求出一组解，因为扩展欧几里得算法解不定方程$ax+by=gcd(a,b)$，求出的解一定满足$|x|\le |b|$且$|y|\le |a|$。</p>
<p>整个同余方程组的最小正解，一定就是卷积结果的系数的真实值。因为任何一个比最小正解大的解，一定大于$m_1\cdot m_2\cdot m_3$，而这已经到了$10^{27}$的级别了，但这道题的答案不会超过$10^{23}$。</p>
<p>那么我们现在算出了最小的$k_1$，带回$x=c+k_1m$就可以得到$x$的值了。这里的乘法计算，当然要先对$P$取模再算乘法（要不然还是会爆long long QAQ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这三个模数的原根都是3</span></span><br><span class="line"><span class="keyword">int</span> M[<span class="number">3</span>]=&#123;<span class="number">1004535809</span>,<span class="number">104857601</span>,<span class="number">998244353</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> C[<span class="number">3</span>][N],A[N],B[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b[],<span class="keyword">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[i]=a[i],B[i]=b[i];</span><br><span class="line">		FFT(A,<span class="number">1</span>,M[k]),FFT(B,<span class="number">1</span>,M[k]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) C[k][i]=A[i]*(ll)B[i]%M[k];</span><br><span class="line">		FFT(C[k],<span class="number">-1</span>,M[k]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ll P1=M[<span class="number">0</span>]*(ll)M[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ll k0,k1; exgcd(M[<span class="number">0</span>],M[<span class="number">1</span>],k0,k1); k0=(k0*(C[<span class="number">1</span>][i]-C[<span class="number">0</span>][i])%M[<span class="number">1</span>]+M[<span class="number">1</span>])%M[<span class="number">1</span>];</span><br><span class="line">		ll x1=(C[<span class="number">0</span>][i]+k0*M[<span class="number">0</span>]%P1)%P1;</span><br><span class="line">		exgcd(P1,M[<span class="number">2</span>],k0,k1); k0=(k0%M[<span class="number">2</span>]*((C[<span class="number">2</span>][i]-x1)%M[<span class="number">2</span>])+M[<span class="number">2</span>])%M[<span class="number">2</span>];</span><br><span class="line">		a[i]=(x1+k0%P*(P1%P))%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="方法二：MTT"><a href="#方法二：MTT" class="headerlink" title="方法二：MTT"></a>方法二：MTT</h2><p>用FFT计算的瓶颈在于精度爆炸，那么我们可以拆系数，把系数的值域变小，用时间换精度。</p>
<p>我们把原来的多项式$A(x)$拆成$A_0(x)\cdot M+A_1(x)$，其中$M$是一个常数。即，令${A_0}_i=\lfloor{A_i\over M}\rfloor,{A_1}_i=A_i\mod M$。这样计算两个多项式乘积就是算：</p>
<script type="math/tex; mode=display">
A(x)B(x)=(A_0(x)\cdot M+A_1(x))(B_0(x)\cdot M+B_1(x))\\
=A_0(x)B_0(x)M^2 + A_1(x)B_0(x)M+A_0(x)B_1(x)M+A_1(x)B_1(x)</script><p>如果$M$取到$\sqrt P$左右的话，我们需要计算卷积的那些多项式的系数都只有$\sqrt P$级别了，精度得到有效改善。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> C[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) T1[i]=Comp(A[i],<span class="number">0</span>),T2[i]=Comp(B[i],<span class="number">0</span>);</span><br><span class="line">    FFT(T1,<span class="number">1</span>),FFT(T2,<span class="number">1</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) T1[i]=T1[i]*T2[i]; FFT(T1,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) C[i]=((ll)(T1[i].a+<span class="number">0.5</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a0[N],a1[N],b0[N],b1[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> C[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a0[i]=A[i]/M,a1[i]=A[i]%M;</span><br><span class="line">        b0[i]=B[i]/M,b1[i]=B[i]%M;</span><br><span class="line">        C[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mul(a0,b0,c); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) C[i]=(C[i]+c[i]%mod*(ll)M%mod*M%mod)%mod;</span><br><span class="line">    Mul(a1,b0,c); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) C[i]=(C[i]+c[i]%mod*(ll)M%mod)%mod;</span><br><span class="line">    Mul(a0,b1,c); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) C[i]=(C[i]+c[i]%mod*(ll)M%mod)%mod;</span><br><span class="line">    Mul(a1,b1,c); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) C[i]=(C[i]+c[i])%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FFT优化：DFT与IDFT合并"><a href="#FFT优化：DFT与IDFT合并" class="headerlink" title="FFT优化：DFT与IDFT合并"></a>FFT优化：DFT与IDFT合并</h3><p>这是一种可以通过一次FFT，算出两个多项式的DFT/IDFT的骚操作。</p>
<p>假设要算$A(x),B(x)$的DFT。那么我们构造：</p>
<script type="math/tex; mode=display">
P(x)=A(x)+iB(x)\\
Q(x)=A(x)-iB(x)\\</script><p>如果我们得到了$P,Q$的DFT，我们就可以得到$A,B$的DFT。而$P$和$Q$有一个非常奇妙的性质（下面设$W=k\cdot {2\pi  \over l}$）：</p>
<script type="math/tex; mode=display">
P(\omega_n^k )=\sum_{j} (A_j+iB_j)\omega^{jk}\\
=\sum_{j} (A_j+iB_j)(\cos jW + i\sin jW)\\
=\sum_{j} (A_j\cos jW - B_j \sin jW) + i\sum_j (A_j\sin jW +B_j\cos jW)\\
Q(\omega_n^k)=\sum_j (A_j-iB_j)\omega^{jk}\\
=\sum_j (A_j-iB_j)(\cos jW + i\sin jW)\\
=\sum_j (A_j\cos jW +B_j\sin jW) + i \sum_j  (A_j\sin jW - B_j \cos jW)</script><p>上下式子好像啊（废话，本来就构造得很相似），而且，$Q$最终式子的前半部分，$\sin$前面的都变了号，而$\cos$前面的没有变；后半部分$\cos$变了号，而$sin$不变。而正好$\sin$是奇函数，$\cos$是偶函数，即$\sin (-x) = - \sin x,\cos (-x) = \cos x$于是可以得到：</p>
<script type="math/tex; mode=display">
P(\omega_n^k) = conj(Q(\omega_n^{-k}))</script><p>因为$w_n^{-k} = w_n^{n-k}$，所以$conj(P(\omega_n^{n-k})) = Q(\omega_n^k)$。</p>
<p>这样，如果我们算出了$P$的DFT，就可以得到$Q$的DFT。然后就可以得到：</p>
<script type="math/tex; mode=display">
A(\omega_n^k) = {P(\omega_n^k)+Q(\omega_n^k)\over 2}\\
B(\omega_n^k) = {P(\omega_n^k) - Q(\omega_n^k)\over 2i}\\
= -i{P(\omega_n^k) - Q(\omega_n^k)\over 2}</script><p>那么DFT怎么办呢？考虑构造$M(\omega_n^k) = A(\omega_n^k)+iB(\omega_n^k) = P(\omega_n^k)$，那么我们把$P$IDFT回去以后，分别取实部和虚部，就可以得到$A,B$的IDFT。</p>
<p>由此，我们的DFT/IDFT的运算次数可以减少一半，只需要算4次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Comp T[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],Comp a[],Comp b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) T[i]=Comp(A[i],B[i]); FFT(T,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j=(len-i)%len;</span><br><span class="line">		a[i]=(T[i]+T[j].conj())*Comp(<span class="number">0.5</span>,<span class="number">0</span>);</span><br><span class="line">		b[i]=(T[i]-T[j].conj())*Comp(<span class="number">0</span>,<span class="number">-0.5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IDFT</span><span class="params">(Comp A[],Comp B[],<span class="keyword">int</span> a[],<span class="keyword">int</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) T[i]=A[i]+B[i]*Comp(<span class="number">0</span>,<span class="number">1</span>); FFT(T,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=((ll)(T[i].a+<span class="number">0.5</span>))%mod,b[i]=((ll)(T[i].b+<span class="number">0.5</span>))%mod;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="keyword">int</span> a0[N],a1[N],b0[N],b1[N];</span><br><span class="line">Comp A0[N],A1[N],B0[N],B1[N],T1[N],T2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> C[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		a0[i]=A[i]/M,a1[i]=A[i]%M;</span><br><span class="line">		b0[i]=B[i]/M,b1[i]=B[i]%M;</span><br><span class="line">		C[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DFT(a0,a1,A0,A1); DFT(b0,b1,B0,B1);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) T1[i]=A0[i]*B0[i],T2[i]=A1[i]*B1[i];</span><br><span class="line">	IDFT(T1,T2,a0,a1);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) C[i]=(C[i]+M*(ll)M%mod*a0[i]%mod+a1[i])%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) T1[i]=A0[i]*B1[i]+A1[i]*B0[i];</span><br><span class="line">	FFT(T1,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) C[i]=(C[i]+M*((ll)(T1[i].a+<span class="number">0.5</span>)%mod))%mod;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>对数组长度有要求的FFT</title>
    <url>/2022/06/30/%E5%AF%B9%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E6%9C%89%E8%A6%81%E6%B1%82%E7%9A%84FFT/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/01/10/dLBt1mTpZarDbRX.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CTSC2010 循环卷积</title>
    <url>/2022/06/30/CTSC2010-%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4191" target="_blank" rel="noopener">洛谷上的题面</a></p>
<p>有两个长度为$n$的多项式$A$和$B$，需要求出$A<em>B^C$。其中的$</em>$运算定义如下：</p>
<script type="math/tex; mode=display">
C[k]=\sum_{i+j\equiv k\text{ mod } n} A[i]*B[j]\text{ mod } (n+1)</script><p>数据范围：$n\le 5\times 10^5,C\le 10^9$。保证$n$一定可以被分解成若干个不超过$10$的正整数的乘积，并且$n+1$是质数。</p>
<p>Solution：<br>我们用FFT计算卷积的过程，本质上是构造了一个$trans(p,i)$（贡献系数），令DFT后的数组为$A’[p]=\sum_{i=0}^n trans(p,i)\times A[i]$，我们必须让$trans(p,i)\times trans(p,j)=trans(p,i+j)$成立。FFT中，我们的$trans(p,i)=\omega_n^{pi}$。而$trans(p,i)\times trans(p,j)=\omega_n^{pi}\cdot \omega_n^{pj} =\omega_n^{p(i+j)}=trans(p,i+j)$。故而这个变换可以满足我们的要求。</p>
<p>考虑用类似的思想来解决这个问题，我们要构造一个$trans(p,i)$，使得$trans(p,i)\times trans(p,j)=trans(p,(i+j)\text{ mod }n)$。有一个令人惊喜的发现：$trans(p,i)=\omega_n^{pi}$是满足条件的，因为$\omega_n^k=\omega_n^{k-n}$。</p>
<p>这就意味着，我们可以FFT，然后直接对点值快速幂，再IDFT回去。</p>
<p>可是，整个数组的长度并不是$2^k$。而且$C$很大，直接$power$肯定会炸精度，而如果用NTT，模数也满足$t\cdot 2^k +1$的形式。怎么办呢？</p>
<p>题目里面有一个条件：保证$n$一定可以被分解成若干个不超过$10$的正整数的乘积。（实际上，这样的$n$被称作smooth number）。我们进行分治的时候，不一定将一个长度为$n$的区间分成两个长度为${n\over 2}$的区间；可以取出当前区间长度的一个质因子$p$，然后将当前区间分成$p$个区间，分治完了之后再合并。具体地，假设我们现在分治序列$a_0,a_2,\cdots a_{n-1}$，那么我们取$n$的一个质因子$p$，然后按照模$p$的余数分组。以$n=6,p=3$为例，我们希望计算对于每一个$k\in [0,n)$，$f(\omega_n^k)$的值，其中$f(x)=\sum_{i=0}^{n-1}a_ix^i$。稍加推导：</p>
<script type="math/tex; mode=display">
f(x)=a_0+a_1x+a_2x^2+a_3x^3+a_4x^4+a_5x^5\\
=(a_0+x^3a_3)+x(a_1+a_4x^3)+x^2(a_2+a_5x^3)\\
f(\omega_n^k) =(a_0+\omega_n^{3k}a_3)+\omega_n^k(a_1+a_4\omega_n^{3k})+\omega_n^{2k}(a_2+a_5\omega_n^{3k})\\
=(a_0+\omega_{n\over 3}^{k}a_3)+\omega_n^k(a_1+a_4\omega_{n\over 3}^{k})+\omega_n^{2k}(a_2+a_5\omega_{n\over 3}^{k})</script><p>由于$\omega_n^k = \omega_{n\over p}^{k\over p}$，我们可以递归下去，对每一个长度为$2$的区间进行分治，算出$k\in [0,{n\over 3})$时，该区间$f(x)$的取值。我们不需要算得更多，是因为$\omega_n^k =\omega_n^{k+n}$。然后合并就可以了。由于$p$总是很小，也就是划分的区间的数量很小，合并的复杂度可以视作常数。所以总复杂度是$n\log n$的。</p>
<p>还有精度的问题：可以直接用模数的原根替代单位根，因为我们只需要满足，模数-1是所有分治区间的长度的倍数就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>; c=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mod,G;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;ll res=<span class="number">1</span>; <span class="keyword">while</span>(y)&#123;<span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=res*x%mod; x=x*x%mod,y&gt;&gt;=<span class="number">1</span>;&#125; <span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="keyword">namespace</span> P_root&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">720</span>+<span class="number">22</span>;</span><br><span class="line">	<span class="keyword">int</span> flg[N],pri[N],num,d[N],tot;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">predo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;<span class="keyword">if</span>(!flg[i])pri[num++]=i; <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num&amp;&amp;pri[j]*i&lt;=n;++j)&#123;flg[i*pri[j]]=<span class="number">1</span>; <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;&#125;&#125;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;tot=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num&amp;&amp;pri[j]*pri[j]&lt;=n;++j)<span class="keyword">if</span>(n%pri[j]==<span class="number">0</span>)&#123;d[++tot]=pri[j];<span class="keyword">while</span>(n%pri[j]==<span class="number">0</span>)n/=pri[j];&#125;<span class="keyword">if</span>(n&gt;<span class="number">1</span>)d[++tot]=n;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">che</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;++j)<span class="keyword">if</span>(Pow(x,(mod<span class="number">-1</span>)/d[j])==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">()</span></span>&#123;predo(N<span class="number">-22</span>),get(mod<span class="number">-1</span>);<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;mod;++i) <span class="keyword">if</span>(che(i)) <span class="keyword">return</span> i; <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> di[<span class="number">33</span>],num,n,pos[N];</span><br><span class="line">ll A[N],B[N],t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findpos</span><span class="params">(<span class="keyword">int</span> pr,<span class="keyword">int</span> x,<span class="keyword">int</span> dep)</span></span>&#123;<span class="keyword">return</span> dep==num+<span class="number">1</span>?pr+x:findpos(pr*di[dep]+x%di[dep],x/di[dep],dep+<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">(ll A[],ll B[])</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) A[i]=B[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(ll A[],<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) t[pos[i]]=A[i]; cpy(A,t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> lt=<span class="number">1</span>,l=di[num],cur=num;cur&gt;=<span class="number">1</span>;cur--,lt=l,l*=di[cur])</span><br><span class="line">	&#123;</span><br><span class="line">		ll wn=Pow(G,f==<span class="number">1</span>?n/l:n-n/l);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=l)</span><br><span class="line">		&#123;</span><br><span class="line">			ll wk=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;l;++k,wk=wk*wn%mod) <span class="comment">// now calculate i+k, w-&gt;wn^k</span></span><br><span class="line">			&#123;</span><br><span class="line">				ll tmp=<span class="number">0</span>; ll w=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=k%lt;j&lt;l;j+=lt,w=w*wk%mod)</span><br><span class="line">					tmp=(tmp+w*A[i+j])%mod;</span><br><span class="line">				t[i+k]=tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cpy(A,t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>)&#123;ll Inv=Pow(n,mod<span class="number">-2</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) A[i]=A[i]*Inv%mod;&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t; read(n),read(t); mod=n+<span class="number">1</span>,G=P_root::cal();</span><br><span class="line">	<span class="keyword">int</span> tmp=n; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=tmp;++i)&#123;<span class="keyword">while</span>(tmp%i==<span class="number">0</span>)tmp/=i,di[++num]=i;&#125;<span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)di[++num]=tmp;</span><br><span class="line"><span class="comment">//	sort(di+1,di+num+1);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) pos[i]=findpos(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) read(A[i]); FFT(A,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) read(B[i]); FFT(B,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) A[i]=A[i]*Pow(B[i],t)%mod;</span><br><span class="line">	FFT(A,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,A[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>公平组合游戏的经典模型</title>
    <url>/2022/06/30/%E5%85%AC%E5%B9%B3%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="The-Subtraction-Game"><a href="#The-Subtraction-Game" class="headerlink" title="The Subtraction Game"></a>The Subtraction Game</h2><blockquote>
<p>Nim 游戏。每一次可以从某一堆里面取走至多 $k$ 个石头，不能操作者输。</p>
</blockquote>
<p>每一堆的是独立的，所以局面的 sg 值是每一堆的 sg 值的异或和。此外，不难发现一个包含 $n$ 个石头的堆的 sg 值为 $n \pmod {k+1}$。</p>
<h2 id="Greedy-Nim"><a href="#Greedy-Nim" class="headerlink" title="Greedy Nim"></a>Greedy Nim</h2><h3 id="不能操作者输"><a href="#不能操作者输" class="headerlink" title="不能操作者输"></a>不能操作者输</h3><p>参考 <a href="https://en.wikipedia.org/wiki/Nim" target="_blank" rel="noopener">wikipedia - Nim</a></p>
<blockquote>
<p>Nim 游戏。每次只能从石头个数最大的堆中拿石头。不能操作者输。</p>
</blockquote>
<p>设当前单个堆中石头个数的最大值为 $m$，次大值为 $n(n &lt; m)$，石头个数最大的堆数为 $p_m$，石头个数次大的堆数为 $p_n$。</p>
<p>结论是，$p_m$ 为奇数时是必胜状态，否则是必败状态。</p>
<p>必胜状态可以转移到必败状态：</p>
<ul>
<li>$p_m = 1$<ul>
<li>通过决定操作后那堆石子剩下的数量是等于 $n$ 还是小于 $n$ 来调整 $p_n$ 的奇偶性。</li>
</ul>
</li>
<li>$p_m &gt; 1$<ul>
<li>任意操作即可</li>
</ul>
</li>
</ul>
<p>必败态只能转移到必胜态：</p>
<ul>
<li>必败态中 $p_m \ge 2$，所以操作后 $p_m \ge 1$ 且为奇数</li>
</ul>
<h3 id="不能操作者赢"><a href="#不能操作者赢" class="headerlink" title="不能操作者赢"></a>不能操作者赢</h3><p>没有找到相关的资料，所以下面是我自己口胡的。</p>
<blockquote>
<p>Nim 游戏。每次只能从石头个数最大的堆中拿石头。不能操作者赢。</p>
</blockquote>
<p>仍然设当前单个堆中石头个数的最大值为 $m$，次大值为 $n(n &lt; m)$，石头个数最大的堆数为 $p_m$，石头个数次大的堆数为 $p_n$。</p>
<p>结论是，以下状态为必胜状态：</p>
<ol>
<li>$m=1$ 且 $2\mid p_m$</li>
<li>$m\neq 1$ 且 $2\nmid p_m$</li>
</ol>
<p>必胜状态可以转移到必败状态：</p>
<ul>
<li>$m=1$：显然</li>
<li>$m=2$：<ul>
<li>$p_m &gt; 1$：随意操作即可</li>
<li>$p_m = 1$：通过决定把操作的石头堆拿到只剩下 $1$ 还是只剩下 $0$，达到决定操作后 $p_1$ 的奇偶性的目的</li>
</ul>
</li>
<li>$m=3$：<ul>
<li>证明同“不能操作者输”</li>
</ul>
</li>
</ul>
<p>必败状态只能转移到必胜状态：</p>
<ul>
<li>$m=1$：显然</li>
<li>$m&gt; 1$：因为 $p_m \ge 2$，所以不可能转移到 $m=1$ 的状态，所以只可能转移到 $m&gt; 1$ 的必胜态</li>
</ul>
<h2 id="阶梯Nim"><a href="#阶梯Nim" class="headerlink" title="阶梯Nim"></a>阶梯Nim</h2><blockquote>
<p>每一次可以从第$i(i&gt;1)$堆中拿若干个放到第$i-1$堆里面，或者从第$1$堆里面扔掉若干个，不能操作者输。</p>
</blockquote>
<p>等价于对编号为奇数的堆做Nim游戏。</p>
<p>如果第一个人操作了偶数堆，那么第二个人可以把第一个放进那个奇数堆的石子放进后面的偶数堆，这样奇数堆的状态不变。所以偶数堆可以直接当做“垃圾桶”用。</p>
<p>每一个人都按照奇数堆的必胜策略操作即可。</p>
<p>一个变形是挪硬币游戏：$1\times n$ 的方格中，若干个格子上有硬币。每次可以选择一个硬币、往左移若干格（要求保证跨过的位置都没有硬币），不能操作者输。</p>
<p>可以把硬币之间的间隙看作石头堆，转化成阶梯 Nim 游戏。</p>
<h2 id="Nim-K游戏（Moore’s-Nim-K）"><a href="#Nim-K游戏（Moore’s-Nim-K）" class="headerlink" title="Nim-K游戏（Moore’s Nim-K）"></a>Nim-K游戏（Moore’s Nim-K）</h2><p>参考 <a href="https://www.cnblogs.com/vongang/archive/2013/06/01/3112790.html" target="_blank" rel="noopener">这篇博客</a></p>
<h3 id="不能操作者输-1"><a href="#不能操作者输-1" class="headerlink" title="不能操作者输"></a>不能操作者输</h3><blockquote>
<p>有$n$堆石子，每次可从至多$k$堆中拿走任意数量的石子，不能不拿。不能操作者输。</p>
</blockquote>
<p>把每堆的石子数用二进制表示，如果每一位上$1$的个数$\pmod {k+1}$都是$0$则先手必败，否则先手必胜。</p>
<p>证明：</p>
<p>如果是必败态，那么由于每一位上都至多有$k$个数被改变，所以转移到的一定是必胜态。</p>
<p>下面证明从必胜态可以转移到必败态。从高位到低位依次调整，显然在调整高位的时候用过的那些堆，在当前这一位是可以任意取值的。设用过的堆有$m$个，去掉这$m$堆之后还有$s$堆在这一位上是$1$：</p>
<ul>
<li>若$s + m \le k$，我们可以直接对那$s$堆进行操作，这样进行过操作的总堆数不会超过$k$。</li>
<li>否则$s+m &gt; k$，也就是说$m &gt; k - s$，也就是说$m\ge k+1-s$，所以可以直接将$m$中的$k+1-s$堆设置为$1$，其它的设置为$0$，使得这一位上的$1$的总数为$k+1$的倍数。</li>
</ul>
<h3 id="不能操作者赢（Mis-ere-Nim-k"><a href="#不能操作者赢（Mis-ere-Nim-k" class="headerlink" title="不能操作者赢（Mis`ere Nim-k)"></a>不能操作者赢（Mis`ere Nim-k)</h3><blockquote>
<p>有$n$堆石子，每次可从至多$K$堆中拿走任意数量的石子，不能不拿。不能操作者赢。</p>
</blockquote>
<p>只有两种可能的必胜局面：</p>
<ol>
<li>每堆里面都只有一个石头，并且堆数 $\pmod {K+1} \neq 1$。</li>
<li>每堆的石头个数不全为 1，且存在某个二进制位上 1 的个数 $\pmod{K+1} \neq 0$</li>
</ol>
<p>对应的，必败局面为：</p>
<ol>
<li>每堆里面都只有一个石头，并且堆数 $\pmod {K+1} = 1$。</li>
<li>每堆的石头个数不全为 1，且每个二进制位上 1 的个数 $\pmod{K+1} = 0$</li>
</ol>
<p>必败态只能转移到必胜态：</p>
<ul>
<li>该局面存在石头个数大于 1 的堆<ul>
<li>不能转移到必败态 2. ：一次操作至多只能改变 $K$ 堆石头，但是这样的转移需要让某一位的 1 的个数减少 $K+1$</li>
<li>不能转移到必败态 1. ：由于存在石头个数大于 1 的堆且每个二进制位上 1 的个数都是 $K+1$ 的倍数，所以石头个数大于 1 的堆的数量一定不小于 $K+1$，所以一定不可能转移到每堆石头的个数都是 1 的状态</li>
</ul>
</li>
<li>该局面所有堆的石头个数都是 1 且石头总数大于 $K+1$<ul>
<li>不能转移到必败态 2. ：每堆中石头的个数只会减小</li>
<li>不能转移到必败态 1. ：这需要操作 $K+1$ 堆石头</li>
</ul>
</li>
<li>该局面所有堆的石头个数都是 1 且石头总数等于 $1$<ul>
<li>拿走这唯一的一个石头之后，给对方的是必胜状态（终态）</li>
</ul>
</li>
</ul>
<p>必胜态可以转移到必败态：</p>
<ul>
<li>存在石头个数大于 1 的堆<ul>
<li>石头个数大于 1 的堆的数量不超过 $K$：可以转移到必败态 1.</li>
<li>石头个数大于 1 的堆的数量超过了 $K$：按照“不能操作者输”的策略进行操作，可以转移到必败态 2.</li>
</ul>
</li>
<li>所有的堆的石头个数都是 1：<ul>
<li>可以通过拿走不超过 $K$ 堆来转移到必败态 1.</li>
</ul>
</li>
</ul>
<h2 id="Fibonacci-Nim"><a href="#Fibonacci-Nim" class="headerlink" title="Fibonacci Nim"></a>Fibonacci Nim</h2><blockquote>
<p>有一堆石子，双方轮流取石子：第一轮中，先手不能一次性把所有的石头取完；以后的每一轮中，玩家取的石头数不能超过上一轮中对手取的石头数的2倍，至少要取一颗石头。</p>
</blockquote>
<p>结论是，当石头数为斐波那契数的时候，先手必败，否则先手必胜。</p>
<p><a href="https://blog.csdn.net/dgq8211/article/details/7602807" target="_blank" rel="noopener">nyist_xiaod的博客的证明很清楚</a></p>
<h2 id="k-倍减法-Nim"><a href="#k-倍减法-Nim" class="headerlink" title="k 倍减法 Nim"></a>k 倍减法 Nim</h2><p>参考：</p>
<ul>
<li>NOI2009 冬令营论文 《从“k 倍动态减法游戏”出发探究一类组合游戏问题》</li>
<li><a href="https://www.cnblogs.com/SovietPower/p/9699436.html#c-%E6%80%A5%E5%BC%80%E9%94%81%E5%8D%9A%E5%BC%88%E8%AE%BA" target="_blank" rel="noopener">SovietPower 的博客</a></li>
<li><a href="http://www.cnblogs.com/jianglangcaijin/archive/2012/12/19/2825539.html" target="_blank" rel="noopener">朝拜明天19891101的博客</a></li>
</ul>
<p>题目：poj3922 A simple stone game</p>
<blockquote>
<p>有一堆石子，石子的数量为 $n$，双方轮流取石子：第一轮中，先手可以取任意多个，但是不能取完；以后的每一轮中，玩家可以取的数量不能超过上一个人取的石头数量的 $k$ 倍。不能操作者输。问谁会赢。</p>
</blockquote>
<h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法 1"></a>做法 1</h3><p>考虑 $f_i$ 表示石头的总数为 $i$ 时，上一轮中取掉的石头个数至少是多少，这个状态是必胜态。注意到 $f_i \le \lceil \frac{i}{k} \rceil$。则 $f_i = \min\{ \lceil \frac{i-j}{k} \rceil, (i-j)k &lt; f_j\}$。</p>
<p>注意到 $(i-j)k &lt; f_j$ 也就是 $ik &lt; f_j + kj$，要求 $\lceil \frac{i-j}{k} \rceil$ 最小也就是要求 $j$ 最大，所以我们用个单调栈维护 $f_j + kj$ 即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法 2"></a>做法 2</h3><p>如果我们知道 $n$ 颗石头是必败态，那么可以推得：</p>
<ul>
<li>$n+1, n+2, \cdots n+x(xk &lt; n)$ 是必胜态</li>
<li>对于 $n + x (xk \ge n)$，这个状态的胜负取决于谁能拿到 $x$ 个石头中的最后一个石头</li>
</ul>
<p>所以我们可以维护必败状态集合，初始 $S = \{ 2, 3, \cdots k+1\}$。每次取出 $S$ 中最大的元素 $n$，找出最小的必败的 $x \ge \lceil \frac{n}{k} \rceil$，将 $n+x$ 加入集合。注意到这样找出来的 $n+x$ 一定是 $&gt;n$ 的最小的必败状态。</p>
<p>复杂度 $O(\log_{\frac{k+1}{k}} n)$。</p>
<h2 id="翻硬币游戏"><a href="#翻硬币游戏" class="headerlink" title="翻硬币游戏"></a>翻硬币游戏</h2><p>参考 <a href="https://github.com/AlanYume/ACM-ICPC/blob/master/paper/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%8D%9A%E5%BC%88/%E8%B4%BE%E5%BF%97%E8%B1%AA/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F%E7%95%A5%E8%BF%B0%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88SG%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%8B%93%E5%B1%95%E5%8F%8A%E5%8F%98%E5%BD%A2%E3%80%8B.pdf" target="_blank" rel="noopener">IOI2009 贾志豪的论文</a>。</p>
<blockquote>
<p>有一些关于翻的硬币的限制（例如，硬币排成一排，要求翻转的必须是长度为 $k$ 的一段），并且要求翻的最右边（二维的时候则是右下角）的硬币必须是从正面到背面，不能操作者输。</p>
</blockquote>
<p>结论是，局面的 sg 值等于每个正面朝上的硬币单独存在时的游戏的 sg 值的异或和。</p>
<p>可以考虑一个这样的游戏：每次可以拿走一个石头，并且按照限制在别的地方放入一些石头（例如，一排方格，拿走某个石头，并且在左边的 $k-1$ 个格子都放入一个石头）。如果某个位置的石头个数是偶数，那么拿走那个位置的石头是没有意义的（因为后手可以模仿先手的操作）；所以这个游戏和翻硬币游戏是等价的（因为放入一个石头也就是反转了“这个格子是否会被操作”）。并且，这个游戏中每个石头显然是独立的，我们算出每个石头的子游戏的 sg 值异或起来，得到的就是整个游戏的 sg 值。</p>
<h2 id="删边游戏-Green-Hackenbush"><a href="#删边游戏-Green-Hackenbush" class="headerlink" title="删边游戏 Green Hackenbush"></a>删边游戏 Green Hackenbush</h2><p>参考：IOI2009贾志豪论文，以及 Winning Ways for Your Mathematical Plays, Vol1, Chapter 7 Hackenbush。</p>
<blockquote>
<p>给一张无向图，其中有一个点为根。每次操作可以删去一条边，并拿走操作之后不与根连通的部分。不能操作者输。</p>
</blockquote>
<p>结论：</p>
<ul>
<li>树的删边游戏：叶子节点的 SG 值为 0；中间节点的 SG 值为它的所有子节点的 SG 值加 1 后的异或和。（这里的“某个点的 SG 值”指的是这个点的子树内的点构成的子游戏的 SG 值）</li>
<li>无向图的删边游戏：（Fusion Principle）不断把图中的任意一个偶环缩成一个新点，任意一个奇环缩成一个新点和一个自环，所有连到原先环上的边全部改为与新点相连，这样的改动不会影响图的 SG 值。最终转化成树的删边游戏。</li>
</ul>
<h2 id="Anti-SG游戏"><a href="#Anti-SG游戏" class="headerlink" title="Anti-SG游戏"></a>Anti-SG游戏</h2><h3 id="Anti-Nim游戏-Mis-ere-Nim"><a href="#Anti-Nim游戏-Mis-ere-Nim" class="headerlink" title="Anti-Nim游戏 (Mis`ere Nim)"></a>Anti-Nim游戏 (Mis`ere Nim)</h3><blockquote>
<p>有$n$堆石子，每次操作可以从某一堆中拿走至少一个石子。两个人轮流操作，不能操作者胜。</p>
</blockquote>
<p>一个状态为必胜态，当且仅当下列两个条件有一个成立：</p>
<ul>
<li>所有堆的石子个数为$1$，且石子个数的异或和为$0$。</li>
<li>存在一个堆的石子个数大于$1$，且石子个数的异或和不为$0$。</li>
</ul>
<p>证明：</p>
<ul>
<li>如果每一堆的石头个数都是$1$，每个人每一次都必须取完一堆，所以堆数是偶数的时候先手胜，否则后手胜。</li>
<li>存在至少一个石子数大于$1$的堆：<ul>
<li>只有一个堆的石子数大于$1$：显然此时石子个数异或和不为$0$。先手可以选择把这一堆的石头取完或者取到只剩下一个，留给后手奇数个石子数为$1$的堆，所以这种状态先手必胜。</li>
<li>至少有两个堆的石子数大于$1$：如果此时的石子数异或和为$0$，则只能转移到存在至少一个石子数大于$1$且石子数异或和非$0$的状态；而若异或和非$0$，则一定存在一种转移方法可以转移到至少有两个堆的石子数大于$1$且石子数异或和为$0$的状态。</li>
</ul>
</li>
</ul>
<h3 id="Anti-SG游戏-1"><a href="#Anti-SG游戏-1" class="headerlink" title="Anti-SG游戏"></a>Anti-SG游戏</h3><blockquote>
<p>无法继续转移的人获胜。其余规则与SG游戏相同。</p>
</blockquote>
<p>则有类似的结论：先手必胜当且仅当下列两个条件中有至少一个被满足：</p>
<ul>
<li>所有单一游戏的SG值为$1$，且它们的SG值的异或和为$0$；</li>
<li>存在单一游戏的SG值不为$1$，且它们的SG值异或和不为$0$。</li>
</ul>
<p>可以用与SG定理证明相似的方法，证明游戏与Nim游戏等价，从而推出结论成立。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/zwfymqz/p/8469862.html" target="_blank" rel="noopener">自为风月马前卒的博客</a></p>
<p>贾志豪论文</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Sprague–Grundy theorem(SG定理)</title>
    <url>/2022/06/30/Sprague%E2%80%93Grundy-theorem-SG%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="相关的定义"><a href="#相关的定义" class="headerlink" title="相关的定义"></a>相关的定义</h2><h3 id="公平组合游戏-impartial-combinatorial-game"><a href="#公平组合游戏-impartial-combinatorial-game" class="headerlink" title="公平组合游戏 (impartial combinatorial game)"></a>公平组合游戏 (impartial combinatorial game)</h3><p>定义为满足下列条件的游戏：</p>
<ol>
<li>两个玩家轮流操作，无法操作者输。</li>
<li>游戏会在有限的轮数内结束。</li>
<li>对于每个状态，每一个玩家可以进行的操作是相同的。也就是说可以进行的操作只取决于当前所处的状态而不取决于操作的玩家。</li>
<li>信息公开，且没有随机行为。即，两个玩家都能够知道关于游戏状态的所有信息以及对手的操作，且玩家的操作会转移到的后继状态是确定的（而不会受到随机因子的影响）。</li>
</ol>
<h3 id="状态-position"><a href="#状态-position" class="headerlink" title="状态 (position)"></a>状态 (position)</h3><p>我们约定用如下的记号来表示游戏状态：假设某个状态$G$能够转移到的状态集合是$\{G_1,G_2\cdots G_k\}$，我们就用$\{G_1,G_2\cdots G_k\}$来表示$G$。没有可行的转移的状态记为$\{\}$。此外，我们用$<em>n$表示有一个有$n$个石子的Nim游戏的状态，即：$</em>0=\{\},<em>n = </em>(n-1) \cup \{<em>(n-1)\} = \{</em>(n-1),<em>(n-2),\cdots </em>0\}$。</p>
<p>公平组合游戏的状态可以根据其结果分为两类，一类是 N-positions ，表示先手必胜态；另一类是 P-positions ，表示先手必败态。一个简单的结论是，一个状态是 N-position 当且仅当它存在一个后继状态是 P-positioin ，一个状态是 P-position 当且仅当它所有的后继状态都是 N-position。</p>
<h3 id="组合-to-combine"><a href="#组合-to-combine" class="headerlink" title="组合 (to combine)"></a>组合 (to combine)</h3><p>用$A+B$表示由$A$和$B$两个游戏组合起来得到的游戏。组合的含义是：$A+B = \{ a + B \mid a \in A\} \cup \{ b + A\mid b \in B\}$。</p>
<h3 id="等价-equivalence"><a href="#等价-equivalence" class="headerlink" title="等价 (equivalence)"></a>等价 (equivalence)</h3><p>称两个状态$G,G’$是等价的当且仅当对于任意一个状态$H$，$G+H$和$G’+H$的结果相同。记为$G\approx G’$。</p>
<h2 id="Sprague–Grundy-theorem"><a href="#Sprague–Grundy-theorem" class="headerlink" title="Sprague–Grundy theorem"></a>Sprague–Grundy theorem</h2><p>任意一个公平组合游戏的任意一个状态都可以与唯一确定的一个Nim游戏的状态等价。我们把它所等价于的Nim游戏中的石子数称为Grundy number（也称为Grundy value, nim-value, nimber ）。</p>
<h2 id="proof"><a href="#proof" class="headerlink" title="proof"></a>proof</h2><h3 id="First-Lemma"><a href="#First-Lemma" class="headerlink" title="First Lemma"></a>First Lemma</h3><p>对于任意一个 P-position $A$和任意一个状态$G$，$G\approx G+A$。</p>
<p>证明：等价于证明，对于任意一个状态$H$，$G+H$和$G+A+H$的结果是一样的。</p>
<p>假设$G+H$是必胜状态 ，则只需要说明$G+H+A$是必胜状态。先手只需要先进行$G+H$中的必胜策略的第一步，然后$G+H$转化成了必败状态，而此时$A$也是必败状态。接下来，如果后手操作$A$，先手也跟着操作$A$，使$A$仍然是必败状态；如果后手操作$G+H$，先手就跟着操作$G+H$。这样就可以保证$A$和$G+H$始终都是必败状态，直到结束。所以$G+H+A$是必胜状态。</p>
<p>假设$G+H$是必败状态，则$G+H+A$等价于上一种情况中第一步之后的局面，所以$G+H+A$也是必败状态。</p>
<p>综上，对于任意一个 P-position $A$和任意一个状态$G$，$G\approx G+A$。</p>
<h3 id="Second-Lemma"><a href="#Second-Lemma" class="headerlink" title="Second Lemma"></a>Second Lemma</h3><p>$G\approx G’$的充要条件是$G+G’$为P-position。</p>
<p>证明：<br>必要性：如果$G\approx G’$，则$G+G\approx G+G’$，而由于$G+G$显然是一个P-positiong（先手在某一个$G$上操作了之后，后手可以在另一个$G$上做同样的操作，这样先手就必败了），所以$G+G’$是一个P-position。<br>充分性：如果$G+G’$为P-position，那么对于任意一个状态$H$，我们有$G+H \approx G+H+(G+G’) \approx G’+H+(G+G) \approx G’+H$，所以$G\approx G’$。</p>
<h3 id="证明Sprague–Grundy-theorem"><a href="#证明Sprague–Grundy-theorem" class="headerlink" title="证明Sprague–Grundy theorem"></a>证明Sprague–Grundy theorem</h3><p>证明：考虑归纳。若状态为终态显然成立，此时等价于$<em>0$。假设现在有一个不是终态的状态$G=\{G_1,G_2,\cdots G_k\}$，由归纳假设已经知道$G_i \approx </em>n_i$。令$G’ = \{ <em>n_1,</em>n_2,\cdots *n_k\}$。令$m$为$\{n_1,n_2\cdots n_k\}$中没有出现过的最小自然数。</p>
<p>首先证明$G\approx G’$，等价于要证明$G+G’$是P-position。如果$G=\{\}$显然成立；如果先手把$G’$转移到了$<em>n_i$，则后手可以把$G$转移到$G_i$，由于$</em>n_i \approx G_i$，所以$<em>n_i + G_i$为P-position；如果先手把$G$转移到了$G_i$，后手则可以把$G’$转移到$</em>n_i$，也得到了$*n_i +G_i$。综上，$G\approx G’$。</p>
<p>下面证明$G\approx <em>m$，由于等价的传递性，这个命题等价于$G’+</em>m$为P-position。假设先手操作了$<em>m$转移到了$</em>n’$，则$G’$一定也包含$<em>n’$这个转移，后手只要将$G’$转移到$</em>n’$就可以把必败局面留给先手。而如果先手操作了$G’$转移到了$<em>n’$，若$n’&gt;m$则后手可以操作$</em>n’$转移到$<em>m$，而若$n’&lt;m$则后手可以操作$</em>m$转移到$*n’$。注意由于$m$的定义，不可能出现$n’=m$的情况。</p>
<p>证毕。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem" target="_blank" rel="noopener">wiki</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Nim积</title>
    <url>/2022/06/30/Nim%E7%A7%AF/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/zjp-shadow/p/10507030.html" target="_blank" rel="noopener">zjp-shadow 的博客</a></li>
<li><a href="https://www.chitanda.moe/2019/11/08/%E4%BB%8E-nim-%E5%92%8C%E5%88%B0-nim-%E7%A7%AF/" target="_blank" rel="noopener">chitanda 的博客</a></li>
<li><a href="https://www.cnblogs.com/suwakow/p/12200462.html" target="_blank" rel="noopener">suwakow 的博客</a></li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义 $x$ 和 $y$ 的 Nim 积为 $x\otimes y = \max\{(a\otimes b) \oplus (a\otimes y) \oplus (x\otimes b), 0\le a &lt; x, 0\le b &lt; y\}$</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="运算性质"><a href="#运算性质" class="headerlink" title="运算性质"></a>运算性质</h3><ul>
<li><p>$x\otimes 0 = 0\otimes x = 0$</p>
</li>
<li><p>$x\otimes 1 = 1 \otimes x = x$</p>
</li>
<li><p>$x\otimes y = y \otimes x$</p>
</li>
<li><p>$(x\otimes y) \otimes z = x \otimes (y\otimes z)$</p>
</li>
<li>$x\otimes (y\oplus z) = (x\otimes y) \oplus (x\otimes z)$</li>
</ul>
<h3 id="费马数"><a href="#费马数" class="headerlink" title="费马数"></a>费马数</h3><p>定义 Fermat 2-power 为 $2^{2^n}$，其中 $n\in \N$，设其为 $a$。有如下性质：</p>
<ol>
<li>$a\otimes x = a\times x (x &lt; a)$</li>
<li>$a\otimes a = \frac{3}{2} a$</li>
</ol>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p>设 $g(x,y) = 2^x \otimes 2^y$，$f(x,y) = x\otimes y$。</p>
<p>对于任意的 $x,y$，考虑将它用分配律（$x\otimes (y\oplus z) = (x\otimes y) \oplus (x\otimes z)$）拆开，转化成 $f(x,y) = \oplus_{x’\in x, y’\in y} g(x’,y’)$。</p>
<p>下面考虑怎么求 $g(x,y)$。</p>
<p>将 $x,y$ 的二进制位拆出来，转化成费马数相乘：</p>
<script type="math/tex; mode=display">
2^x \otimes 2^y = (\prod_{x'\in x} 2^{2^{x'}}) \otimes (\prod_{y\in y} 2^{2^{y'}} )= (\otimes_{x'\in x} 2^{2^{x'}}) \otimes (\otimes_{y\in y} 2^{2^{y'}} )</script><p>考虑 $x,y$ 的最高位，设为 $u$：</p>
<ol>
<li>$u\in x, u\in y$：设 $M = 2^{2^u}, A = 2^{x-2^u}, B=2^{y-2^u}$，则 $g(x,y) = (\frac{3}{2} M) \otimes A\otimes B$。</li>
<li>$u\in x,u\notin y$：设 $M=2^{2^u}, A=2^{x-2^u}, B=2^y$，则 $g(x,y) = M \otimes A \otimes B$</li>
</ol>
<p>$A\otimes B$ 的部分可以往下递归；我们把往下递归的部分展开，发现 $g(x,y)$ 正是：</p>
<script type="math/tex; mode=display">
(\otimes_{u\in (x \text{ xor } y)} 2^{2^u}) \otimes (\otimes_{u\in (x\text{ and } y)} \frac{3}{2} 2^{2^u})\\
= (\prod_{u\in (x \text{ xor } y)} 2^{2^u}) \otimes (\otimes_{u\in (x\text{ and } y)} \frac{3}{2} 2^{2^u})</script><p>对于后者，直接调用 $f(x,y)$ 递归计算即可。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>参考 2009 论文《从“k倍动态减法游戏”出发探究一类组合游戏问题》 p25（？）</p>
<p>据说是 $O(\log x \log y)$</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><a href="https://www.cnblogs.com/ljzalc1022/protected/p/12935948.html" target="_blank" rel="noopener">划愤</a> （高维 Nim 积行列式）</p>
<p>hdu3404 Switch lights（二维 Nim 积模板）</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Nim游戏 结论及证明</title>
    <url>/2022/06/30/Nim%E6%B8%B8%E6%88%8F-%E7%BB%93%E8%AE%BA%E5%8F%8A%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>设初始状态中，每一堆的石子个数分别$\{a_1,a_2,a_3\cdots a_n\}$。则先手获胜的充要条件是$a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_n \neq 0$。</p>
<p>证明：</p>
<ol>
<li>终止状态满足$a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_n=0$。</li>
<li>每一个$a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_n=0$的状态，都只能够转移到$a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_n\neq 0$的状态。因为假设操作后$a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_n$仍然是$0$，则有$a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_i\bigoplus \cdots a_n = a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_i ‘\bigoplus \cdots a_n$，则$a_i = a_i’$，推出矛盾。</li>
<li>每一个$a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_n\neq 0$的状态，都可以转移到$a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_n=0$的状态。因为假设$a_1\bigoplus a_2\bigoplus a_3\bigoplus\cdots a_n=k$，，设$k$二进制下最高的为$1$的位是$p$，那么$a_1,a_2\cdots a_n$中一定存在一个数$a_i$满足$a_i$的第$p$位是$1$，从而我们可以推出$a_i \bigoplus k &lt; a_i$（高于第$p$位的不变，第$p$位从$1$变成了$0$），将$a_i$改成$a_i \bigoplus k$即可。</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值</title>
    <url>/2022/06/25/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<p>有$n$个点$(x_1,y_1),(x_2,y_2)\cdots (x_n,y_n)$，满足$\forall i\not =j,x_i\not =x_j$。你需要求出一个次数小于等于$n-1$的多项式$f(x)$，使得$\forall i\in [1,n],f(x_i) = y_i$。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>考虑对于每一个$i$，构造出一个在$x_i$处取值为$1$、在另外$n-1$个点取值为$0$的多项式$\ell _i (x)$：</p>
<script type="math/tex; mode=display">
\ell_i(x) = {\prod_{j\not =i} (x-x_j)\over \prod _{j\not= i} (x_i-x_j)}</script><p>这个多项式显然是满足上面的条件的。</p>
<p>由此我们可以构造出一个多项式$L(x) = \sum_{i=1}^n y_i\ell _i(x)$。这个多项式显然满足在$x_i$点取值为$y_i$。</p>
<h2 id="唯一性证明"><a href="#唯一性证明" class="headerlink" title="唯一性证明"></a>唯一性证明</h2><p>假设存在两个次数小于等于$n-1$的满足条件的多项式$P_1$和$P_2$，那么$P_1-P_2$在$x_1,x_2\cdots x_n$的取值一定都是$0$，也就是说这个多项式是$(x-x_1)(x-x_2)\cdots (x-x_n)$的倍数。考虑到$P_1-P_2$的次数不可能超过$n-1$，而$(x-x_1)(x-x_2)\cdots (x-x_n)$是一个$n$次多项式，所以$P_1-P_2$一定是这个多项式的$0$倍，也就是说$P_1-P_2=0$，也就是$P_1=P_2$。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一般我们是需要求出将某个值带入这个多项式得到的值。这个时候我们就没有必要求多项式的表达式了，直接把值带入式子里面算，时间复杂度$O(n^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rd(n),rd(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(x[i]),rd(y[i]);</span><br><span class="line">    <span class="keyword">int</span> Ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> d=<span class="number">1</span>,f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span>(i!=j) &#123;</span><br><span class="line">                d=d*(ll)(k-x[j])%mod;</span><br><span class="line">                f=f*(ll)(x[i]-x[j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        f=Pow(f,mod<span class="number">-2</span>);</span><br><span class="line">        Ans=(Ans+y[i]*(ll)f%mod*d)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(Ans+mod)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取值连续时的优化"><a href="#取值连续时的优化" class="headerlink" title="取值连续时的优化"></a>取值连续时的优化</h2><p>当$x$的取值是连续的一段自然数的时候，我们可以算出$(x-x_i)$的前缀积和后缀积，就可以在$O(1)$的时间内得到分子。观察发现$\ell_i$分母的绝对值是${1\over (i-1)!(n-i)!}$，它的符号与$n-i$的奇偶性相关。预处理出阶乘的逆元也就可以$O(1) $算了。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>泰勒展开</title>
    <url>/2022/06/25/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://blog.csdn.net/qq_42452134/article/details/83095736" target="_blank" rel="noopener">一个比较详细的介绍</a><br><a href="https://blog.csdn.net/qq_36330643/article/details/77288486" target="_blank" rel="noopener">一个微积分的推导</a><br><a href="https://blog.csdn.net/weixin_40100502/article/details/80531027" target="_blank" rel="noopener">一个我没有看懂的推导</a><br><a href="https://www.zhihu.com/question/21149770/answer/111173412" target="_blank" rel="noopener">知乎上一个提了拉格朗日中值定理的回答</a><br><a href="https://zhuanlan.zhihu.com/p/25413823" target="_blank" rel="noopener">知乎上一个使用了柯西中值定理的证明</a></p>
<hr>
<h2 id="泰勒公式推导"><a href="#泰勒公式推导" class="headerlink" title="泰勒公式推导"></a>泰勒公式推导</h2><p>简单来说，如果我们知道某一个函数在某一个点的取值，以及在这个点的各阶导数的取值，我们就可以通过泰勒公式构造出一个多项式，从而近似地得到这个点附近的点的这个函数取值。</p>
<p>对于函数$f(x)$，我们已经知道$f(x_0)$以及$f$在$x_0$处的$1,2,3\cdots n$阶导数。我们需要构造一个关于$x$的多项式$P$，使得$P(x)$的取值尽可能地接近$f(x)$。</p>
<p>考虑$P(x)$满足什么条件它才能够和$f(x)$比较接近：</p>
<ul>
<li>$P(x_0)$应该等于$f(x_0)$</li>
<li>在$x_0$这个点，两个函数的切线的斜率应该相等，也就是他们的一阶导数相等。</li>
<li>在$x_0$这个点，两个函数的曲率也应该相等，也就是他们的二阶导数也应该相等。</li>
<li>$\cdots $</li>
<li>在$x_0$这个点，两个函数的$1,2,3\cdots n$阶导数都应该相等。</li>
</ul>
<p>我们设$P(x)= \sum_{i=0}^n A_i(x-x_0)^i + R_n(x)$，最后的$R_n(x)$是余项，也就是误差。那么根据前面的推导我们可以知道：</p>
<ul>
<li>$P(x_0) = A_0 =f(x_0)$</li>
<li>$P’(x_0) = 1\cdot A_1 = f’(x_0) $（次数高于$1$的项此时因为$x-x_0=0$所以取值都是$0$；取值低于$1$的项因为求导已经没有了）</li>
<li>$P’’(x_0) = 1\cdot 2\cdot A_2 = f’’(x_0)$</li>
<li>$P’’’(x_0) = 1\cdot 2\cdot 3 \cdot A_3 = f’’’(x_0)$</li>
<li>$\cdots $</li>
<li>$P^{(n)}(x_0)= n!A_n = f^{(n)}(x_0)$</li>
</ul>
<p>于是我们得到了$A_i = {f^{(n)}(x_0)\over n!}$。</p>
<p>因此我们有了泰勒公式：</p>
<script type="math/tex; mode=display">
f(x) = f(x_0) +\sum_{i=1}^n {f^{(i)}(x_0)\over i!} (x-x_0)^i + R_n(x)</script><p>当$x_0 = 0$的时候这就是麦克劳林公式：</p>
<script type="math/tex; mode=display">
f(x) = f(0) + \sum_{i=1}^n {f^{(i)}(0) \over i!} x^i + R_n(x)</script><hr>
<h3 id="一些常用函数的泰勒展开"><a href="#一些常用函数的泰勒展开" class="headerlink" title="一些常用函数的泰勒展开"></a>一些常用函数的泰勒展开</h3><script type="math/tex; mode=display">
e^x = \sum_{i=0}^{\infty } {x^i \over i!}\\
\ln (1+x) = \sum_{i=1}^{\infty } {(-1)^{i+1} (i-1)!\over i!}x^i = \sum_{i=1}^{\infty }{(-1)^{i+1}\over i}x^i\\
\sin(x) = {\cos(0)\over 1!}x^1 - {\sin(0) \over 2!}x^2 - {
\cos(0)\over 3!}x^3 + {\sin(0)\over 4!}x^4\cdots \\
={x^1\over 1!} - {x^3\over 3!} + {x^5\over 5!} - {x^7\over 7!}\cdots \\
\cos(x) = 1-{x^2\over 2!} +{x^4\over 4!} - {x^6\over 6!}\\
{1\over 1-x} = 1 + x + x^2 + x^3\cdots</script><hr>
<p>upd 2020.1.15</p>
<h3 id="余项的估计"><a href="#余项的估计" class="headerlink" title="余项的估计"></a>余项的估计</h3><ol>
<li>函数$c \cdot {x^n \over n!}$的$n$阶导数是$c$。</li>
<li>对于连续且可以求$n+1$阶导的函数$f(x)$，以及某两个点$a,b$，令$y=cx^{n+1}$过$(a,f(a)),(b,f(b))$，则至少存在一个点$\theta \in (a,b)$，满足${f^{(n+1)}(\theta)\over (n+1)!} = c$。（拉格朗日中值定理的推广？我不会证）</li>
<li>$R_n(x) = f(x) - \sum_{i=0}^n {f^{(i)}(a)\over i!}(x-a)^i$，如果把$R_n(x)$看做一个关于$x$的函数，将$f(x)$泰勒展开为$f(x) = \sum_{i=0}^\infty {f^{(i)}(a)\over i!}(x-a)^i$，就可以得到$R_n^{(n+1)} (x)= f^{(n+1)}(x)$。</li>
<li>必然存在一个点$\theta \in (a,x)$，满足$R_n(x) - R_n(a) = {R_n^{(n+1)}(\theta)\over (n+1)!} (x-a)^{n+1}$，也就是$R_n(x) = {f^{(n+1)}(\theta)\over (n+1)!}(x-a)^{n+1}$。</li>
<li>所以，如果某个$M$满足$M\ge |R_n^{(n+1)}(\theta)|, \theta \in (a,x)$，那么就可以得到$|R_n(x)| \le {M\over (n+1)!}(x-a)^{n+1}$</li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>20220625 多项式与生成函数 讲课资料</title>
    <url>/2022/06/25/20220625-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E8%AE%B2%E8%AF%BE%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<h2 id="多项式与组合数学-ppt："><a href="#多项式与组合数学-ppt：" class="headerlink" title="多项式与组合数学 ppt："></a>多项式与组合数学 ppt：</h2><div class="pdf" target="/files/多项式与组合数学20220623.pdf" height=""></div>
<h2 id="FFT-NTT-FWT-ppt："><a href="#FFT-NTT-FWT-ppt：" class="headerlink" title="FFT NTT FWT ppt："></a>FFT NTT FWT ppt：</h2><div class="pdf" target="/files/FFT,NTT,FWT.pdf" height=""></div>
<h2 id="jzoj6058-false-false-true题解"><a href="#jzoj6058-false-false-true题解" class="headerlink" title="jzoj6058 false-false-true题解"></a>jzoj6058 false-false-true题解</h2><p>（下面pdf里的T3）</p>
<div class="pdf" target="/files/3.13纪中集训（联考5）.pdf" height=""></div>
<h2 id="拉格朗日插值、泰勒展开、微积分"><a href="#拉格朗日插值、泰勒展开、微积分" class="headerlink" title="拉格朗日插值、泰勒展开、微积分"></a>拉格朗日插值、泰勒展开、微积分</h2><p>在博客内搜索就能找到。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>我感谢一切相遇——退役录</title>
    <url>/2020/09/12/%E6%88%91%E6%84%9F%E8%B0%A2%E4%B8%80%E5%88%87%E7%9B%B8%E9%81%87%E2%80%94%E2%80%94%E9%80%80%E5%BD%B9%E5%BD%95/</url>
    <content><![CDATA[<p>并不想记叙那些太多细节，也没有那么多心力和时间去仔细地回忆。随手写几句这些年学习竞赛的感想，也算是认真地跟 OI 道个别吧。</p>
<p>也许这就是为什么学竞赛的女生很少吧？让一个多愁善感的人在这个多愁善感的年纪只是安安静静地做学问，简直是无法想象。学 OI 的这几年里我所追寻的不过是一种感觉而已：称其为“虐”也罢，称其为“追求挑战和刺激”也罢。那时候我还不懂得人间其实有温情在，只有对精神的堕落与死亡的恐惧会刺激我、让我振奋；于是没有麻烦也要制造麻烦，没有困难也要制造困难，总之绝对不能停下来（尽管当时的我根本不可能意识到“我在给自己找麻烦”这一点）。这是我所以选择了竞赛。</p>
<p>这样做的结果是，我在消灭麻烦这件事情上变得越来越强大，我却愈发不能和平地与自己相处。我所取得的成绩越好，我就越是用别的方式惩罚自己，比如生病，比如失眠，比如抑郁。只是因为我内心深处从不承认自己应该得到这些而已。只是因为我相信折磨（区别于“为了某个目标而奋斗”）真的应该成为我的主旋律而已。</p>
<p>我很幸运，在这条路上我遇见的人们，先让我明白“他人”其实并不是什么会伤害我的大怪兽，然后告诉我每一个人其实都很善良，最后使我慢慢体会到“他人”的头脑中也存在着和我类似的“心理活动”，我和“他人”是能够彼此理解的。我感激他们的友善，他们对我的那些如对待幼儿一般的教诲，也感激那双在我极度困顿时向北四楼的窗台上犹豫的我伸出的手，那双把我往回拉的手。</p>
<p>如今，我知道了我曾经所选择的，它们不是我曾以为的“唯一的选择”。我知道了一种可以成为生活的动力、并且比恐惧更加强大的力量——“爱”，我还知道了自己也是可以成为这个词语的主体和对象的。曾经总是坐在角落、感觉自己比机房里的耗子还要卑微的我，现在却敢怀揣着对自己的爱站着从这里走出去。</p>
<p>此刻我听着窗外的雨声——我曾经万般眷恋、却从某一天开始无比惧怕、后来又重新为之感慨的，来自天空的乐音；倘若要谈什么理想，我希望我能为我曾经遇见的人们和即将遇见的人们，给这个世界增添一点“美好”，我希望能怀揣着这份“生命可贵”的心情，去珍惜自己的和他人的生命。</p>
<p>“当你真的决定了要认真生活下去以后，剩下的一切事情其实都很容易。”</p>
<p>雨声渐渐消停、远去，一切归于平静。一切归于空境。这不是结束，这只是开始而已。</p>
<p>“我感谢一切相遇。”</p>
]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值练习题</title>
    <url>/2020/05/28/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="luogu-P5437-【XR-2】约定"><a href="#luogu-P5437-【XR-2】约定" class="headerlink" title="luogu P5437 【XR-2】约定"></a>luogu P5437 【XR-2】约定</h2><p>考虑每条边的贡献。所有生成树的边数和为 $n^{n-2} \cdot (n-1)$，原图中的边数为 $\frac{n(n-1)}{2}$，因为原图中每条边在最终的树中出现的概率是相同的，所以某条边出现在生成树中的概率为 $\frac{\frac{n^{n-2} \cdot (n-1)}{\frac{n(n-1)}{2}}}{n^{n-2}} = \frac{2}{n}$。</p>
<p>所以</p>
<script type="math/tex; mode=display">
\begin{gathered}
Ans = \frac{2}{n} \sum_{i=1}^n \sum_{j=1}^{i-1} (i+j)^k\\
= \frac{1}{n}\left(\sum_{i=1}^n \sum_{j=1}^n (i+j)^k - \sum_{i=1}^n (i+i)^k\right)
\end{gathered}</script><p>$\sum_{i=1}^n (2i)^k = 2^k \sum_{i=1}^n i^k$ 可以一次拉格朗日插值求出来。</p>
<p>可以证明 $f(n) = \sum_{i=1}^n \sum_{j=1}^n (i+j)^k$ 是一个关于 $n$ 的 $k+2$ 次多项式。</p>
<p>方法 1：$\sum_{t=0}^k \binom{k}{t} \left(\sum_{i=1}^n i^t\right) \left( \sum_{j=1}^n j^{k-t}\right)$，一个 $t+1$ 次多项式和 $k-t+1$ 次多项式相乘后为 $k+2$ 次多项式，求和后仍为 $k+2$ 次多项式。</p>
<p>方法 2：做差，分析得知 $f(n) - f(n-1)$ 是个 $k+1$ 次多项式。</p>
<p>最后的问题是如何算出 $f(1),f(2),\cdots f(k+3)$。</p>
<p>枚举 $u = i+j$，则合法的 $i$ 必须满足 $1\le i\le n, 1\le u-i \le n$。讨论一下可知</p>
<script type="math/tex; mode=display">
f(n) = \sum_{u=1}^n u^k (u-1) + \sum_{u=n+1}^{2n} u^k (2n-u+1)</script><p>预处理 $i^k$ 的前缀和即可。</p>
<h2 id="BZOJ4559-luogu-P3270-JLOI2016-成绩比较"><a href="#BZOJ4559-luogu-P3270-JLOI2016-成绩比较" class="headerlink" title="BZOJ4559 / luogu P3270 [JLOI2016]成绩比较"></a>BZOJ4559 / luogu P3270 [JLOI2016]成绩比较</h2><p>考虑求出 $F(x)$ 表示钦定 $x$ 个同学被碾压，此时给所有人赋分使得 B 神的排名符合题意的方案数。</p>
<script type="math/tex; mode=display">
F(x) = \prod_{i=1}^M \left(\binom{N-x}{R_i - x} \cdot \sum_{j=1}^{U_i} j^{N-R_i}(U_i-j)^{R_i-1}\right)</script><p>则由二项式反演知答案为 $\sum_{x=K}^N \binom{x}{K}(-1)^{x-K} F(x)$。</p>
<p>可以看出 $\sum_{j=1}^{U_i} j^{N-R_i}(U_i-j)^{R_i-1}$ 是一个关于 $U_i$ 的 $N$ 次多项式，可以用拉格朗日插值算。</p>
<p>总时间复杂度 $O(MN^2)$。</p>
<h2 id="BZOJ2655-luogu-P4463-集训队互测2012-calc"><a href="#BZOJ2655-luogu-P4463-集训队互测2012-calc" class="headerlink" title="BZOJ2655 / luogu P4463 [集训队互测2012] calc"></a>BZOJ2655 / luogu P4463 [集训队互测2012] calc</h2><p>钦定 $a_1 &lt; a_2 &lt; \cdots &lt; a_n$ 算答案，最后乘上一个 $n!$ 即可。</p>
<p>设 $f_{i,j}$ 表示：考虑了前 $i$ 个数，最大的数为 $j$，所有方案的权值和。</p>
<p>则 $f_{i,j} = \sum_{k&lt;j} f_{i-1,k} \cdot j$。</p>
<p>注意到，如果 $f_{i,j}$ 是个关于 $j$ 的 $p$ 次多项式，则 $f_{i,j} \cdot j$ 是个关于 $j$ 的 $p+1$ 次多项式，$\sum_{k &lt; j} f_{i,k}$ 是个关于 $j$ 的 $p+1$ 次多项式。</p>
<p>所以 $f_{n,j}$ 是个关于 $j$ 的 $2n+1$ 次多项式。</p>
<p>直接 dp + 拉格朗日插值，可以做到 $O(n^2)$。</p>
<h2 id="luogu-P5850-calc加强版"><a href="#luogu-P5850-calc加强版" class="headerlink" title="luogu P5850 calc加强版"></a>luogu P5850 calc加强版</h2><p>考虑答案关于 $n$ 的生成函数</p>
<script type="math/tex; mode=display">
\begin{gathered}
F(x) = \prod_{i=1}^A (1+ix)\\
= \exp\left( \sum_{i=1}^A \ln\left(1+ix\right) \right)\\
= \exp\left( \sum_{i=1}^A \sum_{j=1}^\infty \frac{(ix)^j (-1)^{j+1}}{j} \right)\\
= \exp\left(\sum_{j=1}^\infty \frac{x^j(-1)^{j+1}}{j} \sum_{i=1}^A i^j\right)\\
\end{gathered}</script><p>剩下的问题就是对每个 $j$ 算 $\sum_{i=1}^A i^j$：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{i=0}^\infty \frac{x^i}{i!} \sum_{j=0}^A j^i\\
= \sum_{j=0}^A \frac{x^i j^i}{i!}\\
= \sum_{j=0}^A e^{jx}\\
= \frac{e^{(A+1)x} - 1}{e^x - 1}
\end{gathered}</script><p>复杂度 $O(n\log n)$，需要卡常。</p>
<p><del>所以拉格朗日插值有什么用呢？</del></p>
<h2 id="BZOJ3453-tyvj-1858-XLkxc"><a href="#BZOJ3453-tyvj-1858-XLkxc" class="headerlink" title="BZOJ3453 tyvj 1858 XLkxc"></a>BZOJ3453 tyvj 1858 XLkxc</h2><p>$f(n) = \sum_{i=1}^n i^k$ 是关于 $n$ 的 $k+1$ 次多项式；</p>
<p>所以 $g(n) = \sum_{i=1}^n f(i)$ 是关于 $n$ 的 $k+2$ 次多项式。</p>
<p>注意到 $h(n) = g(a+nd)$ 仍然是关于 $n$ 的 $k+2$ 次多项式。</p>
<p>所以 $p(n) = \sum_{i=0}^n h(n)$ 是关于 $n$ 的 $k+3$ 次多项式。</p>
<p>拉格朗日插值即可，复杂度大约 $O(k^2)$。</p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Social Infrastructure Information Systems Division, Hitachi Programming Contest 2020 D Manga Market</title>
    <url>/2020/05/19/Atcoder-Social-Infrastructure-Information-Systems-Division-Hitachi-Programming-Contest-2020-D-Manga-Market/</url>
    <content><![CDATA[<p>稍微转化一下题目：</p>
<ol>
<li>把在商店之间行走的时间加到 $b_i$ 里面（也就是让所有的 $b_i$ 自增 1）；由于最后一次购物之后不需要走到别的商店去，所以这样算出来的所需时间会多 1，所以让 $T$ 相应地加 1。</li>
<li>令 $t$ 为当前已经花费的时间，发现 $t’=t+ at + b =(a+1)t+b$，所以令 $a_i$ 自增 1；这样转化以后，已经用了 $t$ 时间后再在第 $i$ 家商店购物，结束的时间恰为 $a_it + b_i$。</li>
</ol>
<p>考虑如果我们已经知道了在要在哪些商店购物，如何确定购物所需的最小时间：假设最优的购物顺序是第 $i$ 次去商店 $p_i$，则</p>
<script type="math/tex; mode=display">
\begin{gathered}a_{p_{i+1}} ( a_{p_i} t + b_{p_i}) + b_{p_{i+1}} < a_{p_i} ( a_{p_{i+1}} t + b_{p_{i+1}}) + b_{p_i}\\\Rightarrow a_{p_{i+1}} b_{p_i} + b_{p_{i+1}} < a_{p_i} b_{p_{i+1}} + b_{p_i}\\\Rightarrow (a_{p_{i+1}} - 1)b_{p_i} < (a_{p_i}-1)b_{p_{i+1}}\\\Rightarrow \frac{a_{p_{i+1}} - 1}{b_{p_{i+1}}} < \frac{a_{p_i}-1}{b_{p_i}}\end{gathered}</script><p>所以最优的购物顺序一定是按照 $\frac{a_i - 1}{b_i}$ 降序。</p>
<p>不妨将所有的商店按照 $\frac{a_i - 1}{b_i}$ 排序，然后进行 dp。设 $f_{i,j}$ 表示考虑完前 $i$ 家店，在 $j$ 家店购物所需的最小时间，然后直接枚举第 $i+1$ 个商店选或者不选转移即可。时间复杂度 $O(N^2)$。</p>
<p>注意到如果所有的 $a_i$ 都大于 $1$，那么 $j$ 取值不超过 $\lfloor \log_2 T \rfloor$。所以可以对 $a_i &gt; 1$ 的商店单独 dp，对于 $a_i = 1$ 的商店直接贪心取 $b_i$ 最小的即可。</p>
<p>时间复杂度 $O(N\log T)$。</p>
<p><a href="https://atcoder.jp/contests/hitachi2020/submissions/13398909" target="_blank" rel="noopener">my submission</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Panasonic Programming Contest 2020 F Fractal Shortest Path</title>
    <url>/2020/05/18/Atcoder-Panasonic-Programming-Contest-2020-F-Fractal-Shortest-Path/</url>
    <content><![CDATA[<h2 id="observation"><a href="#observation" class="headerlink" title="observation"></a>observation</h2><p> 阶分形的第一列、最后一列、第一行、最后一行都是白色的格子。</p>
<h2 id="lemma"><a href="#lemma" class="headerlink" title="lemma"></a>lemma</h2><p>对于一个  阶分形，从其中的任意一个点走到这个分形的右下角的最短路长度为这两个点的曼哈顿距离。</p>
<p>证明：考虑归纳，对于  显然成立；当结论对于  成立时，构造  阶分形中的行走方案：先走到点所属的  阶分形的右下角，然后沿着其它  阶分形的边缘走过去即可。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>将当前的图分为八个部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A B C</span><br><span class="line">D x E</span><br><span class="line">F G H</span><br></pre></td></tr></table></figure>
<p>如果两个点不在同一行或者同一列，那么它们之间的最短路就是它们之间的曼哈顿距离（与 lemma 证明类似构造）。</p>
<p>如果两个点都在 <code>B x G</code> 这一列或者都在 <code>D x E</code> 这一行（以 <code>B x G</code> 为例）：最短路径要么是（起点 -&gt; B 的左下角 -&gt; G 的左上角 -&gt; 终点），要么是（起点 -&gt; B 的右下角 -&gt; G 的右上角 -&gt; 终点）。可以直接算出来。</p>
<p>否则两个点在同一行或者同一列，并且之间全部是  阶分形。递归下去做即可。</p>
<p>为了减少讨论量，可以在初始的时候令点的横坐标绝对值之差大于纵坐标绝对值之差。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://atcoder.jp/contests/panasonic2020/submissions/13379144" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF516E Drazil and His Happy Friends</title>
    <url>/2020/05/13/CF516E-Drazil-and-His-Happy-Friends/</url>
    <content><![CDATA[<p>如果 $n\not \perp m$，则只有编号 $\bmod \{\gcd(n,m)\}$ 同余的编号才会互相影响，对每组同余的编号单独求解（相当于转化成了 $n\perp m$ 的问题）取最大值即可。</p>
<p>以下只考虑 $n\perp m$ 的情况。</p>
<p>观察：</p>
<ul>
<li><p>如果在 $t$ 时刻，第 $i$ 个男生让第 $j$ 个女生变得快乐了，那么第 $t+n$ 时刻第 $i$ 个男生会让第 $j+n \bmod m$ 个女生变得快乐。不妨看作，如果 $j$ 这个女生在 $t$ 这个时刻变得快乐了，那么她会让第 $j+n\bmod m$ 个女生在 $t+n$ 时刻变得快乐。男生同理。</p>
</li>
<li><p>如果男生 $i$ 是被某个女生 $j$ 变快乐的，那么未来的时间里，被这个男生变快乐的女生都可以用前文的方法看作是被 $j$ 变快乐的女生。换而言之，初始的时候不快乐的男生，对于女生们来说是没有用的。初始时不快乐的女生同理。</p>
</li>
</ul>
<p>所以，计算每个人最早什么时候变快乐，只需要考虑以下两种情况：</p>
<ol>
<li>男生 / 女生 $i$ 在 $t$ 时刻变快乐了，那么男生 $i+m\bmod n$ / 女生 $i+n\bmod m$ 会在 $t+m$ / $t+n$ 时刻变快乐</li>
<li>男生 / 女生 $i$ 在初始时是快乐的，他 / 她会在时刻 $i$ 让女生 $i\bmod m$ / 男生 $i\bmod n$ 变得快乐</li>
</ol>
<p>第一种情况中，考虑女生，可以看出这样的“路径”会形成一个环（$i \to i+n\bmod m \to i+2n \bmod m \cdots$）。按照点在环上的出现位置重编号，令原来的 $0$ 重标号后的编号为 $0$，则原来的 $i$ 重编号后的编号为 $i \cdot n^{-1} \bmod m$。令环上第二种情况涉及到的点和初始时开心的点为关键点，发现每个关键点能贡献到的一定是重标号后的环上以它开头的一段区间。直接计算每个关键点能贡献到的区间中最晚的变开心的时间即可。注意如果关键点是第二种情况造成的，则关键点变开心的时间也要计入答案。男生同理。</p>
<p><a href="https://codeforces.com/contest/516/submission/79937328" target="_blank" rel="noopener">my submission on codeforces.com</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Burnside Lemma的证明</title>
    <url>/2020/05/06/%E5%85%B3%E4%BA%8EBurnside-Lemma%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://tgsteven.github.io/2018/07/10/2018-07-10-polya/" target="_blank" rel="noopener">TGSteven 的博客</a>（那篇博客现在已经被TGSteven删掉了）</li>
<li><a href="https://en.wikipedia.org/wiki/Burnside&#39;s_lemma" target="_blank" rel="noopener">wikipedia: Burside’s lemma</a></li>
</ul>
<h3 id="轨道-orbit"><a href="#轨道-orbit" class="headerlink" title="轨道 orbit"></a>轨道 orbit</h3><p>我们记$X$中的元素$x$在置换群$G$作用下的轨道为：</p>
<script type="math/tex; mode=display">
G\cdot x = \{ g\cdot x \mid g\in G\}</script><p>那么，$x$的轨道中的所有元素一定和$x$属于同一个等价类，并且不在$x$的轨道中的元素一定不与$x$属于同一个等价类。比如说，$2$种颜色的珠子串长度为$4$的项链，允许旋转，那么0101和1010都是0101的轨道中的元素。又比如给$2\times 2$的方格涂色，允许进行旋转，那么$\begin{matrix} 1&amp; 0 \ 0 &amp; 1\end{matrix}$的轨道中的元素有$\begin{matrix} 1&amp; 0 \ 0 &amp; 1\end{matrix}$和$\begin{matrix} 0&amp; 1 \ 1 &amp; 0\end{matrix}$。一个元素的轨道，就是它在$G$的作用下能够得到的元素组成的集合。</p>
<p>定义一个集合$X$的轨道是所有元素的轨道的集合，记为$X/G$。实际上，一个轨道就是我们之前提到的一个等价类。</p>
<hr>
<h3 id="不动点与稳定子集"><a href="#不动点与稳定子集" class="headerlink" title="不动点与稳定子集"></a>不动点与稳定子集</h3><p>定义一个置换$g$的不动点为：</p>
<script type="math/tex; mode=display">
X^g=\{ x\in X \mid g\cdot x=x\}</script><p>定义$X$中的一个元素$x$的稳定子集为：</p>
<script type="math/tex; mode=display">
G_x = \{g\in G\mid g\cdot x=x\}</script><hr>
<h3 id="证明orbit-stabilizer-theorem（口胡）"><a href="#证明orbit-stabilizer-theorem（口胡）" class="headerlink" title="证明orbit-stabilizer theorem（口胡）"></a>证明orbit-stabilizer theorem（口胡）</h3><blockquote>
<p>orbit-stabilizer theorem：一个元素的轨道中的元素数量与这个元素的稳定子集的大小的乘积等于置换群中置换的数量，即$\forall x\in X,| G\cdot x|\cdot |G_x| = |G|$</p>
</blockquote>
<p>限于本人的水平，以下内容是在阅读了若干资料之后用口水话胡的。</p>
<p>对于一个元素$x$，我们可以将$G$中的置换分为两类，一类是$G_x$中的，一类是不属于$G_x$的。那么对于$x$的轨道中的所有元素，这个“分类”的结果是一样的。即对于一个置换$g$，如果$g\cdot x=x$，那么$\forall x’\in G\cdot x,g\cdot x’=x’$；如果$g\cdot x\not= x$，那么$\forall x’\in G\cdot x,g\cdot x’\not =x’$。</p>
<p>一个置换作用在$x$上，得到的结果一定在$x$的轨道中。那么任意一个置换，它可以表达为：$x$的轨道中的一个元素在$G_x$中的一个置换下得到的结果。并且，“$x$的轨道中的一个元素在$G_x$中的一个置换下得到的结果”和“$G$中的一个置换”，这两者是一一对应的关系。因此，$|G\cdot x|\cdot |G_x|=|G|$。</p>
<p>这也就是为什么我们要求置换构成群：这个定理成立的前提是置换结合满足封闭性。如果从$x$到达“$x$的轨道中的一个元素在$G_x$中的一个置换下得到的结果”这个置换不在$G$中，那么在计数的时候就会出错。</p>
<hr>
<h3 id="证明Burnside-Lemma"><a href="#证明Burnside-Lemma" class="headerlink" title="证明Burnside Lemma"></a>证明Burnside Lemma</h3><blockquote>
<p>Burnside Lemma：一个集合$X$在置换群$G$作用下的等价类（轨道）的数量，等于$G$中每一个置换的不动点的数量的平均值。即$|X/G|={1\over |G|}\sum_{g\in G}|X^g|$</p>
</blockquote>
<p>首先，显然有</p>
<script type="math/tex; mode=display">
\sum_{g\in G}|X^g| = \sum_{x\in X} |G_x| \tag{1}</script><p>考虑某一个轨道$G\cdot x$，轨道中的每一个元素的轨道都是$G\cdot x$，每一个元素对$(1)$的贡献是$|G_x|$，所以每一个轨道对$(1)$的贡献就是$|G\cdot x|\cdot |G_x| = |G|$（轨道稳定定理）。也就是说每个轨道对$(1)$的贡献是一样的。</p>
<p>由于轨道的数量为 $|X/G|$，故而 $\sum_{g\in G}|X^g| = |G||X/G|$，即$\frac{1}{|G|} \sum_{g\in G} |X^g| = |X/G|$。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3047 「ZJOI2019」浙江省选</title>
    <url>/2020/05/04/LOJ3047-%E3%80%8CZJOI2019%E3%80%8D%E6%B5%99%E6%B1%9F%E7%9C%81%E9%80%89/</url>
    <content><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>能够排名第 $k$ 的一定满足：存在一个 $x$，使得分数比这个人高的人不超过 $k-1$ 个。可以枚举其它的每一个人，然后计算它比这个人优秀的 $x$ 区间，最后检查一下被覆盖次数最小的部分被覆盖了多少次即可。这样是 $O(n^2 \log n)$ 的。</p>
<p>由于 $m$ 很小，我们考虑对每个 $k\in [1,m]$ 分别求解。假设现在已经求出了排名为 $1$ 到 $k-1$ 的人，则排名为 $k$ 的人一定在剩下的人的半平面交上，并且让它能进队的 $x$ 也一定在半平面交中它贡献的线段上。对其它人求出：对于哪些 $x$，它会比半平面交上对应位置的直线优秀；由于半平面交的形状是个凸壳，所以这样的 $x$ 一定也会构成一个连续区间。而一个人的排名为 $k$ 的条件就是：半平面交中它贡献的线段上，存在整点 $x$，满足 $x$ 只被那些区间覆盖了不到 $k$ 次。时间复杂度 $O(nm\log n)$。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol>
<li><p>排名为“分数<strong>严格</strong>大于自己的人数+1”，所以：</p>
<ol>
<li>对每个人求出的可以覆盖的 $x$ 区间，其端点是不能取到的</li>
<li>半平面交中，如果三条直线交于一点，则三条直线都应该保留</li>
</ol>
</li>
<li><p>题目中要求 $x$ 为非负<strong>整数</strong>，所以要特殊判断半平面交中的某条线段上没有整点的情况</p>
</li>
<li><p>判断某个人是否排名为 $k$：事先求出所有的被覆盖次数不到 $k$ 的区间（称为好区间），然后检查这些好区间与这个人在半平面交上的区间是否有交，这个可以转化成判断与这个人在半平面交上的区间无交的好区间数量是否等于总数量。</p>
</li>
<li><p>（似乎）<code>long double</code> 会精度爆炸，所以用了两个 <code>__int128</code> 来表示一个分数。从 <a href="https://blog.csdn.net/qq_39972971/article/details/92386663" target="_blank" rel="noopener">cz_xuyixuan</a> 的代码中学到了一个很妙的判断直线和凸壳上的点的位置关系的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">frac</span> &#123;</span></span><br><span class="line">	__int128 a,b;</span><br><span class="line">	frac(__int128 a=<span class="number">0</span>,__int128 b=<span class="number">1</span>): a(a),b(b) &#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(frac A,frac B) &#123; <span class="keyword">return</span> A.a*B.b &lt; A.b*B.a; &#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(frac A,frac B) &#123; <span class="keyword">return</span> A.a*B.b &lt;= A.b*B.a; </span><br><span class="line">&#125;s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">	ll k,b;</span><br><span class="line">&#125;q[N],L[N];</span><br><span class="line"><span class="keyword">int</span> tl;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> frac <span class="title">INTER</span><span class="params">(Line A,Line B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(B.k&gt;A.k) <span class="keyword">return</span> frac(A.b-B.b,B.k-A.k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> frac(B.b-A.b,A.k-B.k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L[x].k!=L[y].k) <span class="keyword">return</span> L[x].k&lt;L[y].k;</span><br><span class="line">	<span class="keyword">return</span> L[x].b&gt;L[y].b;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p 为要求半平面交的直线的编号</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">HPI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">	sort(p.begin(),p.end(),cmp);</span><br><span class="line">	tl=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.size();++i) &#123;</span><br><span class="line">		Line c=L[p[i]];</span><br><span class="line">		<span class="keyword">if</span>(tl&amp;&amp;c.k==L[p[i<span class="number">-1</span>]].k) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span>(tl&gt;=<span class="number">2</span> &amp;&amp; INTER(q[tl],c)&lt;s[tl]) tl--;</span><br><span class="line">		<span class="keyword">while</span>(tl&gt;=<span class="number">1</span> &amp;&amp; q[tl].b&lt;c.b) tl--;</span><br><span class="line">		q[++tl]=c;</span><br><span class="line">		<span class="keyword">if</span>(tl==<span class="number">1</span>) s[tl]=frac(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> s[tl]=INTER(q[tl],q[tl<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	s[tl+<span class="number">1</span>]=frac(inf,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://loj.ac/submission/801213" target="_blank" rel="noopener">my submission on loj.ac</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>20200423 SCOI模拟2</title>
    <url>/2020/04/24/20200423-SCOI%E6%A8%A1%E6%8B%9F2/</url>
    <content><![CDATA[<h2 id="A-矩阵求和"><a href="#A-矩阵求和" class="headerlink" title="A - 矩阵求和"></a>A - 矩阵求和</h2><p>答案是</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{i=lx}^{rx} \sum_{j=ly}^{ry} (a_i (m-1) + b_j) \binom{rx-i+k}{k} \binom{ry-j+k}{k}
\end{gathered}</script><p>把组合数拆开，用树状数组维护区间的 $\sum a_i i^j (j\in [0,maxk])$。</p>
<p>时间复杂度 $O\left(q\left(k\log n + k^2\right)\right)$。</p>
<h2 id="B-西行寺无余涅槃"><a href="#B-西行寺无余涅槃" class="headerlink" title="B - 西行寺无余涅槃"></a>B - 西行寺无余涅槃</h2><p>可以参考一下CF1119H（<a href="https://www.luogu.com.cn/blog/command-block/solution-cf1119h" target="_blank" rel="noopener">点此传送到command_block的题解</a>）的做法。</p>
<p>下文中，把 $F$ 数组 FWT 之后的结果写为 $FWT(F)$，把其中第 $i$ 个元素写为 $FWT(F)[i]$。</p>
<p>设</p>
<script type="math/tex; mode=display">
F_t[x] = \sum_{p_{t,j} = x} a_j</script><p>只要对每个 $i\in [0,2^m)$，求出 $\prod_{t=1}^n \left(FWT(F_t)[i]\right)$，就能得到答案。</p>
<p>$FWT(F_t)$ 中的每一项一定都是 $(-1)^{x_1} a_1 + (-1)^{x_2}a_2 + \cdots + (-1)^{x_k}a_k$ 的形式，这只有 $2^k$ 种不同的取值。由于 $k$ 很小，考虑求出每种取值出现了多少次。</p>
<p>设</p>
<script type="math/tex; mode=display">
C_{i,S} = \sum_{t=1}^n \prod_{j=0}^{k-1}\left[{bitcount(i\& p_{t,j})\bmod {2}} = [j\in S]\right]</script><p>显然有</p>
<script type="math/tex; mode=display">
\begin{gathered}
\prod_{t=1}^n (FWT(F_t)[i])\\
= \prod_{S=0}^{2^k-1}\left( \sum_{j\notin S} a_j - \sum_{j\in S} a_j\right)^{C_{i,S}}
\end{gathered}</script><p>想办法构建方程解出 $C_{i,S}$。</p>
<p>选取一个 $\{0,1,\cdots k-1\}$ 的子集 $T$，令</p>
<script type="math/tex; mode=display">
\begin{gathered}
G_{T,t}[j] = \left[\bigoplus_{x\in T} p_{t,x} = j\right]\\
D_{i,T} = \sum_{t=1}^n \left(FWT(G_{T,t})[i]\right)
\end{gathered}</script><p>则</p>
<script type="math/tex; mode=display">
\begin{gathered}
FWT(G_{T,t})[i]=(-1)^{bitcount\left(i\& \left(\bigoplus_{x\in T} p_{t,x}\right)\right)}\\
= (-1)^{\sum_{x\in T} bitcount(i\& p_{t,x})}\\
D_{i,T}\\
= \sum_{t=1}^n \left(FWT\left(G_{T,t}\right)[i] \right)\\
= \sum_{t=1}^n (-1)^{\sum_{x\in T} bitcount(i\& p_{t,x})}\\
= \sum_{S\in [0,2^k)} (-1)^{bitcount(S\&T)} \cdot C_{i,S}
\end{gathered}</script><p>所以 $C_{i} = IFWT(D_i)$。</p>
<p>而 $\sum_t FWT(G_{T,t}) = FWT\left(\sum_t G_{T,t} \right)$，枚举完 $T$ 之后 $O(nk + 2^m m)$ 计算即可求出所有的 $D_{i,T}$ 。</p>
<p>总时间复杂度为 $O(2^k (nk+2^m m) + 2^m2^k k)$。</p>
<h2 id="C-鱼贯而入"><a href="#C-鱼贯而入" class="headerlink" title="C - 鱼贯而入"></a>C - 鱼贯而入</h2><h3 id="做法-0"><a href="#做法-0" class="headerlink" title="做法 0"></a>做法 0</h3><p>特判 $n=1,2,3$。对于 $a_i$ 随机的数据来说，最优的 $len$ 一定不会比 $n$ 大太多。</p>
<h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法 1"></a>做法 1</h3><p>显然只有当 $\exists i,j, len\mid (a_i - a_j)$ 的时候，$Ans &gt; 0$。如此直接枚举 $len$ 计算。</p>
<h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法 3"></a>做法 3</h3><p>根据模运算的一些性质，$kp$ 有的寻址时间 $p$ 一定也有。设 $mind(n)$ 为 $n$ 的最小质因子，那么我们只需要检查满足 $\frac{len}{mind(len)} &lt; n \le len$  的 $len$。</p>
<p>$a_i - a_j$ 的大于等于 $n$ 的质因子一定是可以的。可以的合数一定在 $[n,n^2]$ 内。分别枚举并检查即可。</p>
<h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法 4"></a>做法 4</h3><p>把 Pollard-rho 求 gcd 的那个 $O(\log n)$ 优化掉（可以参考<a href="https://www.cnblogs.com/812-xiao-wen/p/10544546.html" target="_blank" rel="noopener">wch的博客</a>）。这样可以得到 100 分。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3112 「SDOI2019」世界地图</title>
    <url>/2020/04/23/LOJ3112-%E3%80%8CSDOI2019%E3%80%8D%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<p>考虑这样一个问题：有两棵边带权的树，以及若干条两个端点分别在两棵树上、有边权的边。求最小生成树。多次询问，每次给出两棵树之间的边，要求回答询问的复杂度与给出的边数相关。</p>
<p>一个暴力做法是动态最小生成树，每次尝试用新加的边替换掉原来的树上的边。</p>
<p>我们称连接两棵树的那些边的端点为关键点。观察到，对于树上的某条路径，如果任意的一对关键点之间的路径都包含它或者与它无交，那么这条路径上至多有一条边被新加入的边替换掉。因为一旦这条路径的某条边被替换掉（也就意味着这条路径被断开了），那么它将不再与任何的关键点之间的路径有交。</p>
<p>这意味着我们可以对关键点建虚树，虚树上两点之间的边权为它们路径上边权的最大值，然后进行之前的动态最小生成树做法。也可以直接 Kruskal，因为虚树上的点数不超过关键点数量的二倍。</p>
<p>回到本题，可以用上面说的方法求出每个前缀、后缀的最小生成树，对于每个询问，把 $[1,l_i)$ 与 $(r_i,n]$ 合并起来即可。时间复杂度 $O((m+q)n\log n)$。</p>
<p>实现细节可以参考<a href="https://loj.ac/submission/793488" target="_blank" rel="noopener">代码</a>。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu P6151 [集训队作业2019] 青春猪头少年不会梦到兔女郎学姐</title>
    <url>/2020/04/22/luogu-P6151-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2019-%E9%9D%92%E6%98%A5%E7%8C%AA%E5%A4%B4%E5%B0%91%E5%B9%B4%E4%B8%8D%E4%BC%9A%E6%A2%A6%E5%88%B0%E5%85%94%E5%A5%B3%E9%83%8E%E5%AD%A6%E5%A7%90/</url>
    <content><![CDATA[<h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>定义一个序列是好的，当且仅当它以 $1$ 开始且不以 $1$ 结尾。</p>
<p>任意一个序列 $S$，假设它对应的圆排列中有 $c(S)$ 段 $1$，那么它的循环移位中有 $c(S)$ 个好的序列（这其中可能有相同的好序列）。也就是说，所有的好序列的、等于 $S$ 的循环移位的数量为 $c(S)$。</p>
<p>设 $val(S)$ 为序列 $S$ 的权值（与题目中的定义相同），那么</p>
<script type="math/tex; mode=display">
\begin{gathered}
Ans\\
= \sum_{\text{S为符合题意的序列}} val(S) \\
= \sum_{\text{S为符合题意的序列}} \frac{1}{c(S)}\sum_{\text{P是S的循环移位且P是好序列}} val(P)\\
= 
\sum_{\text{S为符合题意的序列}} \sum_{\text{P是S的循环移位且P是好序列}} \frac{1}{c(P)} val(P)\\
= \sum_{\text{P 是符合题意的好序列}} \frac{ val(P)}{c(P)} \sum_{\text{S 是 P 的循环移位}} 1\\
= \sum_{\text{P 是符合题意的好序列}} \frac{val(P)}{c(P)} |P|
\end{gathered}</script><p>因为序列的长度是固定的，我们只需要统计 $\sum_{\text{P是符合题意的好序列}} \frac{val(P)}{c(P)}$ 就能得到答案。</p>
<p>将 $a$ 个相同的数字划分成 $b$ 段的所有方案的权值和为</p>
<script type="math/tex; mode=display">
\sum_{x_i \ge 1, x_1+x_2+\cdots x_b = a} \prod_{i=1}^b x_i</script><p>考虑到 $\prod_i x_i$ 的组合意义相当于是从每段里面再选出一个球，把选的这个球当成板子，可以得到上式等价于</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{x_i \ge 0, x_1+x_2+\cdots x_{2b} = a-b} 1\\
= \binom{a+b-1}{2b-1}
\end{gathered}</script><p>先枚举每种数字在最终的序列中形成了多少段，然后由于要求同种数字的段不能相邻，所以再枚举同种数字的哪些段被粘在了一起（容斥）。不为 $1$ 的数字，它的 EGF 为（假设这种数字共有 $a$ 个）</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{b=1}^a \binom{a+b-1}{2b-1} \sum_{j=1}^b (-1)^{b-j} \binom{b-1}{j-1} \frac{x^j}{j!}\\
= \sum_{j=1}^a \frac{x^j}{j!(j-1)!} (-1)^j \sum_{b=j}^a \frac{(b-1)!}{(b-j)!} (-1)^b \binom{a+b-1}{2b-1}
\end{gathered}</script><p>可以一次 FFT 算出来。</p>
<p>而对于数字 $1$，容斥的时候除了可以把相邻的段粘在一起，还可以把最后一段和结尾粘在一起，并且第一段在序列中的位置是确定了的，不参与排列，所以它的 EGF 为（仍然设 $a=c_1$）</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{b=1}^a \frac{1}{b} \binom{a+b-1}{2b-1} \sum_{j=0}^{b-1} \binom{b}{b-1-j} (-1)^{b-1-j} \frac{x^j}{j!}\\
= \sum_{j=0}^{a-1} \frac{x^j}{j!(j+1)!} (-1)^j \sum_{b=j+1}^a \frac{b!}{(b-j-1)!}(-1)^{b-1} \frac{1}{b} \binom{a+b-1}{2b-1}
\end{gathered}</script><p>也可以一次 FFT 算出来。</p>
<p>最后我们需要算的是每个数字的 EGF 的乘积，分治 FFT 即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,<span class="keyword">int</span> y)</span> </span>&#123; ll res=<span class="number">1</span>; <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%mod; <span class="keyword">return</span> res; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> wn[<span class="number">2</span>][N],rev[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getwn</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;l);i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> w0=Pow(<span class="number">3</span>,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>)),w1=Pow(<span class="number">3</span>,mod<span class="number">-1</span>-(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">            wn[<span class="number">0</span>][i]=wn[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line">                wn[<span class="number">0</span>][i+j]=wn[<span class="number">0</span>][i+j<span class="number">-1</span>]*(ll)w0%mod,</span><br><span class="line">                wn[<span class="number">1</span>][i+j]=wn[<span class="number">1</span>][i+j<span class="number">-1</span>]*(ll)w1%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(len&gt;&gt;<span class="number">1</span>)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> len,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) <span class="keyword">if</span>(rev[i]&lt;i) swap(A[i],A[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=l&lt;&lt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;l;++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t0=A[i+j],t1=A[i+l+j]*(ll)wn[f][l+j]%mod;</span><br><span class="line">                    A[i+j]=(t0+t1)%mod,A[i+l+j]=(t0-t1)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> Inv=Pow(len,mod<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[i]=A[i]*(ll)Inv%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span> *C,<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> l3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a[N],b[N];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>; <span class="keyword">while</span>(len&lt;n+m<span class="number">-1</span>||len&lt;l3) len&lt;&lt;=<span class="number">1</span>; getr(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=b[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) a[i]=A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) b[i]=B[i];</span><br><span class="line">        FFT(a,len,<span class="number">0</span>),FFT(b,len,<span class="number">0</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=a[i]*(ll)b[i]%mod; FFT(a,len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l3;++i) C[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span> *C,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123; Mul(A,B,C,n,m,n+m<span class="number">-1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;C)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> a[N],b[N];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>; <span class="keyword">while</span>(len&lt;A.size()+B.size()<span class="number">-1</span>) len&lt;&lt;=<span class="number">1</span>; getr(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=b[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();++i) a[i]=A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B.size();++i) b[i]=B[i];</span><br><span class="line">        FFT(a,len,<span class="number">0</span>),FFT(b,len,<span class="number">0</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=a[i]*(ll)b[i]%mod; FFT(a,len,<span class="number">1</span>);</span><br><span class="line">        C.resize(A.size()+B.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;C.size();++i) C[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N],s[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="keyword">void</span>)(s[c]=g[l]);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	solve(l,mid,c&lt;&lt;<span class="number">1</span>),solve(mid+<span class="number">1</span>,r,c&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	Poly::Mul(s[c&lt;&lt;<span class="number">1</span>],s[c&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],s[c]);</span><br><span class="line">	s[c&lt;&lt;<span class="number">1</span>].clear();</span><br><span class="line">	s[c&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].clear();</span><br><span class="line">&#125;</span><br><span class="line">ll fac[N&lt;&lt;<span class="number">1</span>],inv[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">// ll A[N],B[N],C[N];</span></span><br><span class="line"><span class="keyword">int</span> A[N],B[N],C[N];</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="comment">//ll sum[N],tmp[N];</span></span><br><span class="line"><span class="comment">//int len;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getfac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=Pow(fac[n],mod<span class="number">-2</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;</span><br><span class="line"><span class="keyword">int</span> ra[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m; rd(m);</span><br><span class="line">	getfac(<span class="number">400000</span>);</span><br><span class="line">	Poly::getwn(<span class="number">18</span>);</span><br><span class="line"><span class="comment">//	sum[0]=1;</span></span><br><span class="line">	<span class="keyword">int</span> coe=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">1</span>,a;now&lt;=m;++now) &#123;</span><br><span class="line">		rd(a),coe+=a;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a;++i) A[i]=B[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(now==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) A[i]=binom(a+i<span class="number">-1</span>,<span class="number">2</span>*i<span class="number">-1</span>)*fac[i<span class="number">-1</span>]%mod*(i&amp;<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) B[a-i]=inv[i<span class="number">-1</span>];</span><br><span class="line">			Poly::Mul(A,B,C,a+<span class="number">1</span>,a+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;++i) f[i]=C[i+a]*inv[i]%mod*inv[i+<span class="number">1</span>]%mod*(i&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line"><span class="comment">//			for(int i=1;i&lt;=a;++i) B[i]=inv[i-1];</span></span><br><span class="line"><span class="comment">//			for(int i=1;i&lt;=a;++i) for(int j=1;j&lt;=i;++j) (C[i-j]+=A[i]*B[j]%mod)%=mod;</span></span><br><span class="line"><span class="comment">//			for(int i=0;i&lt;a;++i) f[i]=C[i]*inv[i]%mod*inv[i+1]%mod*(i&amp;1?-1:1),C[i]=0;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) A[i]=binom(a+i<span class="number">-1</span>,<span class="number">2</span>*i<span class="number">-1</span>)*fac[i<span class="number">-1</span>]%mod*(i&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;++i) B[a-i]=inv[i];</span><br><span class="line">			Poly::Mul(A,B,C,a+<span class="number">1</span>,a+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) f[i]=C[i+a]*inv[i]%mod*inv[i<span class="number">-1</span>]%mod*(i&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line"><span class="comment">//			for(int i=0;i&lt;a;++i) B[i]=inv[i];</span></span><br><span class="line"><span class="comment">//			for(int i=1;i&lt;=a;++i) for(int j=0;j&lt;i;++j) (C[i-j]+=A[i]*B[j]%mod)%=mod;</span></span><br><span class="line"><span class="comment">//			for(int i=1;i&lt;=a;++i) f[i]=C[i]*inv[i]%mod*inv[i-1]%mod*(i&amp;1?-1:1),C[i]=0;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a;++i) g[now].PB(f[i]),f[i]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;=a;++i)</span></span><br><span class="line"><span class="comment">//		for(int j=0;j&lt;=len;++j)</span></span><br><span class="line"><span class="comment">//			(tmp[i+j]+=f[i]*sum[j]%mod)%=mod;</span></span><br><span class="line"><span class="comment">//		len+=a;</span></span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;=len;++i) sum[i]=tmp[i],tmp[i]=0;</span></span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;=a;++i) f[i]=0;</span></span><br><span class="line">	&#125;</span><br><span class="line">	solve(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;=len;++i) (ans+=sum[i]*fac[i]%mod)%=mod;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s[<span class="number">1</span>].size();++i) (ans+=s[<span class="number">1</span>][i]*fac[i]%mod)%=mod;</span><br><span class="line">	ans=<span class="number">1l</span>l*ans*coe%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,(ans+mod)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3102 「JSOI2019」神经网络</title>
    <url>/2020/04/21/LOJ3102-%E3%80%8CJSOI2019%E3%80%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/792389" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<p>不难发现问题等价于：把每棵树划分成若干条链，把这些链拿来做圆排列，要求相邻的链不能来自同一棵树，求方案数。</p>
<p>假设我们已经把每棵树划分成了若干条链，并且确定好了链在圆排列中出现的方向（长度大于 $1$ 的链有两种可能的方向），求圆排列方案数。假设此时第 $i$ 棵树的点划分成了 $A_i$ 条链。</p>
<p>把环断开为序列，钦定序列的开头为第一棵树的 $1$ 号点所在的链。我们对序列的要求是：</p>
<ul>
<li>相邻的两条链不能来自同一棵树</li>
<li>结尾的链不能来自第一棵树</li>
</ul>
<p>首先我们确定每棵树内的点在序列中的相对顺序（也就是最终答案乘上 $(A_1 - 1)! \prod_{i=2}^m A_i!$）。</p>
<p>如果没有上面两个限制，方案数就是 $\frac{(\sum A_i -1)!}{(A_1 - 1)!\prod_{i=2}^m A_i!}$。</p>
<p>对于上面的两个限制，钦定一些同一棵树中相对顺序相邻的链粘在一起（或者钦定第一棵树中相对顺序在最右边的和序列的结尾粘在一起）进行容斥即可。</p>
<p>把方案数中的 $\frac{1}{(A_1 - 1)! \prod_{i=2}^m A_i! }$ 下放到每个 $A_i$ 头上（也就是在我们确定 $A_i$ 的时候就乘上相应的系数），那么计算总方案数就只需要知道 $\sum A_i$。把 $\sum A_i$ 作为状态进行 dp（或者把 $\sum A_i$ 作为生成函数的指数进行卷积）即可。</p>
<p>总时间复杂度 $O((\sum k_i)^2 )$。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3059 「HNOI2019」序列</title>
    <url>/2020/04/20/LOJ3059-%E3%80%8CHNOI2019%E3%80%8D%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>IOI2018 集训队论文 高睿泉 《浅谈保序回归问题》</li>
<li><a href="https://www.cnblogs.com/Paul-Guderian/p/10801584.html" target="_blank" rel="noopener">大米饼的博客</a></li>
</ul>
<h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><h3 id="部分分：-m-0"><a href="#部分分：-m-0" class="headerlink" title="部分分：$m=0$"></a>部分分：$m=0$</h3><p>考虑一个更加一般的形式：已知 $w_i, A_i \ge 0$，要求确定 $B_i$，使得 $B_i \le B_{i+1}$ 且 $\sum w_i(A_i - B_i)^2$ 最小。</p>
<p>定义一个点集 $U$ 的均值为：让 $\sum_{j\in U} w_j (A_j - k)^2$ 取到最小值的 $k$。对于这道题，$k = \frac{\sum_{j\in U} w_jA_j}{\sum_{j\in U} w_j}$（通过求导可得）</p>
<h4 id="引理-1"><a href="#引理-1" class="headerlink" title="引理 1"></a>引理 1</h4><p>能达到最优解的 $\{ B_i \}$ 是唯一的。</p>
<p>证明：将 $(A_1,A_2,\cdots A_n)$ 和 $(B_1, B_2, \cdots B_n)$ 看作两个 $n$ 维向量，权值函数可以看作两个点之间的距离。由于不等式组 $B_i \le B_{i+1}$ 的解空间是一个凸集，所以到 $A$ 的距离最短的 $B$ 是唯一的。</p>
<h4 id="引理-2"><a href="#引理-2" class="headerlink" title="引理 2"></a>引理 2</h4><p>如果 $A_i &gt; A_{i+1}$，那么最优解中一定有 $B_i = B_{i+1}$。</p>
<p>证明：参考 IOI2018 集训队论文《浅谈保序回归问题》</p>
<p>引理 2 启发我们可以考虑这样的一个过程：每一次找到一个满足 $A_i &gt; A_{i+1}$ 的 $i$，然后将 $i$ 和 $i+1$ 合并。具体地，应该把 $(w_i, A_i), (w_{i+1},A_{i+1})$ 替换为 $(w_i + w_{i+1}, \frac{w_iA_i + w_{i+1}A_{i+1}}{w_i + w_{i+1}})$，这样前后的权函数只相差一个常数，直接在合并的时候把这个常数加入答案即可。合并到无法合并的时候，直接令每个 $B_i$ 都取 $A_i$，这就是最优方案。最终的答案就是在合并的过程中产生的那些常数的和。</p>
<p>由引理 1 可知，无论以任何顺序合并，最终得到的 $\{ B_i \}$ 都是相同的，所以合并过程完成以后得到的那些同值的段（下文称为等值段）也一定是相同的。</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>把询问离线下来依次处理。对于询问 $(x,y)$，先处理好只考虑 $[1,x-1]$ 和 $[x+1,n]$ 时，等值段的划分情况（可以用从左到右和从右到左的单调栈分别维护）。</p>
<p>最终的划分方案一定是：保留 $[1,x-1]$ 的等值段划分的一个前缀，保留 $[x+1,n]$ 的等值段划分的一个后缀，剩下的部分和 $x$ 合并为一段。设这个前缀包含了 $[1,x-1]$ 的前 $L_0$ 个等值段，这个后缀包含了 $[x+1,n]$ 的后 $R_0$ 个等值段。设 $L_0,R_0$ 之间（不含 $L_0,R_0$）的元素合并起来后的权值（也就是它们的平均值）为 $v(L_0,R_0)$。设 $[1,x-1]$ 中从左到右第 $x$ 段的 $A_i$ 为 $lv(x)$，设 $[x+1,n]$ 中从右到左第 $x$ 段的 $A_i$ 为 $rv(x)$。</p>
<p>考虑如何求出 $L_0,R_0$。我们对 $L_0,R_0$ 的要求是：</p>
<ul>
<li>$lv(L_0) &lt; v(L_0,R_0) &lt; rv(R_0)$</li>
<li>$L_0,R_0$ 之间的元素确实能合并成一段（即合并过程中不存在把 $A_i &lt; A_{i+1}$ 的两个元素合并了的情况）</li>
</ul>
<p>考虑这样一个算法：从大到小枚举 $R_0$，然后求出最大的 $L_0$，使得 $lv(L_0) &lt; v(L_0, R_0)$；如果 $v(L_0, R_0) &lt; v(R_0)$ 就退出，把此时的 $L_0, R_0$ 作为答案，否则继续枚举 $R_0$。</p>
<ul>
<li>对于某个固定的 $R_0$ 来说<ul>
<li>考虑某个比求出的 $L_0$ 更小的 $L_0’$：$v(L_0’,R_0)$ 一定合并了不能合并的段（即满足 $A_i &lt; A_{i+1}$ 的两个段）</li>
<li>考虑某个比求出的 $L_0$ 更大的 $L_0’$：$v(L_0’,R_0)$ 一定还能和左边的段合并，所以不可能和 $R_0$ 一起作为最终的等值段</li>
</ul>
</li>
<li>故而，对于固定的 $R_0$ 来说，最大的满足 $lv(L_0) &lt; v(L_0, R_0)$ 的 $L_0$ 是<strong>唯一可能使 $(L_0,R_0)$ 合法</strong>的 $L_0$</li>
</ul>
<p>假设 $r$ 为算法结束时的 $R_0$：任意一个大于 $r$ 的 $R_0$ 显然不可能成为最终的等值段的右端点（因为还可以和右边的段合并）；而任意一个小于 $r$ 的 $R_0$，$v(L_0,R_0)$ 一定合并了不能合并的段。</p>
<p>所以，算法结束时求出来的 $L_0,R_0$ 就是我们想求的答案。</p>
<p>算法的优化：</p>
<ul>
<li>在已知 $R_0$ 的情况下求最大的满足 $lv(L_0) &lt; v(L_0, R_0)$ 的 $L_0$<ul>
<li>可以证明，如果 $L_0$ 满足条件，那么 $L_0 - 1$ 也满足条件<ul>
<li>由于 $lv(L_0) &lt; v (L_0, R_0)$，又因为 $lv(L_0 - 1) &lt; lv(L_0)$，所以 $lv(L_0 - 1) &lt; v(L_0, R_0)$，那么 $lv(L_0 - 1)$ 一定小于 $lv(L_0), v(L_0,R_0)$ 中的元素的平均值（也就是 $v(L_0 - 1,R_0)$），所以 $L_0 - 1$ 一定也满足条件</li>
</ul>
</li>
<li>所以可以直接二分 $L_0$</li>
</ul>
</li>
<li>求最大的 $R_0$，使得满足 $lv(L_0) &lt; v(L_0, R_0)$ 的最大的 $L_0$ 也满足 $v(L_0, R_0) &lt; rv(R_0)$<ul>
<li>一个重要的观察是，对于某个固定的 $R_0$，满足 $lv(L_0) &lt; v(L_0, R_0)$ 的最大的 $L_0$，就是使 $v(L_0,R_0)$ 取到最大值的 $L_0$</li>
<li>可以证明，如果 $R_0$ 满足条件，那么$R_0-1$ 也满足条件<ul>
<li>设 $R_0$ 求出的 $L_0$ 为 $L$，$R_0 - 1$ 求出的 $L$ 为 $L’$，那么 $v(L’, R_0) \le v(L, R_0) &lt; rv(R_0) &lt; rv(R_0 - 1)$，$v(L’,R_0)$ 和 $rv(R_0)$ 都小于 $rv(R_0 - 1)$，所以 $v(L’, R_0 - 1)$ 小于 $rv(R_0 - 1)$</li>
</ul>
</li>
<li>所以可以直接二分 $R_0$</li>
</ul>
</li>
</ul>
<p>总时间复杂度为 $O(n \log^2 n)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://loj.ac/submission/791870" target="_blank" rel="noopener">my submission on loj.ac</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3056 「HNOI2019」多边形</title>
    <url>/2020/04/18/LOJ3056-%E3%80%8CHNOI2019%E3%80%8D%E5%A4%9A%E8%BE%B9%E5%BD%A2/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/790203" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<p>对于一个已经无法继续旋转的多边形，我们考虑它上面的一个四边形，其顶点依次为 $A,B,C,D$（$O$ 点表示多边形的 $1$ 号顶点）：</p>
<p><img src="https://i.loli.net/2020/04/18/rAujCUZgbMqxNYH.jpg" alt="0.jpg"></p>
<p>从 $C$ 到 $D$ 的这一段：</p>
<ul>
<li>假设以 $CD$ 为一边的另一个三角形为 $\triangle CDT_1$（显然 $T_1\in (C,D)$，$CD$ 无法再旋转）</li>
<li>不可能有以 $T_1C$ 为一边的异于 $\triangle CDT_1$ 的三角形（否则 $CT_1$ 将可以旋转）</li>
<li>可以有以 $T_1D$ 为一边的异于 $\triangle CDT_1$ 的三角形，设为 $\triangle DT_1T_2$</li>
<li>不可能有以 $T_2T_1$ 为一边的异于 $\triangle DT_1T_2$ 的三角形，但是可以有以 $DT_1$ 为一边的异于 $\triangle DT_1T_2$ 的三角形，设为 $\triangle DT_2T_3$</li>
<li>……</li>
</ul>
<p>从 $B$ 到 $D$ 这一段：不可能有以 $BC$ 为边且不同于 $\triangle BCD$ 的三角形，否则 $BC$ 将可以旋转。从 $A$ 到 $B$ 的这一段同理。</p>
<p>从 $D$ 到 $A$ 的这一段：</p>
<ul>
<li>如果有以 $AD$ 为一边的异于 $\triangle ABD$ 的三角形，设为 $\triangle ADP_1$：<ul>
<li>$P_1\in (D,n]$，那么 $AD$ 就可以旋转了</li>
<li>如果 $P_1\in [1, A-1)$ 则是合法的</li>
</ul>
</li>
<li>不可能有以 $P_1A$ 为一边异于 $\triangle AP_1D$ 的三角形，因为这样 $P_1A$ 就可以旋转了</li>
<li>可以有以 $P_1D$ 为一边的异于 $\triangle AP_1D$ 且另一顶点 $\in [1,P_1)$的三角形，设为 $\triangle DP_1P_2(P_2 \in [1,P_1))$</li>
<li>不可能有以 $P_1P_2$ 为一边的异于 $\triangle DP_1P_2$ 的三角形，但是可以有以 $DP_2$ 为一边的异于 $\triangle DP_1P_2$ 且另一顶点位于 $[1,P_2)$ 的三角形，设为 $\triangle DP_2P_3$</li>
<li>……</li>
</ul>
<p><img src="https://i.loli.net/2020/04/18/91LQVh7Tgq8PREG.jpg" alt="1.jpg"></p>
<p>综上所述，一个多边形如果无法继续旋转，那么除了 $n$ 号点以外的每个点必须直接和 $n$ 号点相连。</p>
<p>对于一个状态，发现它不直接连接 $n$ 和其它点的边会形成一个树形结构（实际上是个二叉树森林）：</p>
<p><img src="https://i.loli.net/2020/04/18/JPl9guIyODTzkfV.jpg" alt="2.jpg"></p>
<p><img src="https://i.loli.net/2020/04/18/1DrkNOBKEcub2Pp.jpg" alt="3.jpg"></p>
<p>最小的操作次数就是树上的点数（即多边形中不直接连接 $n$ 和其它点的边数）；操作的方案数也就是将树中的点排列使得祖先总是在自己之前出现的方案数。一个经典结论是这样的排列方案数为点数的阶乘除以每个点的子树大小。</p>
<p>考虑在初始状态上进行一次旋转会造成什么样的影响：</p>
<p><img src="https://i.loli.net/2020/04/18/3IOwP9UaCG6qntv.jpg" alt="4.jpg"></p>
<p>发现只有被旋转的那条边的子树大小改变了。预处理出初始状态的操作方案数，就能快速地得到旋转之后的答案。注意特判被旋转的边为根的情况。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>20200416 SCOI模拟1</title>
    <url>/2020/04/17/20200416-SCOI%E6%A8%A1%E6%8B%9F1/</url>
    <content><![CDATA[<h2 id="A-同桌与室友"><a href="#A-同桌与室友" class="headerlink" title="A - 同桌与室友"></a>A - 同桌与室友</h2><p>相当于是有一张图，边有两种，与每个点相邻的每种边至多有一条。求有多少种重标号的方案，使得重标号前后的图相同。</p>
<p>由于每个点的度数不超过 2，我们可以对连通块的形态讨论（每个连通块要么是链，要么是环）。</p>
<p><strong>记得取模</strong>。</p>
<h2 id="B-传送"><a href="#B-传送" class="headerlink" title="B - 传送"></a>B - 传送</h2><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>这是我考场上的想法。</p>
<p>一个观察是，只需要保证两个相邻的点之间的边权大于等于两个点的点权差，就能保证方案合法，因为考虑在同一条链上的三个点 $A,B,C$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dis(A,C) =& dis(A,B) + dis(B,C)\\
\ge& |a_A-a_B| + |a_B-a_C|\\
\ge& \left|\left(a_A - a_B\right) + \left(a_B - a_C\right)\right|\\
=& | a_A - a_C|
\end{aligned}</script><p>对于每个点，求出 $L_x,R_x$ 表示当 $a_x \in [L_x,R_x]$ 时存在一种合法的给 $x$ 的子树内的点赋值的方案。</p>
<p>设 $w(u,v)$ 为 $u,v$ 之间的边的边权，则有转移方程</p>
<script type="math/tex; mode=display">
\begin{gathered}
L_x = \max_{v\in son_x} \{ L_v-w(x,v)\}\\
R_x = \min_{v\in son_x} \{ R_v+w(x,v)\}
\end{gathered}</script><p>一组 $\{[l_i,r_i]\}$ 是合法的当且仅当对于所有的 $x$ 都有 $L_x \le R_x$。</p>
<p>对于 $type=1$ 的，套个二分就可以了。</p>
<p>复杂度 $O(n\log V)$，我以为能过，但是只有70分。。。:ambulance:</p>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>我们不妨带上未知数进行 dp。假设花费的代价是 $v$，发现有了 $v$ 之后 $L_x,R_x$ 只不过就是变成了 $L_x - v, R_x + v$（因为 min 和 max 函数里面每一项都是原来的值 $+v$）。</p>
<p>所以当 $type=1$ 的时候，答案就是</p>
<script type="math/tex; mode=display">
\left\lceil \frac{\max\{ \max_{i\in [1,n]}\{ L_x-R_x\},0\}}{2}\right\rceil</script><h2 id="C-生成树"><a href="#C-生成树" class="headerlink" title="C - 生成树"></a>C - 生成树</h2><p>设 $A_{i,j}$ 为一个二元生成函数，$x^ay^b(a,b\ge 0, a+b\in [0,1])$ 的系数为从 $i$ 到 $j$ 的边中选出 $a$ 条绿色边、$b$ 条蓝色边的方案数。</p>
<p>根据矩阵树定理我们知道</p>
<script type="math/tex; mode=display">
\det(L_r) = \sum_{T\text{为生成树}} \prod_{(i,j)\in T} A_{i,j}</script><p>我们只要求出 $\det(L_r)$ 的各项系数就能得到答案。</p>
<p>把 $A_{i,j}$ 的点值带入求行列式，最后再插值回去，可以做到 $O(n^5)$ 的复杂度。</p>
<p>一种实现：由于最后多项式中 $x$ 的次数至多是 $n-1$，所以可以把 $y$ 带成 $x^{n}$，避开二维插值。</p>
<p><strong>注意判掉输入的自环</strong>。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵树定理及证明</title>
    <url>/2020/04/17/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E5%8F%8A%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://oi-wiki.org/graph/matrix-tree/" target="_blank" rel="noopener">OI-wiki(没有证明)</a></li>
<li><a href="http://math.mit.edu/~levine/18.312/alg-comb-lecture-19.pdf" target="_blank" rel="noopener">通过 google search 找到的一篇资料</a></li>
</ul>
<h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><p>一个排列的逆序对数的奇偶性与（排列的长度-环数）相同。</p>
<p>证明：</p>
<p>观察 1：如果交换排列中的两个元素，逆序对数的奇偶性恰好会改变。</p>
<ul>
<li>假设交换的元素是 $i, j (i &lt; j)$</li>
<li>$i$ 左侧，$j$ 右侧的元素的贡献不会变化</li>
<li>开区间 $(i,j)$ 中的元素的贡献的奇偶性不变</li>
<li>$i,j$ 的贡献会变化 1（加 1 或者减 1）</li>
</ul>
<p>观察 2：单位排列的逆序对数为 0，是一个偶数。</p>
<p>观察 3：可以通过（排列 $P$ 的长度-环数）次“交换两个元素”的操作，将单位排列变成 $P$。</p>
<h2 id="定义们"><a href="#定义们" class="headerlink" title="定义们"></a>定义们</h2><p>定义有向图 $G$ 的以 $r$ 为根的有向生成树 (oriented spanning tree) 为：$r$ 出度为 $0$、其余点出度为 $1$ 的弱连通生成图。</p>
<p>定义有向图 $G$ 的拉普拉斯矩阵 $L$ 为 $D-A$，其中</p>
<script type="math/tex; mode=display">
D_{i,j} = \begin{cases}
\text{i 号点的出度} & i = j\\
0 & i\neq j
\end{cases}</script><p>而 $A$ 为 $G$ 的邻接矩阵（$A$ 为 01 矩阵且 $A_{i,j}$ 为 $1$ 当且仅当 $G$ 中存在一条从 $i$ 到 $j$ 的边）。</p>
<p>设 $L_r$ 为去掉 $L$ 的第 $r$ 行、第 $r$ 列之后得到的 $(n-1)\times (n-1)$ 的矩阵。</p>
<p>矩阵树定理：$G$ 的以 $r$ 为根的有向生成树个数为 $\det(L_r)$。</p>
<p>容易把矩阵树定理扩展到无向图的生成树计数。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>如果选取的根 $r \neq n$，则可以通过重标号让 $r=n$。所以下面我们只考虑 $r=n$ 的情况。</p>
<p>定义 $S_n$ 为长度为 $n$ 在所有排列构成的集合。对于一个排列 $\sigma$，定义 $\operatorname{sgn}(\sigma)$ 为 $(-1)^{\sigma \text{的逆序对个数}}$。</p>
<script type="math/tex; mode=display">
\det (L_r) = \sum_{\sigma \in S_{n-1}} \operatorname{sgn}(\sigma) L_{1,\sigma(1)} L_{2,\sigma(2)} \cdots L_{n-1,\sigma(n-1)}</script><p>考虑这个式子的组合意义：不考虑正负号，当 $\sigma(i) = i$ 的时候，$L_{i,\sigma(i)}$ 相当于选择一条从 $i$ 出发的边的方案数；当 $\sigma(i) \neq i$ 的时候，$L_{i,\sigma(i)}$ 相当于选择一条从 $i$ 到 $\sigma (i)$ 的边的方案数。注意到这也就相当于是在枚举 $n$ 点出度为 $0$、其余点出度为 $1$ 的子图。</p>
<p>我们要证明的是：在枚举 $\sigma$ 的过程中，所有是树的子图被统计到的系数都是 $1$，所有不是树的子图被统计到的系数都是 $0$。</p>
<p>注意到：由于 $\sigma$ 是一个排列，所以 $i\to \sigma(i)$ 必然形成若干个大小大于 $1$ 的环和一些 $i = \sigma(i)$ 的单点（自环）。</p>
<p>对于树：由于树无环，所以这种子图绝对不可能选择 $i\to \sigma(i)(\sigma(i)\neq i)$ 的边，所以它只会在 $\sigma = \{1,2,\cdots n-1\}$ 的时候被数到，其系数显然为 $1$。</p>
<p>对于不是树的子图：它至少包含了一个环。设子图中的环为 $C_1,C_2,\cdots C_k(k &gt; 0)$（$C_i$ 为第 $i$ 个环上的点构成的点集），设不在环上的点集为 $T$。考虑什么样的 $\sigma$ 会数到这个子图：$T$ 中的每个点 $x$ 一定都有 $\sigma(x) = x$；而对于每个 $C_i$，要么 $C_i$ 中的每个点都有 $\sigma(x) = x$，要么就用 $i\to \sigma(i)(i\neq \sigma(i))$ 这样的形式来表示出 $C_i$ 这个环。假设 $C_{i_1},C_{i_2},\cdots C_{i_l}$ 这些环上的点满足 $\sigma(x) = x$，而 $C_{j_1},C_{j_2},\cdots C_{j_m}$ 这些环是用 $i \to \sigma(i)(i\neq \sigma(i))$ 表示的，那么对应的 $\operatorname{sgn}(\sigma)$ 为（考虑前面的引理）</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\operatorname{sgn}(\sigma)\\
=& (-1)^{n-1-(|C_{i_1}|+|C_{i_2}|+\cdots +|C_{i_l}|+m)}\\
=& (-1)^{(|C_{j_1}|-1)+(|C_{j_2}|-1)+\cdots +(|C_{j_m}|-1)}\\
\end{aligned}</script><p>而 $\prod_{i=1}^{n-1} L_{i,\sigma(i)}$ 所带的系数为</p>
<script type="math/tex; mode=display">
(-1)^{|C_{j_1}| + |C_{j_2}| + \cdots + |C_{j_m}|}</script><p>注意到两者的乘积恰好为 $(-1)^m$。</p>
<p>所有可能的 $\sigma$ 的系数之和为</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \sum_{\{j_1,j_2,\cdots\}\subseteq \{1,2,\cdots k\}} (-1)^{|\{j_1,j_2,\cdots \}|}\\
= & \sum_{i=0}^{k} \binom{k}{i} (-1)^i\\
= &(1-1)^{k}
\end{aligned}</script><p>在 $k&gt;0$ 的时候这个系数为 $0$。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>这个证明的本质是：枚举所有的 $n$ 号点出度为 $0$、其余点出度为 $1$ 的子图，并说明这其中每个有环的子图贡献系数为 0，无环的子图贡献系数为 1。</p>
<p>我们可以得到一个更加一般的形式：</p>
<script type="math/tex; mode=display">
\det(L_r)=\sum_{\text{T is a oriented spanning tree rooted at r }} \prod_{\text{ j is i's father in T}} A_{i,j}</script>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3054 「HNOI2019」鱼</title>
    <url>/2020/04/16/LOJ3054-%E3%80%8CHNOI2019%E3%80%8D%E9%B1%BC/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/788299" target="_blank" rel="noopener">my AC submission</a></p>
<h2 id="关于题意的补充说明"><a href="#关于题意的补充说明" class="headerlink" title="关于题意的补充说明"></a>关于题意的补充说明</h2><ul>
<li>令 $\alpha(0\le \alpha &lt; 2\pi)$ 为 $\overrightarrow{DA}$ 逆时针旋转到 $\overrightarrow{DE}$ 经过的角度，$\beta ( 0\le \beta &lt; 2\pi )$ 为 $\overrightarrow{DA}$ 逆时针旋转到 $\overrightarrow{DF}$ 经过的角度，那么题意中对 $\angle ADE, \angle ADF$ 的限制等价于：$\frac{1}{2} \pi &lt; \alpha, \beta &lt; \frac{3}{2} \pi$。</li>
<li>可以参考我的这份<a href="https://loj.ac/submission/788307" target="_blank" rel="noopener">O(n^6)暴力</a>来确认自己没有读错题意。</li>
</ul>
<h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>枚举 $D$ 和 $A$，然后统计合法的 $B,C,E,F$ 的数量。</p>
<p>发现 $B,C$ 和 $E,F$ 是独立的，可以分别统计然后相乘。</p>
<p>统计 $B,C$ 的数量：某一对 $B,C$ 合法的充要条件是 $BC$ 的中垂线与 $AD$ 重合且交点（也就是 $BC$ 的中点）在线段 $AD$ 上（不含端点）。可以预先枚举所有的 $BC$，求出中垂线及中点并排好序，枚举 $AD$ 的时候直接在序列上二分即可。</p>
<p>统计 $E,F$ 的数量：枚举 $D$ 之后对其它点进行极角排序，扫描线维护。</p>
<p>总时间复杂度 $O(n^2 \log n)$。</p>
<h2 id="实现细节：直线方程的处理"><a href="#实现细节：直线方程的处理" class="headerlink" title="实现细节：直线方程的处理"></a>实现细节：直线方程的处理</h2><p>用 $Ax + Bx + C = 0(A,B,C \in \mathbb{Z})$ 的形式来表示直线。</p>
<h3 id="求-BC-的中垂线"><a href="#求-BC-的中垂线" class="headerlink" title="求 $BC$ 的中垂线"></a>求 $BC$ 的中垂线</h3><p>对于一个在 $BC$ 中垂线上的点 $P$，它满足</p>
<script type="math/tex; mode=display">
\begin{gathered}
(\overrightarrow{P} - \overrightarrow{B})\cdot (\overrightarrow{C} - \overrightarrow{B}) = \frac{1}{2}(\overrightarrow{C} - \overrightarrow{B})\cdot (\overrightarrow{C} - \overrightarrow{B})\\
2\overrightarrow{P}\cdot (\overrightarrow{C}-\overrightarrow{B}) - (\overrightarrow{C}-\overrightarrow{B}) \cdot (\overrightarrow{C} + \overrightarrow{B}) = 0
\end{gathered}</script><p>带入点乘定义式即可。</p>
<h3 id="求直线-AD"><a href="#求直线-AD" class="headerlink" title="求直线 $AD$"></a>求直线 $AD$</h3><p>对于一个直线 $AD$ 上的点 $P$，它满足</p>
<script type="math/tex; mode=display">
\begin{gathered}
(\overrightarrow{P} - \overrightarrow{A}) \times (\overrightarrow{D} - \overrightarrow{A}) = 0\\
\overrightarrow{P} \times (\overrightarrow{D} - \overrightarrow{A}) - \overrightarrow{A} \times (\overrightarrow{D} - \overrightarrow{A}) = 0
\end{gathered}</script><p>带入叉乘的定义式即可。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3045 「ZJOI2019」开关</title>
    <url>/2020/04/11/LOJ3045-%E3%80%8CZJOI2019%E3%80%8D%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<ul>
<li><a href="https://loj.ac/submission/784772" target="_blank" rel="noopener">my submission on loj.ac</a></li>
<li>参考了 <a href="https://www.cnblogs.com/zhoushuyu/p/10687696.html" target="_blank" rel="noopener">zsy的博客</a></li>
</ul>
<p>设</p>
<script type="math/tex; mode=display">
\begin{gathered}
A(x) = \sum_{i=0}^\infty [\text{操作 i 次之后状态为 s 的概率}]\frac{x^i}{i!}\\
B(x) = \sum_{i=0}^\infty [\text{操作 i 次之后状态为 000.....00 的概率}]\frac{x^i}{i!}
\end{gathered}</script><p>那么（可以类比奇自然数和偶自然数的 EGF）</p>
<script type="math/tex; mode=display">
\begin{gathered}
A(x) &=& \prod_{i=1}^n \frac{e^{\frac{p_i}{P}x}+(-1)^{s_i}e^{-\frac{p_i}{P}x}}{2}\\
B(x) &=& \prod_{i=1}^n \frac{e^{\frac{p_i}{P}x}+e^{-\frac{p_i}{P}x}}{2}
\end{gathered}</script><p>$A(x)$ 和 $B(x)$ 都可以表示为 $\sum_{i=-P}^P a_i e^{\frac{i}{P}x}$ 的形式。</p>
<p>设 $A(x),B(x)$ 对应的 OGF 为 $F(x),G(x)$。（$e^{cx}$ 对应的 OGF 为 $\sum_{i=0}^\infty (cx)^i = \frac{1}{1-cx}$）</p>
<p>设</p>
<script type="math/tex; mode=display">
H(x) = \sum_{i=0}^\infty [\text{操作 i 次之后第一次达到 s 的概率}]\frac{x^i}{i!}</script><p>则</p>
<script type="math/tex; mode=display">
\begin{gathered}
H(x) G(x) = F(x)\\
H(x) = \frac{F(x)}{G(x)}
\end{gathered}</script><p>答案是 $H(1)’ = \frac{F’(1)G(1) - F(1)G’(1)}{G^2(1)}$。</p>
<p>但是，因为 $\frac{1}{1-\frac{P}{P}x}$ 这一项在 $x=1$ 的时候没有定义，所以不能直接算。</p>
<p>对 $H(x)$ 上下同时乘以 $\prod_{i=-P}^P(1-\frac{i}{P}x)$，这时候的 $F(x),G(x)$ 都是这样的形式：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n a_i \prod_{j\neq i} (1-\frac{j}{P})</script><p>此时的 $F(x)$ 对应的 $F(1),F’(1)$ 为（由于 $x=1$，所以所有系数里面有 $(1-\frac{P}{P}x)$ 的项都没了）：</p>
<script type="math/tex; mode=display">
\begin{gathered}
F(1) = a_P\prod_{i\neq P} (1-\frac{i}{P})\\
F'(1) = \sum_{i} a_i \sum_{j\neq i} \left(-\frac{j}{P}\right) \prod_{k\neq i,k\neq j} \left(1-\frac{k}{P}x\right)\\
= \sum_{i\neq P} a_i (-1) \prod_{k\neq i, k\neq P} \left(1-\frac{k}{P}\right) + a_P \sum_{j\neq P} \left(-\frac{j}{P}\right)\prod_{k\neq P,k\neq j} \left(1-\frac{k}{P}\right)\\
= - \left(\prod_{k\neq P} ( 1-\frac{k}{P}) \right) \cdot \left( \sum_{i\neq P} \frac{1}{1-\frac{i}{P}} \left(a_i + a_P \cdot \frac{i}{P}\right)\right)
\end{gathered}</script><p>$G(1),G’(1)$ 的计算同理。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3044 「ZJOI2019」Minimax 搜索</title>
    <url>/2020/04/10/LOJ3044-%E3%80%8CZJOI2019%E3%80%8DMinimax-%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<ul>
<li><a href="https://loj.ac/submission/784365" target="_blank" rel="noopener">my AC submission on loj.ac</a></li>
<li><a href="https://loj.ac/submission/784068" target="_blank" rel="noopener">my O((R-L)n) solution on loj.ac</a></li>
<li>参考了<a href="https://memset0.cn/luogu5281" target="_blank" rel="noopener">memset0的博客</a>和<a href="https://www.cnblogs.com/suika/p/10725476.html" target="_blank" rel="noopener">fcwww的博客</a></li>
</ul>
<p>设 $W$ 为初始根节点的权值。由于每个叶子的权值互不相同，所以 $W$ 来自的叶子结点唯一。</p>
<p>改变 $W$ 的策略有以下三种：</p>
<ol>
<li>直接改变 $W$ 这个叶子的权值</li>
<li>不改变 $W$ 这个叶子的权值，把若干小于 $W$ 的叶子的权值改得大于 $W$，使得根节点的权值变得大于 $W$</li>
<li>不改变 $W$ 这个叶子的权值，把若干大于 $W$ 的叶子的权值改得小于 $W$，使得根节点的权值变得小于 $W$</li>
</ol>
<p>在可以采用第一种策略的时候 Cedyks 一定会采用第一种策略，因为把 $W$ 改成 $W-1$ 或者 $W+1$ 的花费仅为 $1$。所以，任何的包含 $W$ 这个叶子的集合，其稳定度都为 $1$。接下来我们只考虑不包含 $W$ 的集合。</p>
<p>如果采用第二种策略，最优的方法一定是把若干个小于 $W$ 的叶子改成 $W+1$；如果采用第三种策略，最优的方法一定是把若干个大于 $W$ 的叶子改成 $W-1$。（你可以把叶子结点的权值根据与 $W$ 的大小关系替换成 -1/0/1 然后 dp 以判断根节点的值是否被改变了）</p>
<p>差分一下答案，转化成对于 $k\in [L-1,\min\{n-1,R\}]$，求稳定度小于等于 $k$ 的子集数量。由于子集总数很好求，可以转化成有多少个集合 $S$ 满足：设 $T= S\cap ([W+1-k,W)\cup (W,W-1+k])$，将 $T$ 中所有小于 $W$ 的叶子的权值改成 $W+1$，所有大于 $W$ 的叶子改成 $W-1$，根节点的权值没有改变；也就是 $S$ 的稳定度大于 $k$。</p>
<p>为了式子推起来更简洁，把方案数转化成概率，即：除 $W$ 以外的每个叶子均有 $\frac{1}{2}$ 的概率 $\in S$，有 $\frac{1}{2}$ 的概率 $\notin S$，求根节点权值被改变了的概率。</p>
<p>显然第二种策略和第三种策略牵涉到的点是独立的，我们可以分别计算这两种策略无法改变根节点权值的概率，最后乘起来。</p>
<p>两者的计算方式是相似的，下面以第二种策略为例。</p>
<p>设 $f_u$ 为：将集合内所有在 $\left[W+1-k,W\right)$ 中的点改成 $W+1$，可以使得 $w_u &gt; W$ 的概率。</p>
<p>对于叶子结点，如果它在 $\left[W+1-k,W\right)$ 内，那么 $f_u= \frac{1}{2}$；否则 $f_u = [u&gt;W]$。</p>
<p>对于非叶子结点有</p>
<script type="math/tex; mode=display">
\begin{gathered}
f_u = \begin{cases}
\prod_{x\in son_u} f_v & 2\mid dep_u\\
1- \prod_{x\in son_u} (1-f_v) & 2\nmid dep_u
\end{cases}
\end{gathered}</script><p>设</p>
<script type="math/tex; mode=display">
\begin{gathered}
f'_u = \begin{cases}
f_u & 2 \mid dep_u\\
1-f_u & 2 \nmid dep_u
\end{cases}
\end{gathered}</script><p>那么有转移方程</p>
<script type="math/tex; mode=display">
f'_u = \prod_{v\in son_u} (1-f'_v)</script><p>这样每个点的转移方程就是一样的了。</p>
<p>从小到大依次枚举 $k$，$k$ 每次变化的时候只有 $O(1)$ 个叶子的 $f’_u$ 会改变，用动态 dp 维护即可。</p>
<p>具体地，设 $g_u = \prod_{v\in son_u, v\neq heavy_son_u} (1-f’_v)$，那么 $f’_u = (1-f’_{heavy_son_u}) g_u = - g_u \cdot f’_{heavy_son_u} + g_u$，如果把重儿子的 dp 值当成未知数则这是一个 $kx+b$ 的形式，可以区间合并（也就意味着可以用任意的数据结构维护）。</p>
<p>时间复杂度 $O(n\log^2 n)$，瓶颈是在修改 $g_u$ 的时候需要求 $O(\log n)$ 次 $1-f’_v$ 的逆元。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3093 「BJOI2019」光线</title>
    <url>/2020/04/09/LOJ3093-%E3%80%8CBJOI2019%E3%80%8D%E5%85%89%E7%BA%BF/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/783696" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<p>设 $f_i$ 表示从第 $i-1$ 块玻璃和第 $i$ 块玻璃之间向第 $n$ 块玻璃的方向射出了一束大小为 $1$ 的光线，最终能穿过第 $n$ 层玻璃的光的数量。特别地，$f_{n+1} = 1$，你可以想象成在第 $n$ 块玻璃的后面还有一块反射率为 $0\%$、透光率为 $100\%$ 的玻璃。</p>
<p>下文中的 $a_i,b_i$ 为原题中的 $a_i\%, b_i\%$。</p>
<p>根据定义有</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_i &= a_i f_{i+1} + b_i \left( b_{i-1}f_i + a_{i-1}b_{i-2}f_{i-1} + a_{i-1}a_{i-2}b_{i-3}f_{i-2}+\cdots \right)
\end{aligned}</script><p>移项得</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{i+1} &= \frac{1}{a_i} \left( f_i - b_i \left( b_{i-1}f_i + a_{i-1}b_{i-2}f_{i-1} + a_{i-1}a_{i-2}b_{i-3}f_{i-2}+\cdots \right) \right)
\end{aligned}</script><p>这样等号右边的项下标都小于等于 $i$。</p>
<p>设 $f_1 = x$，则所有的 $f_i$ 都可以用上面的递推式表示成 $kx$ 的形式。最后由 $f_{n+1} = 1$ 就可以解出 $x$ 的取值。</p>
<p>优化递推：设 $s_i = b_{i-1}f_i + a_{i-1}b_{i-2}f_{i-1} + a_{i-1}a_{i-2}b_{i-3}f_{i-2}+\cdots$，那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
s_1 &= 0\\
s_i &= a_{i-1}s_{i-1} + b_{i-1}f_i\\
f_{i+1} &= \frac{1}{a_i}\left(f_i - b_is_i\right)
\end{aligned}</script><p>时间复杂度为 $O(n)$ 或者 $O(n\log n)$，瓶颈为求逆元。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3090 「BJOI2019」勘破神机</title>
    <url>/2020/04/09/LOJ3090-%E3%80%8CBJOI2019%E3%80%8D%E5%8B%98%E7%A0%B4%E7%A5%9E%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/783396" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<h3 id="m-2"><a href="#m-2" class="headerlink" title="$m=2$"></a>$m=2$</h3><p>设填满 $2\times n$ 的方案数为 $f_n$，则 $F(n,k) = \binom {f_n}{k}$，而 $\binom{f_n}{k}$ 可以展开为一个关于 $f_n$ 的 $k$ 次多项式。故而问题转化为了：对于每个 $j\in [0,k]$，求 $\sum_{n=l}^r f_n^j$ 。</p>
<p>显然 $f_n = f_{n-1}+f_{n-2}$（考虑最后一列填两个横着的还是填一个竖着的）。</p>
<p>该递推式的特征根为 $x_1 = \frac{1+\sqrt 5}{2}, x_2 = \frac{1-\sqrt 5}{2}$，由 $f_0=1,f_1=1$ 解得通项公式为 $f_n = \frac{5+\sqrt 5}{10}x_1^n +\frac{5-\sqrt 5}{10} x_2^n$。</p>
<p>令 $A=x_1,B=x_2,p=\frac{5+\sqrt 5}{10},q=\frac{5-\sqrt 5}{10}$，则 $f_n = pA^n + qB^n$。</p>
<p>而我们要求的是</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{n=l}^r f_n^j\\
=& \sum_{n=l}^r (pA^n + qB^n)^j\\
=& \sum_{n=l}^r \sum_{i=0}^j \binom{j}{i} (pA^n)^i (qB^n)^{j-i}\\
=& \sum_{i=0}^j \binom{j}{i} p^i q^{j-i} \sum_{n=l}^r (A^iB^{j-i})^n
\end{aligned}</script><p>最后面是个等比数列求和，可以分治求解。</p>
<h3 id="m-3"><a href="#m-3" class="headerlink" title="$m=3$"></a>$m=3$</h3><p>设填满一个 $3\times n$ 的网格的方案数是 $f_n$，填满一个 $3\times n + 2$ 的网格的方案数为 $g_n$。其中，$3\times n + 2$ 的网格定义如下：</p>
<p><img src="https://i.loli.net/2020/04/09/XhTJzksyiePYjmB.png" alt="1.png"></p>
<p>枚举 $3\times n$ 的网格中最靠右的颗粒进行讨论，得到 $f_n = f_{n-2} + 2g_{n-2}$</p>
<p><img src="https://i.loli.net/2020/04/09/mqu8jTOraUHvS6Y.png" alt="0.png"></p>
<p>同理得到 $g_n = f_{n} + g_{n-2}$</p>
<p><img src="https://i.loli.net/2020/04/09/REkMnL24aOFHpvB.png" alt="2.png"></p>
<p>将 $g$ 的递推式展开得到 $g_n = f_n + f_{n-2} + f_{n-4} + \cdots + f_0$</p>
<p>对于任意的 $2\nmid n$ 显然有 $f_n = g_n = 0$。不妨设 $F_n = f_{2n}, l’=\lceil\frac{l}{2}\rceil, r’=\lfloor\frac{r}{2}\rfloor$。与 $m=2$ 的方法同理，我们只要求出 $\sum_{n=l’}^{r’} F_n^i$ 即可。</p>
<script type="math/tex; mode=display">
\begin{aligned}
F_n & = 3F_{n-1} + 2\sum_{i=0}^{n-2} F_i\\
F_n - F_{n-1} & = (3F_{n-1} + 2F_{n-2}) - (3F_{n-2})\\
& = 3F_{n-1}-F_{n-2}\\
\therefore F_n &= 4F_{n-1}- F_{n-2}
\end{aligned}</script><p>特征根为 $x_1 = 2+\sqrt 3, x_2 = 2-\sqrt 3$，带入 $F_0 = 1, F_1 = 3$ 得 $F_n = \frac{3+\sqrt 3}{6} x_1^n + \frac{3-\sqrt 3}{6} x_2^n$，和 $m=2$ 的情况类似做就可以了。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>弦图、完美消除序列与MCS算法</title>
    <url>/2020/04/05/%E5%BC%A6%E5%9B%BE%E3%80%81%E5%AE%8C%E7%BE%8E%E6%B6%88%E9%99%A4%E5%BA%8F%E5%88%97%E4%B8%8EMCS%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cs.cmu.edu/~janh/courses/411/18/lec/03-chordal-mcs.pdf" target="_blank" rel="noopener">一份通过google search找到的资料</a></li>
<li><a href="https://oi-wiki.org/graph/chord/#_8" target="_blank" rel="noopener">OI-wiki</a></li>
</ul>
<h2 id="定义们"><a href="#定义们" class="headerlink" title="定义们"></a>定义们</h2><p>记 $N(u)$ 为 $u$ 的所有的邻居构成的集合。对于一个点集 $S$，定义 $N(S)$ 为 $\{ x\mid \forall v\in S, x\in N(v)\}$。</p>
<p><strong>弦图 (chordal graph)</strong>：满足任意一个长度大于 3 的环都有弦的图。</p>
<p><strong>单纯点 (simplicial vertex)</strong>：如果 $N(u)$ 的导出子图为团，就称 $u$ 为单纯点。</p>
<p><strong>完美消除序列 (perfect elimination ordering)</strong>：称 $G$ 的结点的一个排列 $\{v_1,v_2,\cdots v_n\}$ 为 $G$ 的完美消除序列，当且仅当对于每一个 $i$ ，$v_i$ 在 $v_i,v_{i+1},\cdots v_n$ 的导出子图中是单纯点。</p>
<p>下文中，称完美消除序列的逆序为<strong>单纯消除序列 (simplicial elimination ordering)</strong>（这个中文名称是我编的，因为没有在网上找到相应的中文资料），也就是满足 $v_i$ 在 $v_1,v_2,\cdots v_i$ 的导出子图中为单纯点的排列。</p>
<h2 id="一个定理"><a href="#一个定理" class="headerlink" title="一个定理"></a>一个定理</h2><p>引理 1：弦图的任意导出子图也是弦图。</p>
<p>引理 2：任何弦图都至少有一个单纯点；不是完全图的弦图至少有两个不相邻的单纯点。</p>
<p>定理：$G$ 是弦图当且仅当 $G$ 存在完美消除序列。</p>
<p><a href="https://oi-wiki.org/graph/chord/" target="_blank" rel="noopener">证明可参考 OI-wiki</a></p>
<h2 id="完美消除序列判定"><a href="#完美消除序列判定" class="headerlink" title="完美消除序列判定"></a>完美消除序列判定</h2><p>判断一个序列是否为完美消除序列。</p>
<p>设 $v_i$ 在 $v_{i+1},v_{i+2}\cdots v_n$ 中相邻的点按照它们在序列中出现的顺序依次为 $v_{c_1},v_{c_2},\cdots v_{c_k}$，只需要判断 $v_{c_1}$ 与其它点是否相邻即可。</p>
<p>正确性证明：假设已知 $v_{i+1},v_{i+2},\cdots v_n$ 是合法的完美消除序列的后缀，那么由于 $v_{c_1}$ 在 $\{v_{c_1},v_{c_1+1},\cdots v_n\}$ 的导出子图中为单纯点，如果 $v_{c_1}$ 与 $v_{c_2},v_{c_3},\cdots v_{c_k}$ 都相邻，那么 $v_{c_2},v_{c_3},\cdots v_{c_k}$ 一定形成团。</p>
<h2 id="最大势算法"><a href="#最大势算法" class="headerlink" title="最大势算法"></a>最大势算法</h2><p>又称为<strong>maximum cardinality search algorithm</strong>、<strong>MCS algorithm</strong>。是用来求完美消除序列的一种算法。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>设图 $G$ 的点集为 $V$；用 $weight(u)$ 表示点 $u$ 的权重。</p>
<ol>
<li>初始化 $W$ 为 $V$，并将 $V$ 中所有点的权重置为 $0$</li>
<li>对 $i=1,2,\cdots n$ ，执行以下过程<ol>
<li>令 $u$ 为此时 $W$ 中权重最大的点</li>
<li>令 $v_i = u$</li>
<li>将 $u$ 的所有邻居的权重增加 $1$</li>
<li>将 $u$ 从 $W$ 中删除</li>
</ol>
</li>
<li>返回 $\{v_1,v_2,\cdots v_n\}$</li>
</ol>
<p>用链表实现可以做到 $O(n+m)$ 的复杂度。</p>
<p>可以证明，当 $G$ 为弦图时，MCS 算法返回的序列是 $G$ 的单纯消除序列。</p>
<h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>令 $V_i = \{v_,v_2,\cdots v_i\}$ ；令 $W_i$ 为第 2 步进行了 $i$ 次之后的 $W$ ；令 $weight_i(v)$ 表示第 2 步进行了 $i$ 次之后 $v$ 点的权重；令 $a \prec b$ 表示在返回的序列中 $a$ 在 $b$ 的前面。</p>
<p>我们通过证明以下循环不变式来证明命题：</p>
<ol>
<li>$v_i$ 在 $V_i$ 的导出子图中为单纯点</li>
<li>令 $S$ 为 $V$ 的一个子集，其中的每个点 $v_x$ 都满足 $v_x$ 在 $V_x$ 的导出子图中为单纯点；对于两个点 $a,v_i \in N(S) - S$ ，如果 $a\prec v_i$ 且 $N(S)-S$ 中存在一条从 $a$ 到 $v_i$ 的路径，那么 $N(S)-S$ 中存在一条从从 $a$ 到 $v_i$ 且经过的所有点都满足 $\prec v_i$ 的路径</li>
</ol>
<h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明 1."></a>证明 1.</h4><p>考虑反证：假设 $v_i$ 在 $V_i$ 的导出子图中不是单纯点，那么必定存在 $v_j,v_k\in N(v_i)\cap V_{i-1}$ 满足 $j&lt; k &lt; i, v_k\notin N(v_j)$。</p>
<h5 id="case-1-对于所有的-v-j-v-k-in-N-v-i-cap-V-i-1-v-k-notin-N-v-j-，都有-V-i-1-cap-N-v-i-cap-N-v-j-cap-N-v-k-varnothing"><a href="#case-1-对于所有的-v-j-v-k-in-N-v-i-cap-V-i-1-v-k-notin-N-v-j-，都有-V-i-1-cap-N-v-i-cap-N-v-j-cap-N-v-k-varnothing" class="headerlink" title="case 1: 对于所有的 $v_j,v_k\in N(v_i)\cap V_{i-1}, v_k \notin N(v_j)$，都有 $V_{i-1}\cap N(v_i)\cap N(v_j) \cap N(v_k) = \varnothing$"></a>case 1: 对于所有的 $v_j,v_k\in N(v_i)\cap V_{i-1}, v_k \notin N(v_j)$，都有 $V_{i-1}\cap N(v_i)\cap N(v_j) \cap N(v_k) = \varnothing$</h5><p>对于连通图 $G$ ，我们可以归纳地证明 $V_i$ 都是连通的。而 $N(v_i)$ 中的点显然在 $G$ 的同一个连通块中，所以 $N(v_i)\cap V_{i-1}$ 中的点在 $V_{i-1}$ 的导出子图中是连通的。</p>
<p>找出一对 $V_{i-1}$ 中的 $v_j,v_k$ 使其满足 $v_k \notin N(v_j)$ 且它们在 $V_{i-1}$ 的导出子图中的最短路最短。由于 $v_k \notin N(v_j)$ ，所以最短路的点数大于 2（含 $v_j,v_k$）。</p>
<p>那么最短路上的每个点一定都和 $v_i$ 直接有边相连（如果没有加额外的边则不符合弦图的定义；如果是加的其它的边则不符合最短路的定义）：</p>
<ul>
<li>如果最短路的长度大于 3，那么从这条最短路上随便选取连续的三个点，把第一个点和第三个点作为 $v_j,v_k$，就能得到更短的最短路</li>
<li>如果最短路的长度等于 3，那么最短路上的第二个点属于集合 $V_{i-1}\cap N(v_i) \cap N(v_j) \cap N(v_k)$，与 $V_{i-1}\cap N(v_i)\cap N(v_j) \cap N(v_k) = \varnothing$ 矛盾。</li>
</ul>
<h5 id="case-2-存在-v-j-v-k-in-V-i-1-cap-N-v-i-v-k-notin-N-v-j-满足-V-i-1-cap-N-v-j-cap-N-v-k-cap-N-v-i-neq-varnothing"><a href="#case-2-存在-v-j-v-k-in-V-i-1-cap-N-v-i-v-k-notin-N-v-j-满足-V-i-1-cap-N-v-j-cap-N-v-k-cap-N-v-i-neq-varnothing" class="headerlink" title="case 2: 存在 $v_j,v_k\in V_{i-1} \cap N(v_i), v_k \notin N(v_j)$ 满足 $V_{i-1} \cap N(v_j)\cap N(v_k) \cap N(v_i) \neq \varnothing$"></a>case 2: 存在 $v_j,v_k\in V_{i-1} \cap N(v_i), v_k \notin N(v_j)$ 满足 $V_{i-1} \cap N(v_j)\cap N(v_k) \cap N(v_i) \neq \varnothing$</h5><p>令 $S$ 为满足 $v_i,v_j,v_k\in N(S)-S$ 的仅由 $V_{i-1}$ 中的点构成的集合（显然不为空集的 $S$ 一定存在，并且由归纳假设我们知道 $S$ 中的每个点 $v_x$ 都满足 $v_x$ 在 $V_x$ 的导出子图中为单纯点）。那么 $v_j \to v_i \to v_k$ 是 $N(S)-S$ 中的一条路径，所以一定存在一条 $N(S)-S$ 中的路径 $P=\{v_j = x_0 \to x_1 \to x_2 \cdots x_{m-1} \to x_m = v_k\}$，路径上的每个点都满足 $\prec v_i$（应用不变式2.，注意这里与不变式中的形式不完全一样）。在所有可能的四元组 $(v_j,v_k,S,P)$ 中，我们选择一个 $|S|$ 最大的；如果有两个 $|S|$ 相同的，我们选择 $P$ 的长度更短的。如此，$v_i,v_j=x_0,x_1,\cdots x_m=v_k,v_i$ 将会是一个长度大于 3 的环。根据弦图的定义这个环上一定有弦：</p>
<ul>
<li>如果弦为 $(x_a,x_b)$，其中 $a+1&lt;b$，那么 $P$ 可以更短</li>
<li>如果弦为 $(x_a,v_i)$，其中 $0&lt;a&lt;m-1$，那么令 $v_j=x_a,P=\{v_j=x_a\to x_{a+1}\cdots x_{m-1}\to x_m=v_k\}$ 将会使 $P$ 更短；弦为 $(x_a,v_i), 1 &lt; a &lt; m$ 同理</li>
<li>否则，$m=2$ 且弦为 $(x_1,v_i)$ ，但是显然此时 $S\cup \{x_1\}$ 是一个更大的满足 $v_i,v_j,v_k \in N(S)-S$ 且每个点都属于 $V_{i-1}$ 的点集。</li>
</ul>
<h4 id="证明-2"><a href="#证明-2" class="headerlink" title="证明 2."></a>证明 2.</h4><p>如果 $a\in N(v_i)$ ，证毕。接下来考虑 $a\notin N(v_i)$ 的情况。</p>
<p>如果存在一个 $b\in (V_{i-1}-S) \cap N(v_i)$，那么对于每个 $s\in S$：</p>
<ul>
<li>若 $s\prec v_i$，则因为 $b,s\in N(v_i)$，在 $V_i$ 的导出子图中我们可以推出 $b,s$ 相邻，所以 $G$ 中 $b,s$ 相邻；</li>
<li>若 $a\prec v_i\prec s$，由于 $a,v_i\in N(s)$，在 $V_s$ 的导出子图中可以推出 $a\in N(v_i)$，矛盾</li>
</ul>
<p>所以一定有 $b\in N(S)-S$，由归纳假设知 $N(S)-S$ 中存在一条从 $a$ 到 $b$ 的只经过 $\prec \max\{a,b\}$ 的点的路径，在这条路径后面加上点 $v_i$ 即得证。</p>
<p>否则 $N(v_i) \cap (V_{i-1}-S)=\varnothing$，所以 $weight_{i-1}(v_i) = \left|S\cap V_{i-1} \right|$。由于 $N(S)-S$ 中存在一条从 $a$ 到 $v_i$ 的路径，这段路径上一定存在两个相邻的点 $c,d$，满足 $c\prec v_i\prec d$（因为从 $v_i$ 出发的第一个点一定 $\succ v_i$，而 $a\prec v_i$），于是推出 $weight_{i-1}(d) \ge |S\cap V_{i-1}|+1$（+1是因为 $c\in N(d),c\prec v_i$），这和 $weight_{i-1}(v_i)$ 为 $weight_{i-1}$ 的最大值矛盾。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ2719 「NOI2018」冒泡排序</title>
    <url>/2020/04/03/LOJ2719-%E3%80%8CNOI2018%E3%80%8D%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><a href="https://loj.ac/submission/779435" target="_blank" rel="noopener">my submission on loj.ac</a></p>
<p>一个排列 $P$ 的冒泡排序交换次数达到下界当且仅当：对于某个位置 $i$ ，在它左边的、比 $P_i$ 大的数的个数不能超过 $\max\{0, i-P_i\}$ 个。</p>
<p>这个条件也等价于：</p>
<ul>
<li>对于 $P_i\le i$ 的元素，它的右侧至少有 $(n-P_i) - (i-P_i) = n-i$ 个比它大的元素，也就是说它是后缀最小值</li>
<li>对于 $P_i \ge i$ 的元素，它是前缀最大值</li>
</ul>
<p>此外一个观察是，对于任意的一个排列，除了 $P_i=i$ 的元素之外，不会有元素既是前缀最大值又是后缀最小值（因为既是前缀最大值又是后缀最小值也就意味着左边有 $P_i-1$ 个比它小的且右边有 $n-P_i$ 个比它大的）。</p>
<p>对于一个冒泡排序交换次数达到下界的排列 $P$ ，考虑把它的所有的前缀最大值都抠掉之后的序列：</p>
<ul>
<li>这些剩下的元素不是前缀最大值，所以它们一定满足 $P_i &lt; i$ ，也就是意味着它们一定是后缀最小值</li>
<li>所以，不是前缀最大值的元素一定是升序排列的</li>
<li>这也就意味着，只要知道了前缀最大值，就能够唯一地确定一个可能合法的排列 $P$</li>
<li>所以只需要对合法的前缀最大值序列计数就可以了</li>
</ul>
<p>一个前缀最大值序列 $\{ M_i = \max_{j\le i} \{P_j\} \}$ 合法当且仅当 $M_{i-1}\le M_i \wedge M_i\ge i$ ：</p>
<ul>
<li>必要性：因为除了 $P_i = i$ 的元素之外不会有元素同时是前缀最大值和后缀最小值，故而是前缀最大值的元素一定都满足 $P_i \ge i$，所以必须有 $M_i \ge i$</li>
<li>充分性：<ul>
<li>对于任意排列，是前缀最大值的元素都满足 $P_i \ge i$ ，满足 $P_i\ge i$ 必然是前缀最大值（左边的空位比小于它的数少）</li>
<li>将不是前缀最大值的位置升序填入之后，这些位置必然满足 $P_i &lt; i$ （因为 $i$ 左边的空位置比小于 $i$ 的数少）；$P_i &lt; i$ 的位置必然是后缀最小值（大于它的数的数量超过了它右边的空位的数量）</li>
</ul>
</li>
</ul>
<p>故而只要统计满足 $M_i \ge i, M_{i-1} \le M_i$ 的 $\{M_i\}$ 的数量即可。</p>
<p>考虑折线模型。例如，对于排列 $\{2,3,1,5,4\}$ ，它前缀最大值序列对应到的折线是这样的：</p>
<p><img src="https://i.loli.net/2020/04/03/NazDKZ7oySBChLT.png" alt="0.PNG"></p>
<p>发现本质上就是一条从 $(0,1)$ 到 $(n,n)$ 且不经过直线 $y=x-1$ 的折线。</p>
<p>回到原题。设 $ans(x,y)$ 表示从 $(x,y)$ 出发走到 $(n,n)$ 不经过 $y=x-1$ 的方案数，也就是$\binom{2n-x-y}{n-x} - \binom{2n-x-y}{n+1-x}$。我们枚举排列 $p$ 与输入给出的 $q$ 第一个不同的位置 $i$ ，分以下几种情况讨论（设 $mx=\max_{j &lt; i} \{ q_j \}$）：</p>
<ul>
<li>$q$ 的长度为 $i-1$ 的前缀不合法：必然也不存在合法的 $p$ ，所以对答案的贡献是 $0$</li>
<li>$q$ 的长度为 $i-1$ 的前缀合法：<ul>
<li>$q_i &gt; mx$<ul>
<li>由于要求 $p_i &gt; q_i$ ，所以 $p_i$ 也必然是个前缀最大值，所以方案数是 $ans(i-1,q_i + 1)$</li>
</ul>
</li>
<li>$q_i &lt; mx$<ul>
<li>$p_i &gt; mx$ ：此时方案数是 $ans(i-1,mx+1)$</li>
<li>$p_i &lt; mx$ ：将不是前缀最大值的数依次升序填入不是前缀最大值的位置，如果到 $i$ 这个位置，该填的数大于 $q_i$ ，这种情况就对答案产生 $ans(i,mx)$ 的贡献；否则贡献为 $0$ 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>预处理阶乘及其逆元就可以在 $O(1)$ 的时间内统计 $i$ 的贡献。总时间复杂度 $O(n)$ 。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分基础：极限、求导、导数的应用、积分</title>
    <url>/2020/04/02/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%9E%81%E9%99%90%E3%80%81%E6%B1%82%E5%AF%BC%E3%80%81%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%81%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<p>以下为我在校内讲课的课件。主要的参考资料为 James Stewart Calculus, 7th edition ，课件中的大部分的图片为这本书（6th or 7th edition）的截图，少部分图片来自维基百科（来自维基百科的图片均已在文中注明）。</p>
<p>错误可能比较多，欢迎指出。</p>
<p><a href="https://drive.google.com/open?id=1SyrqVCko7zbdFzfV_qOjDw4n70wlIzi6" target="_blank" rel="noopener">链接：在google drive中查看</a></p>
<div class="pdf" target="/files/calculus_is_gu-ing.pdf" height=""></div>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAcademy Round #35 Counting Quests</title>
    <url>/2020/03/30/CSAcademy-Round-35-Counting-Quests/</url>
    <content><![CDATA[<ul>
<li><a href="https://csacademy.com/contest/round-35/task/counting-quests/" target="_blank" rel="noopener">link to the problem</a></li>
<li><a href="https://csacademy.com/submission/2707618/" target="_blank" rel="noopener">my submission</a></li>
</ul>
<p>对于一个序列和一个询问集合，设 $S_i$ 为包含了 $i$ 这个位置的询问的集合。一个询问集合合法当且仅当 $S_i$ 互不相同。</p>
<p>性质 1 ：如果 $a&lt;b&lt;c&lt;d, S_a=S_c, S_b=S_d$，那么 $S_a=S_b=S_c=S_d$ 。</p>
<p>证明：包含了 $a$ 和 $c$ 的询问必然包含 $b$ ，而由于 $S_b=S_d$ ，所以也就必然包含了 $d$ 。其它情况同理。</p>
<p>性质 2 ：假设 $a$ 是序列中第一个其 $S_i$ 至少出现了两次的元素，$b$ 是 $S_a$ 最后一次出现的位置，那么询问集合中不存在区间与 $[a,b]$ 有交且不互相包含。</p>
<p>证明：对于一个与 $[a,b]$ 相交且不互相包含的区间，这个区间必然只包含了 $a,b$ 中的一个，于是推出 $S_a\neq S_b$ ，矛盾。</p>
<p>统计不合法的询问集合数量。对于一不合法的询问集合和一个序列，我们对 $\{S_i\}$ 进行如下的操作：</p>
<ol>
<li>找到第一个出现了至少两次的 $S_i$ ，然后找到它最后一次出现的位置，设这两个位置是 $l,r$</li>
<li>将 $[l,r]$ 区间内的元素删掉，替换为一个 $S_i = S_l$ 的元素，并重复 1.</li>
</ol>
<p>显然不会有与被删掉的区间有交但不包含的询问；所以确定“没有被包含于删掉了的区间的询问”的方案数就是把被删掉的区间换成一个点之后的合法的询问集合数；被包含在删除了的区间内部的询问可以任意地确定。</p>
<p>设表示 $f_i$ 序列长度为 $i$ 时，合法的询问集合的数量；设 $s_{i,j}$ 表示有 $i$ 个被删除的区间，其总长度为 $j$ ，确定被这些区间完全包含了的询问的方案数。计算 $f_i$ 的时候枚举被删掉的区间数量和长度总和即可。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>20200328 联考</title>
    <url>/2020/03/30/20200328-%E8%81%94%E8%80%83/</url>
    <content><![CDATA[<h2 id="A-数一数"><a href="#A-数一数" class="headerlink" title="A - 数一数"></a>A - 数一数</h2><p>总感觉是做过的题，甚至清晰的记得给赵爷讲过，但是想不起来做法了…… :sob:</p>
<p>ZJK 告诉我题意是有问题的，每一列只能有恰好一个 $1$ ，否则样例 1 的答案就应该是 $\frac{3}{4}$ 。</p>
<p>整个表格的数确定的时候，用一个简单的 dp（$g_{j,i} = \max\{ g_{j+1,i-1}, g_{j+1,i}, g_{j+1,i+1}\} + v_{j,i}$）就能得到这个表格的最大得分。可惜由于表格无限长，这个 dp 的可能的取值也是无限多的，不能作为 dp 状态。</p>
<p>不妨设 $g’_{j,i} = g_{j,i} - \min_{k\in [1,n]} \{ g_{j,k} \}$ ，不难发现 $g’_j$ 的取值是有限的，并且将 $g_j$ 替换成 $g’_j$ 并不会影响之后的转移。</p>
<p>考虑这样一张图：每个结点是一个 $g’_j$ ；有向边 $(u,v)$ 的权值为二元组 $(p,w)$ ，表示当前在 $u$ ，下一步走到 $v$ 的概率是 $p$ ，而 $v$ 的 $\min\{g’_{j,k}\}$ 比 $u$ 大 $w$ 。设在这张图上随机游走 $m$ 步之后，走过的边的 $w$ 的和的期望为 $f(m)$ ，答案就是 $\lim_{m\to \infty} \frac{f(m)}{m}$ 。</p>
<p>$\lim_{m\to \infty} \frac{f(m)}{m}$ 等价于每条边的权值按照其被经过的期望次数加权平均，用高斯消元算即可。</p>
<h2 id="B-数二数"><a href="#B-数二数" class="headerlink" title="B - 数二数"></a>B - 数二数</h2><ul>
<li><a href="https://csacademy.com/contest/round-35/task/counting-quests/" target="_blank" rel="noopener">link to the problem</a></li>
<li><a href="https://csacademy.com/submission/2707618/" target="_blank" rel="noopener">my submission</a></li>
</ul>
<p>对于一个序列和一个询问集合，设 $S_i$ 为包含了 $i$ 这个位置的询问的集合。一个询问集合合法当且仅当 $S_i$ 互不相同。</p>
<p>性质 1 ：如果 $a&lt;b&lt;c&lt;d, S_a=S_c, S_b=S_d$，那么 $S_a=S_b=S_c=S_d$ 。</p>
<p>证明：包含了 $a$ 和 $c$ 的询问必然包含 $b$ ，而由于 $S_b=S_d$ ，所以也就必然包含了 $d$ 。其它情况同理。</p>
<p>性质 2 ：假设 $a$ 是序列中第一个其 $S_i$ 至少出现了两次的元素，$b$ 是 $S_a$ 最后一次出现的位置，那么询问集合中不存在区间与 $[a,b]$ 有交且不互相包含。</p>
<p>证明：对于一个与 $[a,b]$ 相交且不互相包含的区间，这个区间必然只包含了 $a,b$ 中的一个，于是推出 $S_a\neq S_b$ ，矛盾。</p>
<p>统计不合法的询问集合数量。对于一不合法的询问集合和一个序列，我们对 $\{S_i\}$ 进行如下的操作：</p>
<ol>
<li>找到第一个出现了至少两次的 $S_i$ ，然后找到它最后一次出现的位置，设这两个位置是 $l,r$</li>
<li>将 $[l,r]$ 区间内的元素删掉，替换为一个 $S_i = S_l$ 的元素，并重复 1.</li>
</ol>
<p>显然不会有与被删掉的区间有交但不包含的询问；所以确定“没有被包含于删掉了的区间的询问”的方案数就是把被删掉的区间换成一个点之后的合法的询问集合数；被包含在删除了的区间内部的询问可以任意地确定。</p>
<p>设表示 $f_i$ 序列长度为 $i$ 时，合法的询问集合的数量；设 $s_{i,j}$ 表示有 $i$ 个被删除的区间，其总长度为 $j$ ，确定被这些区间完全包含了的询问的方案数。计算 $f_i$ 的时候枚举被删掉的区间数量和长度总和即可。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>KD-Tree 学习笔记</title>
    <url>/2020/03/27/KD-Tree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://oi-wiki.org/ds/kdt/" target="_blank" rel="noopener">OI-wiki</a></li>
<li><a href="https://en.wikipedia.org/wiki/K-d_tree" target="_blank" rel="noopener">wikipedia</a></li>
<li><a href="https://courses.cs.washington.edu/courses/cse373/02au/lectures/lecture22l.pdf" target="_blank" rel="noopener">一份有详细图解的课件</a></li>
</ol>
<h2 id="KD-Tree-是什么"><a href="#KD-Tree-是什么" class="headerlink" title="KD-Tree 是什么"></a>KD-Tree 是什么</h2><p>KD-Tree（k-dimensional tree 的简写）是一种用来维护 $k$ 维的<strong>点集</strong>的数据结构。它是一棵深度为 $O(\log n)$ 的二叉搜索树，每个结点代表了点集中的一个点。</p>
<p>它可以支持以下的操作（设 $n$ 为点集的大小）：</p>
<ol>
<li>插入/删除一个点，时间复杂度为均摊 $O(\log n)$</li>
<li>查询一个边界平行于坐标轴的矩形/超矩形内的点的信息，时间复杂度上界为 $O(n^{1-\frac{1}{k}})$</li>
<li>对一个边界平行于坐标轴的矩形/超矩形内的点进行支持标记合并的修改（维护和线段树类似的标记），时间复杂度上界为 $O(n^{1-\frac{1}{k}})$</li>
<li>查询一个点的最近点/最远点，数据随机的时候时间复杂度期望为 $O(\log n)$ ，最坏复杂度为 $O(n)$ 。</li>
</ol>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>选择一个维度，然后在点集中选择一个这一维的坐标是中位数的点作为根，然后把其它的点按照这一维的坐标和根的大小关系分成左右两棵子树，递归到子树内进行建造。</p>
<p>定义一个结点的<strong>范围</strong>是它子树内的点的坐标范围，也就是一个 $k$ 维的、所有边都平行于坐标轴的超矩形。</p>
<p>注意到：对于某个点，显然它的左右子树的范围的交要么为空，要么只包含了这个点所在的、垂直于这一次所选的维度的坐标轴的一条线段。</p>
<p>以下是二维情形的建树代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">rec[c] 代表 c 结点的范围</span></span><br><span class="line"><span class="comment">tr[c] 表示 c 结点所代表的点的坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> d)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> (<span class="keyword">void</span>)(c=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	nth_element(P+l,P+mid,P+r+<span class="number">1</span>,(d&amp;<span class="number">1</span>?cmpx:cmpy));</span><br><span class="line">	tr[c=newnode()]=P[mid];</span><br><span class="line">	build(l,mid<span class="number">-1</span>,ch[c][<span class="number">0</span>],d+<span class="number">1</span>),build(mid+<span class="number">1</span>,r,ch[c][<span class="number">1</span>],d+<span class="number">1</span>);</span><br><span class="line">	rec[c].lx=min(tr[c].x,min(rec[ch[c][<span class="number">0</span>]].lx,rec[ch[c][<span class="number">1</span>]].lx));</span><br><span class="line">	rec[c].rx=max(tr[c].x,max(rec[ch[c][<span class="number">0</span>]].rx,rec[ch[c][<span class="number">1</span>]].rx));</span><br><span class="line">	rec[c].ly=min(tr[c].y,min(rec[ch[c][<span class="number">0</span>]].ly,rec[ch[c][<span class="number">1</span>]].ly));</span><br><span class="line">	rec[c].ry=max(tr[c].y,max(rec[ch[c][<span class="number">0</span>]].ry,rec[ch[c][<span class="number">1</span>]].ry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入/删除"></a>插入/删除</h2><p>按照 KD-Tree 的子树划分方式递归到相应的位置，然后插入/删除即可。</p>
<p>为了保证平衡，我们要在某个点的某个儿子的子树大小大于这个点的子树大小 $\times \alpha$ 的时候对这个子树进行重构。其中 $\alpha$ 一般取 0.75 左右。</p>
<p>单次插入/删除的时间复杂度是均摊 $O(\log n)$ 的。</p>
<p>以下是二维情形的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(POINT A,POINT B)</span> </span>&#123; <span class="keyword">return</span> A.x&lt;B.x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(POINT A,POINT B)</span> </span>&#123; <span class="keyword">return</span> A.y&lt;B.y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmptx</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> tr[x].x&lt;tr[y].x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpty</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> tr[x].y&lt;tr[y].y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	sum[c]=sum[ch[c][<span class="number">0</span>]]+sum[ch[c][<span class="number">1</span>]]+val[c];</span><br><span class="line">	sz[c]=sz[ch[c][<span class="number">0</span>]]+sz[ch[c][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> (<span class="keyword">void</span>)(c=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	nth_element(b.begin()+l,b.begin()+mid,b.begin()+r+<span class="number">1</span>,(d?cmptx:cmpty));</span><br><span class="line">	c=b[mid];</span><br><span class="line">	rebuild(l,mid<span class="number">-1</span>,ch[c][<span class="number">0</span>],d^<span class="number">1</span>);</span><br><span class="line">	rebuild(mid+<span class="number">1</span>,r,ch[c][<span class="number">1</span>],d^<span class="number">1</span>);</span><br><span class="line">	rec[c].lx=min(tr[c].x,min(rec[ch[c][<span class="number">0</span>]].lx,rec[ch[c][<span class="number">1</span>]].lx));</span><br><span class="line">	rec[c].rx=max(tr[c].x,max(rec[ch[c][<span class="number">0</span>]].rx,rec[ch[c][<span class="number">1</span>]].rx));</span><br><span class="line">	rec[c].ly=min(tr[c].y,min(rec[ch[c][<span class="number">0</span>]].ly,rec[ch[c][<span class="number">1</span>]].ly));</span><br><span class="line">	rec[c].ry=max(tr[c].y,max(rec[ch[c][<span class="number">0</span>]].ry,rec[ch[c][<span class="number">1</span>]].ry));</span><br><span class="line">	push_up(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!rt) <span class="keyword">return</span>; b.PB(rt);</span><br><span class="line">	recycle(ch[rt][<span class="number">0</span>]),recycle(ch[rt][<span class="number">1</span>]);</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	recycle(rt),rebuild(<span class="number">0</span>,b.size()<span class="number">-1</span>,rt,d),b.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> d,POINT p,<span class="keyword">int</span> v,<span class="keyword">int</span> flg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!c) &#123;</span><br><span class="line">		tr[c=++ncnt]=p,val[c]=v,push_up(c);</span><br><span class="line">		rec[c].lx=rec[c].rx=tr[c].x;</span><br><span class="line">		rec[c].ly=rec[c].ry=tr[c].y;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> lr=(d?cmpx(tr[c],p):cmpy(tr[c],p));</span><br><span class="line">	<span class="keyword">int</span> cur_flg=(sz[c]<span class="number">-1</span>)*alpha&lt;=max(sz[ch[c][lr]]+<span class="number">1</span>,sz[ch[c][lr^<span class="number">1</span>]]);</span><br><span class="line">	ins(ch[c][lr],d^<span class="number">1</span>,p,v,flg|cur_flg);</span><br><span class="line">	rec[c].lx=min(rec[c].lx,p.x);</span><br><span class="line">	rec[c].rx=max(rec[c].rx,p.x);</span><br><span class="line">	rec[c].ly=min(rec[c].ly,p.y);</span><br><span class="line">	rec[c].ry=max(rec[c].ry,p.y);</span><br><span class="line">	push_up(c);</span><br><span class="line">	<span class="keyword">if</span>(!flg&amp;&amp;cur_flg) rebuild(c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩形查询"><a href="#矩形查询" class="headerlink" title="矩形查询"></a>矩形查询</h2><p>从根开始往下递归：</p>
<ol>
<li>如果当前结点的范围与查询的范围没有交，直接退出；</li>
<li>如果当前结点的范围被完全包含在查询的范围内，返回当前结点的子树信息</li>
<li>否则考虑当前结点所代表的点的贡献，并递归到子树内继续查询</li>
</ol>
<p>可以证明，单次操作的时间复杂度上界为 $O(n^{1-\frac{1}{k}})$ 。</p>
<p>以下是二维情形的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,<span class="keyword">int</span> ly,<span class="keyword">int</span> ry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rx&lt;rec[c].lx||lx&gt;rec[c].rx||ry&lt;rec[c].ly||ly&gt;rec[c].ry) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(lx&lt;=rec[c].lx&amp;&amp;rx&gt;=rec[c].rx&amp;&amp;ly&lt;=rec[c].ly&amp;&amp;ry&gt;=rec[c].ry) <span class="keyword">return</span> sum[c];</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(lx&lt;=tr[c].x&amp;&amp;rx&gt;=tr[c].x&amp;&amp;ly&lt;=tr[c].y&amp;&amp;ry&gt;=tr[c].y) tot+=val[c];</span><br><span class="line">	tot+=qry(ch[c][<span class="number">0</span>],d^<span class="number">1</span>,lx,rx,ly,ry);</span><br><span class="line">	tot+=qry(ch[c][<span class="number">1</span>],d^<span class="number">1</span>,lx,rx,ly,ry);</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩形修改"><a href="#矩形修改" class="headerlink" title="矩形修改"></a>矩形修改</h2><p>与矩形查询是类似的。</p>
<p>从根开始往下递归：</p>
<ol>
<li>如果当前结点的范围与查询的范围没有交，直接退出；</li>
<li>如果当前结点的范围被完全包含在查询的范围内，对当前结点打子树修改标记</li>
<li>否则考虑修改对当前结点代表的点的贡献，并递归到当前结点的子树内继续以上过程</li>
</ol>
<p>单次操作的时间复杂度上界是 $O(n^{1-\frac{1}{k}})$ 。</p>
<p>以下是二维情形的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,<span class="keyword">int</span> ly,<span class="keyword">int</span> ry,<span class="keyword">int</span> op,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rec[c].lx&gt;rx||rec[c].rx&lt;lx||rec[c].ly&gt;ry||rec[c].ry&lt;ly) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(rec[c].lx&gt;=lx&amp;&amp;rec[c].rx&lt;=rx&amp;&amp;rec[c].ly&gt;=ly&amp;&amp;rec[c].ry&lt;=ry) <span class="keyword">return</span> (<span class="keyword">void</span>)(op==<span class="number">1</span>?add(c,v):mul(c,v));</span><br><span class="line">	push_down(c);</span><br><span class="line">	<span class="keyword">if</span>(lx&lt;=tr[c].x&amp;&amp;rx&gt;=tr[c].x&amp;&amp;ly&lt;=tr[c].y&amp;&amp;ry&gt;=tr[c].y) val[c]=(op==<span class="number">1</span>?(val[c]+v)%mod:<span class="number">1l</span>l*val[c]*v%mod);</span><br><span class="line">	upd(ch[c][<span class="number">0</span>],lx,rx,ly,ry,op,v);</span><br><span class="line">	upd(ch[c][<span class="number">1</span>],lx,rx,ly,ry,op,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询一个点的最近-最远点"><a href="#查询一个点的最近-最远点" class="headerlink" title="查询一个点的最近/最远点"></a>查询一个点的最近/最远点</h2><p>本质上是对暴力搜索的剪枝。</p>
<p>剪枝 1 ：如果一个结点的范围内的所有点到查询点的距离都不如现在的最优答案优秀，那么直接退出。</p>
<p>剪枝 2 ：在决定先往左子树走还是往右子树走的时候，走范围边界上最优的那个点更优的那个子树。</p>
<p>可以证明，随机数据的时候单次查询的期望复杂度为 $O(\log n)$ ，最坏情况下的时间复杂度为 $O(n)$ 。</p>
<h3 id="拓展：查询一个点的第-k-近-远的点"><a href="#拓展：查询一个点的第-k-近-远的点" class="headerlink" title="拓展：查询一个点的第 $k$ 近/远的点"></a>拓展：查询一个点的第 $k$ 近/远的点</h3><p>用优先队列维护现在已经搜到的答案最优的 $k$ 个，搜索的过程中进行和前面同理的剪枝；复杂度和上面最近/最远点的复杂度是相同的。</p>
<p>二维 $k$ 远点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">db <span class="title">Sqr</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="function">db <span class="title">dis_to_rec</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!c) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> max(Sqr(rec[c].lx-qx),Sqr(rec[c].rx-qx))+max(Sqr(rec[c].ly-qy),Sqr(rec[c].ry-qy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> Sqr(tr[c].x-qx)+Sqr(tr[c].y-qy); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!c) <span class="keyword">return</span>;</span><br><span class="line">	item tmp=(item)&#123;tr[c].id,dis(c)&#125;;</span><br><span class="line">	<span class="keyword">if</span>(tmp&lt;Q.top()) Q.pop(),Q.push(tmp);</span><br><span class="line">	db d[<span class="number">2</span>]=&#123;dis_to_rec(ch[c][<span class="number">0</span>]),dis_to_rec(ch[c][<span class="number">1</span>])&#125;;</span><br><span class="line">	<span class="keyword">int</span> lr=(d[<span class="number">1</span>]&gt;d[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span>(sgn(d[lr]-Q.top().d)&gt;=<span class="number">0</span>) qry(ch[c][lr]);</span><br><span class="line">	<span class="keyword">if</span>(sgn(d[lr^<span class="number">1</span>]-Q.top().d)&gt;=<span class="number">0</span>) qry(ch[c][lr^<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题表"><a href="#题表" class="headerlink" title="题表"></a>题表</h2><ul>
<li>luogu P2093 【国家集训队】JZPFAR</li>
<li>luogu P3710 方方方的数据结构</li>
<li>luogu P3710 方方方的数据结构</li>
<li>luogu P4148 简单题</li>
<li>luogu P4357 【CQOI2016】K远点对</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>20200325 联考</title>
    <url>/2020/03/26/20200325-%E8%81%94%E8%80%83/</url>
    <content><![CDATA[<h2 id="A-string"><a href="#A-string" class="headerlink" title="A - string"></a>A - string</h2><p>经典题目。</p>
<h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B - tree"></a>B - tree</h2><p>容易想到 $f_u$ 表示把 $u$ 子树变成 $T_1$ 中它们对应的子树，能够有的最大深度和。</p>
<p>设个中间量 $dp_{u,j}$ 表示 $u$ 子树中，$u$ 在的那条链的长度是 $j$ 时，最大深度和。</p>
<p>合并子树的时候，因为 $T_2$ 必须是二叉树，所以状态中再加入大小为 $2^2$ 的一维表示左右儿子选过没有。</p>
<p>总时间复杂度 $O(n^2)$ 。</p>
<h2 id="C-sort"><a href="#C-sort" class="headerlink" title="C - sort"></a>C - sort</h2><h3 id="思路和实现细节"><a href="#思路和实现细节" class="headerlink" title="思路和实现细节"></a>思路和实现细节</h3><p>考场上想的是线段树套trie，修改的时候需要支持可持久化分裂/合并，空间是两个 $\log$ 的，其中一个还是 $\log V$ ，用脚趾头想都知道开不下。</p>
<p>考后看题解发现自己 zz 了：<strong>如果不需要实时查询区间信息，就不需要在节点里维护整个子树的信息。</strong> 题解还是很妙的，用平衡树维护每个排过序的段，段内用 trie 维护元素。在这一段被再次分裂之前进行的操作都不要打到 trie 上，这样 trie 中的元素的大小关系就是它们在序列中的位置关系。输出答案的函数中传入对这整个 trie 进行过的操作，然后按照它们操作前的大小关系顺序输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d,uint v,TAG t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">-1</span>) &#123;</span><br><span class="line">        v&amp;=t.t0,v|=t.t1,v^=t.r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i) <span class="built_in">printf</span>(<span class="string">"%u "</span>,v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(u,d);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]) getans(ch[u][<span class="number">0</span>],d<span class="number">-1</span>,v,t);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>]) getans(ch[u][<span class="number">1</span>],d<span class="number">-1</span>,v|<span class="number">1u</span>&lt;&lt;d,t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外层用的是 fhq_treap ，因为这样区间操作很舒服。考虑到分裂的时候可能会分裂一个节点，给每个节点随机一个权值可能就不太均匀了，所以写的是这样的 <code>merge</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> &amp;r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||!b) <span class="keyword">return</span> (<span class="keyword">void</span>)(r=a+b);</span><br><span class="line">    push_down(a),push_down(b);</span><br><span class="line">    <span class="keyword">if</span>(rnd()&amp;<span class="number">1</span>) mer(ch[r][<span class="number">0</span>],a,ch[r=b][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span> mer(ch[r][<span class="number">1</span>],ch[r=a][<span class="number">1</span>],b);</span><br><span class="line">    push_up(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>rnd</code> 是返回随机数。</p>
<p>关于操作的标记的处理：把 <code>AND</code> 和 <code>OR</code> 想象成赋值，<code>XOR</code> 想象成取反。优先操作 <code>AND</code> 和 <code>OR</code> ，加入 <code>XOR</code> 标记的时候要计算它对 <code>AND</code> 和 <code>OR</code> 标记的影响。也就是没有被 <code>AND</code> 和 <code>OR</code> 覆盖到的位才去考虑 <code>XOR</code> 标记的影响。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uint S=~<span class="number">0u</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TAG</span> &#123;</span></span><br><span class="line">    uint t0,t1,r;</span><br><span class="line">    TAG(): t0(S),t1(<span class="number">0</span>),r(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add0</span><span class="params">(uint a)</span> </span>&#123; t0&amp;=a,t1&amp;=a,r&amp;=a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(uint a)</span> </span>&#123; t0|=a,t1|=a,r&amp;=~a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addr</span><span class="params">(uint a)</span> </span>&#123;</span><br><span class="line">        uint A0=(~t0)&amp;a,A1=t1&amp;a;</span><br><span class="line">        t1^=A1,t1|=A0;</span><br><span class="line">        t0^=A0,t0&amp;=~A1;</span><br><span class="line">        r=(r^a)&amp;((~t1)&amp;t0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TAG B)</span> </span>&#123;</span><br><span class="line">        t0&amp;=B.t0,t0|=B.t1;</span><br><span class="line">        t1&amp;=B.t0,t1|=B.t1;</span><br><span class="line">        r=r&amp;((~t1)&amp;t0);</span><br><span class="line">        addr(B.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于 trie 中下放标记的时候合并左右子树的复杂度：可以用和线段树合并复杂度同理的分析，得到复杂度均摊 $O(\log n)$ （可参看我的<a href="https://zhongyuwei.github.io/2020/03/01/NOI2018-%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/">这篇题解</a>的结尾处的分析）。是的你没看错下面这个反复递归调用的玩意的复杂度居然 TMD 只有一个 $\log$ ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> v,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u||!v) <span class="keyword">return</span> (<span class="keyword">void</span>)(u=u+v);</span><br><span class="line">    sz[u]+=sz[v];</span><br><span class="line">    push_down(u,d),push_down(v,d);</span><br><span class="line">    mer(ch[u][<span class="number">0</span>],ch[v][<span class="number">0</span>],d<span class="number">-1</span>),mer(ch[u][<span class="number">1</span>],ch[v][<span class="number">1</span>],d<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(tg[c].t0&gt;&gt;d&amp;<span class="number">1</span>)) mer(ch[c][<span class="number">0</span>],ch[c][<span class="number">1</span>],d<span class="number">-1</span>),ch[c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tg[c].t1&gt;&gt;d&amp;<span class="number">1</span>) mer(ch[c][<span class="number">1</span>],ch[c][<span class="number">0</span>],d<span class="number">-1</span>),ch[c][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tg[c].r&gt;&gt;d&amp;<span class="number">1</span>) swap(ch[c][<span class="number">0</span>],ch[c][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[c][<span class="number">0</span>]) tg[ch[c][<span class="number">0</span>]].add(tg[c]);</span><br><span class="line">    <span class="keyword">if</span>(ch[c][<span class="number">1</span>]) tg[ch[c][<span class="number">1</span>]].add(tg[c]);</span><br><span class="line">    tg[c]=TAG();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它的感觉就和这些数据结构的正常写法没有什么区别。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> uint S=~<span class="number">0u</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TAG</span> &#123;</span></span><br><span class="line">    uint t0,t1,r;</span><br><span class="line">    TAG(): t0(S),t1(<span class="number">0</span>),r(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add0</span><span class="params">(uint a)</span> </span>&#123; t0&amp;=a,t1&amp;=a,r&amp;=a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(uint a)</span> </span>&#123; t0|=a,t1|=a,r&amp;=~a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addr</span><span class="params">(uint a)</span> </span>&#123;</span><br><span class="line">        uint A0=(~t0)&amp;a,A1=t1&amp;a;</span><br><span class="line">        t1^=A1,t1|=A0;</span><br><span class="line">        t0^=A0,t0&amp;=~A1;</span><br><span class="line">        r=(r^a)&amp;((~t1)&amp;t0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TAG B)</span> </span>&#123;</span><br><span class="line">        t0&amp;=B.t0,t0|=B.t1;</span><br><span class="line">        t1&amp;=B.t0,t1|=B.t1;</span><br><span class="line">        r=r&amp;((~t1)&amp;t0);</span><br><span class="line">        addr(B.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> trie &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1e7</span>+N;</span><br><span class="line">    TAG tg[M];</span><br><span class="line">    <span class="keyword">int</span> ch[M][<span class="number">2</span>],sz[M],ncnt;</span><br><span class="line">    <span class="keyword">int</span> st[<span class="number">1000000</span>],top;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(x&amp;&amp;top&lt;<span class="number">1000000</span>) st[top++]=x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(top) &#123;</span><br><span class="line">    		<span class="keyword">int</span> u=st[--top];</span><br><span class="line">    		ch[u][<span class="number">0</span>]=ch[u][<span class="number">1</span>]=sz[u]=<span class="number">0</span>,tg[u]=TAG();</span><br><span class="line">    		<span class="keyword">return</span> u;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">return</span> ++ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; sz[c]=sz[ch[c][<span class="number">0</span>]]+sz[ch[c][<span class="number">1</span>]]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> v,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u||!v) <span class="keyword">return</span> (<span class="keyword">void</span>)(u=u+v);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        push_down(u,d),push_down(v,d);</span><br><span class="line">        mer(ch[u][<span class="number">0</span>],ch[v][<span class="number">0</span>],d<span class="number">-1</span>),mer(ch[u][<span class="number">1</span>],ch[v][<span class="number">1</span>],d<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(tg[c].t0&gt;&gt;d&amp;<span class="number">1</span>)) mer(ch[c][<span class="number">0</span>],ch[c][<span class="number">1</span>],d<span class="number">-1</span>),ch[c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tg[c].t1&gt;&gt;d&amp;<span class="number">1</span>) mer(ch[c][<span class="number">1</span>],ch[c][<span class="number">0</span>],d<span class="number">-1</span>),ch[c][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tg[c].r&gt;&gt;d&amp;<span class="number">1</span>) swap(ch[c][<span class="number">0</span>],ch[c][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ch[c][<span class="number">0</span>]) tg[ch[c][<span class="number">0</span>]].add(tg[c]);</span><br><span class="line">        <span class="keyword">if</span>(ch[c][<span class="number">1</span>]) tg[ch[c][<span class="number">1</span>]].add(tg[c]);</span><br><span class="line">        tg[c]=TAG();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> &amp;rt,uint x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=rt=newnode(); sz[cur]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ch[cur][c]) ch[cur][c]=newnode();</span><br><span class="line">            cur=ch[cur][c],sz[cur]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> &amp;v,<span class="keyword">int</span> k,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(u=<span class="number">0</span>,v=c);</span><br><span class="line">        <span class="keyword">if</span>(k==sz[c]) <span class="keyword">return</span> (<span class="keyword">void</span>)(u=c,v=<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!u) u=newnode();</span><br><span class="line">        <span class="keyword">if</span>(!v) v=newnode();</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">-1</span>) &#123;</span><br><span class="line">            sz[u]=k,sz[v]=sz[c]-k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(c,d);</span><br><span class="line">        <span class="keyword">if</span>(sz[ch[c][<span class="number">0</span>]]&gt;=k) &#123;</span><br><span class="line">            ch[v][<span class="number">1</span>]=ch[c][<span class="number">1</span>],ch[u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            split(ch[c][<span class="number">0</span>],ch[u][<span class="number">0</span>],ch[v][<span class="number">0</span>],k,d<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ch[u][<span class="number">0</span>]=ch[c][<span class="number">0</span>],ch[v][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            split(ch[c][<span class="number">1</span>],ch[u][<span class="number">1</span>],ch[v][<span class="number">1</span>],k-sz[ch[c][<span class="number">0</span>]],d<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        push_up(u),push_up(v);</span><br><span class="line">        rec(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d,uint v,TAG t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">-1</span>) &#123;</span><br><span class="line">            v&amp;=t.t0,v|=t.t1,v^=t.r;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i) <span class="built_in">printf</span>(<span class="string">"%u "</span>,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(u,d);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">0</span>]) getans(ch[u][<span class="number">0</span>],d<span class="number">-1</span>,v,t);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">1</span>]) getans(ch[u][<span class="number">1</span>],d<span class="number">-1</span>,v|<span class="number">1u</span>&lt;&lt;d,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> treap &#123;</span><br><span class="line">    uint seed=<span class="number">128</span>;</span><br><span class="line">    <span class="function">uint <span class="title">rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seed^=seed&lt;&lt;<span class="number">13</span>,seed^=seed&gt;&gt;<span class="number">17</span>,seed^=seed&lt;&lt;<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M=N+N*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[M][<span class="number">2</span>],ncnt;</span><br><span class="line">    <span class="keyword">int</span> len[M],sz[M],rt[M];</span><br><span class="line">    TAG tg[M],val[M];</span><br><span class="line">    <span class="keyword">int</span> RT;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++ncnt; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c,TAG t)</span> </span>&#123; tg[c].add(t),val[c].add(t); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[c][<span class="number">0</span>]) add(ch[c][<span class="number">0</span>],tg[c]);</span><br><span class="line">        <span class="keyword">if</span>(ch[c][<span class="number">1</span>]) add(ch[c][<span class="number">1</span>],tg[c]);</span><br><span class="line">        tg[c]=TAG();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; sz[c]=sz[ch[c][<span class="number">0</span>]]+sz[ch[c][<span class="number">1</span>]]+len[c]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span> (<span class="keyword">void</span>)(a=b=<span class="number">0</span>);</span><br><span class="line">        push_down(x);</span><br><span class="line">        <span class="keyword">if</span>(sz[ch[x][<span class="number">0</span>]]&lt;k&amp;&amp;sz[ch[x][<span class="number">0</span>]]+len[x]&gt;k) &#123;</span><br><span class="line">            a=newnode(),b=newnode();</span><br><span class="line">            val[a]=val[b]=val[x];</span><br><span class="line">            trie::split(rt[x],rt[a],rt[b],k-sz[ch[x][<span class="number">0</span>]],<span class="number">31</span>);</span><br><span class="line">            ch[a][<span class="number">0</span>]=ch[x][<span class="number">0</span>],ch[b][<span class="number">1</span>]=ch[x][<span class="number">1</span>];</span><br><span class="line">            ch[a][<span class="number">1</span>]=ch[b][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            len[a]=k-sz[ch[x][<span class="number">0</span>]],len[b]=len[x]-len[a];</span><br><span class="line">            push_up(a),push_up(b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sz[ch[x][<span class="number">0</span>]]&gt;=k) split(ch[x][<span class="number">0</span>],k,a,ch[b=x][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> split(ch[x][<span class="number">1</span>],k-sz[ch[x][<span class="number">0</span>]]-len[x],ch[a=x][<span class="number">1</span>],b);</span><br><span class="line">        push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mer</span><span class="params">(<span class="keyword">int</span> &amp;r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a||!b) <span class="keyword">return</span> (<span class="keyword">void</span>)(r=a+b);</span><br><span class="line">        push_down(a),push_down(b);</span><br><span class="line">        <span class="keyword">if</span>(rnd()&amp;<span class="number">1</span>) mer(ch[r][<span class="number">0</span>],a,ch[r=b][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> mer(ch[r][<span class="number">1</span>],ch[r=a][<span class="number">1</span>],b);</span><br><span class="line">        push_up(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split_rng</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> &amp;z)</span> </span>&#123;</span><br><span class="line">        split(RT,l<span class="number">-1</span>,x,y);</span><br><span class="line">        split(y,r-l+<span class="number">1</span>,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_mer</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        push_down(u);</span><br><span class="line">        trie::tg[rt[u]].add(val[u]),val[u]=TAG();</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">0</span>]) dfs_mer(ch[u][<span class="number">0</span>]),trie::mer(rt[u],rt[ch[u][<span class="number">0</span>]],<span class="number">31</span>);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">1</span>]) dfs_mer(ch[u][<span class="number">1</span>]),trie::mer(rt[u],rt[ch[u][<span class="number">1</span>]],<span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">opt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> op,l,r,v; rd(op),rd(l),rd(r); <span class="keyword">if</span>(op&lt;=<span class="number">3</span>) rd(v);</span><br><span class="line">        <span class="keyword">int</span> x,y,z; split_rng(l,r,x,y,z);</span><br><span class="line">        <span class="keyword">if</span>(op&lt;=<span class="number">3</span>) &#123;</span><br><span class="line">            TAG tmp;</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>) tmp.add1(v);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">2</span>) tmp.add0(v);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">3</span>) tmp.addr(v);</span><br><span class="line">            add(y,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> dfs_mer(y),len[y]=trie::sz[rt[y]],ch[y][<span class="number">0</span>]=ch[y][<span class="number">1</span>]=<span class="number">0</span>,push_up(y);</span><br><span class="line">        mer(RT,x,y),mer(RT,RT,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(uint *a,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=newnode();</span><br><span class="line">            trie::init(rt[u],a[i]),len[u]=<span class="number">1</span>,push_up(u);</span><br><span class="line">            mer(RT,RT,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> u=RT)</span> </span>&#123;</span><br><span class="line">        push_down(u);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">0</span>]) getans(ch[u][<span class="number">0</span>]);</span><br><span class="line">        trie::getans(rt[u],<span class="number">31</span>,<span class="number">0</span>,val[u]);</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">1</span>]) getans(ch[u][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">uint a[N],n,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rd(n),rd(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]);</span><br><span class="line">    treap::build(a,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) treap::opt();</span><br><span class="line">    treap::getans();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>三角函数及其反函数的导数 整理+证明</title>
    <url>/2020/03/20/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%8F%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0-%E6%95%B4%E7%90%86-%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h2 id="定义-三角函数"><a href="#定义-三角函数" class="headerlink" title="定义-三角函数"></a>定义-三角函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数名称</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>正弦</td>
<td>$\sin \theta$</td>
</tr>
<tr>
<td>余弦</td>
<td>$\cos \theta$</td>
</tr>
<tr>
<td>正切</td>
<td>$\tan \theta$</td>
</tr>
<tr>
<td>余切</td>
<td>$\cot \theta$</td>
</tr>
<tr>
<td>正割</td>
<td>$\sec \theta = \frac{1}{\cos \theta}$</td>
</tr>
<tr>
<td>余割</td>
<td>$\csc \theta = \frac{1}{\sin \theta}$</td>
</tr>
</tbody>
</table>
</div>
<p>其中</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cot \theta &= \frac{1}{\tan \theta}\\
\sec \theta &= \frac{1}{\cos \theta}\\
\csc \theta &= \frac{1}{\sin \theta}
\end{aligned}</script><p>相关恒等式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin(x+y) &= \sin x \cos y + \cos x \sin y\\
\cos(x+y) &= \cos x \cos y - \sin x \sin y\\
\tan(x+y) &= \frac{\tan x + tan y}{1 - \tan x \tan y}\\
\sin^2 \theta + \cos^2 \theta &= 1\\
1 + \tan^2 \theta &= \sec^2 \theta\\
1 + \cot^2 \theta &= \csc^2 \theta
\end{aligned}</script><h2 id="求导-三角函数"><a href="#求导-三角函数" class="headerlink" title="求导-三角函数"></a>求导-三角函数</h2><h3 id="几个非常有用的结论"><a href="#几个非常有用的结论" class="headerlink" title="几个非常有用的结论"></a>几个非常有用的结论</h3><h4 id="a-lim-theta-to-0-frac-sin-theta-theta-1"><a href="#a-lim-theta-to-0-frac-sin-theta-theta-1" class="headerlink" title="a) $\lim_{\theta\to 0} \frac{\sin \theta}{\theta} = 1$"></a>a) $\lim_{\theta\to 0} \frac{\sin \theta}{\theta} = 1$</h4><h5 id="1-cos-theta-lt-frac-sin-theta-theta"><a href="#1-cos-theta-lt-frac-sin-theta-theta" class="headerlink" title="1. $\cos \theta &lt; \frac{\sin \theta}{\theta}$"></a>1. $\cos \theta &lt; \frac{\sin \theta}{\theta}$</h5><p><img src="https://i.loli.net/2020/02/28/6QbjXn4qyVBx5er.jpg" alt="0.jpg"></p>
<p>如图， $\odot A$ 是单位圆， $AC$ 为一条过 $A$ 的射线，它与 $x$ 轴正方向的夹角为 $\theta$ 。则：</p>
<ul>
<li>$\theta = \overset{\large\frown}{BC}$（由弧度制的定义得)</li>
<li>$\sin \theta = CH$</li>
<li>$\tan \theta = EB$</li>
</ul>
<p>于是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\theta = \overset{\large\frown}{BC}\\
< CD+DB\\
< ED + DB\\
= EB = \tan \theta\\
\therefore \theta < \tan \theta\\
\Rightarrow \theta < \frac{\sin \theta}{\cos \theta}\\
\Rightarrow \cos \theta < \frac{\sin \theta}{\theta}
\end{aligned}</script><h5 id="2-frac-sin-theta-theta-lt-1"><a href="#2-frac-sin-theta-theta-lt-1" class="headerlink" title="2. $\frac{\sin\theta}{\theta} &lt; 1$"></a>2. $\frac{\sin\theta}{\theta} &lt; 1$</h5><p>从上面的图可以看出来：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin \theta &= CH < BC < \overset{\large\frown}{BC} = \theta\\
\therefore \sin \theta &< \theta\\
\Rightarrow \frac{\sin \theta}{\theta} &< 1
\end{aligned}</script><h5 id="3-final-proof"><a href="#3-final-proof" class="headerlink" title="3. final proof"></a>3. final proof</h5><p>因为</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cos \theta < \frac{\sin \theta}{\theta} < 1\\
\lim_{\theta \to 0} \cos \theta = 1\\
\lim_{\theta \to 0} 1 = 1
\end{aligned}</script><p>由夹逼定理知</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lim_{\theta\to 0} \frac{\sin \theta}{\theta} = 1
\end{aligned}</script><h4 id="b-lim-theta-to-0-frac-cos-theta-1-theta-0"><a href="#b-lim-theta-to-0-frac-cos-theta-1-theta-0" class="headerlink" title="b) $\lim_{\theta\to 0} \frac{\cos \theta -1 }{\theta} = 0$"></a>b) $\lim_{\theta\to 0} \frac{\cos \theta -1 }{\theta} = 0$</h4><script type="math/tex; mode=display">
\begin{aligned}
&\lim_{\theta\to 0} \frac{\cos \theta -1 }{\theta}\\
=& \lim_{\theta\to 0} \frac{\cos \theta - 1}{\theta} \cdot \frac{\cos \theta + 1}{\cos \theta + 1}\\
=& \lim_{\theta\to 0} \frac{-\sin^2 \theta}{\theta(\cos \theta + 1)}\\
=& - \lim_{\theta\to 0} \frac{\sin \theta}{\theta} \cdot \lim_{\theta \to 0} \frac{\sin \theta}{\cos \theta + 1}\\
=& - 1 \cdot \frac{0}{1+1} = 0
\end{aligned}</script><h4 id="c-lim-x-to-0-frac-1-cos-x-frac-x-2-2-1"><a href="#c-lim-x-to-0-frac-1-cos-x-frac-x-2-2-1" class="headerlink" title="c) $\lim_{x\to 0} \frac{1-\cos x }{\frac{x^2}{2}} = 1$"></a>c) $\lim_{x\to 0} \frac{1-\cos x }{\frac{x^2}{2}} = 1$</h4><script type="math/tex; mode=display">
\begin{aligned}
& \lim_{x\to 0} \frac{1-\cos x}{\frac{x^2}{2}}\\
= & 2\lim_{x\to 0} \frac{1-\cos x}{x^2}\\
= & 2\lim_{x\to 0} \frac{(1-\cos x)(1+\cos x)}{x^2(\cos x +1)}\\
= & 2\lim_{x\to 0} \frac{\sin^2 x}{x^2(\cos x +1)}\\
= & 2\lim_{x\to 0} \left(\frac{\sin x}{x}\right)^2 \lim_{x\to 0} \frac{1}{1+\cos x}\\
= & 2 \cdot 1 \cdot \frac{1}{2}\\
= & 1
\end{aligned}</script><h3 id="sin-x-’-cos-x"><a href="#sin-x-’-cos-x" class="headerlink" title="$(\sin x)’ = \cos x$"></a>$(\sin x)’ = \cos x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\sin x)'\\
=& \lim_{h\to 0} \frac{\sin (x+h) - \sin x}{h}\\
=& \lim_{h\to 0} \frac{\sin x \cos h + \sin h \cos x - \sin x}{h}\\
=& \sin x \cdot \lim_{h\to 0} \frac{ \cos h - 1}{h} + \cos x\cdot \lim_{h\to 0} \frac{\sin h}{h}\\
=& \cos x
\end{aligned}</script><h3 id="cos-x-’-sin-x"><a href="#cos-x-’-sin-x" class="headerlink" title="$(\cos x)’ = -\sin x$"></a>$(\cos x)’ = -\sin x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\cos x)'\\
=& \lim_{h\to 0} \frac{\cos(x+h)-\cos x}{h}\\
=& \lim_{h\to 0} \frac{\cos x\cos h - \sin x \sin h - \cos x}{h}\\
=& \cos x \cdot \lim_{h\to 0} \frac{\cos h - 1}{h} - \sin x \lim_{h\to 0} \frac{\sin h}{h}\\
=& - \sin x
\end{aligned}</script><h3 id="tan-x-’-sec-2-x"><a href="#tan-x-’-sec-2-x" class="headerlink" title="$(\tan x)’ = \sec^2 x$"></a>$(\tan x)’ = \sec^2 x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\tan x)'\\
=& (\frac{\sin x}{\cos x})'\\
=& \frac{\cos^2 x + \sin^2 x}{\cos^2 x}\\
=& \sec^2 x
\end{aligned}</script><h3 id="cot-x-’-csc-2-x"><a href="#cot-x-’-csc-2-x" class="headerlink" title="$(\cot x)’ = -\csc^2 x$"></a>$(\cot x)’ = -\csc^2 x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\cot x)'\\
=& (\frac{\cos x}{\sin x})'\\
=& \frac{-\sin^2 x - \cos^2 x}{\sin^2 x}\\
=& - \csc^2 x
\end{aligned}</script><h3 id="sec-x-’-sec-x-cdot-tan-x"><a href="#sec-x-’-sec-x-cdot-tan-x" class="headerlink" title="$(\sec x)’ = \sec x \cdot \tan x$"></a>$(\sec x)’ = \sec x \cdot \tan x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\sec x)'\\
=& (\frac{1}{\cos x})'\\
=& \frac{\cos x \cdot 0 + \sin x \cdot 1}{\cos ^ 2 x}\\
=& \sec x\cdot \tan x
\end{aligned}</script><h3 id="csc-x-’-csc-x-cot-x"><a href="#csc-x-’-csc-x-cot-x" class="headerlink" title="$(\csc x)’ = -\csc x \cot x$"></a>$(\csc x)’ = -\csc x \cot x$</h3><script type="math/tex; mode=display">
\begin{aligned}
&(\csc x)'\\
=& (\frac{1}{\sin x})'\\
=& \frac{\sin x \cdot 0 - \cos x \cdot 1}{\sin^2 x}\\
=& - \csc x\cdot \cot x
\end{aligned}</script><h2 id="求导-反三角函数"><a href="#求导-反三角函数" class="headerlink" title="求导-反三角函数"></a>求导-反三角函数</h2><h3 id="sin-1-x-’-frac-1-sqrt-1-x-2"><a href="#sin-1-x-’-frac-1-sqrt-1-x-2" class="headerlink" title="$(\sin^{-1} x)’ = \frac{1}{\sqrt {1-x^2}}$"></a>$(\sin^{-1} x)’ = \frac{1}{\sqrt {1-x^2}}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\sin y &= x\\
\cos y \cdot y'&= 1\\
y' &= \frac{1}{\cos \left(\sin^{-1} x\right)}\\
y' &= \frac{1}{\sqrt{1-x^2}}
\end{aligned}</script><h3 id="cos-1-x-’-frac-1-sqrt-1-x-2"><a href="#cos-1-x-’-frac-1-sqrt-1-x-2" class="headerlink" title="$(\cos^{-1} x)’ = -\frac{1}{\sqrt{1-x^2}}$"></a>$(\cos^{-1} x)’ = -\frac{1}{\sqrt{1-x^2}}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\cos y &= x\\
-\sin y \cdot y' &= 1\\
y' &= \frac{1}{-\sin \left(\cos^{-1} x\right)}\\
y' &= - \frac{1}{\sqrt{1-x^2}}
\end{aligned}</script><h3 id="tan-1-x-’-frac-1-1-x-2"><a href="#tan-1-x-’-frac-1-1-x-2" class="headerlink" title="$(\tan^{-1} x)’ = \frac{1}{1+x^2}$"></a>$(\tan^{-1} x)’ = \frac{1}{1+x^2}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\tan y &= x\\
\sec^2 y \cdot y' &=1\\
y' &= \frac{1}{\sec^2\left(\tan^{-1}x\right)}\\
\because \sec^2 \theta - 1 &= \left(\sec \theta \cdot \sqrt{1-\frac{1}{\sec^2 \theta }}\right)^2 = \tan^2 \theta\\
\therefore y'&= \frac{1}{1+x^2}
\end{aligned}</script><h3 id="cot-1-x-’-frac-1-1-x-2"><a href="#cot-1-x-’-frac-1-1-x-2" class="headerlink" title="$(\cot^{-1} x)’ = - \frac{1}{1+x^2}$"></a>$(\cot^{-1} x)’ = - \frac{1}{1+x^2}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\cot y &= x\\
-\csc^2 y \cdot y' &= 1\\
y' &= -\frac{1}{\csc^2 \left( \cot^{-1} x\right)}\\
\because \csc^2 \theta -1 &= \left( \csc x \sqrt{1-\frac{1}{\csc^2 x} }\right)^2 = \cot^2 x\\
y' &= -\frac{1}{x^2+1}
\end{aligned}</script><h3 id="sec-1-x-’-frac-1-x-sqrt-x-2-1"><a href="#sec-1-x-’-frac-1-x-sqrt-x-2-1" class="headerlink" title="$(\sec^{-1} x)’ = \frac{1}{x\sqrt{x^2 - 1}}$"></a>$(\sec^{-1} x)’ = \frac{1}{x\sqrt{x^2 - 1}}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\sec y &= x\\
\sec y' \cdot \tan y' \cdot y' &= 1\\
y' &= \frac{1}{\sec\left(\sec^{-1}{x}\right) \tan \left( \sec^{-1} x\right)}\\
y' &= \frac{1}{x\sqrt{x^2-1}}
\end{aligned}</script><h3 id="csc-1-x-’-frac-1-x-sqrt-x-2-1"><a href="#csc-1-x-’-frac-1-x-sqrt-x-2-1" class="headerlink" title="$(\csc^{-1} x)’ = - \frac{1}{x\sqrt{x^2 - 1}}$"></a>$(\csc^{-1} x)’ = - \frac{1}{x\sqrt{x^2 - 1}}$</h3><script type="math/tex; mode=display">
\begin{aligned}
\csc y &= x\\
-\csc y' \cdot \cot y' \cdot y' &= 1\\
y' &= -\frac{1}{\csc\left(\csc^{-1}{x}\right) \cot \left(\csc^{-1} x\right)}\\
y' &= \frac{1}{x\sqrt{x^2-1}}
\end{aligned}</script>]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ2743 「JOI Open 2016」摩天大楼</title>
    <url>/2020/03/20/LOJ2743-%E3%80%8CJOI-Open-2016%E3%80%8D%E6%91%A9%E5%A4%A9%E5%A4%A7%E6%A5%BC/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>假设 $A$ 按照从小到大排好序之后得到的数组是 $B$ 。对于相邻的两个位置，假设其中一个是 $B_i$ ，另一个是 $B_j$ ，其中 $i&lt;j$ ，那么这两个位置对 $\sum |f_i - f_{i+1}|$ 的贡就是 $B_j - B_i = \sum_{k=i}^{j-1} (B_{i+1}-B_i)$ 。这个式子启发我们，对每个 $B_{i+1} - B_i$ 算有多少对相邻的位置满足其中一个数 $\le B_i$ 另一个 $\ge B_{i+1}$ ，就能得到 $\sum |f_{i+1}-f_i|$ 。这也等价于我们把所有 $\le B_i$ 的数插入之后得到的序列中，极大连续段的端点数。</p>
<p>设 $f_{i,j,k,d}$ 表示已经插入了 $i$ 个数，插入了的数在序列中形成了 $j$ 个极长的连续段，已经统计过的 $\sum |f_i-f_{i+1}|$ 的贡献和是 $k$ ，两个端点是否被占用过，对应的方案数。转移 $O(1)$ ，最后的答案是 $\sum_{j\le m} f_{n,1,j,2}$ ，总复杂度 $O(n^2m)$ 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/769208" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC026D Histogram Coloring</title>
    <url>/2020/03/20/AGC026D-Histogram-Coloring/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>考虑给一个第一行确定的矩形涂色的方案数：</p>
<ul>
<li>第一行是红蓝交错的（RBRBRBR…或者BRBRBRB…）<ul>
<li>那么，接下来的每一行都有恰好两种选择，RBRBR…或者BRBRBR…，方案数是 $2^{n-1}$ </li>
</ul>
</li>
<li>第一行存在两个相邻的位置颜色相同<ul>
<li>显然在第二行中，那两个位置的颜色也是相同的；以此类推，这个矩形中的每一行都会有两个相邻的位置颜色相同</li>
<li>对于第二行来说，由于上一行和这一行的至少两个格子的颜色是确定的，所以第二行每个格子的颜色都是确定的；后面的行也是同理</li>
<li>所以涂色的方案数是 $1$</li>
</ul>
</li>
</ul>
<p>考虑按照区间最小值进行分治，按照 $[1,n]$ 的最小值的出现位置把区间割开，对每个子区间分治下去，求出每个区间内：红蓝交错/不红蓝交错地填到区间最小值-1的高度的方案数，记为 $f_{l,r,0/1}$ 。</p>
<p><img src="https://i.loli.net/2020/03/20/6XYyhN7aCkvzmZg.png" alt=""></p>
<p>图中紫色的框出的是每一个子区间，红色标出每个子区间的 $f_{l,r,0/1}$ 考虑过的格子，蓝色标出大区间的 $f_{l,r,0/1}$ 需要考虑的格子。</p>
<p>合并子区间的信息，得到大区间的 $f_{l,r,0/1}$ 。直接算 $f_{l,r,1}$ 比较困难，可以考虑算总方案数，然后用总方案数减去 $f_{l,r,0}$ 。具体细节参见代码。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://atcoder.jp/contests/agc026/submissions/11021955" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF908G New Year and Original Order</title>
    <url>/2020/03/20/CF908G-New-Year-and-Original-Order/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>设 $c_i(0\le i\le 9)$ 表示 $i$ 这个数字在 $k$ 中出现了几次，则</p>
<script type="math/tex; mode=display">
\begin{aligned}
Ans &= \sum_{k=1}^X \sum_{i=1}^9 i \cdot \frac{10^{\sum_{j=i}^9 c_j}-10^{\sum_{j=i+1}^9 c_j}}{9}\\
&= \sum_{k=1}^X \sum_{i=1}^9 \sum_{y=1}^i \frac{10^{\sum_{j=i}^9 c_j}-10^{\sum_{j=i+1}^9 c_j}}{9}\\
&= \sum_{k=1}^X \sum_{y=1}^9 \sum_{i=y}^9 \frac{10^{\sum_{j=i}^9 c_j}-10^{\sum_{j=i+1}^9 c_j}}{9}\\
&= \sum_{k=1}^X \sum_{y=1}^9 \frac{10^{\sum_{j=y}^9 c_j}-1}{9}\\
\end{aligned}</script><p>在最外层枚举 $y$ 之后，可以用数位 dp 在 $O(\lg^2 X)$ 的时间内算出答案。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://codeforces.com/contest/908/submission/73772415" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC002E Candy Piles</title>
    <url>/2020/03/19/AGC002E-Candy-Piles/</url>
    <content><![CDATA[<p>简单转化之后（可以参考<a href="http://agc002.contest.atcoder.jp/data/agc/002/editorial.pdf" target="_blank" rel="noopener">官方题解</a>），变成了：网格中有个阶梯形状的轮廓线，棋子从 $(0,0)$ 开始走，每次可以往左走或者往上走，走到边界的那一步的操作者输（即，边界上的点是必胜态）。</p>
<p>可以证明，如果 $(x+1,y+1)$ 不在边界上，那么 $(x,y)$ 的胜负状态和 $(x+1,y+1)$ 的胜负状态相同。</p>
<p>证明：</p>
<p>1）可以从 $(x+1,y+1)$ 为必败态推出 $(x,y)$ 为必败态：如果 $(x+1,y+1)$ 必败，那么 $(x,y+1), (x+1,y)$ 都是必胜态，那么 $(x,y)$ 就必败。</p>
<p>2）可以从 $(x+1,y+1), (x+2,y+2)$ 是必胜态推出 $(x,y)$ 是必胜态：$(x+3,y+2)$ 和 $(x+2,y+3)$ 中至少有一个是必败态，我们假设 $(x+3,y+2)$ 是必败态，可以推出：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>\</th>
<th>x</th>
<th>x+1</th>
<th>x+2</th>
<th>x+3</th>
</tr>
</thead>
<tbody>
<tr>
<td>y+2</td>
<td>*</td>
<td>*</td>
<td><em>1</em></td>
<td><em>0</em></td>
<td></td>
</tr>
<tr>
<td>y+1</td>
<td>*</td>
<td><em>1</em></td>
<td>0 (b)</td>
<td>1 (a)</td>
<td></td>
</tr>
<tr>
<td>y</td>
<td>1 (e)</td>
<td>0 (d)</td>
<td>1 (c)</td>
<td>*</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>其中，* 表示不确定，斜体表示已知的条件，(a) ~ (e) 代表推理的顺序。</p>
<p>对于 $(x+2,y+3)$ 必败的情况可以同理证明。</p>
<p>代码实现：从 $(0,0)$ 出发往右上走，直到下一步会碰到边界，然后算出其上方和右边的格子的状态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) rd(a[i]);</span><br><span class="line">	sort(a,a+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(y+<span class="number">1</span>&lt;a[x+<span class="number">1</span>]) x++,y++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> t1=!((a[x]-(y+<span class="number">1</span>))&amp;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> r=x; <span class="keyword">while</span>(y&lt;a[r+<span class="number">1</span>]) r++;</span><br><span class="line">	<span class="keyword">int</span> t2=!((r+<span class="number">1</span>-(x+<span class="number">1</span>))&amp;<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!(t1&amp;t2)) <span class="built_in">printf</span>(<span class="string">"First"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Second"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ346 【清华集训2017】某位歌姬的故事</title>
    <url>/2020/03/09/UOJ346-%E3%80%90%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%E3%80%91%E6%9F%90%E4%BD%8D%E6%AD%8C%E5%A7%AC%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>分开考虑 $h$ 不同的限制。每个的位置的值在包含它的、 $h$ 最小的限制那里确定。</p>
<p>对于某个确定的 $h$ ，如果有两个限制满足 $l_1\le l_2\le r_2\le r_1$ 的，只保留 $[l_2,r_2]$ 就可以了（注意最后要给答案乘上给 $[l_1,l_2)\cup (r_2,r_1]$ 赋值的方案数）。这样处理以后，限制的区间的左右端点都是单调的。</p>
<p>然后，将区间按照端点位置排序之后，考虑极长的、相邻的两个区间都有交的段，对每个段单独统计方案数。</p>
<p>考虑容斥（即区间内所有数都 $\le h$ 的方案数 - 区间内所有数都 $\le h-1$ 的方案数）。设 $f_{i,j}$ 为考虑了前 $i$ 个区间、上一个要求所有数 $\le h-1$ 的区间右端点是 $j$ 时，给 $\le j$ 的位置赋值的方案数 * 对应的容斥系数。每次枚举下一个要求所有数 $\le h-1$ 的区间是谁进行转移即可。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="http://uoj.ac/submission/386686" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3046 「ZJOI2019」语言</title>
    <url>/2020/03/07/LOJ3046-%E3%80%8CZJOI2019%E3%80%8D%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>考虑对每个点算出能够与它进行贸易活动的点数，也就是到它的路径被那 $m$ 条路径中的某一条完全包含的点数。</p>
<p>对原树进行链分治（重链剖分），这样每条路径最多会经过 $\log n$ 条链。</p>
<p>对每条链考虑，经过了它的路径长这样：</p>
<p><img src="https://i.loli.net/2020/03/07/3dRAXn2xeM1B6Qt.png" alt=""></p>
<p>黑色代表那条链，其它每种颜色代表了一条路径。</p>
<p>对于这条链上的一个点，它能进行贸易的点数实际上就是：那些左端点在这个点左侧、右端点在这个点右侧的路径，它们的端点的虚树大小。</p>
<p>对链上的点扫描线，并动态维护满足条件的路径的虚树大小即可。</p>
<p>复杂度 $O(n\log ^ 2 n)$ 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/760970" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3042 「ZJOI2019」麻将</title>
    <url>/2020/03/05/LOJ3042-%E3%80%8CZJOI2019%E3%80%8D%E9%BA%BB%E5%B0%86/</url>
    <content><![CDATA[<p>参考 <a href="https://blog.csdn.net/qq_39972971/article/details/88981526" target="_blank" rel="noopener">cz_xuyixuan的blog</a></p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>把原问题转化成 $\sum_{i=0}^\infty P(S_i 不存在一个子集能胡)$ 。要算这个玩意则需要对每个 $i$ ，求出大小为 $i$ 且加上初始的牌之后不存在胡子集的子集的数量。</p>
<p>怎样判断一副牌能不能胡：</p>
<ol>
<li>如果有不少于 $7$ 种牌，每种牌的数量都不少于 $2$ ，就能胡；</li>
<li>设 $f_{i,x,y,0/1}$ 表示考虑了前 $i$ 种牌，从 $i-1$ 开始的 $(a,a+1,a+2)$ 型的面子有 $x$ 个，从 $i$ 开始的 $(a,a+1,a+2)$ 型的面子有 $y$ 个，前 $i$ 种牌是否凑出过对子，这种情况下能够得到的面子数量的最大值（不包括从 $i,i-1$ 开始的 $(a,a+1,a+2)$ 型面子）。由于三个 $(a,a+1,a+2)$ 型的面子可以转化成三个 $(a,a,a)$ 型的面子，所以 $0\le x,y &lt; 3$ 。如果 $f_{n,x,y,1} \ge 4$ ，就能胡；</li>
</ol>
<p>把 $f_i$ 每个位置的取值、以及能凑出对子的牌的数量，作为 dp 的状态进行 dp 即可。搜索发现状态数不超过 3227 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/759458" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown preview enhanced 以及 hexo 中的行间公式换行符问题</title>
    <url>/2020/03/04/markdown-preview-enhanced-%E4%BB%A5%E5%8F%8A-hexo-%E4%B8%AD%E7%9A%84%E8%A1%8C%E9%97%B4%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>在使用 <code>vscode</code> 的 <code>markdown preview enhanced</code> 进行预览的时候，经常会出现这种情况：如果行间公式包含了 <code>\\</code> ，预览就会显示：<code>ParseError: KaTeX parse error: \cr valid only within a tabular/array environment</code> 。重启 <code>vscode</code> 就能恢复正常。</p>
<p>最近无意中发现，如果把公式用 <code>\begin{aligned}</code> 和 <code>\end{aligned}</code> 包围起来，就不会出现上面的问题。</p>
<p><img src="https://i.loli.net/2020/03/04/axokF4XUdT7uqQ6.jpg" alt=""></p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>我最近重装了 <code>hexo</code> ，可能是配置的问题，行间公式里面的 <code>\\</code> 全部都没有换行。</p>
<p><img src="https://i.loli.net/2020/03/04/qiH6rVBmd7NLZ5l.jpg" alt=""><br><img src="https://i.loli.net/2020/03/04/MDGLWf1OtgrjRmH.jpg" alt=""></p>
<p>上图中，两个公式之间本来应该有一个换行，但是却挤在了一行。</p>
<p>我发现，把公式用 <code>\begin{aligned}</code> 和 <code>\end{aligned}</code> 包围起来，就可以正常换行了，效果如下</p>
<p><img src="https://i.loli.net/2020/03/04/D6NOPGvhljZmIrk.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ3053 「十二省联考 2019」希望</title>
    <url>/2020/03/04/LOJ3053-%E3%80%8C%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%83-2019%E3%80%8D%E5%B8%8C%E6%9C%9B/</url>
    <content><![CDATA[<h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><h3 id="0"><a href="#0" class="headerlink" title="0"></a>0</h3><p>部署方案合法的条件是：存在一个点$u$，使得所有搜救范围都包含$u$且所有在搜救范围中出现过的点到$u$的距离不超过$L$。此时我们称部署方案可以被点$u$识别。</p>
<p>定义一种部署方案可以被一条边识别，当且仅当这条边的两个端点都能识别它。</p>
<p>显然，对于某种部署方案，可以识别它的$u$会构成一个连通块，而连通块点数 - 边数 = 1。所以，（每个点可以识别的部署方案数 - 每条边可以识别的部署方案数）就是答案。</p>
<p>设$s_u$表示包含$u$且所有点到$u$的距离均不超过$L$的连通块数，设$s_{(x,y)}$表示既包含在$s_x$里又包含在$s_y$里的连通块数，则</p>
<script type="math/tex; mode=display">
Ans = \sum_u s_u^k - \sum_{(x,y) \in T} s_{(x,y)}^k</script><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>用$dp$计算$s_u,s_{(x,y)}$。</p>
<p>设$f_{u,j}$表示只包含$u$子树内的点，且所有点到$u$的距离不超过$j$，且包含了$u$的连通块数。设$g_{u,j}$表示包含了$u$的父亲$fa_u$，且不包含$u$的子树内的点，且所有点到$fa_u$的距离不超过$j$的连通块数。距离定义为两个点之间最短路上的边数。</p>
<p>则</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{u,j} = \prod_{v\in son_u} (f_{v,j-1}+1) - 1\\
g_{u,j} = (g_{fa_u,j-1}+1)\prod_{v\in son_{fa_u},v\neq u}(f_{v,j-1}+1)\\
s_u = f_{u,L}\cdot (g_{u,L-1}+1),s_{(u,fa_u)}=f_{u,L-1}\cdot g_{u,L-1}
\end{aligned}</script><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>用长链剖分优化dp。</p>
<p>设$len_u$表示$u$的子树中深度最深的点到$u$的距离。观察可知$f_{u,len_u} = f_{u,len_u+1} = f_{u,len_u+2} \cdots$，所以我们只需要算$f_{u,0},f_{u,1},\cdots f_{u,len_u}$就可以了。</p>
<p>处理某个点的$f$的时候，直接让它继承重儿子的信息（这一步要求支持全局+1的操作）。合并轻儿子$v$的时候，对于$f_{v,0},f_{v,1}\cdots f_{v,len_v}$可以直接暴力，剩下的相当于是令$f_u$数组的一个后缀乘上$f_{v,len_v}$。</p>
<p>如果$f_{v,len_v}$不为$0$的话，我们可以让$f_{u,0},f_{u,1} \cdots f_{u,len_v}$都乘上$f_{v,len_v}$的逆元（注意，不应是直接对数组中的数进行乘$f_{v,len_v}$的逆元的操作，而应该将数组中的值赋为“经过当前的全局标记的运算之后为$f_{u,i}\over f_{v,len_v}$”的值），然后打上全局乘以$f_{v,len_v}$的标记。</p>
<p>如果$f_{v,len_v}$为$0$，就相当于是让一段后缀都变成了$0$，我们可以另外维护一个标记$(l,x)$，表示从$l$开始的位置，数组中的值都是$x$（同理，$x$不一定是$0$，而是“经过当前的全局标记的运算之后为$0$”的值）。</p>
<p>$g$的维护则要更加麻烦一些。首先，我们将所有的链分成两类：长度小于$L-1$的，我们只需要记录链顶元素$u$的$g_{u,L-1-len_u},g_{u,L-1-len_u+1} \cdots g_{u,L-1}$就能够算出这个子树内所有点的$g_{v,L-1}$；长度大于等于$L-1$的，记录链顶元素的$u$的$g_{u,0},g_{u,1} \cdots g_{u,L-1}$即可。而从某个点到它的重儿子时，$g_u$的长度至多加$1$。这样状态数降到了$O(n)$。</p>
<p>直接让重儿子继承当前点的$g$（这个也要求支持全局+1），然后把其他儿子的贡献$(f_{v,j}+1)$合并上来（这个需要支持对后缀的乘法，与$f$的处理类似）。而对于轻儿子$v$，把$\prod_{v’\in son_u,v’\neq v}(f_{v’,j}+1)$分为三部分：1.在我们处理这个轻儿子之前遍历过的轻儿子的贡献；2.还没有遍历过的轻儿子的贡献；3.重儿子的贡献。按照$len$从小到大的顺序依次处理轻儿子，就能够及其方便地统计在当前的轻儿子之前遍历过的轻儿子的贡献；在计算$f$的时候，我们按照轻儿子的$len$从大到小的顺序来合并，把$v$被并入之后的我们对$f$的那些操作撤销掉，就可以得到$v$被并入之前的$f$，也就是2. 3.两部分的贡献。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>将儿子按照$len$排序，可以先把重儿子找出来，然后对剩下的进行基数排序。这样总复杂度为$O(n)$。</p>
<p>实际上我们需要用到的逆元只有每个点的$f_{u,len_u}$，可以在$O(n)$的时间预处理出它们的逆元。</p>
<p>总复杂度$O(n)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://loj.ac/submission/733990" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF582D Number of Binominal Coefficients</title>
    <url>/2020/03/03/CF582D-Number-of-Binominal-Coefficients/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>如何判断 $p^\alpha \mid \binom{n}{k}$ 是否成立：只需要知道 $\binom{n}{k}$ 中 $p$ 的次数是否大于等于 $\alpha$ 。</p>
<p>设 $f(n)$ 为 $n!$ 中 $p$ 的次数，显然有 $f(n) = \sum_{i=1}^\infty \lfloor \frac{n}{p^i} \rfloor$。而我们要做的就是检查 $f(n)-f(k)-f(n-k)$ 是否成立。</p>
<p>$f(n)$ 实际上相当于：$n$ 的 $p$ 进制表示去掉最后一位后的值 + $n$ 的 $p$ 进制表示去掉最后两位后的值 + $n$ 的 $p$ 进制表示去掉最后三位后的值 ……</p>
<p>考虑 $f(a+b)$ 和 $f(a)+f(b)$ 的区别：如果 $a+b$ 在 $p$ 进制下没有进位，那么两者显然相同；考虑如果 $a+b$ 在 $p^k$ 这一位进位了，那么相较于 $f(a)+f(b)$ ，$f(a+b)$ 在 $i\le k$ 的时候的贡献是不变的，但是在 $i=k+1$ 的时候就会多贡献 $1$ 。又因为这是两个数的加法，每一位至多进位一次，所以不会出现在第 $k$ 位的进位贡献到第 $k+2$ 位的情况。所以 $f(a+b)-(f(a)+f(b))$ 就是 $a+b$ 在 $p$ 进制加法中进位的次数。</p>
<p>令 $a=k,b=n-k$ ，我们相当于要统计满足 $0\le a,0\le b, a+b\le A$ 且 $a+b$ 进位次数不小于 $\alpha$ 的 $(a,b)$ 的数量。这是一个基础的数位 dp 问题。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://codeforces.com/contest/582/submission/72292629" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI2018 你的名字</title>
    <url>/2020/03/01/NOI2018-%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>答案相当于 $T$ 中不被 $S_{l\cdots r}$ 包含的本质不同的子串数量。</p>
<p>求出 $T$ 中被 $S_{l\cdots r}$ 包含了的本质不同的子串数量，用 $T$ 的本质不同的子串数量减去它就是答案。后者容易求，我们考虑怎么求前者。</p>
<h4 id="部分分：-l-1-r-S"><a href="#部分分：-l-1-r-S" class="headerlink" title="部分分：$l=1,r=|S|$"></a>部分分：$l=1,r=|S|$</h4><p>对 $T$ 建出 SAM ，然后对 SAM 中的每个节点，考虑这个节点代表的子串集合的贡献。这个集合形如“ $T$ 的某个子串 $w$ 的所有长度不小于 $minlen$ 的后缀”。我们只需要知道 $w$ 最长的、在 $S$ 中出现过的后缀是谁，就能够统计这个集合中有多少个串在 $S$ 中出现过（长度更短的都出现过，长度更长的都没有出现过）。更进一步观察发现，我们其实只需要知道，以 $w$ 结尾的那个前缀，它的最长的、在 $S$ 中出现过的后缀是谁，就可以了（ $w$ 的最长的在 $S$ 中出现过的后缀长度就是那个后缀的长度和 $|w|$ 的较小值）。</p>
<p>这是个经典的后缀自动机问题。对 $S$ 建出 SAM ，然后让 $T$ 在 $S$ 上面跑匹配就可以了。具体地，维护一个 <code>u</code> 表示当前的位置，<code>len</code> 表示当前匹配上了的长度。每次从 <code>u</code> 走向 <code>ch[u][T[i]]</code> 的时候，就把变成 <code>len+1</code>；如果转移不存在，就从 <code>u</code> 跳到 <code>fail[u]</code> ， <code>len</code> 变成现在的 <code>u</code> 中最长的子串的长度。复杂度分析：一次跳 <code>fail</code> 会让匹配长度至少减少 1 ，而一次 <code>u -&gt; ch[u][T[i]]</code> 则会让匹配长度 + 1 ，匹配长度总是非负并且整个过程中匹配的长度只会增加 $|T|$ 次，所以复杂度是 $O(|T|)$ 的。</p>
<h4 id="l-r-任意"><a href="#l-r-任意" class="headerlink" title="$l,r$ 任意"></a>$l,r$ 任意</h4><p>考虑对前面在 SAM 的匹配做一些修改：我们称一个节点“存在”，当且仅当它所代表的子串集合中，最短的那个串在 $S_{l\cdots r}$ 中出现过。那么匹配过程中我们相当于需要支持：</p>
<ul>
<li>查询一个点是否存在</li>
<li>查询一个点所代表的子串集合中，在 $S_{l\cdots r}$ 中出现过的、最长的串</li>
</ul>
<p>第一问：设这个节点的子串集合中最短的串长度是 $minlen$ 。用可持久化线段树合并维护出每个节点的 endpos 集合，查询 $[l+minlen-1, r]$ 这个区间内是否有这个节点的 endpos 即可。</p>
<p>第二问：找出 $[l+minlen-1, r]$ 中最靠右的那个 endpos ，它到 $l$ 的距离和这个节点代表的最长子串长度的较小值即为答案。</p>
<p>具体细节见代码。</p>
<h4 id="附：可持久化线段树合并的空间复杂度"><a href="#附：可持久化线段树合并的空间复杂度" class="headerlink" title="附：可持久化线段树合并的空间复杂度"></a>附：可持久化线段树合并的空间复杂度</h4><p>可能有锅，欢迎指正。</p>
<p>分成两个部分：</p>
<ol>
<li>将 $n$ 个节点插进 $n$ 棵不同的树。</li>
<li>合并两棵树，并复制两棵树的公共部分，得到一棵新的树。</li>
</ol>
<p>第一部分会用到至多 $n\lceil\log_2 n\rceil$ 个节点。</p>
<p>第二部分中，考虑每个非叶子节点：每一次复制它，它子树内的叶子节点数量一定变多了，所以它被复制的次数至多是它子树内的叶子节点数量。每个叶子至多在 $\lceil \log_2 n\rceil$ 个节点的子树中，所以复制节点的次数至多是 $n\lceil\log_2 n\rceil$ 次。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/756501" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>Comet #3 F 毒瘤的菜菜子</title>
    <url>/2020/02/29/Comet-3-F-%E6%AF%92%E7%98%A4%E7%9A%84%E8%8F%9C%E8%8F%9C%E5%AD%90/</url>
    <content><![CDATA[<p><a href="https://www.cometoj.com/contest/38/problem/F?problem_id=1545" target="_blank" rel="noopener">link to the problem</a></p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>设 $s(a,b,c,d) = \sum_{i=a}^b \sum_{j=c}^d [ a_i \mid a_j ] + [ a_j \mid a_i ]$</p>
<p>考虑莫队，相当于将原问题转化成了 $O(n)$ 次形如 $\sum_{i=r+1}^{r’} s(l,i-1,i,i)$ 或 $\sum_{i=l’}^{l-1} s(i+1,r,i,i)$ 的询问（分别对应了左端点和右端点的移动）。</p>
<p>差分一下得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=r+1}^{r'} s(l,i-1,i,i) = \sum_{i=r+1}^{r'} s(1,i-1,i,i) - s(1,l-1,i,i)\\
\sum_{i=l'}^{l-1} s(i+1,r,i,i) = \sum_{i=l'}^{l-1} s(1,r,i,i) - s(1,i,i,i)
\end{aligned}</script><p>这样我们就把原问题转化成了 $O(n)$ 个形如 $\sum_{i=l}^r s(1,p,i,i)$ 的询问，并且 $\sum r-l = O(n\sqrt n)$。</p>
<p>考虑扫描线，那么我们要支持的操作就是：</p>
<ul>
<li>加入一个数</li>
<li>给出一个区间，枚举这个区间中的每一个数 $x$ ，查询已经加入的数中<br> 1) 有多少个数是 $x$ 的倍数<br> 2) 有多少个数是 $x$ 的因数</li>
</ul>
<p>对于第一问：每加入一个数，我们就枚举它所有的约数、打上标记，查询的时候直接返回 $x$ 的标记即可。</p>
<p>对于第二问：我们考虑对加入的数进行根号分治。对于超过 $\sqrt n$ 的数，直接枚举它所有的倍数打上标记；对于小于等于 $\sqrt n$ 的数，我们枚举所有的 $y\in [1,\sqrt n]$ ，然后处理出序列的每个前缀中有多少个数是 $y$ 的倍数（以支持查询一个区间内有多少个数是 $y$ 的倍数），扫描线的时候维护前 $p$ 个位置有多少个数等于 $y$ 即可。</p>
<p>总时间复杂度 $O(n\sqrt n)$ ，空间复杂度 $O(n)$ 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://www.cometoj.com/status/xscggv2xwqii3464k8bnj39h4di2dhi8" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3744 Gty的妹子序列</title>
    <url>/2020/02/29/BZOJ3744-Gty%E7%9A%84%E5%A6%B9%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p><a href="https://www.cnblogs.com/zzqsblog/p/7522528.html" target="_blank" rel="noopener">参考了zzq的blog</a></p>
<p>考虑分块。对于一次询问，涉及到的元素有如下的形式：</p>
<p><img src="https://i.loli.net/2020/02/29/ZCrAkeET4JOj31X.png" alt=""></p>
<p>讨论逆序对中的两个元素分别属于哪个部分，即得到一个时间复杂度 $O(n\sqrt n)$ ，空间复杂度 $O(n\sqrt n)$ 的算法：</p>
<h5 id="x-in-A-y-in-A"><a href="#x-in-A-y-in-A" class="headerlink" title="$x\in A,y\in A$"></a>$x\in A,y\in A$</h5><p>预处理每个块的每个后缀中的逆序对数。</p>
<h5 id="x-in-C-y-in-C"><a href="#x-in-C-y-in-C" class="headerlink" title="$x\in C,y\in C$"></a>$x\in C,y\in C$</h5><p>预处理每个块的每个后缀中的逆序对数。</p>
<h5 id="x-in-B-y-in-B"><a href="#x-in-B-y-in-B" class="headerlink" title="$x\in B,y\in B$"></a>$x\in B,y\in B$</h5><p>预处理出 $f_{i,j}$ 表示第 $i$ 块到第 $j$ 块这个区间中的元素两两之间的逆序对数。</p>
<p>具体地，先对每个块预处理出块内的元素排序后的结果，然后归并求出 $g_{i,j}$ 表示第 $i$ 块和第 $j$ 块中的元素两两之间的逆序对数。这一步的复杂度是 $O(n\log n + \sqrt n \cdot (\sqrt n)^2 ) = O(n\sqrt n)$ 。</p>
<p>然后对 $g_{i,j}$ 做个类似区间 dp 的东西就能得到 $f$ （即：$f_{i,j} = g_{i,j} + f_{i,j-1} + f_{i+1,j} - f_{i+1,j-1}$）。这一步的复杂度是 $O((\sqrt n)^2) = O(n)$ 。</p>
<h5 id="x-in-A-y-in-B"><a href="#x-in-A-y-in-B" class="headerlink" title="$x\in A,y\in B$"></a>$x\in A,y\in B$</h5><p>预处理出 $s_{i,j}$ 表示前 $i$ 块中小于等于 $j$ 的数有多少个，然后枚举 $A$ 中的每一个数进行查询就好。预处理复杂度 $O(n\sqrt n)$ ，单次查询的复杂度 $O(\sqrt n)$ 。空间复杂度是 $O(n\sqrt n)$ 。</p>
<h5 id="x-in-B-y-in-C"><a href="#x-in-B-y-in-C" class="headerlink" title="$x\in B,y\in C$"></a>$x\in B,y\in C$</h5><p>同 $x\in A, y\in B$ 。</p>
<h5 id="x-in-A-y-in-C"><a href="#x-in-A-y-in-C" class="headerlink" title="$x\in A,y\in C$"></a>$x\in A,y\in C$</h5><p>对 $A$ 所在的整块和 $C$ 所在的整块进行归并，复杂度 $O(\sqrt n)$ 。</p>
<p>具体地，归并的时候每加入一个 $C$ 中的元素，就让 <code>cnt++</code> ；每加入一个 $A$ 中的元素，就让 <code>ans+=cnt</code> 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">260</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">	<span class="keyword">int</span> a[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">I</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> t)</span> </span>&#123; <span class="keyword">for</span>(;i&lt;=m;i+=i&amp;-i) a[i]+=t; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="keyword">for</span>(;i;i-=i&amp;-i) ans+=a[i]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bel[N],T;</span><br><span class="line"><span class="keyword">int</span> pos[N],s[M][N];</span><br><span class="line"><span class="keyword">int</span> f[M][M],pre[N],suf[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmppos</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> a[x]==a[y]?x&lt;y:a[x]&lt;a[y]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lv,<span class="keyword">int</span> rv)</span> </span>&#123; <span class="keyword">return</span> s[x][rv]-s[x][lv<span class="number">-1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> lv,<span class="keyword">int</span> rv)</span> </span>&#123; <span class="keyword">return</span> Qry(r,lv,rv)-Qry(l<span class="number">-1</span>,lv,rv); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ql,qr,lastans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]),b[i]=a[i];</span><br><span class="line">	sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>); m=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=lower_bound(b+<span class="number">1</span>,b+m+<span class="number">1</span>,a[i])-b;</span><br><span class="line">	</span><br><span class="line">	T=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) bel[i]=(i<span class="number">-1</span>)/T+<span class="number">1</span>,pos[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=T) &#123;</span><br><span class="line">		<span class="keyword">int</span> len=min(T,n-i+<span class="number">1</span>);</span><br><span class="line">		sort(pos+i,pos+i+len,cmppos);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) s[bel[i]][j]=s[bel[i]<span class="number">-1</span>][j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+len;++j) s[bel[i]][a[j]]++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+len;++j) pre[j]=BIT::Q(m-(a[j]+<span class="number">1</span>)+<span class="number">1</span>),BIT::I(m-a[j]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+len;++j) BIT::I(m-a[j]+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+len<span class="number">-1</span>;j&gt;=i;--j) suf[j]=BIT::Q(a[j]<span class="number">-1</span>),BIT::I(a[j],<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+len<span class="number">-1</span>;j&gt;=i;--j) BIT::I(a[j],<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;i+len;++j) pre[j]+=pre[j<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+len<span class="number">-2</span>;j&gt;=i;--j) suf[j]+=suf[j+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bel[n];++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) s[i][j]+=s[i][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bel[n];++i) f[i][i]=suf[(i<span class="number">-1</span>)*T+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+<span class="number">1</span>&lt;=bel[n];++i) f[i][i+<span class="number">1</span>]=suf[(i<span class="number">-1</span>)*T+<span class="number">1</span>]+suf[i*T+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=bel[n];++l)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> r=l+<span class="number">1</span>;r&lt;=bel[n];++r) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> pl=(l<span class="number">-1</span>)*T+<span class="number">1</span>,liml=l*T;</span><br><span class="line">			<span class="keyword">int</span> pr=(r<span class="number">-1</span>)*T+<span class="number">1</span>,limr=min(r*T,n);</span><br><span class="line">			<span class="keyword">while</span>(pl&lt;=liml||pr&lt;=limr)</span><br><span class="line">				<span class="keyword">if</span>(pl&lt;=liml&amp;&amp;(pr&gt;limr||a[pos[pl]]&lt;=a[pos[pr]]))</span><br><span class="line">					f[l][r]+=cnt,pl++;</span><br><span class="line">				<span class="keyword">else</span> cnt++,pr++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=bel[n];++len)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=bel[n];++l) &#123;</span><br><span class="line">			<span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">			f[l][r]+=f[l+<span class="number">1</span>][r]+f[l][r<span class="number">-1</span>]-f[l+<span class="number">1</span>][r<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">int</span> q; rd(q);</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		rd(ql),rd(qr);</span><br><span class="line">		ql^=lastans,qr^=lastans;</span><br><span class="line">		<span class="keyword">if</span>(ql&gt;qr) swap(ql,qr);</span><br><span class="line">		<span class="keyword">if</span>(bel[ql]==bel[qr]) &#123;</span><br><span class="line">			<span class="keyword">int</span> pl=(bel[ql]<span class="number">-1</span>)*T+<span class="number">1</span>,pr=min(bel[ql]*T,n);</span><br><span class="line">			<span class="keyword">if</span>(ql==pl) lastans=pre[qr];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(qr==pr) lastans=suf[ql];</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				lastans=pre[qr]-pre[ql<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=pl;i&lt;=pr;++i) &#123;</span><br><span class="line">					<span class="keyword">if</span>(pos[i]&gt;=ql&amp;&amp;pos[i]&lt;=qr) cnt++;</span><br><span class="line">					<span class="keyword">if</span>(pos[i]&lt;=ql<span class="number">-1</span>) lastans-=cnt;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> bl=bel[ql]+<span class="number">1</span>,br=bel[qr]<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(ql==(bel[ql]<span class="number">-1</span>)*T+<span class="number">1</span>) bl--;</span><br><span class="line">			<span class="keyword">if</span>(qr==min(bel[qr]*T,n)) br++;</span><br><span class="line">			lastans=f[bl][br]+(bel[ql]==bl?<span class="number">0</span>:suf[ql])+(bel[qr]==br?<span class="number">0</span>:pre[qr]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=ql;bel[i]!=bl;++i) lastans+=Qry(bl,br,<span class="number">1</span>,a[i]<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=qr;bel[i]!=br;--i) lastans+=Qry(bl,br,a[i]+<span class="number">1</span>,m);</span><br><span class="line">			<span class="keyword">if</span>(bel[ql]!=bl&amp;&amp;bel[qr]!=br) &#123;</span><br><span class="line">				<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">int</span> pl=(bl<span class="number">-2</span>)*T+<span class="number">1</span>,liml=(bl<span class="number">-1</span>)*T;</span><br><span class="line">				<span class="keyword">int</span> pr=br*T+<span class="number">1</span>,limr=min((br+<span class="number">1</span>)*T,n);</span><br><span class="line">				<span class="keyword">while</span>(pl&lt;=liml||pr&lt;=limr)</span><br><span class="line">					<span class="keyword">if</span>(pl&lt;=liml&amp;&amp;(pr&gt;limr||a[pos[pl]]&lt;=a[pos[pr]])) &#123;</span><br><span class="line">						<span class="keyword">if</span>(pos[pl]&gt;=ql) lastans+=cnt;</span><br><span class="line">						pl++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span>(pos[pr]&lt;=qr) cnt++;</span><br><span class="line">						pr++;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lastans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3289 Mato的文件管理</title>
    <url>/2020/02/29/BZOJ3289-Mato%E7%9A%84%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>设 $s(l_1,r_1,l_2,r_2) = \sum_{i\in [l_1,r_1]} \sum_{j\in [l_2,r_2]} [i &lt; j \wedge a_i &gt; a_j]$ 。</p>
<p>考虑莫队算法，当右端点从$r-1$移动到$r$的时候，答案的改变量是</p>
<script type="math/tex; mode=display">
s(l,r-1,r,r) = s(1,r-1,r,r) - s(1,l-1,r,r)</script><p>第一项只与 $r$ 有关，可以预处理；第二项中， $[1,l-1]$ 是整个序列的一段前缀。我们把所有第二项的询问都离线下来，然后扫描线处理。注意到总共有 $O(n)$ 次修改以及 $O(n\sqrt n)$ 次询问，我们用修改 $O(\sqrt n)$ ，查询 $O(1)$ 的分块，即可在 $O(n\sqrt n)$ 的复杂度解决问题。</p>
<p>右端点的左移、左端点的移动都是同理。</p>
<p>总时间复杂度 $O(n\sqrt n)$ ，空间复杂度 $O(n)$ 。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],b[N];</span><br><span class="line">ll sl[N],sr[N],qans[N];</span><br><span class="line"><span class="keyword">int</span> bel[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">	<span class="keyword">int</span> c[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) c[i]=<span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">I</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">for</span>(;i&lt;=m;i+=i&amp;-i) c[i]++; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="keyword">for</span>(;i;i-=i&amp;-i) ans+=c[i]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WRY</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,id;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpQ</span><span class="params">(WRY A,WRY B)</span> </span>&#123; <span class="keyword">return</span> bel[A.l]==bel[B.l]?(bel[A.l]&amp;<span class="number">1</span>?A.r&lt;B.r:A.r&gt;B.r):A.l&lt;B.l; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,id,ty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Qry&gt; Pl[N],Pr[N];</span><br><span class="line"><span class="keyword">namespace</span> sol2 &#123;</span><br><span class="line">	<span class="keyword">int</span> bel[N];</span><br><span class="line">	<span class="keyword">int</span> s1[M],s0[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">I</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=x;bel[i]==bel[x];++i) s0[i]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=bel[x];i&lt;=bel[m];++i) s1[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> s1[bel[x]<span class="number">-1</span>]+s0[x]; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> T=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(m));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) bel[i]=(i<span class="number">-1</span>)/T+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">			I(m-a[i]+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Pl[i].size();++j)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=Pl[i][j].l;x&lt;=Pl[i][j].r;++x)</span><br><span class="line">					qans[Pl[i][j].id]+=Pl[i][j].ty*Q(m-a[x]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) s0[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=bel[m];++i) s1[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) &#123;</span><br><span class="line">			I(a[i]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Pr[i].size();++j)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=Pr[i][j].l;x&lt;=Pr[i][j].r;++x)</span><br><span class="line">					qans[Pr[i][j].id]+=Pr[i][j].ty*Q(a[x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cid,L,R;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addR</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	qans[cid]+=t*sr[R];</span><br><span class="line"><span class="comment">//	Pl[L-1].PB(MP(R,-t*cid));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addL</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;	</span><br><span class="line">	qans[cid]+=t*sl[L];</span><br><span class="line"><span class="comment">//	Pr[R+1].PB(MP(L,-t*cid));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	rd(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rd(a[i]),b[i]=a[i];</span><br><span class="line">	sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>),m=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=lower_bound(b+<span class="number">1</span>,b+m+<span class="number">1</span>,a[i])-b;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) sr[i]=BIT::Q(m-a[i]+<span class="number">1</span>),BIT::I(m-a[i]+<span class="number">1</span>); BIT::init();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) sl[i]=BIT::Q(a[i]),BIT::I(a[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> T=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) bel[i]=(i<span class="number">-1</span>)/T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> q; rd(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) rd(Q[i].l),rd(Q[i].r),Q[i].id=i;</span><br><span class="line">	sort(Q+<span class="number">1</span>,Q+q+<span class="number">1</span>,cmpQ);</span><br><span class="line">	L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) &#123;</span><br><span class="line">		cid=Q[i].id;</span><br><span class="line">		<span class="keyword">if</span>(R&lt;Q[i].r) Pl[L<span class="number">-1</span>].PB((Qry)&#123;R+<span class="number">1</span>,Q[i].r,cid,<span class="number">-1</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(R&gt;Q[i].r) Pl[L<span class="number">-1</span>].PB((Qry)&#123;Q[i].r+<span class="number">1</span>,R,cid,<span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">while</span>(R&lt;Q[i].r) R++,addR(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(R&gt;Q[i].r) addR(<span class="number">-1</span>),R--;</span><br><span class="line">		<span class="keyword">if</span>(L&gt;Q[i].l) Pr[R+<span class="number">1</span>].PB((Qry)&#123;Q[i].l,L<span class="number">-1</span>,cid,<span class="number">-1</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(L&lt;Q[i].l) Pr[R+<span class="number">1</span>].PB((Qry)&#123;L,Q[i].l<span class="number">-1</span>,cid,<span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">while</span>(L&gt;Q[i].l) --L,addL(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(L&lt;Q[i].l) addL(<span class="number">-1</span>),L++;</span><br><span class="line">	&#125;</span><br><span class="line">	sol2::main();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) qans[Q[i].id]+=qans[Q[i<span class="number">-1</span>].id];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,qans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>lemon配置捆绑测试</title>
    <url>/2020/02/27/lemon%E9%85%8D%E7%BD%AE%E6%8D%86%E7%BB%91%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>首先添加试题，然后选择“添加多组测试点”。</p>
<p><img src="https://i.loli.net/2020/02/27/RnLUOyA6zrCSgFE.jpg" alt="0.jpg"></p>
<p>在出现的测试点添加向导中，可以直接点击下一步。每个测试点（也就是每个子任务）的时间、空间限制以及分值都是可以在配置完成之后单独调整的。</p>
<p><img src="https://i.loli.net/2020/02/27/L4rGlw7BzxXKODt.jpg" alt="1.jpg"></p>
<p>在输入输出文件格式中，输入 <code>试题名称\文件名称格式</code> 。</p>
<p>其中，打了勾的正则表达式，表示这一项相同的会在同一个测试点（即子任务）中。</p>
<p>可以用 <code>\d*</code> 或者 <code>[0-9]*</code> 来匹配任意数量的数字。</p>
<p>例如，我的第 i 个子任务的第 j 组数据的文件名是 <code>i_j.in/ans</code>，就可以这样写：</p>
<p><img src="https://i.loli.net/2020/02/27/RUvsoZQY59OB1br.jpg" alt="2.jpg"></p>
<p>点击下一步之后，就可以预览配置的结果。如果有问题，则可以点击左上角的箭头返回上一步修改。</p>
<p><img src="https://i.loli.net/2020/02/27/7xGAfcTWSHm8KeX.jpg" alt="3.jpg"></p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ2498 Xavier is Learning to Count</title>
    <url>/2020/02/22/BZOJ2498-Xavier-is-Learning-to-Count/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>容易想到$O(Bell(P))$地枚举$P$的集合划分，然后进行容斥（强制同一个集合里的数取值相同），但是容斥系数应该如何取呢？</p>
<p>对于一个大小为$x$的集合，设它的容斥系数为$f_x$。一种集合划分的容斥系数为每个集合的容斥系数的乘积。</p>
<p>对于某一种选$P$个数的方案，假设其中第$a_{1,1},a_{1,2},\cdots a_{1,k_1}$个数相同，第$a_{2,1},a_{2,2},\cdots a_{2,k_2}$个数相同，……第$a_{m,1},a_{m,2},\cdots a_{m,k_m}$个数相同，那么这种方案将会被计算的次数是</p>
<script type="math/tex; mode=display">
\prod_{i=1}^m (\sum_{\{S_1,S_2\cdots S_l\}是\{a_{i,1},a_{i,2},\cdots a_{i,k_i}\}的集合划分} \prod_{j=1}^l f(|S_j|))</script><p>根据定义我们需要让这个式子在至少有一个$k_i &gt; 1$的时候为$0$，所有的$k_i$都为$1$的时候为$1$。</p>
<p>记</p>
<script type="math/tex; mode=display">
g(n) = \sum_{\{S_1,S_2\cdots S_l\}是\{1,2,\cdots n\}的集合划分} \prod_{j=1}^l f(|S_j|)</script><p>我们相当于是要让</p>
<script type="math/tex; mode=display">
g(n) = [ n = 1]</script><p>枚举$n$所属的集合的大小得</p>
<script type="math/tex; mode=display">
g(n) = \sum_{i=1}^n \binom{n-1}{i-1} g(n-i) f(i)</script><p>因为$\forall i&gt;1, g(i)=0$，所以</p>
<script type="math/tex; mode=display">
g(n) = (n-1) \cdot f(n-1) + f(n) =0</script><p>令$f(n) = -(n-1)f(n-1), f(1) = 1$，也就是$f(i) = (-1)^{i-1}(i-1)!$，即得到一组满足条件的容斥系数。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> db Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Comp</span> &#123;</span></span><br><span class="line">    db a,b;</span><br><span class="line">    Comp (db a=<span class="number">0</span>,db b=<span class="number">0</span>): a(a),b(b) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> *(Comp A,Comp B)&#123;<span class="keyword">return</span> Comp(A.a*B.a-A.b*B.b,A.a*B.b+A.b*B.a);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> +(Comp A,Comp B)&#123;<span class="keyword">return</span> Comp(A.a+B.a,A.b+B.b);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> -(Comp A,Comp B)&#123;<span class="keyword">return</span> Comp(A.a-B.a,A.b-B.b);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> /(Comp A,db B)&#123;<span class="keyword">return</span> Comp(A.a/B,A.b/B);&#125;</span><br><span class="line">    <span class="keyword">friend</span> Comp <span class="keyword">operator</span> *(Comp A,db B)&#123;<span class="keyword">return</span> Comp(A.a*B,A.b*B);&#125;</span><br><span class="line">    <span class="function">Comp <span class="title">conj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Comp(a,-b);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;l);++i) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;l<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Comp A[],<span class="keyword">int</span> len,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) <span class="keyword">if</span>(rev[i]&lt;i) swap(A[i],A[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Comp wn=Comp(<span class="built_in">cos</span>(<span class="number">2</span>*Pi/l),f*<span class="built_in">sin</span>(<span class="number">2</span>*Pi/l));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=l)</span><br><span class="line">        &#123;</span><br><span class="line">            Comp w=Comp(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;i+(l&gt;&gt;<span class="number">1</span>);++k,w=w*wn)</span><br><span class="line">            &#123;</span><br><span class="line">                Comp t1=A[k],t2=A[k+(l&gt;&gt;<span class="number">1</span>)]*w;</span><br><span class="line">                A[k]=t1+t2,A[k+(l&gt;&gt;<span class="number">1</span>)]=t1-t2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[i]=A[i]/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Comp A[<span class="number">6</span>][N],B[N];</span><br><span class="line">db frac[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,len;</span><br><span class="line"><span class="keyword">int</span> buc[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> mx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==m+<span class="number">1</span>) &#123;</span><br><span class="line">		db coe=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i) coe*=frac[buc[i]<span class="number">-1</span>]*(buc[i]&amp;<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j) &#123;</span><br><span class="line">			Comp t=Comp(coe,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i) t=t*A[buc[i]][j];</span><br><span class="line">			B[j]=B[j]+t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx+<span class="number">1</span>;++i)</span><br><span class="line">		buc[i]++,dfs(u+<span class="number">1</span>,max(i,mx)),buc[i]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	frac[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i) frac[i]=frac[i<span class="number">-1</span>]*i;</span><br><span class="line">	<span class="keyword">int</span> T,cas=<span class="number">0</span>; rd(T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> num; rd(num),rd(m);</span><br><span class="line">		n=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=num;++i) &#123;</span><br><span class="line">			rd(x);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) A[j][x*j].a+=<span class="number">1</span>;</span><br><span class="line">			n=max(n,x*m);</span><br><span class="line">		&#125;</span><br><span class="line">		len=<span class="number">1</span>; <span class="keyword">int</span> cnt=<span class="number">0</span>; <span class="keyword">while</span>(len&lt;=n) len&lt;&lt;=<span class="number">1</span>,cnt++; getr(cnt);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) FFT(A[j],len,<span class="number">1</span>);</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		FFT(B,len,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++cas);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) &#123;</span><br><span class="line">			db ans=B[i].a/frac[m];</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;<span class="number">0.5</span>) <span class="built_in">printf</span>(<span class="string">"%d: %.0Lf\n"</span>,i,ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[j][i].a=A[j][i].b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) B[i].a=B[i].b=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3840 【WF2011】Chips Challenge</title>
    <url>/2020/02/21/HDU3840-%E3%80%90WF2011%E3%80%91Chips-Challenge/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>2016年集训队论文的第二篇讲到了这道题，但是论文中的建图方式似乎会出现负环（也有可能是我写炸了？）。下面的建图方法是从KIDGIN7439的<a href="https://blog.csdn.net/KIDGIN7439/article/details/84637086" target="_blank" rel="noopener">这篇博客</a>中看到的，因为觉得原文的阐述十分不清楚，重新阐述如下。</p>
<p>首先枚举$lim$为每一行、每一列的部件数量的最大值。求出在$lim$限制下能个放的最大零件数$tot’$，只要判断$lim \le \lfloor tot’ \cdot \frac{A}{B} \rfloor$是否成立，就能限制为$lim$时是否存在合法的方案，并更新答案。</p>
<p>建图方法：</p>
<ol>
<li>对第$i$行建一个点$A_i$，对第$i$列建一个点$B_i$</li>
<li>从$S$向$A_i$连容量下界为$0$，上界为$lim$，费用为$0$的边</li>
<li>从$B_i$向$T$连容量下界为$0$，上界为$lim$，费用为$0$的边</li>
<li>从$A_i$向$B_i$连容量下界为$0$，上界为$\infty$，费用为$0$的边</li>
<li>如果$(i,j)$这个位置是<code>.</code>，就从$A_i$向$B_j$连一条容量下界为$0$，上界为$1$，费用为$1$的边</li>
<li>如果$(i,j)$这个位置是<code>C</code>，就从$A_i$向$B_j$连一条容量下界为$1$，上界为$1$，费用为$1$的边</li>
</ol>
<p>这张图的最大费用最大流 - <code>C</code>的个数就是答案。</p>
<p>考虑如何满足题目中的几个限制：</p>
<ul>
<li>一个观察是，$S$到$A_i$、$B_i$到$T$的边都会满流<ul>
<li>流量大小 = $S$到$A_i$的边的流量和 = $B_i$到$T$的流量和</li>
<li>存在方案使这些边都满流：只流第2，3，4类边，不流第5类边</li>
<li>我们求的是最大费用最大流</li>
</ul>
</li>
<li>第二观察是，从$A_i$流出的第5，6类边的流量，等于流入$B_i$的第5，6类边的流量，这样就满足了“第$i$行的零件数量等于第$i$列的零件数量<ul>
<li>从$A_i$流出的总流量 = 流入$B_i$的总流量 = $lim$</li>
<li>从$A_i$通过第4类边流出的流量 =通过第4类边流入$B_i$的流量</li>
<li>两式相减即得出上面的观察</li>
</ul>
</li>
<li>从第二个观察也可看出，每个$A_i$流出的第5，6类边的流量不超过$lim$，流入$B_i$的第5，6类边的流量不超过$lim$，也就满足了每行、每列的部件数量不超过$lim$的限制</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> S,T;</span><br><span class="line"><span class="keyword">namespace</span> Flow &#123;</span><br><span class="line">    <span class="keyword">int</span> head[N],cur[N],dis[N],vis[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ed</span> &#123;</span> <span class="keyword">int</span> to,next,f,w; &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ed&gt; e;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e.PB((ed)&#123;y,head[x],f,w&#125;); head[x]=e.size()<span class="number">-1</span>;</span><br><span class="line">        e.PB((ed)&#123;x,head[y],<span class="number">0</span>,-w&#125;); head[y]=e.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="built_in">memcpy</span>(cur,head,<span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(S),vis[S]=<span class="number">1</span>,dis[S]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.front(); q.pop(),vis[u]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=head[u];~k;k=e[k].next) <span class="keyword">if</span>(e[k].f) &#123;</span><br><span class="line">                <span class="keyword">int</span> v=e[k].to;</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&lt;dis[u]+e[k].w) &#123;</span><br><span class="line">                    dis[v]=dis[u]+e[k].w;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[v]) vis[v]=<span class="number">1</span>,q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T]&gt;<span class="number">-1e9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==T||!f) <span class="keyword">return</span> f; <span class="keyword">int</span> ret=<span class="number">0</span>,tmp;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;k=cur[u];~k;k=e[k].next) <span class="keyword">if</span>(e[k].f) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[k].to;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]&amp;&amp;dis[v]==dis[u]+e[k].w&amp;&amp;(tmp=dfs(v,min(f,e[k].f)))) &#123;</span><br><span class="line">                e[k].f-=tmp,e[k^<span class="number">1</span>].f+=tmp;</span><br><span class="line">                ret+=tmp,f-=tmp;</span><br><span class="line">                <span class="keyword">if</span>(!f) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="keyword">while</span>(bfs()) ans+=dis[T]*dfs(S,<span class="number">1e9</span>); <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,A,B;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ts=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;A,&amp;B)) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!n&amp;&amp;!A&amp;&amp;!B) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">		S=<span class="number">2</span>*n+<span class="number">1</span>,T=<span class="number">2</span>*n+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> M=n*n*n+<span class="number">10</span>; <span class="comment">// shoule be larger than length of any possible path</span></span><br><span class="line">		<span class="keyword">int</span> mx=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> lim=n;lim&gt;=<span class="number">0</span>;--lim) &#123;</span><br><span class="line">			Flow::init();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">				Flow::ad(S,i,lim,<span class="number">0</span>),</span><br><span class="line">				Flow::ad(i,i+n,<span class="number">1e9</span>,<span class="number">0</span>),</span><br><span class="line">				Flow::ad(i+n,T,lim,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) &#123;</span><br><span class="line">					<span class="keyword">if</span>(mp[i][j]==<span class="string">'.'</span>) Flow::ad(i,j+n,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">					<span class="keyword">if</span>(mp[i][j]==<span class="string">'C'</span>) Flow::ad(i,j+n,<span class="number">1</span>,M+<span class="number">1</span>),tot++;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">int</span> ans=Flow::work();</span><br><span class="line">			<span class="keyword">if</span>(ans&lt;tot*(M+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">			ans%=M;</span><br><span class="line">			<span class="keyword">if</span>(ans*A&lt;lim*B) <span class="keyword">continue</span>;</span><br><span class="line">			mx=max(mx,ans-tot);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,++ts);</span><br><span class="line">		<span class="keyword">if</span>(mx&lt;=<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>PKUWC2020</title>
    <url>/2020/02/20/PKUWC2020/</url>
    <content><![CDATA[<h1 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h1><h2 id="A-排列"><a href="#A-排列" class="headerlink" title="A - 排列"></a>A - 排列</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个$\{1,2,\cdots n\}$的排列$P$。按照字典序从小到大的顺序，依次连接所有字典序不大于$P$的$\{1,2,\cdots n\}$的排列（例如$[2,1,3]$得到的是$[1,2,3,1,3,2,2,1,3]$）。</p>
<p>求得到的序列的本质不同的子序列的数量。$n\le 50$，答案对$998244353$取模。</p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>我们设$A_S[i][j]$表示满足下列条件的子序列$t$的个数：</p>
<ol>
<li>$t$的开头是字符$i$，结尾是字符$j$</li>
<li>$t$不是$S$的子序列</li>
<li>$t$删掉最后一个字符之后是$S$的子序列</li>
</ol>
<p>用$S+T$表示将$T$拼在$S$的后面得到的字符串，则$A_{S+T}[i][j] = \sum_k A_S[i][k] \times A_T[k][j]$。</p>
<p>令$P_i$表示最小的$i!$个排列首尾相接得到的序列。$A_{P_1}$可以直接求得。</p>
<p>考虑如何求得$A_{P_i}$求得$A_{P_{i+1}}$，发现$P_{i+1}$的可以分成$i+1$段，每一段的长度为$i!$，并且每一段与$P_i$的构成是相同的，所以每一段的$A$可以通过$A_{P_i}$交换一些行列得到。</p>
<p>预处理出所有的$A_{P_i}$之后，原序列可以被拆分成若干个极长的段，满足每一段是将末$i$个数进行全排列，将得到的排列按照字典序从小到大拼起来得到的。而这一段的$A$一定能通过$A_{P_i}$交换一些行列得到。</p>
<h2 id="B-火山哥与集合"><a href="#B-火山哥与集合" class="headerlink" title="B - 火山哥与集合"></a>B - 火山哥与集合</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>初始有$n$个集合，第$i$个集合只包含$1$个元素$a_i$。</p>
<p>每一次操作会随机选择两个集合合并。</p>
<p>定义一个集合的价值为这个集合中最大值与最小值的差的平方。定义$f(k)$为进行$n-k$次操作后，所有集合的价值的和的期望。</p>
<p>给出$l,r$，求$\sum_{k\in [l,r]} f(k)^{97376} \pmod {998244353}$</p>
<p>$n\le 2\times 10^5,1\le l\le r\le n,a_i &lt; 998244353$</p>
<h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>设$g(t,k)$表示若最终合并为$k$个集合，某个大小为$t$的集合出现的概率。设$h(i)$表示所有大小为$i$的集合的$( \max - \min )^2$的和。则$f(k)=\sum_{i=1}^n h(i) \cdot g(i,k)$。</p>
<p>将$a$从小到大排序后，可以得到$h(i) = \sum_{l\le r} (a_r-a_l)^2 \cdot {r-l-1\choose i-2}$。先对于每一个$t$算出$\sum_{t=r-l} (a_r-a_l)^2$，然后再算$h(i)$。这两步都可以用NTT做到$O(n\log n)$。</p>
<p>将$n$个集合恰好合并成$k$个的方案数是$\prod_{i=k+1}^n {i\choose 2}$（即第$i$次合并的时候，共有$n-i+1$个集合，所以合并的方案数是$n-i+1\choose 2$）。令$D(n)=\prod_{i=2}^n {i\choose 2}$。</p>
<p>则$g(i,k) = {n-k\choose i-1} \cdot D(i) \cdot {D(n-i)\over D(k-1)} \over {D(n)\over D(k)} = {n-k\choose i-1} \cdot  {k\choose 2} \cdot D(i) \cdot D(n-i) \cdot{1\over D(n)}$</p>
<p>则$f(k) = \sum_i h(i)g(i,k)<br>={k\choose 2} \cdot {1\over D(n)}\sum_i h(i)D(i)D(n-i)\cdot  {n-k\choose i-1}$</p>
<p>这是个卷积的形式，可以NTT优化。</p>
<h2 id="C-数论结构"><a href="#C-数论结构" class="headerlink" title="C - 数论结构"></a>C - 数论结构</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一个$n\times m$的矩阵，初始所有位置的数为$0$。先进行$q_1$次修改操作，给出参数$s,l,r,x$，表示给所有满足$\gcd(s,a)=1,b\in [l,r]$的格子$(a,b)$加上$x$。然后进行$q_2$次询问操作，每次给出$(s,l,r)$，你需要回答所有满足$\gcd(s,a)=1,b\in[l,r]$的格子$(a,b)$的和。</p>
<p>保证修改和询问的$s$随机生成。</p>
<p>$n,q_1\le 50000, m,q_2\le 200000,1\le l\le r\le m, 1\le s\le n$</p>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><p>考虑所有修改$(s_i,l_i,r_i,x_i)$对询问$(s,l,r)$的贡献。</p>
<p>设$Q_d$为所有满足$d\mid s_i$的$i$构成的集合。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{q_1} card( [ l_i,r_i]\cap [l,r]) x_i \cdot \sum_{j=1}^n [(s_i,j)=1 ] [(s,j)=1] \\
=\sum_{i=1}^{q_1} card( [ l_i,r_i]\cap [l,r]) x_i \cdot \sum_{j=1}^n ( \sum_{d_1\mid (s_i,j)}\mu (d_1) \sum_{d_2\mid (s,j)} \mu(d_2))\\
=\sum_{d_2\mid s} \mu(d_2) \sum_{d_1=1}^{n} \mu(d_1) \lfloor { n\over lcm(d_1,d_2)} \rfloor \cdot \sum_{i\in Q_{d_1}} card( [ l_i,r_i]\cap [l,r]) x_i
\end{aligned}</script><p>考虑枚举$d_1,d_2$的最大公约数$D$，令$t_1 = {d_1 \over D}, t_2 = {d_2 \over D}$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
原式 = \sum_{D\mid s} \sum_{t_2 \mid {s\over D}} \mu(t_2D) \sum_{t_1=1}^{\lfloor {n\over D} \rfloor}\mu(t_1D) \lfloor {n\over t_1t_2D} \rfloor [(t_1,t_2)=1] \sum_{i\in Q_{t_1D}} card( [ l_i,r_i]\cap [l,r]) x_i\\
= \sum_{D\mid s} \sum_{t_2 \mid {s\over D}} \mu(t_2D) \sum_{t_1=1}^{\lfloor {n\over D} \rfloor}\mu(t_1D) \lfloor {n\over t_1t_2D} \rfloor \sum_{d\mid (t_1,t_2)} \mu(d)\sum_{i\in Q_{t_1D}} card( [ l_i,r_i]\cap [l,r]) x_i\\
\end{aligned}</script><p>令$T=D\cdot d, u_1 = {t_1\over d} = {d_1 \over T},u_2 = {t_2\over d} = {d_2\over T}$，得到</p>
<script type="math/tex; mode=display">
原式 = \sum_{T\mid s} \sum_{d\mid T} \mu(d) \sum_{u_2 \mid {s\over T}} \mu(u_2T) \sum_{u_1=1}^{\lfloor {n\over T}\rfloor} \mu(u_1T) \lfloor {n\over u_1u_2dT}\rfloor \sum_{i\in Q_{u_1T}} card( [ l_i,r_i]\cap [l,r]) x_i</script><p>在最外层枚举$T$，然后考虑所有的$Q_T$对$A_T$（表示所有$T\mid s_i$的询问）的贡献。</p>
<p>维护一个二维的矩阵。对于每个修改，枚举所有$d\mid T, u_1\in [1,\lfloor {n\over T}\rfloor ]$，然后对于每一个$i \in Q_{u_1T}$把第$\lfloor {n\over u_1dT}\rfloor$行的区间$[l_i,r_i]$加上$x_i \cdot \mu(u_1T) \cdot \mu(d)$。对于每一个询问，枚举所有的$u_2$，然后枚举$t$，则所有满足$\lfloor {j\over u_2} \rfloor = t$的$j$形成一个连续的区间，查这个区间的所有行的$[l_i,r_i]$的元素的和，乘上$t$加入答案中。</p>
<p>修改的复杂度：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{T=1}^n \sum_{d\mid T} \sum_{u_1=1}^{\lfloor {n\over T}\rfloor} |Q_{u_1T}|\\
= \sum_{T=1}^n \sum_{d\mid T} \sum_{u_1=1}^{\lfloor {n\over T}\rfloor} {q_1\over u_1T}
\end{aligned}</script><p>因为$n,q_1$同级，用$n$换掉$q_1$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
原式= \sum_{T=1}^n \sum_{d\mid T} {n\over T} \log {n\over T}    \\
\le \sum_{T=1}^n \sum_{d\mid T} {n\over T} \log n    \\
=\sum_{d=1}^n \sum_{T'=1}^{\lfloor {n\over d}\rfloor} {n\over dT'} \log n \\
=\sum_{d=1}^n {n\over d} \log {n\over d} \log n \\
\le \sum_{d=1}^n {n\over d} \log^2 n \\
= n\log^3 n
\end{aligned}</script><p>处理前缀和的复杂度是矩阵的大小。矩阵的行数是$O(\sqrt {n\over T})$的，尽管矩阵的列数是$n$，但是其中只有$|Q_T|+|A_T|$列有用，所以复杂度是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{T=1}^n \sqrt {n\over T} \cdot {q_1+q_2\over T}\\
{\sqrt n (q_1+q_2) }\sum_{T=1}^n {1\over T^{1.5}}
\end{aligned}</script><p>后面部分</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{T=1}^{n} {1\over T^{1.5}} \\
\int_{1}^n T^{-1.5} dT \\
= - {1\over 0.5} n^{-0.5} + {1\over 0.5}1^{-0.5} + C\\
= n^{-0.5} \cdot 0 + C \\
= O(1)
\end{aligned}</script><p>所以这一步的复杂度是$O((q_1+q_2)\sqrt n)$。</p>
<p>离散化那$|Q_T|+|A_T|$列的复杂度是$\sum_{T=1}^n ( |Q_T|+|A_T| )\log n = O(q_2\log ^2 n)$。</p>
<p>询问的复杂度：对于某一个$u_2$，我们会枚举到的$t$一定有$\lfloor {n\over u_1u_2dT} \rfloor = \lfloor { \lfloor {n\over u_2T}\rfloor \over x} \rfloor$的形式，所以，这样的$t$只有$O(\sqrt {n\over u_2T})$个。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{T=1}^n \sum_{j\in A_{T}} \sum_{u_2 \mid {s_j\over T}} \sqrt {n\over u_2T} \\
= \sqrt n\sum_{u_2=1}^n \sqrt { 1 \over u_2 }  \sum_{T=1}^{n\over u_2 } \sqrt{1\over T} |A_{u_2T}| \\
= \sqrt n \sum_{u_2=1}^n \sqrt { 1 \over u_2}  \sum_{T=1}^{n\over u_2 } \sqrt{1\over T} {q_2\over u_2T}\\ 
= \sqrt nq_2 \sum_{u_1=1}^n u_2^{-1.5}\sum_{T=1}^{n\over u_2} T^{-1.5} \\
= O(\sqrt nq_2)
\end{aligned}</script><p>总时间复杂度$O(n\log^3 n +q_2\sqrt n)$。</p>
<h1 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h1><h2 id="A-火山哥的打铁传说"><a href="#A-火山哥的打铁传说" class="headerlink" title="A - 火山哥的打铁传说"></a>A - 火山哥的打铁传说</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>进攻方有两种鱼：小鱼和剧毒鱼。防御方有两种鱼，圣盾鱼和大鱼。每一回合，进攻方会选择自己的一条鱼，然后让它与防御方的某一条鱼战斗。战斗遵循如下规则：</p>
<ol>
<li>如果圣盾鱼与任意一种鱼战斗，它会变成一条大鱼。</li>
<li>如果大鱼和剧毒鱼战斗，它会消失。如果大鱼和小鱼战斗，大鱼不会消失。</li>
</ol>
<p>现在你知道了进攻方前$n$个回合会选择自己的哪种鱼。有$q$次询问，每次询问给出$X$,$K$，你需要回答，如果防御方有$X$条大鱼，进攻方进行前$K$个回合，防御方最多能有多少条圣盾鱼，使得进攻方可以让防御方所有的鱼都消失。</p>
<p>$n,q\le 4\times 10^5$</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数$n,q$。</p>
<p>第二行一个长度为$n$的字符串$s$，$s_i$为<code>1</code>表示第$i$个回合进攻方出剧毒鱼，$s_i$为<code>0</code>则表示第$i$个回合进攻方出小鱼。</p>
<p>接下来$q$行，每行两个整数$X,K(1\le K\le n)$，表示第$i$次询问。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问，输出一行一个整数表示答案。如果圣盾鱼个数为$0$的时候进攻方仍不能消灭所有的鱼，输出$-1$。</p>
<h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol"></a>Sol</h3><p>问题等价于：我方先出$X$条小鱼，然后再进行前$K$个回合，最多能消灭掉多少条对方的圣盾鱼。假设答案为$y$，若$y&lt; x$输出$-1$，否则输出$y-x$。</p>
<p>转化成求出尽可能多的小鱼和剧毒鱼的匹配（要求小鱼在前面），答案就是这个匹配数加上剩下的剧毒鱼的数量的一半下取整。</p>
<p>如果只有一次询问，可以直接贪心：从前往后考虑，用一个变量记录下前面的还没有匹配过的小鱼，遇到剧毒鱼的时候如果前面没有匹配的小鱼数量不为$0$就让它匹配。</p>
<p>从前往后贪心和从后往前贪心得到的结果显然是一样的。先从前往后贪心，求出每一个前缀能够得到的最大的匹配数。询问的时候增加的$X$条小鱼所能够增加的匹配数，是前$K$个回合中还没有匹配的剧毒鱼数量和$X$的较小值。</p>
<p>时间复杂度$O(n+q)$。</p>
<h2 id="B-火山哥的分式"><a href="#B-火山哥的分式" class="headerlink" title="B - 火山哥的分式"></a>B - 火山哥的分式</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>定义如下的表示一个分式的方式：给出一个长度为$l+1$的序列和长度为$l$的排列，排列中的第$i$个数代表了从上往下第$i$条分数线的长度，序列中的第$i$个元素代表了分式从上往下的第$i$个元素。例如，序列$\{ a,b,c\}$和排列$\{2,1\}$所对应的分式是：</p>
<script type="math/tex; mode=display">
{a\over {b\over c}}</script><p>越短的分数线，运算的优先级越高。</p>
<p>现在有一个长度为$n+1$的序列$a$和长度为$n$的$\{1,2,\cdots n\}$的排列。有$q$次询问，每次询问给出$l,r$，你需要求出$a[l-1\cdots r]$和$p[l\cdots r]$对应的分式的值对$998244353$取模的结果。</p>
<p>$n,q\le 5\times 10^5, 0&lt; a_i &lt; 998244353$</p>
<h3 id="Sol-4"><a href="#Sol-4" class="headerlink" title="Sol"></a>Sol</h3><p>单独考虑每一个元素对答案的贡献，这个贡献要么是它本身，要么是它的逆元；找出这个元素左边第一条分数线，然后找出这条分数线的左边第一条比它长的分数线，然后找左边第一条比它长的分数线……直到找到的分数线位置超出了区间，这期间找到过的分数线的个数如果是奇数那么这个数的贡献就是它的逆元，否则就是它本身。</p>
<p>将询问离线下来，然后从左到右扫描整个序列，并用单调栈维护已经扫过的元素（栈顶是最后加入的分数线，栈中的每一个元素的下面是它左边的第一个比它长的分数线）。扫到$r$的时候，我们分两部分求$l$的答案：一部分是仍然在栈中的元素的贡献，对于下标在$l$之后且在栈中的元素，分别查出下标为奇数和偶数的所有元素的乘积就可以得到答案；一部分是已经出栈了的元素的贡献，我们在元素出栈的时候维护。把出栈的元素的贡献分为两部分：一部分是$l$小于出栈后的栈顶的，直接让出栈后的栈顶的权值乘等于当前的栈顶的权值的逆元就可以了；另一部分是$l$在出栈后的栈顶和当前的栈顶之间的，这些$l$形成连续的一段区间且当前出栈的元素对它们的贡献是相同的，用线段树维护即可。</p>
<p>时间复杂度$O((n+q)\log n)$。</p>
<h2 id="C-最小割"><a href="#C-最小割" class="headerlink" title="C - 最小割"></a>C - 最小割</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>对于一张边带权的无向图，定义$s$与$t$的最小割$f(s,t)$：求一个边集$E$使得删去$E$中的边之后$s,t$不连通且$E$中的边的边权和最小，$E$的边权和即为$f(s,t)$。</p>
<p>现在给出了一张$n$个点$m$条边的图，其中第$i$条边连接$x_i$和$y_i$，边权为$w_i(w_i\le 10^4)$。然后可怜又往图中加了$n$条边，第$i$条边连接$i$和$i\pmod n + 1$，每条边的边权都是$10^9$。</p>
<p>可怜希望你求出$\sum_{s=1}^{n-1} \sum_{t=s+1}^n f(s,t) \pmod {998244353}$。</p>
<p>$n\le 7000,m\le 10^5$</p>
<h3 id="Sol-5"><a href="#Sol-5" class="headerlink" title="Sol"></a>Sol</h3><p>由于所有边的权值和最多为$10^9$，所以边权为$10^9$的边肯定恰好被割两条，把原图划分成两条链，然后将链之间的边割掉。</p>
<p>利用二维前缀和可以在$O(n^2)$的时间内求出选择割某两条边，其它需要割掉的边的权值和。</p>
<p>对于$s,t$，我们要求割的一条边在$s,s+1,\cdots ,t-1,t$之间，另一条不在这些点之间。</p>
<p>可能的方案形成了这样的区域（横坐标代表一条边的位置，纵坐标代表另一条边的位置）：</p>
<p><img src="https://i.loli.net/2019/12/26/xcyDwWG9QmMBaVT.png" alt=""></p>
<p>第一种：求出每一列的后缀最小，然后对于第$s$行，求出从第$s$列开始的前缀最小。</p>
<p>第二种：求出每一行的后缀最小，然后对于第$t$列，求出从第$t$行开始的前缀最小。</p>
<p>总时间复杂度$O(n^2 + m)$。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>IOI2020北大集训</title>
    <url>/2020/02/20/IOI2020%E5%8C%97%E5%A4%A7%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="A-递增树列"><a href="#A-递增树列" class="headerlink" title="A - 递增树列"></a>A - 递增树列</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一棵有根树，定义$dis(i)$为$i$点到根经过的边数。求有多少个排列$p$，满足$\forall i \in [1,n-1), dis(lca(p_i,p_{i+1}))\le dis(lca(p_{i+1},p_{i+2}))$。</p>
<p>答案对$10^9+7$取模。$n\le 80$。</p>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>一个观察：从前往后考虑这个排列，一旦出现了相邻两个点的lca不为根，那么此后的点都在根的同一个子树内。而前面的相邻两个点的lca都为根等价于相邻两个点来自根的不同子树。对不是根的点考虑仅由它的子树内的点构成的排列时也有类似的结论。</p>
<p>设$g_{u,j}$表示以$u$为根，用了$u$子树内的$j$个点去构成一个合法的排列的方案数。则最后的答案是$g_{1,n}$。</p>
<p>如果排列中始终没有出现两个相邻的点lca的深度大于$u$，则可以直接用容斥原理计算。对$u$的每一个儿子枚举这个儿子的子树内选了多少个点，以及这些点中有多少对在最终排列里相邻了，并对（选了的点数）和（在同一个儿子的子树内且在排列中相邻的点对数）做背包。</p>
<p>如果存在相邻点lca深度大于$u$，假设其所属的儿子是$v’$，我们最后得到的排列只需满足：在lca均在$v’$之内的那一段（即$g_{v’,x}$所代表的）之前，最后一个点不属于$v’$的子树。这个仍然可以用类似于上一种情况的方法进行容斥，使得在$v’$子树内的点位于$g_{v’,x}$的那段之前的方案被减掉。在背包中再加入一维$0/1$，表示是否已经算过$v’$的贡献就可以处理这种情况。</p>
<p>时间复杂度$O(n^4)$。<del>我n^5过了</del></p>
<h2 id="B-Article"><a href="#B-Article" class="headerlink" title="B - Article"></a>B - Article</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>定义$w(s_1,s_2)$表示$s_1,s_2$的本质不同的公共子串的数量。</p>
<p>定义一个字符串$t$的权值为$\sum_{i=1}^{|t|-1} w^2(s[1\cdots i],s[i+1\cdots |t|])$。</p>
<p>给出一个字符串$s$和正整数$k$，问将$s$划分成恰好$k$段，权值最大的那段的权值最小可以是多少。</p>
<p>$|S|\le 50000$，保证答案不超过$10^{18}$。</p>
<h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>考虑如何在$O(|t|)$的时间内算出$t$的权值：对$t$建SAM，对于每个节点处理出它的出现位置的最小值和最大值；SAM上的每个节点对$i=1$到$|t|-1$时的$w$的贡献，会是一个形如$maxlen,maxlen,\cdots maxlen,maxlen-1,maxlen-2\cdots $的数列，用二次差分就可以处理。求出每个$w$之后再平方、求和即可。</p>
<p>首先二分答案，将问题转化成：要求每段的权值小于等于某值，问能否划分成至多$k$段。由于这个题的权值满足单调性（即一个串的权值一定不小于它的任何一个子串），所以可以直接贪心，让划分的位置尽可能靠后就可以了。</p>
<p>利用倍增找下一个划分点：先检查长度$2^0,2^1,\cdots$直到长度为$2^k$的串的权值大于了限制，然后再依次枚举$2^{k-1},2^{k-2}\cdots$进行倍增。假设这一次划分的段的长度的$L$，由于每一次倍增时需要计算权值的串长度大于等于$2^{k-1}$而小于$2^k$，所以找出这个划分点的复杂度是$\Theta(L\log L)$的。</p>
<p>总复杂度$O(|S|\log |S|\log Ans)$。</p>
<h2 id="C-Travel"><a href="#C-Travel" class="headerlink" title="C - Travel"></a>C - Travel</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有$n$个可重集合$S_1,S_2\cdots S_n$，你可以从每个可重集合中选出一个元素，然后用这$n$个元素构成$k$个环，要求每个环的长度都是奇数。</p>
<p>定义一个环的价值为，相邻两个元素的差的绝对值的最小值。特别地，一个只包含一个元素的环的价值是正无穷。</p>
<p>你需要最大化所有环的价值的最小值，并输出最大化的结果。</p>
<p>$n\le 300,|S_i|\le 5,k&lt; n$。</p>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><h4 id="Lemma-1"><a href="#Lemma-1" class="headerlink" title="Lemma 1"></a>Lemma 1</h4><p>对于确定的$n$个已经从小到大排好序的元素$a_1,a_2,a_3\cdots a_n$，令$m={n-1\over 2}$，则它们构成的环的价值最大值是$\min \{ a_{i+m}-a_i \}$。</p>
<p>证明：考虑$\{a_i,a_{i+1},\cdots a_{i+m}\}$这个集合内有$m+1$个元素，集合外有$m$个元素，所以集合中必然存在一对在环中相邻的元素，所以这是答案的下界。而达到这个下界的解可以这样构造：</p>
<p><img src="https://i.loli.net/2019/12/17/dgliqKfZzND7ROt.png" alt=""></p>
<h4 id="Lemma-2"><a href="#Lemma-2" class="headerlink" title="Lemma 2"></a>Lemma 2</h4><p>最终的答案是由$k-1$个孤立的点和一个长度为$n-k+1$的环构成的。</p>
<p>证明：考虑现在有两个长度大于$1$的环$\{a_1,a_2\cdots a_m\}$和$\{b_1,b_2\cdots b_n\}$（$a_i,b_i$随下标递增），只要证明将它们变成一个孤立点和一个环答案不会变劣就可以了。</p>
<p>如果某个环使用的不是上面的图片中的构造方法，将其改为图片中的构造方法不会变劣。所以下面均认为环是按照上面图片的方式构造的。</p>
<p>从$a$中取出一个孤立点$a_{m+1\over 2}$，得到一条一端为$a_1$，另一端为$a_m$的链。</p>
<p>断开$b$中的边$(b_1,b_{n+1\over 2})$或者边$(b_{n+1\over 2},b_n)$。</p>
<p>考虑如何将两条链拼起来。假设第一条链是的端点分别为$a,b(a&lt; b)$，第二条链的端点为$c,d(c&lt; d)$。若$[a,b]$与$[c,d]$没有交或者包含，则很容易构造使得拼接用的边的权值都大于等于$\min\{b-a,d-c\}$。否则一定有$b_1&lt; a_1 \le b_{n+1\over 2} \le a_m &lt; b_n$，此时若$b_{n+1\over 2}\ge a_{m+1\over 2}$，就连$(b_{n+1\over 2},a_1)$和$(a_m,b_1)$，否则就连$(b_{n+1\over 2},a_m)$和$(b_n,a_1)$。这样构造之后答案都不会变劣。</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>首先二分答案$w$，然后判断能否求出长度为$n-k+1$的哈密顿回路。</p>
<p>令$N=n-k+1$，存在长度为$N$的哈密顿回路等价于存在$N-3\over 2$对匹配和一个三元匹配。</p>
<p>其中$i,j$这两个集合可以匹配，当且仅当$\exists a\in S_i,b\in S_j, |a-b| \ge w$。</p>
<p>其中$i,j,k$这三个集合可以构成三元匹配，当且仅当$\forall x\in S_i,y\in S_j,z\in S_k, \min\{|x-y|,|y-z|,|z-x|\}\ge w$。</p>
<p>必要性：可以把环画成之前的图中的形式，图中红色的边为匹配边。</p>
<p>充分性：显然一个集合只会属于一个匹配。对于每个集合拿出一个它参与了匹配条件判定的那个元素，将所有集合按照它拿出的那个元素的大小排好序。如果它们的匹配边的连法不是之前的图中的那样，则可以进行等价的调整。然后用与前面构造相同的方法就可以构造出解。</p>
<p>最后是怎么求这个匹配。枚举三元匹配中元素的值为中位数的那个集合并枚举它选的元素，然后将这个集合拆成两个点，一个只能连比它小的点，另一个只能连比它大的点，然后跑一般图的最大匹配就可以了（说得就跟我会似的。。。。</p>
<hr>
<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="A-循环数列"><a href="#A-循环数列" class="headerlink" title="A - 循环数列"></a>A - 循环数列</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有一个无限长的下标从$1$开始的序列，初始的时候所有在模$n$意义下等于$m$的位置的数为$1$，其余位置的数为$0$。</p>
<p>每一次操作会使得操作后的序列$F’_i=F_i+F_{i+1}$。</p>
<p>现在给出$n,m,k,pos,P$。你需要求出$k$次操作之后，$F_{pos}\pmod P$的值。</p>
<p>数据组数$T\le 500$，$k\le 10^9, P\le 10^7, \sum n\le 10^6, 1\le m&lt; n, 1\le pos&lt; n$，数据保证$P$为质数且$n\mid p-1$。</p>
<h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol"></a>Sol</h3><p>假设某个初始序列中的$1$的下标为$x$，那么它将对$F_{pos}$产生的贡献等价于：每一次可以让$x$不变或减一，操作$k$次后恰好$x=pos$的方案数。也就是${k \choose x-pos}$。</p>
<p>故而答案为</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{\infty} {k\choose i\cdot n+m-pos }</script><p>令$t=m-pos$，进行单位根反演：</p>
<script type="math/tex; mode=display">
\begin{aligned}
Ans=\sum_{i=0}^{\infty} {k\choose i\cdot n+t}\\
=\sum_{i=0}^{\infty}{k\choose i} [n\mid (i-t)]\\
=\sum_{i=0}^{\infty}{k\choose i} {1\over n} \sum_{j=0}^{n-1} \omega_n^{j(i-t)}\\
={1\over n}\sum_{j=0}^{n-1} \omega_n^{-jt} \sum_{i=0}^{\infty}{k\choose i}\omega_n^{ij}\\
={1\over n}\sum_{j=0}^{n-1} \omega_n^{-jt} (1+\omega_n^j)^k
\end{aligned}</script><p>暴力枚举$j$计算，复杂度$O(n\log k)$。</p>
<h2 id="B-Matrix"><a href="#B-Matrix" class="headerlink" title="B - Matrix"></a>B - Matrix</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出一个$n\times n$的整数矩阵$A$。</p>
<p>问能否求出一组置换矩阵$\{B_1,B_2\cdots B_m\}$，使得<strong>唯一</strong>存在一组非负整系数$\alpha_1,\alpha_2\cdots \alpha_m$，满足$A=\alpha_1\cdot B_1 + \alpha_2\cdot B_2+\cdots +\alpha_m\cdot B_m$。</p>
<p>求出一组$m\le n^2$的解或判定无解。</p>
<p>$n\le 50,T\le 10,A_{i,j}\le 2\times 10^7$</p>
<h3 id="Sol-4"><a href="#Sol-4" class="headerlink" title="Sol"></a>Sol</h3><p>参考Birkhoff–von Neumann theorem。</p>
<p>一个$A$能够被表示出来的充分必要条件是$A$中的每一行元素的和、每一列元素的和都相同。</p>
<p>充分性证明：设$C$为某一行的所有元素的和。构造一个二分图，左侧有$n$个点表示每一行，右侧有$n$个点表示每一列。$(i,j)$这条边存在当且仅当$A_{i,j}&gt;0$。用Hall定理证明这张图存在完备匹配：任选一个左边的点构成的集合$X$，考虑与他们相邻的列集合$Y$，由于$|X|\cdot C = \sum_{x\in X,y\in Y} A_{x,y} \le |Y|\cdot C$，所以有$|X|\le |Y|$，证毕。所以这张二分图一定存在完备匹配，将完备匹配对应的置换矩阵从$A$中减掉（$\alpha$取匹配中的最小边权），就转化成了规模更小的问题。</p>
<p>上述的证明过程也描述了算法的过程。显然这样最多会用$n\times n$个置换矩阵。由于每一次都会让一个位置变成$0$，所以这一步拿出来的置换矩阵与之后拿出来的置换矩阵必然线性无关。</p>
<h2 id="C-杀蚂蚁简单版"><a href="#C-杀蚂蚁简单版" class="headerlink" title="C - 杀蚂蚁简单版"></a>C - 杀蚂蚁简单版</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>有一棵包含$n$个节点的树，每个点有一个权值$v_i$。有一只蚂蚁，如果它当前在的节点为$x$，与它相邻的点集为$\{y_1,y_2\cdots y_m\}$，则它下一秒将以${v_{y_i}\over \sum v_{y_j}}$的概率走到$y_i$这个点。蚂蚁一旦走到$1$节点就会消失。</p>
<p>有$q$次询问，每次询问给出$s,x,y$，你需要回答：如果蚂蚁的初始位置是在$s$，它期望有多少秒停留在$x$到$y$的最短路径上。</p>
<p>$n,q\le 10^5$，答案对$998244353$取模。</p>
<h3 id="Sol-5"><a href="#Sol-5" class="headerlink" title="Sol"></a>Sol</h3><p>设$P_{x,y}$表示从$x$走到$y$的概率。</p>
<p>下面考虑部分分$v=u+1,s=2$的情况怎么做。设$f_i$表示$i$期望被经过多少次，那么显然有$f_2=P_{2,3}\cdot f_2+1={1\over 1-P_{2,3}}$，$f_3 = P_{2,3}f_2 + P_{4,3}\cdot f_4 $，由于出发点是$2$，终点是$1$，所以必然有$f_4P_{4,3} = f_3P_{3,4}$，所以$f_3={1\over 1-P_{3,4}}P_{2,3}f_2$。后面的可以类似的方法推导。概括一下就是，设$g_i = {1\over 1-P_{i,i+1}},h_i=P_{i-1,i}$，则$f_2 = g_2, f_i = h_ig_if_{i-1}(i&gt;2)$。</p>
<p>考虑$v=u+1,s\not = 2$的情况：此时的答案等价于蚂蚁第一次走到$s-1$之前经过每个点的次数的期望 加上 以$s-1$作为出发点的时候的答案。如果限制了不能够经过$s-1$这个点，等价于让$s-1$做根，故而此时$f_s = g_s, f_i = h_ig_if_{i-1}(i&gt;s)$。所以这种情况的答案为$\sum_{i\in [x,y]} \sum_{j=2}^s g_j\prod_{k=j+1}^i h_ig_i$。考虑如何快速计算答案：令$F_i$表示当以$2$作为起点的时候期望经过$i$的次数，那么$F_i$对答案的贡献相当于$F_i(1 + {1\over g_2h_3}+{1\over g_2g_3h_3h_4}+\cdots {1\over g_2g-_3\cdots g_{s-1}h_3h_4\cdots h_s})$。按照从小到大依次枚举$s$，当从$s-1$变成$s$的时候，相当于对于所有大于了$s$的$x$，它的贡献都增加了$F_x\cdot {1\over g_2g-_3\cdots g_{s-1}h_3h_4\cdots h_s}$，可以用线段树维护区间内的贡献和。</p>
<p>上面的结论推广到树仍然成立。对整棵树进行dfs遍历，进入一个点$s$的时候，就使它的子树内的点$x$都加上贡献$F_x \cdot {1\over h_sg_{fa_s}h_{fa_s}g_{fa_{fa_s}}\cdots }$，用树链剖分维护链的贡献和即可。时间复杂度$O(n\log ^2 n)$。</p>
<hr>
<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><h2 id="A-投影对称"><a href="#A-投影对称" class="headerlink" title="A - 投影对称"></a>A - 投影对称</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给定$n$个点，求有多少过$(0,0)$的直线，满足这$n$个点在直线上的投影为中心对称图形。</p>
<p>$n\le 2000$，$|x_i|,|y_i|\le 10^6$，可能会有重合的点。</p>
<h3 id="Sol-6"><a href="#Sol-6" class="headerlink" title="Sol"></a>Sol</h3><p>假设对称中心为$P$，考虑过$P$且与$OP$垂直的直线$l$，对于一对其投影关于$P$对称的点$A,B$，它们到$l$的距离相等。故线段$AB$的中点也一定经过了$l$。枚举$1,2$这两个点匹配的另一个点是什么就可以确定$l$，然后再$O(n\log n)$检查，这样总复杂度是$O(n^3\log n)$的。</p>
<p>考虑由于$l$过所有点对的中点，所以$l$一定过这$n$个点的重心。因此只需要枚举$1$号点匹配的点，再考虑上重心，就可以确定$l$了。时间复杂度$O(n^2\log n)$。</p>
<p>有一种写法是，先对这$n$个点求一次凸包，由于凸包上的点只能和凸包上的点配对，（再加上出题人没有考虑到凸包，因此数据中凸包上的点数很少），可以将总复杂度优化到$O(Cn\log n)$，其中$C$为凸包上的点数。</p>
<h2 id="B-数圈"><a href="#B-数圈" class="headerlink" title="B - 数圈"></a>B - 数圈</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>有$n$个整数排成一个圈，初始它们为$A_1,A_2\cdots A_n$。</p>
<p>定义一次操作为，选择一个数$a$，将与它相邻的数加上$a$，将它变成$-a$。</p>
<p>问至少进行多少次操作，可以使得所有的数非负。如果办不到输出$-1$。</p>
<p>$n\le 10^5, -1000\le A_i \le 1000$</p>
<h3 id="Sol-7"><a href="#Sol-7" class="headerlink" title="Sol"></a>Sol</h3><p>考虑如果是序列怎么做：观察发现，一次操作等价于交换了前缀和数组中的两个元素，所以答案就是前缀和数组的逆序对数。</p>
<p>而对于圈，我们定义它的广义前缀和是一个双向无限的序列$S_i(i\in \mathbb {Z})$，如1,2,-3,4的一个可能的广义前缀和是……-8,-4,-3,-1,-4,0,1,3,0,4,5,7,4,8,9,……定义它的一次交换操作为：选定一个$i$，对于所有在模$n$意义下与$i$同余的位置$x$，交换$S_x$与$S_{x-1}$。</p>
<p>设$sum=\sum_{i=1}^nA_i$，如果$sum&lt; 0$显然无解，如果$sum=0$则当且仅当序列中所有元素都是$0$的时候有解，否则无解。下面只讨论$sum&gt;0$的情况。</p>
<p>定义$R_i = \sum_{j&gt;i} [ S_j&lt; S_i]$，定义逆序对数为$R_1+R_2+\cdots R_n$。由于$sum&gt;0$，所以$R_i$是有限的。由于$S_{x+n}=S_x+sum$，所以$R_i = R_{i+n}$。一次操作会交换所有的$S_{i+kn}$与$S_{i-1+kn}(k\in \mathbb Z)$，对于某一个$k’$，$R_{i+k’n}$只会受到交换$S_{i+k’n},S_{i-1+k’n}$的影响，所以一次操作我们恰好可以让某一个$R_i(i\in [1,n])$减掉一。所以答案就是这个逆序对数。</p>
<p>枚举$j-i$在模$n$意义下的取值。由于$S_{i+n}=S_i + sum$，所以$R_i = \sum_{j=1,S_{i+j}&lt; S_i}^{n-1} \lceil{S_i-S_{i+j}    \over sum}\rceil$。利用这个式子可以在$O(n^2)$的时间内解决问题。</p>
<p>考虑将$S_i$分解为$S_i = u_i \cdot sum +v_i(0 \le v_i &lt; sum)$，则前面的式子转化为$\sum_{j=1,S_{i+j}&lt; S_i}^{n-1} u_i - u_{i+j} + [v_i &gt; v_{i+j}]$。从小到大枚举$i$并动态维护二维点集$(S_{i+j},v_{i+j})$以及点权$u_{i+j}$，可以做到$O(n\log ^ 2 n)$的复杂度。进一步观察，这个动态维护的过程中，我们每一次删除的是$((S_x,v_x),u_x)$，而加入的是$((S_{x+n},v_{x+n}) ,u_{x+n}) = (( S_x +sum, v_x), u_x +1)$。如果我们不去做这个修改，造成的影响是：对于所有的$i&gt;x,S_i &gt; S_x$，$R_i$会多算上$1$的贡献，这是一个二维偏序问题。不做修改的原问题也是个二维偏序问题。这样就做到了$O(n\log n)$的复杂度。</p>
<h2 id="C-search"><a href="#C-search" class="headerlink" title="C - search"></a>C - search</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p>交互题。有一个$n\times n$的单调矩阵（同一行的元素右边的比左边的大，同一列的元素下面的比上面的大），此外还有一个数$x$。保证矩阵内的元素以及$x$两两互不相同。有两种询问：</p>
<ul>
<li>询问矩形内的某两个格子，返回它们的大小关系。</li>
<li>询问矩形内的某一个格子，返回这个格子与$x$的大小关系。</li>
</ul>
<p>你需要回答，矩形内比$x$小的位置的个数。</p>
<p>$n\le 2000$，时限2s，限制询问1的次数不超过$64n$，询问2的次数不超过$34$。</p>
<h3 id="Sol-8"><a href="#Sol-8" class="headerlink" title="Sol"></a>Sol</h3><h4 id="一个随机算法"><a href="#一个随机算法" class="headerlink" title="一个随机算法"></a>一个随机算法</h4><p>随机一个格子$(i,j)$，然后抠出如下图的这个轮廓线：</p>
<p><img src="https://i.loli.net/2019/12/25/wJTPcaYkMhtdEgb.png" alt=""></p>
<p>有颜色的格子是用过询问1的，橘色表示问出来比$x$小，蓝色表示问出来比$x$大。</p>
<p>这样抠一次，$i$行之前的，橘色格子每列至多有一个，蓝色格子每行至多有一个；$i$行之后的，橘色格子每行至多有一个，蓝色格子每列至多有一个。所以这一步会用掉至多$2n$次询问1。</p>
<p>比较$(i,j)$与$x$的大小关系。若$(i,j) &lt; x$，则轮廓线上方的全部都$&lt; x$，可以记入贡献之后删掉；否则，$(i,j) &gt; x$，则轮廓线下方的也全部$&gt; x$，可以删掉。</p>
<p>期望只需要进行$O(\log n)$次上述操作，就可以结束程序。</p>
<hr>
<h1 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h1><h2 id="A-xor"><a href="#A-xor" class="headerlink" title="A - xor"></a>A - xor</h2><h3 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h3><p>给定$n,d$，求</p>
<script type="math/tex; mode=display">
\sum_{0\le x,y,z < n }(x \oplus y\oplus z)^d \pmod {998244353}</script><p>其中$\oplus$表示按位异或。</p>
<p>$n&lt; 2^{30},d\le 100000$。</p>
<h3 id="Sol-9"><a href="#Sol-9" class="headerlink" title="Sol"></a>Sol</h3><h4 id="部分分：-d-le-10"><a href="#部分分：-d-le-10" class="headerlink" title="部分分：$d\le 10$"></a>部分分：$d\le 10$</h4><p>下面是一个和正解毫无关系的暴力。</p>
<p>通过数位$dp$单独对二进制每一位进行考虑。考虑怎么算答案，设$p_i$表示第$i$位是$0$还是$1$，由多项式乘法的组合意义可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\sum_{i=0}^{\log n} p_i 2^i)^d =d!\sum_{l_1+l_2 + \cdots +l_{\log n}=d} \prod_i {(p_i2^i)^{l_i}\over l_i!}
\end{aligned}</script><p>在$dp$状态中加入一维表示$l_1 + l_2  +\cdots l_{cur_len}$，就可以在$O(\log n \cdot 2^3 \cdot d^2)$的时间内解决问题。</p>
<h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><p>枚举$x,y,z$最高的和$n$不同的一位，假设为$a,b,c$。不失一般性地令$a\le b\le c$。$x\oplus y\oplus z$可能取到的数，满足$c$以上的位全部与$n$相同，$c$位为$0$且$n$的$c$位为$1$，$c$以下的位任意。考虑末$c$位取到某个$L\in [0,2^c)$的方案数，发现我们可以先让$x$的末$a$位、$y$的末$b$位随便取，然后根据$x,y$和$L$唯一地确定$z$的末$c$位，故而方案数为$2^{a+b}$。这也就是说，枚举完$a,b,c$之后，$x\oplus y\oplus z$的每一个可能的取值出现的方案数是一样的。所以只需要求出所有的可能取到的数的$d$次方的和就可以了。可能取到的数形成了一个连续的区间，是经典的自然数幂和问题。直接枚举$a,b,c$计算的复杂度为$O(d\log ^ 3 n)$，观察发现可取到的数形成的区间只与$\max\{ a,b,c\}$有关，所以只需要算$\log n$次自然数幂和就可以了，复杂度$O(d\log n + \log^3 n)$。</p>
<h2 id="B-N门问题"><a href="#B-N门问题" class="headerlink" title="B -  N门问题"></a>B -  N门问题</h2><h3 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h3><p>$N$扇门中有一扇门是有奖的。初始的时候$A$认为所有门有奖的概率是相等的。每一轮，$A$会在有奖概率最大的门中随机选择一扇，然后主持人会从没有被$A$选择且没有奖的所有门中随机选择一扇门打开。进行到第$N-1$轮时，$A$的选择就是他的最终选择。</p>
<p>现在你来当主持人，你可以决定（而不是随机地）每一次打开哪一扇没有被$A$选择且没有奖的门，问$A$最终选择的门后面有奖的概率最小是多少。假定$A$不知道你是托儿，即$A$仍然认为你是在随机选择门。</p>
<p>$N\le 10^{18}$</p>
<h3 id="Sol-10"><a href="#Sol-10" class="headerlink" title="Sol"></a>Sol</h3><p><del>假设在某一轮，$n$个门后面有奖且主持人做出这样的选择的概率（贝叶斯公式中的$P(B\mid A)$）分别是$p_1,p_2,\cdots p_n$。</del></p>
<p><del>假设$A$选择的门是$x$，而你打开的门是$y$，则：</del></p>
<script type="math/tex; mode=display">
\begin{aligned}
p'_x = p_x {1\over n-1} \\
p'_k = p_k {1\over n-2} (k\not =x, y) \\
\end{aligned}</script><p><del>下面将证明，在某一轮$\forall k \not = x,y, p’_x &lt; p’_k$。考虑归纳。对于第一轮显然成立。假设现在是第$t$轮，还剩下$n$扇门没有开。由于$p’_k(k\not=x,y)$之间的大小关系由$p_k$决定，所以只需要考虑$p_k$中的最小值$p_q$乘上$1\over n-2$与$p_x \cdot {1\over n-1}$的大小关系。而由于归纳，$p_q$在上一轮中是最大的，用$\{ p’’_i\}$表示上一轮的数，则$p’_q = p’’_q \cdot {1\over (n-2)(n-2)}$，而$p’_x = p’’_x \cdot{ 1\over (n-3)(n-1)}$，所以可以推出。。。什么也推不出来。</del></p>
<p>不知道怎么证明的，$N&gt;10$的时候答案为$0$，$N\le 10$的时候直接搜索。</p>
<h2 id="C-区间匹配"><a href="#C-区间匹配" class="headerlink" title="C - 区间匹配"></a>C - 区间匹配</h2><h3 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h3><p>有两个长度为$n$的序列$a[1\cdots n],b[1\cdots n]$和两个非负整数$la,lb(lb \le la)$，你需要求出一个$1$到$n$的排列$\{p\}$，使得对于所有$i$都有$a[i] \le b[p[i]] \le a[i] + la$，在此基础上你需要最大化满足$a[i] + lb \ge b[p[i]]$的$i$的数量，并输出最大化的结果。</p>
<p>$n\le 500000$，$a[i],b[i],la,lb\le 500000$，且保证存在合法的$p$。</p>
<h3 id="Sol-11"><a href="#Sol-11" class="headerlink" title="Sol"></a>Sol</h3><p>考虑这样的一种贪心：从右到左考虑每一个$a$的元素，确定与它匹配的$b[p[i]]$。设现在还没有匹配过的元素中，最靠右的一个是$b[x]$，以及最靠右且满足$a[i] \le b[y] \le a[i]+lb$的是$b[y]$。如果让$a[i]$匹配上$b[y]$，剩下的点仍然存在合法的匹配，则让$a[i]$匹配$b[y]$；否则让$a[i]$匹配$b[x]$。</p>
<p>正确性证明：假设这样得到的不是最优解，考虑最优匹配中第一个与这样求出来的匹配不同的位置$i$，如果$i$匹配的既不是$x$也不是$y$，将$i$匹配的改成$x$或者$y$，答案一定不会变劣；假设最优匹配中$i$匹配了$y$，则意味着让$i$匹配$y$之后仍然存在完备匹配，所以我们的贪心策略也会让$i$匹配$y$；而如果最优匹配中$i$匹配了$x$，我们的贪心策略让$i$匹配了$y$，设我们的贪心策略中匹配了$x$的是$q_x$（显然$q_x$对答案没有贡献），而最优策略中$q_x$匹配$z$，则有两种情况：</p>
<ol>
<li>$z\le y$，则$q_x,z$这一对有可能对答案产生了贡献，此时我们将最优决策改为$x$匹配$q_x$，$i$匹配$y$，显然是不会变劣的。</li>
<li>$z&gt; y$，则$q_x,z$这一对一定对答案没有贡献。继续考虑$q_z$和最优策略中$q_z$所匹配的$w$，若$w\le y$就改成$q_x$匹配$x$，$q_z$匹配$z$，$i$匹配$y$，答案不会变劣，因为用到的$y$的右侧的点的集合是一样的，并且用到的$y$的左侧的点（从$w$变成了$y$）没有向左移，而已经确定了的匹配的贡献也没有变小；否则，继续考虑$q_w$直到匹配的点在$y$的左侧。</li>
</ol>
<p>直接检查是否存在完备匹配是$O(n\log n)$的（排序+贪心）。由Hall定理可得，存在完备匹配的条件是，不存在$z$使得$\sum_{i} [b[i] \ge z] &gt; \sum_{j} [a[j] + la \ge z]$。用线段树维护每个$z$的$\sum_{i} [b[i] \ge z] - \sum_{j} [a[j] + la \ge z]$以及区间最小值，并支持区间$+1/-1$，即可在$O(n\log n)$的时间内解决问题。</p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ171 【WC2016】挑战NPC</title>
    <url>/2020/02/19/UOJ171-%E3%80%90WC2016%E3%80%91%E6%8C%91%E6%88%98NPC/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>这道题的建图方法：</p>
<ol>
<li>每个筐拆成三个点分别代表三个位置，三个点两两之间互相连边</li>
<li>每个球向它可以放入的筐的三个点都连边</li>
</ol>
<p>求出这张图的最大匹配，减去球数就是答案。</p>
<p>如果一个筐的三个位置只被球占用了0个或者1个，那么这个筐内的位置就能够再构成一个匹配，对最大匹配产生1的贡献；否则，这个筐内的位置将无法再构成匹配。</p>
<p>为什么能保证一定存在一组最大匹配，所有的球都在匹配中？因为题目保证了合法方案存在，而合法方案一定可以对应到一组匹配。</p>
<p>那么如何确保每个球都在最大匹配中呢？在带花树算法中，优先对球进行bfs，其次再bfs筐。因为整个算法过程中，一个点一旦找到匹配的点了，之后就不会再变成孤立点（虽然它的配偶可能会改变）。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="http://uoj.ac/submission/385063" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>对带花树算法的一些思考</title>
    <url>/2020/02/19/%E5%AF%B9%E5%B8%A6%E8%8A%B1%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>推荐两个带花树算法的学习资料：<a href="https://en.wikipedia.org/wiki/Blossom_algorithm" target="_blank" rel="noopener">维基百科</a> <a href="https://blog.bill.moe/blossom-algorithm-notes/" target="_blank" rel="noopener">Bill Yang’s blog</a></p>
<h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>缩掉奇环之后，会不会存在一条交错路，和奇环相交的部分没有经过花根，成为了一条在缩掉了花之后的图中找不到的增广路？</p>
<p><img src="https://i.loli.net/2020/02/19/vjMD6BmsPTpqAHZ.jpg" alt=""></p>
<p>如上图，实线表示匹配边，虚线表示非匹配边，1和12是孤立点，$\{5,6,7,8,9\}$是已经缩起来的一朵花，5是花根。一条交错路是1-3-4-6-7-10-11-12，可以看到这条交错路进入花的最后一条边和离开花的第一条边都是非匹配边，无法在缩掉蓝色的花之后的图中找到。但是当我们访问到6-4这条边的时候，由于蓝色的花已经被缩起来了，就会发现$\{1,3,4,6,7,8,9,5,2\}$这个奇环并把它缩起来。所以这样的交错路是仍然能够被带花树算法找到的。</p>
<hr>
<p>后面的问题和代码实现有关，所以先贴上我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a solution for uoj79</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> n,fa[N],vis[N],par[N],pre[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	fa: 用来缩点的并查集</span></span><br><span class="line"><span class="comment">	vis:</span></span><br><span class="line"><span class="comment">		0 未被访问过</span></span><br><span class="line"><span class="comment">		1 所在的层数奇偶性和出发点相同</span></span><br><span class="line"><span class="comment">		2 所在的层数奇偶性和出发点不同</span></span><br><span class="line"><span class="comment">	par: 现在的配偶，0表示现在没有配偶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d=<span class="number">0</span>)</span> </span>&#123; <span class="keyword">if</span>(d&gt;n) <span class="keyword">return</span> x; <span class="keyword">return</span> fa[x]==x?x:fa[x]=find(fa[x],d+<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> vis[N],tim;	</span><br><span class="line">	tim++;</span><br><span class="line">	x=find(x),y=find(y);</span><br><span class="line">	<span class="keyword">while</span>(x) vis[x]=tim,x=find(pre[par[x]]); <span class="comment">// (1)</span></span><br><span class="line">	<span class="keyword">while</span>(vis[y]!=tim) y=find(pre[par[y]]); <span class="comment">// (1)</span></span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLOWER</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(find(x)!=L) &#123; <span class="comment">// (2)</span></span><br><span class="line">		<span class="keyword">if</span>(fa[x]==x) fa[x]=L; <span class="comment">// (3)</span></span><br><span class="line">		<span class="keyword">if</span>(fa[par[x]]==par[x]) fa[par[x]]=L; <span class="comment">// (3)</span></span><br><span class="line">		<span class="keyword">if</span>(vis[par[x]]==<span class="number">2</span>) vis[par[x]]=<span class="number">1</span>,que.push(par[x]);</span><br><span class="line">		pre[x]=y;</span><br><span class="line">		y=par[x],x=pre[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i,vis[i]=pre[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty()) que.pop();</span><br><span class="line">	que.push(s),vis[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u=que.front(); que.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> v=G[u][i];</span><br><span class="line">			<span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">				pre[v]=u,vis[v]=<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(!par[v]) &#123;</span><br><span class="line">					<span class="keyword">while</span>(v) &#123;</span><br><span class="line">						<span class="keyword">int</span> tmp=par[u];</span><br><span class="line">						par[v]=u,par[u]=v;</span><br><span class="line">						v=tmp,u=pre[v];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				vis[par[v]]=<span class="number">1</span>;</span><br><span class="line">				que.push(par[v]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(vis[v]==<span class="number">1</span>&amp;&amp;find(v)!=find(u)) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp=LCA(u,v);</span><br><span class="line">				FLOWER(u,v,tmp),FLOWER(v,u,tmp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m; rd(n),rd(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i) rd(x),rd(y),G[x].PB(y),G[y].PB(x);	</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123; <span class="keyword">if</span>(!par[i]) ans+=bfs(i); &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,par[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q2-1-2"><a href="#Q2-1-2" class="headerlink" title="Q2 (1) (2)"></a>Q2 (1) (2)</h2><p>(1) 不能写作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x) vis[x]=tim,x=pre[par[x]]; </span><br><span class="line"><span class="keyword">while</span>(vis[y]!=tim) y=pre[par[y]];</span><br></pre></td></tr></table></figure></p>
<p>(2) 不能写作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=L) &#123;</span><br></pre></td></tr></table></figure></p>
<p>原因是，可能尽管我们没有进行显式的缩点，在走到奇环的时候会顺着边爬，但是在奇环嵌套偶环的时候可能会陷入死循环。</p>
<p><img src="https://i.loli.net/2020/02/19/X7Wldj5F6sYHJpR.jpg" alt=""></p>
<p>比如，上面这张图中，我们已经找到 (2,1) ，(3,4) 这两对匹配，现在开始尝试找从 5 开始的增广路。首先会找到 $\{5,1,2\}$ 这个奇环并缩起来，之后会找到 $\{5,1,3,4,2\}$ 这个奇环并缩起来，但是在缩这个奇环的过程中，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(find(x)!=L) &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	pre[x]=y;</span><br><span class="line">	y=par[x],x=pre[y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就会陷入<code>(x=2, y=4) -&gt; (x=3, y=1) -&gt; (x=2, y=4) -&gt; ...</code>的死循环。</p>
<h2 id="Q3-3"><a href="#Q3-3" class="headerlink" title="Q3 (3)"></a>Q3 (3)</h2><p>(3) 不能写作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fa[find(x)]=L;</span><br><span class="line">fa[find(par[x])]=L;</span><br></pre></td></tr></table></figure><br>因为在往上爬的过程中，我们会先经过一些在花中但不是花根的点，这时候如果修改了这个花中所有的点的所属的花编号，会影响下一步用<code>find(x)!=L</code>判断是否已经走到了<code>L所在的花</code>。正确的做法是，走到花根的时候才修改花中的点所属的花编号。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ577 「LibreOJ NOI Round #2」简单算术</title>
    <url>/2020/02/17/LOJ577-%E3%80%8CLibreOJ-NOI-Round-2%E3%80%8D%E7%AE%80%E5%8D%95%E7%AE%97%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>考虑多项式乘法的组合意义，枚举第$i$项被选的次数$b_i$，要求$\sum b_i = m, \sum b_i i = k$，则对应的贡献为</p>
<script type="math/tex; mode=display">
\binom{m}{b_0}\binom{m-b_0}{b_1}\binom{m-b_0-b_1}{b_2} \cdots \cdot \prod_i a_i ^ {b_i}</script><p>如果$p \mid m$，我们对上面的式子应用Lucas定理，发现：</p>
<ul>
<li>若$p \nmid b_0$则第一项一定为$0$，要使整个式子不为$0$就一定要有$p \mid b_0$</li>
<li>于是有$p \mid m - b_0$，于是可以推出$p\mid b_1$</li>
<li>……</li>
</ul>
<p>也就是说，所有的$b_i$都是$p$的倍数。</p>
<p>令</p>
<script type="math/tex; mode=display">
B(x) = \sum_{i=0}^n a_i^{p}x^{ip}</script><p>那么就可以把此时的答案写成</p>
<script type="math/tex; mode=display">
[x^k] A^m(x) = [x^k] B^{\frac{m}{p}}(x)</script><p>这个$B^{\frac{m}{p}}(x)$的意义相当于让原来的$b_i$和$m$都除以$p$，不会影响系数的计算。</p>
<p>考虑到$a_i^p \equiv a_i \pmod p$，所以答案也可以写成</p>
<script type="math/tex; mode=display">
[x^{\frac{k}{p}}]A^{\frac{m}{p}}(x)</script><p>更一般的，对于任意的$m$，设$m = up + v(0\le v &lt; p)$，则有</p>
<script type="math/tex; mode=display">
[x^k] A^m(x) = \sum_{i=0}^{\min\{vn,k\}} [x^{k-i}]A^{up}(x)\cdot [x^i]A^v(x)</script><p>$[x^{k-i}]A^{up}(x)$直接递归，$[x^i]A^v(x)$可以通过预处理$A(x)$的$0$到$p-1$次幂解决。要对访问到过的状态进行记忆化。</p>
<p>因为当$p\nmid i-k$时$[x^{k-i}]A^{up}(x) = 0$，所以只需要枚举和$k$同余的$i$，这样的$i$会有$\frac{vn}{p} \le n$个。</p>
<p>考虑复杂度：</p>
<ul>
<li>每一次往下递归$m$会变成$\lfloor \frac{m}{p} \rfloor$，$k$会变成$\lfloor \frac{k}{p}\rfloor - i’$，$i’$的范围是$<a href="lim\le n">0,lim</a>$；</li>
<li>每一层的$m$都是一样的，所以只用考虑$k$会有多少种不同的取值；</li>
<li>对于第$i$层，$k$能取到的最大值是$\frac{k}{p^{i-1}}$，最小值则不小于$\frac{\frac{\frac{k}{p}-n}{p}-n}{p}\cdots \approx O(\frac{k}{p^{i-1}} - n \cdot {1\over p-1})$，所以每一层不同的$k$的数量至多是$O(n)$的；</li>
<li>状态数$O(n\log_pm)$，转移$O(n)$，所以这里的复杂度是$O(Tn^2\log_p m)$，算上预处理的复杂度就是$O(p^2n^2 + Tn^2\log_p m)$</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><a href="https://loj.ac/submission/746679" target="_blank" rel="noopener">link</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>From Suffix Tree to SAM</title>
    <url>/2020/02/17/From-Suffix-Tree-to-SAM/</url>
    <content><![CDATA[<p>You may check <a href="https://cp-algorithms.com/string/suffix-automaton.html" target="_blank" rel="noopener">this article on cp-algorithms.com</a> (or OI-wiki if you prefer reading in Chinese) for more precise information and proof of complexity about SAM. Here I just want to write about another perspective to understand SAM, which I’ve learned from Huadun Hong, PKU, through Zhengruioi’s online courses on 4th, Feb, 2020.</p>
<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>We can get the suffix tree of string $S$ simply by inserting all of its suffixes into a trie (though this will involve $O(|S|^2)$ vertices). Note that: </p>
<ul>
<li>Each vertex in the suffix tree represents a substring of $S$ (since a substring is a prefix of a suffix of $S$). Let’s call the vertices that represent a suffix of $S$ ‘the suffix vertices’.</li>
<li>The number a substring occurs in $S$ equals to the number of suffix vertices in the subtree of the corresponding  vertex.</li>
<li>The well-known data structure Suffix Array is actually the DFS ordering of the suffix tree. (Sort the suffix vertices by the time we discover them.)</li>
<li>LCP of two suffixes is the LCA of the corresponding suffix vertices in the suffix tree.</li>
</ul>
<p>Define:</p>
<ul>
<li>$len_x$:  the length of the string that vertex $x$ represents, also equals to the depth of $x$ in the suffix tree.</li>
<li>$fail_x$: father of $x$ in the suffix tree.</li>
<li>$go_{x,ch}$: (this definition <strong>differs from traditional definition of SAM</strong>) suppose $x$ represents string $T$, then $go_{x,ch}$ is the vertex that corresponds to the string $cT$. I may write $go_{T,ch}$ for $go_{x,ch}$ or the string $go_{x,ch}$ represents for convenience in the following paragraph, so don’t get confused with it.</li>
</ul>
<p>It seems there is some delicate contact between $go_{x,ch}$ and the suffix links in the Aho–Corasick algorithm, isn’t it? And when the suffix tree is compressed later it turns out that it’s no longer convenient to find the son of a pariticular vertex in the suffix tree, and that’s why we’ve got to maintain the array $go_{x,ch}$. Thus if we want to find the corresponding vertex of a particular string $T$, we just start from the root of the suffix tree, enumerate each character of $T$ from right to left and go to $go_{\text{current node,current character}}$.</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>In this section we’ll talk about how to construct the suffix tree and maintain $len_x, fail_x, go_{x,ch}$ by adding characters of $S$ one by one from right to left.</p>
<p>That is, we have already built SAM of $S$, now we wanna get SAM of $cS$ out of it.</p>
<p>From $S$ to $cS$, only one more suffix’s added, that’s $cS$. So first we’ll insert $cS$ into the suffix tree (remember the suffix tree here is still a trie) and maintain $len_x, fail_x$ of the newly-added vertices. We do it in the following way: we create a new vertex $u$ that represents $cS$, then we find the longest $cS[1:i]$ that occurred in $S$ and let the corresponding vertex be $v$. Then we add vertices representing $cS[1:|S|-1],cS[1:|S|-2], \cdots S[1:i+1]$ between $u$ and $v$.</p>
<p>Consider about the changes in $go_{x,ch}$, they can be divided into two types:</p>
<ul>
<li>$x$ is one of those newly-added vertices, or</li>
<li>$go_{x,ch}$ is one of those newly-added vertices</li>
</ul>
<p>Note it’s impossible to have $x$ and $go_{x,ch}$ both newly-added.</p>
<p>For the first type, since strings the newly-added vertices represent do not occur in $S$, so after adding $c$ at the front they won’t occur either. Then just set all $go_{x,ch}$ of the newly-added vertices to <code>null</code>.</p>
<p>For the second type, we enumerate all prefixes of $S$ that $go_{S[1:j],c}$ is <code>null</code>, then let $go_{S[1:j],c}$ be $cS[1:j]$. This can be done by starting from $S$ and each time jumping to the father of current node until $go_{\text{current node},ch}$ is not <code>null</code>.</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>Note there can be $O(|S|^2)$ vertices in the suffix tree, but number of vertices with degree greater than $2$ is at most $2|S|-1$. Then if a vertex has only one child, we compress it and its’ only-child and say the original father is ‘compressed’. Specially, because suffix vertices contain a lot of important information so we’ll never compress a suffix vertex, even if it has only one child. We call all remaining vertices after the process ‘key vertices’.</p>
<p>Define:</p>
<ul>
<li>$Z(x)$: let $Z(x)$ be the set of strings that vertices compressed into $x$ represented in the original suffix tree. Note that all strings in $Z(x)$ can be represented as one prefix of the longest string in $Z(x)$.</li>
<li>$len_x$: the length of longest string in $Z(x)$.</li>
<li>$fail_x$: the first key vertex we meet in the original suffix tree by starting from $x$ and continuously jumping to father of the current node.</li>
<li>$go_{x,ch}$:<ul>
<li>An important fact is that in the original suffix tree $go_{x,ch}$ must be compressed if $x$ is compressed. To prove this let $T$ be the string $x$ represents and $cT$ be some key vertex.<ul>
<li>If $cT$ is a suffix vertex then $T$ should also be a suffix vertex which made $T$ impossible to be compressed.</li>
<li>Then $cT$ must have two distinct children, let them be $cTx$ and $cTy$. It turns out that $T$ should also have $Tx$ and $Ty$ as its children, which meets a contradiction.</li>
</ul>
</li>
<li>But if $x$ is a key vertex, $go_{x,ch}$ in the original suffix tree may be compressed. In this case we let $go_{x,ch}$ be the key vertex that the original $go_{x,ch}$ has been compressed into. Thus we can ensure $\forall Y\in Z(x), cY \in Z(go_{x,c})$.</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/17/vOGy15NqmpSt9wr.png" alt=""></p>
<p>(This is a picture from Huadun Hong’s slide, representing $go_{x,c}$.)</p>
<p>Then consider how to build SAM with our previous algorithm. First we create a new vertex stands for $cS$. </p>
<p>Finding the greatest $i$ that $cS[1:i]$ occurs in $S$ is equivalent to finding the greatest $i$ that $go_{S[1:i],c}$ is not <code>null</code>. So we can just start from $S$ and continuously jump to $fail_{\text{current node}}$ until the current node satisfies $go_{\text{current node},c}$ is not <code>null</code>. Let this vertex be $Q$ and $E$ be $go_{Q,c}$.</p>
<p>We should set $fail_{cS}$ to a vertex that the longest string it represents is $cQ$. But note that $cQ$ may not be the longest one in $Z(E)$, if so we shall ‘decompress’ it from $E$ since we’re about to add a new child to it. Let the newly-decompressed vertex be $K$ (let $K$ be $E$ in case that $cQ$ is the longest one in $Z(E)$) and let $fail_{cS} = K$.</p>
<p>Now we’ll take a look at changes in $go_{x,ch}$: </p>
<ul>
<li>like the original $O(|S|^2)$ suffix tree, we set $go_{x,c}$ of all vertices on the chain from $S$ to $Q$ to $cS$</li>
<li>and for $Q$ and $Q$’s ancestors satisfying $go_{x,c} = E$, we change $go_{x,c}$ to $K$.</li>
</ul>
<p>Thus we’ve completed contruction of SAM.</p>
<p>It turns out that time complexity and memory complexity of this algorithm are both $O(|S|)$. </p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>APIO2019</title>
    <url>/2020/02/14/APIO2019/</url>
    <content><![CDATA[<h2 id="桥梁"><a href="#桥梁" class="headerlink" title="桥梁"></a>桥梁</h2><p>将所有的操作按照时间顺序分成$T$个大小为$\frac{q}{T}$的块。对于每个块，将块内的询问按照$w_j$排序，将未被块内的操作修改过的边按照执行这个块内的操作之前的边权排序。</p>
<p>按照$w_j$降序枚举块内的询问，然后将所有重$w_j$的车能够通过的、“未被块内的操作修改过的”边加入；再加入块内修改过的、这次询问的时候的边权$\ge w_j$的边，查询$s_j$所在连通块的大小，然后再撤销掉加入的块内修改过的边。</p>
<p>复杂度是$O(\frac{q}{T}(m\log m + m\log n) + qT\log n)$，当$T$大致取到$\sqrt m$的时候最优。由于排序的那个$\log m$比并查集的$\log n$大得多，所以可以适当调大$T$。</p>
<p><a href="https://loj.ac/submission/731393" target="_blank" rel="noopener">Code</a></p>
<h2 id="路灯"><a href="#路灯" class="headerlink" title="路灯"></a>路灯</h2><p>对每个时刻的序列，维护它的极长的、只包含$1$的区间构成的集合。</p>
<p>对每个曾经在集合中出现过的极长$1$区间，将它对每个询问的贡献分成两部分：</p>
<ol>
<li>询问的时候它还在序列中，贡献是询问的时刻 - 它被加入的时刻（由于极长$1$区间不交，所以对于一个询问，这种区间如果有则一定只有一个）；</li>
<li>询问的时候它已经不在序列中了，贡献就是它出现过的时刻数；</li>
</ol>
<p>而一个极长$1$区间$[l,r]$对一个询问$[a,b]$能产生贡献当且仅当$l\le a, b-1\le r$，是个二维偏序。加上“离开序列的时间小于询问的时间”就是三维偏序，可以cdq分治解决。</p>
<p>而第一种贡献用set维护当前时刻所有的极长$1$区间就能计算。</p>
<p><a href="https://loj.ac/submission/744366" target="_blank" rel="noopener">Code</a></p>
<h2 id="奇怪装置"><a href="#奇怪装置" class="headerlink" title="奇怪装置"></a>奇怪装置</h2><p>考虑什么情况下两个时刻的$(x,y)$会相同。</p>
<p>因为$y=(t\bmod B)$，所以这两个时刻可以写成$t,t+kB$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
t + \lfloor \frac{t}{B} \rfloor \equiv t + kB + \lfloor \frac{t+kB}{B} \rfloor \pmod A\\
t + \lfloor \frac{t}{B} \rfloor \equiv t + kB + \lfloor \frac{t}{B} \rfloor + k \pmod A\\
0 \equiv k(B+1) \pmod A\\
A \mid k(B+1)
\end{aligned}</script><p>考虑$B+1,A$的质因数分解：</p>
<script type="math/tex; mode=display">
\begin{aligned}
B+1 = \prod p_i^{b_i}\\
A = \prod p_i^{a_i}
\end{aligned}</script><p>则最小的满足条件的$k$就是</p>
<script type="math/tex; mode=display">
\begin{aligned}
k_{min}\prod p_i^{\max\{a_i - b_i,0\}}\\
= \prod p_i^{a_i - \min\{b_i,a_i\}}\\
= \frac{A}{\gcd(A,B+1)}
\end{aligned}</script><p>且其它满足条件的$k$都是它的倍数。</p>
<p>所以$t_1,t_2$的二元组$(x,y)$相同当且仅当$t_1\equiv t_2\pmod{k_{min}B}$</p>
<p>这样就转化成了简单的区间并问题。</p>
<p>注意考虑$k_{min}B$超过long long范围的情况。</p>
<p><a href="https://loj.ac/submission/744366" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1270 Goodbye 2019 (C,D,E,F,G,H)</title>
    <url>/2020/01/27/CF1270-Goodbye-2019-C-D-E-F-G-H/</url>
    <content><![CDATA[<h2 id="C-Make-Good"><a href="#C-Make-Good" class="headerlink" title="C - Make Good"></a>C - Make Good</h2><p>记$sum$为所有数的异或和，$tot$为所有数的和。$tot$显然必须是偶数。所以如果$tot$是奇数的话，就先往数组里面加入一个$1$。</p>
<p>如果$2\times sum &gt; tot$，就往数组里面加入两个${2\times sum - tot \over 2}$，这对数组中的数的异或和没有影响。</p>
<p>否则，先加入一个$2^{58}$（一个很大的$2$的整数次幂），然后就会转化成$2\times sum &gt; tot$的情况。</p>
<p>如果又要加入$1$又要加入$2^{58}$，可以直接加入数$1+2^{58}$，这样就可以满足加的数至多是三个的限制。</p>
<p><a href="https://codeforces.com/contest/1270/submission/67904998" target="_blank" rel="noopener">Code</a></p>
<h2 id="D-Strange-Device"><a href="#D-Strange-Device" class="headerlink" title="D - Strange Device"></a>D - Strange Device</h2><p>首先考虑$k=n-1$怎么做：可以把每个大小为$n-1$的子集都问一遍，这样第$m+1$小的会出现$m$次，第$m$小的会出现$n-m$次，根据出现过的元素的大小关系以及它们分别的出现次数就可以推出$m$。</p>
<p>当$n&gt;k+1$，直接对前$k+1$个元素通过上面的方法计算就可以了。</p>
<p><a href="https://codeforces.com/contest/1270/submission/67910798" target="_blank" rel="noopener">Code</a></p>
<h2 id="E-Divide-Points"><a href="#E-Divide-Points" class="headerlink" title="E - Divide Points"></a>E - Divide Points</h2><p>将点分成四组：$A_{0,0},A_{0,1},A_{1,0},A_{1,1}$。点$(x,y)$属于组$A_{x\pmod 2,y\pmod 2}$。用$P,Q$代表最后分得的两个点集。</p>
<p>若所有点都属于同一个组，则将所有点的坐标除以$2$（如果原数是奇数，则向下取整）之后再做，与原问题等价。</p>
<p>如果$A_{0,0}\cup A_{1,1}$非空，且$A_{0,1}\cup A_{1,0}$非空，令$P=A_{0,0}\cup A_{1,1},Q=A_{0,1}\cup A_{1,0}$即可。【同一组内的点的$(x+y)\bmod 2$相同】</p>
<p>否则，若$A_{0,0}\cup A_{1,1}$为空集，令$P=A_{0,1},Q=A_{1,0}$即可。【只有同一组内的点的$(x_1-x_2)^2 + (y_1-y_2)^2$是$4$的倍数】</p>
<p>否则$A_{0,1}\cup A_{1,0}$为空集，令$P=A_{0,0},Q=A_{1,1}$。【同上】</p>
<p><a href="https://codeforces.com/contest/1270/submission/68144464" target="_blank" rel="noopener">Code</a></p>
<h2 id="F-Awesome-Substrings"><a href="#F-Awesome-Substrings" class="headerlink" title="F - Awesome Substrings"></a>F - Awesome Substrings</h2><p>设$x = {L\over cnt}$，其中$L$表示子串的长度，$cnt$表示子串内$1$的个数。设$T$为某个定值。</p>
<p>设$a_i = \sum_{j\le i} [s_j = 1]$。</p>
<p>将答案分为两部分计算；</p>
<ol>
<li>$x\le T$：枚举每一个$x$，然后枚举子串右端点$r$，则左端点应满足${r-(l-1)\over a_r-a_{l-1}} = x\Rightarrow r-a_rx = l-1-a_{l-1}x$，直接用map或者hash_table统计一下即可。</li>
<li>$x&gt; T$，显然有$cnt = {L\over x} \le {n\over T}$，所以可以枚举子串的左端点和$cnt$，此时要求右端点必须落在某个区间内且$r-l+1 \pmod {cnt}$为$0$，可以$O(1)$计算这样的右端点的数量。</li>
</ol>
<p>如果用map，时间复杂度$O(nT\log n + n\cdot {n \over T})$，当$T$取${\sqrt{n\over \log n}}$的时候复杂度最优，为$O(n\sqrt {n\log n})$。</p>
<p><a href="https://codeforces.com/contest/1270/submission/68145267" target="_blank" rel="noopener">Code</a></p>
<h2 id="G-Subset-with-Zero-Sum"><a href="#G-Subset-with-Zero-Sum" class="headerlink" title="G - Subset with Zero Sum"></a>G - Subset with Zero Sum</h2><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>$i-n\le a_i \le i-1$等价于$1\le i - a_i \le n$。</p>
<p>令$i$向$i-a_i$连边，会得到基环内向树森林。取一个环上的所有元素：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x - a_x = y \\
y - a_y = z \\
\vdots \\
u - a_u = x
\end{aligned}</script><p>将所有式子加起来，会得到$a_x+a_y+\cdots a_u = 0$。</p>
<p><a href="https://codeforces.com/contest/1270/submission/68150511" target="_blank" rel="noopener">Code</a></p>
<h2 id="H-Number-of-Components"><a href="#H-Number-of-Components" class="headerlink" title="H - Number of Components"></a>H - Number of Components</h2><p>观察发现，如果$i,j(i&lt;j)$连通，那么对于任意的$k\in (i,j)$，$k$与$i,j$连通。</p>
<p>证明：考虑连通块中从$i$到$j$的一条路径，若$k$在这条路径上结论显然成立；否则，这其中必定存在一条边$(u,v)$满足$u &lt; k &lt; v$，由于$a_u &lt; a_v$，所以$a_u &lt; a_k \vee a_k&lt; a_v$一定成立。</p>
<p>所以，连通块一定是序列上的一段连续的区间。</p>
<p>将问题转化成：计算有多少个$p$，满足$[1,p]$和$[p+1,n]$之间没有边。而这个限制条件也等价于$\forall x\in [1,p], y\in [p+1,n], a_x &gt; a_y$。</p>
<p>考虑枚举$[p+1,n]$中的最大值$v$，记序列中小于等于$v$的值为$0$，大于$v$的值为$1$，则$p$合法的条件就是整个序列形如$\overbrace{111\cdots 111}^{\text{p个1}}000\cdots 000$。</p>
<p>发现对于每个$v$而言，它对应的$01$序列是确定的，也就是说尽管一个$v$可以对应多个$p$，但是这些$p$中至多只有一个合法。</p>
<p>所以我们不妨直接统计有多少个$v$对应的$01$序列形如$111\cdots 111000\cdots 000$。</p>
<p>为了方便处理，我们令$a_0 = + \infty, a_{n+1} = -\infty$</p>
<p>用线段树维护对每一个$v$维护它对应的$01$序列中相邻的$10$对的数量，以及$v$是否作为序列中的某个元素出现。由于$10$对的数量至少有一个，所以维护最小值以及最小值的数量，即可得到合法的$v$的数量。</p>
<p><a href="https://codeforces.com/contest/1270/submission/68155123" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>一类序列上的最短路问题-倍增</title>
    <url>/2020/01/27/%E4%B8%80%E7%B1%BB%E5%BA%8F%E5%88%97%E4%B8%8A%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98-%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<h2 id="CF1246F-Cursor-Distance"><a href="#CF1246F-Cursor-Distance" class="headerlink" title="CF1246F Cursor Distance"></a>CF1246F Cursor Distance</h2><p>考虑对于每一个$i$，求出至多走$k$步就能够到达它的位置所构成的区间$[L_{i,k},R_{i,k}]$。我们只要对每个$i$分别求出$\sum_k L_{i,k},\sum_k R_{i,k}$就能得到答案。</p>
<p>最短路不一定是单向的（比如对于baaaaac，从b走到最后一个a），所以$L,R$可能不独立，不能直接倍增计算$L,R$的和。</p>
<p>进一步观察，$R_{i,k+2}$的取值与$[L_{i,k+1},L_{i,k})$中的位置有关的必要条件是$[L_{i,k+1},R_{i,k+1}]$的字符集大于$[L_{i,k},R_{i,k}]$的字符集；如果$[L_{i,k+1},R_{i,k+1}],[L_{i,k},R_{i,k}]$字符集相同，则$R_{i,k+2}$就只与$R_{i,k+1}$和$[L_{i,k},R_{i,k}]$的字符集大小有关。</p>
<p>对于每个$i$，当$k$从$0$取到$+\infty$的时候，$[L_{i,k},R_{i,k}]$的字符集大小只会变化$|\Sigma|$次（$|\Sigma|$表示字符集大小）。故而，我们可以枚举当前这些区间的字符集大小，这时候$L,R$是独立的，可以直接倍增求出它们的和。</p>
<p>实现细节上，在最外层枚举区间的字符集大小$t$，然后对每个位置$i$处理出$fl_i$——表示当$L$为某个满足$[L,i]$字符集大小为$t$的位置，$R=i$的时候，跳一步能够把$R$扩展到哪里；以及类似定义的$fr_i$。预处理出$fl_i,fr_i$倍增的结果。然后对每个$i$从大到小枚举$j$，然后看它现在的区间端点扩展$2^j$次以后，区间内是否仍然只有$t$种字符。</p>
<p><a href="https://codeforces.com/contest/1246/submission/69554739" target="_blank" rel="noopener">Code</a></p>
<hr>
<h2 id="LOJ6435-「PKUSC2018」星际穿越"><a href="#LOJ6435-「PKUSC2018」星际穿越" class="headerlink" title="LOJ6435 「PKUSC2018」星际穿越"></a>LOJ6435 「PKUSC2018」星际穿越</h2><p><a href="https://www.cnblogs.com/HocRiser/p/9166459.html" target="_blank" rel="noopener">参考这篇blog</a></p>
<p>设$f_{i,k}$为从$i$出发，走$k$步能够到达的最靠左的点。则有$f_{i,k+1} &lt; f_{i,k}$。</p>
<p>显然$f_{i,1} = l_i$。</p>
<p>然后是$f_{i,2} = \min_{j \ge l_i} \{l_j\}$：</p>
<ul>
<li>对于$j\in [l_i,i)$，$i$可以在第一步走到$j$；</li>
<li>对于$j&gt;i$，如果$l_j\le i$我们可以选择在第一步走到$j$，否则$l_j &gt; i$，$l_j$一定不会被$\min_{x\ge l_i}\{l_x\}$取到。</li>
</ul>
<p>对于$f_{i,k} (k &gt; 2)$，有$f_{i,k} = \min_{j\in [f_{i,k-1},f_{i,k-2})} \{ l_j \} = \min_{j\in [f_{i,k-1},i)} \{ l_j \}$。由于显然$f_{i,k} &lt; f_{i,2} \le \min_{j\ge i} \{l_j\}(k &gt; 2)$，所以也可以写作$f_{i,k} = \min_{j\in [f_{i,k-1},n]} \{ l_j \}$。这个式子中$f_{i,k}$的取值与$i$无关而只与$f_{i,k-1}$有关，所以可以倍增求出$k=2^j$时的$f_{i,k}$和$\sum_{x\in [1,k]}f_{i,x}$。</p>
<p>实现上，可以强制先走$k=1$的第一步$f_{i,1} = l_i$，这样的话之后的每一步的转移都满足$f_{i,k} = \min_{j\ge f_{i,k-1}} \{ l_j\}$</p>
<p><a href="https://loj.ac/submission/730991" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划练习题</title>
    <url>/2020/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="TopCoder14929-MaxSquare"><a href="#TopCoder14929-MaxSquare" class="headerlink" title="TopCoder14929 MaxSquare"></a>TopCoder14929 MaxSquare</h2><p><a href="https://www.topcoder.com/single-round-match-735-editorials/" target="_blank" rel="noopener">official editorial</a></p>
<p>设$s_i$表示$B$的前缀和。</p>
<script type="math/tex; mode=display">
Ans = \max_{r_1-l_1=r_2-l_2} \{(r_1-l_1)(s_{r_2}-s_{l_2}) +(r_2-l_2)(s_{r_1}-s_{l_1})\}</script><p>显然最优的时候$r_2=r_1,l_2=l_1$，所以</p>
<script type="math/tex; mode=display">
Ans = 2 \max_{l,r} \{ (r-l)(s_r-s_l) \}</script><p>想象成平面上有$n$个点$(i,s_i)$，那么上式等价于：选择两个点作为矩形的两个相对的顶点，矩形的面积的最大值。</p>
<p>我们先考虑一个点作为左下角的点，另一个点作为右上角的点的情况（一个点作为左上角，另一个作为右下角是同理的）。</p>
<p>显然对于作为左下角的那些点来说，如果$i &lt; j\wedge s_i &lt; s_j$，那么$(i,s_i)$是没有用的。右上角同理。</p>
<p>所以有用的点会形成这样的分布：</p>
<p><img src="https://i.loli.net/2020/01/20/aDlrPFwYMVf6nTN.png" alt="TopCoder14929_1_.png"></p>
<p>然后对于每个右上角的点，考虑矩形面积在左下角的哪一个点取到最大值。观察下图：</p>
<p><img src="https://i.loli.net/2020/01/20/LXA8iwFR3cjnDvJ.png" alt="TopCoder14929_2_.png"></p>
<p>可以得到结论：如果对于$p_1$，$q_2$比$q_1$优，那么对于$p_2$，$q_2$一定比$q_1$优秀。</p>
<p>证明：考虑反证</p>
<script type="math/tex; mode=display">
\begin{aligned}
S_{p_1,q_1} < S_{p_1,q_2},S_{p_2,q_1} > S_{p_2,q_2}\\
\Rightarrow S_{p_1,q_1} + S_{p_2,q_2} < S_{p_1,q_2} +S_{p_2,q_1}\\
\Rightarrow S_{p_1,q_1} + S_{p_2,q_2} - S_{p_1,q_2} - S_{p_2,q_1} < 0\\
\end{aligned}</script><p>也就是上图中绿色标出的部分，其面积要小于$0$，推出了矛盾。</p>
<p>用经典的决策单调性的分治算法，就可以在$O(n\log n)$的时间内解决问题。</p>
<h2 id="CF908H-New-Year-and-Boolean-Bridges"><a href="#CF908H-New-Year-and-Boolean-Bridges" class="headerlink" title="CF908H New Year and Boolean Bridges"></a>CF908H New Year and Boolean Bridges</h2><p>$f(i,j) \operatorname{AND} f(j,i) =1$的肯定在同一个SCC里面，而$f(i,j) \operatorname{XOR} f(j,i) =1$的肯定不在同一个SCC里面。而由于$f(i,j) \operatorname{AND} f(j,i) =1,f(i,j) \operatorname{XOR} f(j,i) =1$中都蕴含着$f(i,j) \operatorname{OR} f(j,i) =1$，所以我们必须把所有的SCC都连成一条链。由于要让边数尽可能少，所以每个SCC一定都是单独一个点或者一个环。我们只要最小化点数大于$1$的SCC的数量就可以了。</p>
<p>$f(i,j) \operatorname{AND} f(j,i) =1$的点可以直接缩起来。缩完点之后，在原图中的点数为$1$的都不需要考虑；对于剩下的点，对所有的$f(i,j) \operatorname{XOR} f(j,i) =1$在$i,j$之间建一条边，问题转化成求最小的$k$，使得在这张图中可以将这些点划分成$k$个独立集。</p>
<p>注意到在原图中对应的点数大于$1$的点的数量不超过$\lfloor{n\over 2}\rfloor = 23$。</p>
<p>直接子集$dp$的复杂度是$O(3^{n\over 2})$或者$O(n^22^{n\over 2})$。</p>
<p>先枚举$k$，在判断的时候我们把条件放松一些：我们只要求能够选出$k$个独立集，它们的并是全集就可以了。</p>
<p>设$f_S$表示$S$的子集中是独立集的数量，通过容斥就可以得到：</p>
<script type="math/tex; mode=display">
Ans = \sum_{T\in V} (-1)^{|V|-|T|}f_T^k</script><p>这个$Ans$会很大，但是我们只关心$Ans$是否为$0$，用取模或者直接溢出后的结果判断就可以了。</p>
<p>时间复杂度$O(n2^{n\over 2})$。</p>
<p><a href="https://codeforces.com/contest/908/submission/69094070" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2292-「THUSC-2016」成绩单"><a href="#LOJ2292-「THUSC-2016」成绩单" class="headerlink" title="LOJ2292 「THUSC 2016」成绩单"></a>LOJ2292 「THUSC 2016」成绩单</h2><p>设$f_{i,j,l,r}$表示区间$[i,j]$已经删掉若干，剩下的那些元素中的最大值为$r$，最小值为$l$，删掉那若干个元素的最小代价；$g_{i,j}$表示将区间$[i,j]$全部删完的最小代价。</p>
<p>对于$f_{i,j,l,r}$，考虑$j$这个元素是否被删掉了：</p>
<ul>
<li>如果它已经被删掉，我们枚举它是和哪些元素一起删掉的，就有：<script type="math/tex; mode=display">
f_{i,k,l,r} + g_{k+1,j} \to f_{i,j,l,r}</script></li>
<li>否则，$j$没有被删掉，则得到<script type="math/tex; mode=display">
f_{i,j-1,l,r} \to f_{i,j,\min\{l,w_j\},\max\{r,w_j\}}</script></li>
</ul>
<p>对于$g$，考虑我们是否对$[i,j]$整体进行过操作：</p>
<ul>
<li>如果没有，则<script type="math/tex; mode=display">
g_{i,k} + g_{k+1,j}\to g_{i,j}</script></li>
<li>否则<script type="math/tex; mode=display">
f_{i,j,l,r} + a + b(r-l)^2 \to g_{i,j}</script></li>
</ul>
<p>复杂度$O(n^5)$。</p>
<p><a href="https://loj.ac/submission/726342" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>图论练习题</title>
    <url>/2020/01/19/%E5%9B%BE%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="LOJ2146-「SHOI2017」寿司餐厅"><a href="#LOJ2146-「SHOI2017」寿司餐厅" class="headerlink" title="LOJ2146 「SHOI2017」寿司餐厅"></a>LOJ2146 「SHOI2017」寿司餐厅</h2><p>把$mx^2 + cx$拆一下就是：只要吃的寿司里面有代号为$x$的就要付出$mx^2$的代价；每吃一种代号为$x$的寿司就要付出$x$的代价。直接令$d_{i,i}$减掉$a_i$，就可以不再考虑$cx$这部分。</p>
<p>对每个区间$[l,r]$建一个点，权值为$d_{l,r}$；对每个代号建一个点，权值为$-mx^2$。如果选了$d_{l,r}$就必须选$d_{l,r-1}$和$d_{l+1,r}$，如果选了$d_{i,i}$就必须选$ma_i^2$。求出这张图的最大权闭合子图即可。</p>
<p><a href="https://loj.ac/submission/723604" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2100-「TJOI2015」线性代数"><a href="#LOJ2100-「TJOI2015」线性代数" class="headerlink" title="LOJ2100 「TJOI2015」线性代数"></a>LOJ2100 「TJOI2015」线性代数</h2><p>把$A$想象成$\{1,2,\cdots n\}$的一个子集，$0$表示不选，$1$表示选。则：</p>
<script type="math/tex; mode=display">
val(A) = \sum_{i\in A\wedge j\in A} B_{i,j} - \sum_{i\in A} C_i</script><p>对每个$B_{i,j}$和$C_i$建一个点，权值分别为$B_{i,j},-C_i$，要求如果选了$B_{i,j}$则必须选$-C_i$和$-C_j$。求出这张图的最大权闭合子图即可。</p>
<p><a href="https://loj.ac/submission/723647" target="_blank" rel="noopener">Code</a></p>
<h2 id="UOJ41-【清华集训2014】矩阵变换"><a href="#UOJ41-【清华集训2014】矩阵变换" class="headerlink" title="UOJ41 【清华集训2014】矩阵变换"></a>UOJ41 【清华集训2014】矩阵变换</h2><p>考虑什么样的方案是不合法的：第$x$行选择了$y$，并且存在另一行$x’$，$y$在$x’$行的出现的列编号大于$y$在$x$行出现的列编号，且$x’$行选择的那个数字的列编号在$y$之后。</p>
<p>可以转化成稳定婚姻问题：由于要求每列中每个数至多出现一次，所以每一行选择的数显然是不同的，所以可以把问题看作求行和数字的匹配。对于每一行，在那一行出现的列编号越小的数字越好；对于每一个数字，它在其中出现的位置越靠后的行越好。这样求出的解显然能够规避上面说的不合法情况。</p>
<p><a href="http://uoj.ac/submission/380077" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2052-「HNOI2016」矿区"><a href="#LOJ2052-「HNOI2016」矿区" class="headerlink" title="LOJ2052 「HNOI2016」矿区"></a>LOJ2052 「HNOI2016」矿区</h2><p>分母很容易算，考虑怎么求分子。</p>
<p>将平面图转化成对偶图之后，以无穷域为根，求出一棵dfs树，并处理出子树内的块的矿量和。</p>
<p>考虑给出的开发区域的每一条边：如果它在对偶图中是非树边则不管它；如果它是树边，且它连接的两个点中，开发区域外的点是父亲，那么就让总和加上区域内的那个子树的权值；如果它是树边，且它连接的两个点中，区域里的点是父亲，那么就让总和减去区域外的那个子树的权值。</p>
<p>注意对偶图中可能是有重边的。</p>
<p><a href="https://loj.ac/submission/725254" target="_blank" rel="noopener">Code</a></p>
<h2 id="TopCoder14750-HeroicSchedule"><a href="#TopCoder14750-HeroicSchedule" class="headerlink" title="TopCoder14750 HeroicSchedule"></a>TopCoder14750 HeroicSchedule</h2><p><a href="https://vjudge.net/problem/TopCoder-14750" target="_blank" rel="noopener">可以在vjudge上提交</a> </p>
<p>下面用$n$表示点数，$m$表示边数。</p>
<p>由费用流的过程可以知道，将所有的任务按照收益从大到小排序之后，依次考虑每个任务，能够加入则加入，则一定能够得到最优的解。</p>
<p>尝试加入的过程就是求匹配的过程，考虑用匈牙利算法来实现这一部分。直接做的复杂度是$O(n^2m^2)$的。</p>
<p>发现尽管边数很大，但是遍历边集的时候我们实际上是在一个区间内的点中找到一个vis不为$0$的点，用set就可以在$O(\log m)$的时间内完成。复杂度优化到$O(n(\log m + m\log m))$。</p>
<p>更进一步观察发现，只要当前已经求出的匹配没有变化，就没有清空vis的必要。而匹配的大小只会从$1$变到至多$m$，也意味着匹配至多会改变$m$次。所以我们的等到匹配改变的时候才清空vis，就能把复杂度做到$O(n\log m + m^2 \log m)$。</p>
<p><a href="https://vjudge.net/solution/23740620" target="_blank" rel="noopener">Code</a></p>
<h2 id="HDU6431-NewNippori"><a href="#HDU6431-NewNippori" class="headerlink" title="HDU6431 NewNippori"></a>HDU6431 NewNippori</h2><p>分别求出$maxflow(x,y)$为1,2的点对的数量，就可以算出答案。</p>
<p>$maxflow(x,y)=1$的点对即不在同一个边双连通分量的点对。</p>
<p>$maxflow(x,y)=2$的点对一定在同一个边双连通分量且可以通过割掉两条边使它们不连通。</p>
<p>对每个边双连通分量分别考虑。首先求出一棵dfs树。考虑割掉哪些边能够把这个边双分成不连通的两个部分：</p>
<ul>
<li>割一条树边和一条非树边。我们称一条非树边覆盖了一条树边，当且仅当非树边的两个端点在树上的最短路包含了那条树边。由于这是一个边双，所以每条树边至少被一条非树边覆盖；又由于我们只能割一条非树边，而覆盖了我们割的那条树边的非树边必须全部被割掉，所以我们割的树边一定恰好只有一条非树边覆盖了它。把那条树边和覆盖它的非树边割掉，可以把dfs树上树边两侧的部分割开。</li>
<li><p>割两条树边。考虑这两条树边割开之后树边将dfs树分成了三部分：<br><img src="https://i.loli.net/2020/01/18/28qR5MKJlmvCa3w.png" alt="hdu6431.png"><br>其中黑色的圈表示树上的连通块，黑色的虚线表示割掉的树边，1，2，3分别表示在这三个连通块之间的非树边。</p>
<ul>
<li>如果1存在，由于每条树边都至少有一条非树边覆盖了它，所以2和3至少有一条边存在，所以这时三个块仍然连通。2存在同理。</li>
<li>如果这三种边中，只有3这种边存在，发现割了两条树边之后，A和B组成的连通块和C之间没有边。</li>
</ul>
<p>所以，割的两条树边一定满足：所有的非树边要么同时覆盖这两条边，要么同时不覆盖这两条边。</p>
</li>
</ul>
<p>如何判断覆盖了两条树边的非树边集合是否相同：可以用与<a href="http://uoj.ac/problem/207" target="_blank" rel="noopener">uoj207</a>那道题一样的方法，给每一条非树边随机一个$[0,2^{64})$的权值，设每个点的权值为所有以它作为一端的非树边的权值的异或和。则当两个点的子树内所有点的权值的异或和相同的时候，我们认为这两个点到它们的父亲的那两条边被非树边覆盖的情况相同；当某个点子树内点的权值异或和为某条非树边的权值，我们就认为这个点到父亲的那条边只被那条非树边覆盖。</p>
<p>首先统计跨越了只被一条非树边覆盖了的树边的点对的贡献，然后把这些树边都断开。下面考虑的是断开了这些边之后的每个连通块。</p>
<p>对每个点$x$，统计出满足下面条件的点的数量：存在一对树边，割开之后能够把$x$和这个点隔开，且$x$位于与两条树边都相邻的那个连通块里面（上图中的连通块C）。</p>
<p>由于我们求的是dfs树，所有的非树边都是返祖边，不存在横叉边。所以，被覆盖情况相同的两条树边也一定是祖孙关系。</p>
<p>考虑把$x$夹在了中间的那些可以割掉的树边对：</p>
<p><img src="https://i.loli.net/2020/01/18/8cZQa4xRTtLAPCl.jpg" width="40%" height="100%" ></p>
<p>观察到：</p>
<ul>
<li>对于某条树边，能够和它配对的边显然都在一条祖孙链上。</li>
<li>不可能存在两对树边$(u,v),(x,y)$，满足$dep_u &lt; dep_x &lt; dep_v &lt; dep_y$。</li>
</ul>
<p>所以，对于某个$x$，把它夹在了中间的树边对一定满足：假设这些树边对按照在$x$的上面的那条边的深度升序排序得到的序列是$w_1,w_2,\cdots w_k$，那么按照在$x$的下面的那条边的深度升序排序得到的序列就是$w_k,w_{k-1},\cdots w_1$。我们只需要找出$w_k$：$w_k$把整棵树分成三部分中不包含$x$的那两部分的大小，就是能够通过割两条树边与$x$隔开的点数。</p>
<p>对连通块进行dfs，到达某个点$u$的时候，先递归处理$u$的子树内的点，然后再处理$u$到它的父亲之间的这条边与$u$的子树内的边配对所能够产生的贡献。</p>
<p>找出最后一次访问到的与$e(u,fa_u)$的覆盖情况相同的边$e’$，如果这条边不在$u$的子树内说明$e(u,fa_u)$无法与子树内的边配对；否则，我们只需要考虑$e(u,fa_u)$与$e’$配对就可以了（因为对每个$x$我们只关心包含了它且离它最近的边对，$e(u,fa_u)$和其它的边配对显然不满足这个条件）。我们找出$e’,e(u,fa_u)$之间还没有找到最近的树边对的点，统计它们的贡献，并把它们标记为已经找到了最近的树边对的点。实现上可以用一个数组$ex[u]$来记录每个点的子树内还没有找到最近树边对的点数；由于$e(u,fa_u)$已经和$e’$配对了，所以$e(u,fa_u)$上方的边不可能与$e(u,fa_u)$和$e’$之间的边配对，因此我们不需要维护$e(u,fa_u),e’$之间的点的$ex$，只对$ex[u]$做出相应的更新就可以了。</p>
<p>总复杂度$O(n+m)$或者$O(n\log n + m)$（取决于使用map还是hash_table）</p>
<p>下面是我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> RNG &#123;</span><br><span class="line">    ull seed=<span class="number">13244074693642402u</span>ll;</span><br><span class="line">    <span class="function">ull <span class="title">rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seed^=seed&lt;&lt;<span class="number">13</span>,seed^=seed&gt;&gt;<span class="number">7</span>,seed^=seed&lt;&lt;<span class="number">17</span>;</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> RNG::rnd;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span> &#123;</span> <span class="keyword">int</span> to,id; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;ed&gt; G[N];</span><br><span class="line">ll ans0,ans1;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">namespace</span> tree &#123;</span><br><span class="line">    <span class="keyword">int</span> In[N],vis[N];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line">    <span class="built_in">set</span>&lt;ull&gt; val;</span><br><span class="line">    ull xi[N];</span><br><span class="line">    <span class="keyword">int</span> vise[M];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) <span class="keyword">if</span>(!vise[G[u][i].id]&amp;&amp;In[G[u][i].to]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[u][i].to; vise[G[u][i].id]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]) &#123;</span><br><span class="line">                ull tmp=rnd();</span><br><span class="line">                val.insert(tmp),xi[u]^=tmp,xi[v]^=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> son[u].PB(v),dfs1(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;ull,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> _size,__size;</span><br><span class="line">    <span class="keyword">int</span> ex[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        ex[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre_c=mp.count(xi[u])?mp[xi[u]]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[u].size();++i)</span><br><span class="line">            <span class="keyword">if</span>(vis[son[u][i]]!=<span class="number">2</span>) dfs3(son[u][i]),ex[u]+=ex[son[u][i]];</span><br><span class="line">        <span class="keyword">int</span> c=mp.count(xi[u])?mp[xi[u]]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c&amp;&amp;c!=pre_c) &#123;</span><br><span class="line">            ans1+=<span class="number">2l</span>l*(ex[u]-ex[c])*(ll)(_size-(ex[u]-ex[c]));</span><br><span class="line">            _size-=ex[u]-ex[c];</span><br><span class="line">            ex[u]=ex[c];</span><br><span class="line">        &#125;</span><br><span class="line">        mp[xi[u]]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[u].size();++i)</span><br><span class="line">            tot+=dfs2(son[u][i]),xi[u]^=xi[son[u][i]];</span><br><span class="line">        <span class="keyword">if</span>(val.count(xi[u])) &#123;</span><br><span class="line">            ans1+=tot*(ll)(__size-tot);</span><br><span class="line">            mp.clear(),_size=tot,dfs3(u);</span><br><span class="line">            vis[u]=<span class="number">2</span>,tot=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        __size=a.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();++i) In[a[i]]=<span class="number">1</span>;</span><br><span class="line">        dfs1(a[<span class="number">0</span>]); val.insert(<span class="number">0</span>);</span><br><span class="line">        dfs2(a[<span class="number">0</span>]);</span><br><span class="line">        val.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();++i) In[a[i]]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) xi[i]=vis[i]=<span class="number">0</span>,son[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) vise[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N],top;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],id;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> lasteid)</span> </span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++id,st[++top]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i) <span class="keyword">if</span>(G[u][i].id!=lasteid) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[u][i].to;</span><br><span class="line">        <span class="keyword">if</span>(dfn[v]) low[u]=min(low[u],dfn[v]);</span><br><span class="line">        <span class="keyword">else</span> tarjan(v,G[u][i].id),low[u]=min(low[u],low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u]) &#123;</span><br><span class="line">        <span class="keyword">do</span> a.PB(st[top]); <span class="keyword">while</span>(st[top--]!=u);</span><br><span class="line">        tree::sol(a),ans0+=a.size()*(n-a.size());</span><br><span class="line">        a.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; rd(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        rd(n),rd(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i) &#123;</span><br><span class="line">            rd(x),rd(y);</span><br><span class="line">            G[x].PB((ed)&#123;y,i&#125;),G[y].PB((ed)&#123;x,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        ans0/=<span class="number">2</span>,ans1/=<span class="number">2</span>;</span><br><span class="line">        ll ans2=n*(ll)(n<span class="number">-1</span>)/<span class="number">2</span>-ans0-ans1;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans0+ans1*<span class="number">2</span>+ans2*<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) G[i].clear(),dfn[i]=<span class="number">0</span>; id=top=<span class="number">0</span>;</span><br><span class="line">        ans0=ans1=<span class="number">0</span>;</span><br><span class="line">        tree::init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>组合计数练习题</title>
    <url>/2020/01/15/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="UOJ422-小z的礼物"><a href="#UOJ422-小z的礼物" class="headerlink" title="UOJ422 小z的礼物"></a>UOJ422 小z的礼物</h2><p>考虑min-max容斥：</p>
<script type="math/tex; mode=display">
\max (S) = \sum_{T\subseteq S} (-1)^{|T|+1} \min (T)</script><p>对希望得到的物品的每一个子集，求出期望最早什么时候子集里至少有一个物品被拿到了，就能算出答案。</p>
<p>设包含了至少一个这个子集内的物品的相邻的格子对的数量是$a$，所有的相邻的格子对的数量是$b$，那么这个期望值就是$b\over a$。$a$是一个定值；$b$则可以看做（子集内每一个物品包含它的相邻格子对数量的和）-（同时包含了子集内的两个物品的相邻格子对的数量）。</p>
<p>设$f_{S,t}$表示上一列选了的格子的集合是$S$，之前选过的格子的（子集内每一个物品包含它的相邻格子对数量的和）-（同时包含了子集内的两个物品的相邻格子对的数量）为$t$，所有方案的容斥系数的和。用类似轮廓线dp的方法转移，就可以做到$O(2^n n^2m^2)$的复杂度。</p>
<p><a href="http://uoj.ac/submission/379524" target="_blank" rel="noopener">Code</a></p>
<h2 id="LOJ2320「清华集训-2017」生成树计数"><a href="#LOJ2320「清华集训-2017」生成树计数" class="headerlink" title="LOJ2320「清华集训 2017」生成树计数"></a>LOJ2320「清华集训 2017」生成树计数</h2><p>把原题的式子换一个表达的方式：把每个连通块看做一个点，设$d_i$为每个点的度数，则</p>
<script type="math/tex; mode=display">
val (T) = (\sum_{i=1}^n d_i^m) (\prod_{i=1}^n d_i^m )(\prod_{i=1}^n a_i^{d_i})</script><p>因为式子里面有度数，所以考虑用prufer序列来计数。枚举每一个点在prufer序列中出现的次数$k_i$，得到</p>
<script type="math/tex; mode=display">
Ans = \sum_{k_1+k_2+\cdots +k_n=n-2} {(n-2)!\over k_1!k_2!\cdots k_n!} \cdot \sum_{i=1}^n (k_i+1)^{2m}a_i^{k_i+1} \prod_{j\neq i} (k_j+1)^ma_j^{k_j+1}</script><p>设</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_i(x) = \sum_{k=0}^\infty {a_i^{k+1}(k+1)^m\over k!} x^k\\
B_i(x) = \sum_{k=0}^\infty {a_i^{k+1}(k+1)^{2m} \over k!}x^k
\end{aligned}</script><p>则</p>
<script type="math/tex; mode=display">
Ans= (n-2)!\sum_{i=1}^n (B_i(x)\prod_{j\neq i} A_j(x) )[x^{n-2}]</script><p>因为$A_i(x)$里面有指数为$k+1$，还有$x^k \over k!$，所以尝试对$A_i(x)$积分得到$T(x)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(x) = \sum_{k=0}^\infty {a_i^{k+1}(k+1)^m \over (k+1)!} x^{k+1}\\
=\sum_{k=1}^\infty {a_i^kk^m\over k!}x^k
\end{aligned}</script><p>将$k^m$展开：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(x) = \sum_{k=1}^\infty {a_i^k \over k!} x^k \sum_{j=0}^{\min\{m,k\}} \begin{Bmatrix}m\\ j\end{Bmatrix} {k\choose j} j!
\end{aligned}</script><p>把${k\choose j}j!$与前面的$k!$抵消，得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(x) = \sum_{k=1}^\infty a_i^k x^k \sum_{j=0}^{\min\{m,k\}} {1\over (k-j)!}\begin{Bmatrix}m\\ j\end{Bmatrix}
\end{aligned}</script><p>把$j$提前</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(x) = \sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} \sum_{k=j}^\infty {a_ix^k\over (k-j)!}\\
=\sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} a_i^jx^j \sum_{k=0}^\infty {a_i^kx^k\over k!}\\
=\sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} a_i^jx^j e^{a_ix}
\end{aligned}</script><p>然后对$T(x)$求导得到$A_i(x)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_i(x) = T'(x)\\
=\sum_{j=0}^m \begin{Bmatrix}m\\ j\end{Bmatrix} (j \cdot a_i^jx^{j-1} e^{a_ix} + a_i \cdot a_i^jx^j e^{a_ix}) \\
=\sum_{j=0}^{m} \begin{Bmatrix}m\\ j+1\end{Bmatrix} (j+1)( a_i^{j+1}x^je^{a_ix}) + \sum_{j=0}^{m} \begin{Bmatrix}m\\ j\end{Bmatrix} (a_i^{j+1} x^j e^{a_ix}) \\
= \sum_{j=0}^{m}(\begin{Bmatrix}m\\ j+1\end{Bmatrix} (j+1)+\begin{Bmatrix}m\\ j\end{Bmatrix} ) a_i^{j+1}x^je^{a_ix}\\
= e^{a_ix}\sum_{j=0}^{m}\begin{Bmatrix}m+1\\ j+1\end{Bmatrix} a_i^{j+1}x^j\\
\end{aligned}</script><p>对$B_i(x)$同理，得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
B_i(x) = e^{a_ix}\sum_{j=0}^{2m}\begin{Bmatrix}2m+1\\ j+1\end{Bmatrix} a_i^{j+1}x^j\\
\end{aligned}</script><p>所以</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n B_i(x)\prod_{j\neq i} A_i(x)\\
= e^s \sum_{i=1}^n (\sum_{j=0}^{2m}\begin{Bmatrix}2m+1\\ j+1\end{Bmatrix} a_i^{j+1}x^j) \prod_{k\neq i}(\sum_{j=0}^{m}\begin{Bmatrix}m+1\\ j+1\end{Bmatrix} a_k^{j+1}x^j)\\
\end{aligned}</script><p>上式可以分治NTT求出。</p>
<p><a href="https://loj.ac/submission/719326" target="_blank" rel="noopener">Code</a></p>
<h2 id="ARC062D-Painting-Graphs-with-AtCoDeer"><a href="#ARC062D-Painting-Graphs-with-AtCoDeer" class="headerlink" title="ARC062D Painting Graphs with AtCoDeer"></a>ARC062D Painting Graphs with AtCoDeer</h2><p>每一个边双连通分量显然是独立的。所有边双的本质不同的染色方案数的乘积即是答案。</p>
<p>如果一个边双只包含一条边，那么答案显然是$K$。</p>
<p>如果一个边双恰好只有一个简单环，则是一个经典的Polya（有$K$种颜色的珠子，问有多少种旋转置换下本质不同的项链）。</p>
<p>而如果一个边双包含多于一个环，则从下面的图（来自<a href="http://arc062.contest.atcoder.jp/data/arc/062/editorial.pdf" target="_blank" rel="noopener">官方题解</a>）可以看出，通过若干次操作我们可以交换一对相邻的边（下图中交换了绿色和蓝色的边）。故而两个给这个边双染色的方案是本质不同的，当且仅当它们染成某种颜色的边的数量不同。所以方案数为${K+C-1\choose K-1}$，其中$C$为这个边双内的边数。</p>
<p><img src="https://i.loli.net/2020/01/15/gPTJSesGaVAMH6E.png" alt="image.png"></p>
<p><a href="https://atcoder.jp/contests/arc062/submissions/9511619" target="_blank" rel="noopener">Code</a></p>
<h2 id="HDU6402-Boolean-3-Array"><a href="#HDU6402-Boolean-3-Array" class="headerlink" title="HDU6402 Boolean 3-Array"></a>HDU6402 Boolean 3-Array</h2><p>可以参考<a href="https://projecteuler.net/problem=626" target="_blank" rel="noopener">PE626</a>，它是这道题的低维情形。</p>
<p>下文中的$A,B,C$表示原题中每一维的大小。</p>
<p>考虑简化题目中的置换：令$p_a,p_b,p_c$为三个长度分别为$A,B,C$的排列，每个排列的第$i$个元素表示这个维度上的swap操作使得最初的第$i$层到了哪个位置，令$a_i,b_i,c_i$分别表示每一维的第$i$层进行的翻转操作次数的奇偶性。我们规定先进行$p_a,p_b,p_c$的操作，再进行$a,b,c$的操作。那么原题中的一系列操作的结果将唯一对应到一组$(p_a,p_b,p_c,a,b,c)$。</p>
<p>利用Burnside lemma，数每一个置换的不动点数目。</p>
<p>先只考虑swap操作。枚举$p_a,p_b,p_c$的循环节，假设当前枚举到的循环节长度分别为$la,lb,lc$，考虑循环节中的方块对应的那个$la\times lb\times lc$的正方体。将每个点$(x,y,z)$与$({p_a}_x,{p_b}_y,{p_c}_z)$连边，则这些方块恰好会分裂成$la\cdot lb\cdot lc\over \operatorname{lcm}\{la,lb,lc\}$个连通块（并且每个连通块都是一个环）。显然每个连通块内的格子必须填同一个数，不同连通块的格子没有影响。</p>
<p>考虑flip操作对每一个连通块的影响：记$d_{x,y,z} = (a_x+b_y+c_z) \bmod 2$，则如果连通块内所有点的$\sum d_{x,y,z}$为奇数，则不存在不动点；否则，如下图，环上打了叉的点表示$d_{x,y,z}=1$的点，箭头表示置换的方向：</p>
<p><img src="https://i.loli.net/2020/01/15/iVUJvFXzDeO653Y.jpg" alt="1.jpg"></p>
<p>那么显然只有两种填数方案是不动点：</p>
<p><img src="https://i.loli.net/2020/01/15/hxeA8qLUlyd9QFX.jpg" alt="2.jpg"><br><img src="https://i.loli.net/2020/01/15/dRp3DWlBGZsJjEV.jpg" alt="3.jpg"></p>
<p>首先枚举$p_a,p_b,p_c$的每种长度的循环节的出现次数（设$k_i,l_i$表示长度为$l_i$的循环节出现了$k_i$次，那么对应的排列数是$n!\over \prod l_i^{k_i} k_i!$），然后求出对于每一组循环节的每一个连通块都满足$\sum d_{x,y,z} \equiv 0 \pmod 2$的$a,b,c$的数量，就能够快速统计贡献。</p>
<p>我们考虑某一组循环节（那个$la\times lb\times lc$的正方体）的某一个连通块对$a,b,c$的限制，设循环节包含的每个维度的下标集合为$a’,b’,c’$，则限制为</p>
<script type="math/tex; mode=display">
\sum_{x\in a'} a_x \operatorname{lcm}{\{la,lb,lc\}\over la} +\sum_{x\in b'} b_x \operatorname{lcm}{\{la,lb,lc\}\over lb} + \sum_{x\in c'} c_x {\operatorname{lcm}\{la,lb,lc\}\over lc} \equiv 0 \pmod 2</script><p>现在将每一个$a_x,b_x,c_x$看做未知数，则问题转化成求方程的解数，是一个经典的线性基问题。</p>
<p>由于数据范围很小，可以直接打表。</p>
<p>下面是我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIR first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x=<span class="number">0</span>; <span class="keyword">char</span> c=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=getchar(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;x=x*(ll)x%mod,y&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*(ll)x%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lcm[<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">20</span>],inv[<span class="number">20</span>],ipw[<span class="number">8000</span>],pw[<span class="number">8000</span>];</span><br><span class="line"><span class="keyword">int</span> Inv[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;PII&gt; &gt; g[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">namespace</span> Mat &#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;39&gt; f[<span class="number">39</span>],b;</span><br><span class="line">    <span class="keyword">int</span> m,cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) f[i].reset(); m=len,cnt=<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;r;++i) b[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"INS:"; for(int i=0;i&lt;m;++i) cout&lt;&lt;(b[i]==1); cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="keyword">if</span>(b[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][i]) b^=f[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i]=b,cnt++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cnt; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i,<span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) <span class="built_in">cout</span>&lt;&lt;(f[i][j]==<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> predo_calc &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b?gcd(b,a%b):a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCM</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a/gcd(a,b)*b; &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; s;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tot==cur) &#123; g[cur].PB(s); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot+u&gt;cur) <span class="keyword">return</span>;</span><br><span class="line">        dfs(u+<span class="number">1</span>,tot);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;tot+j*u&lt;=cur;++j) &#123;</span><br><span class="line">            s.PB(MP(u,j));</span><br><span class="line">            dfs(u+<span class="number">1</span>,tot+j*u);</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getpw</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        pw[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">2l</span>l%mod;</span><br><span class="line">        ipw[n]=Pow(pw[n],mod<span class="number">-2</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) ipw[i<span class="number">-1</span>]=ipw[i]*<span class="number">2l</span>l%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">predo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) Inv[i]=Pow(i,mod<span class="number">-2</span>);</span><br><span class="line">        fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=fac[i<span class="number">-1</span>]*(ll)i%mod;</span><br><span class="line">        inv[n]=Pow(fac[n],mod<span class="number">-2</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) inv[i<span class="number">-1</span>]=inv[i]*(ll)i%mod;</span><br><span class="line">        getpw(n*n*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">                    lcm[i][j][k]=LCM(LCM(i,j),k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cur=i,dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> A,<span class="keyword">int</span> B,<span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa=<span class="number">0</span>;pa&lt;g[A].size();++pa)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pb=<span class="number">0</span>;pb&lt;g[B].size();++pb)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pc=<span class="number">0</span>;pc&lt;g[C].size();++pc) &#123;</span><br><span class="line">        <span class="keyword">int</span> tans=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;PII&gt; &amp;pA=g[A][pa],&amp;pB=g[B][pb],&amp;pC=g[C][pc];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pA.size();++j) tans=tans*(ll)inv[pA[j].SEC]%mod*Pow(Inv[pA[j].FIR],pA[j].SEC)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pB.size();++j) tans=tans*(ll)inv[pB[j].SEC]%mod*Pow(Inv[pB[j].FIR],pB[j].SEC)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pC.size();++j) tans=tans*(ll)inv[pC[j].SEC]%mod*Pow(Inv[pC[j].FIR],pC[j].SEC)%mod;</span><br><span class="line">        Mat::init(A+B+C);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> iA=<span class="number">0</span>,tA=<span class="number">0</span>;iA&lt;pA.size();++iA)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> jA=<span class="number">0</span>;jA&lt;pA[iA].SEC;++jA,tA+=pA[iA].FIR)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> iB=<span class="number">0</span>,tB=A;iB&lt;pB.size();++iB)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> jB=<span class="number">0</span>;jB&lt;pB[iB].SEC;++jB,tB+=pB[iB].FIR)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> iC=<span class="number">0</span>,tC=A+B;iC&lt;pC.size();++iC)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> jC=<span class="number">0</span>;jC&lt;pC[iC].SEC;++jC,tC+=pC[iC].FIR) &#123;</span><br><span class="line">                    <span class="keyword">int</span> a=pA[iA].FIR,b=pB[iB].FIR,c=pC[iC].FIR;</span><br><span class="line">                    tans=tans*(ll)pw[a*b*c/lcm[a][b][c]]%mod;</span><br><span class="line">                    Mat::ins(tA,tA+pA[iA].FIR,lcm[a][b][c]/a);</span><br><span class="line">                    Mat::ins(tB,tB+pB[iB].FIR,lcm[a][b][c]/b);</span><br><span class="line">                    Mat::ins(tC,tC+pC[iC].FIR,lcm[a][b][c]/c);</span><br><span class="line">                    Mat::Ins();</span><br><span class="line">                &#125;</span><br><span class="line">        tans=tans*(ll)pw[A+B+C-Mat::sol()]%mod;</span><br><span class="line">        <span class="comment">// Mat::Debug();</span></span><br><span class="line">        ans=(ans+tans)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans*(ll)ipw[A+B+C]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    predo_calc::predo(<span class="number">13</span>);</span><br><span class="line">    <span class="keyword">int</span> T; rd(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> A,B,C; rd(A),rd(B),rd(C);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sol(A,B,C)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>单位根反演练习题</title>
    <url>/2020/01/14/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="loj6485-LJJ学二项式定理"><a href="#loj6485-LJJ学二项式定理" class="headerlink" title="loj6485 LJJ学二项式定理"></a>loj6485 LJJ学二项式定理</h2><p>首先枚举$i\pmod 4$的余数$t$，然后转化成对于每一个$t$，求</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^n {n\choose i}s^i [ 4\mid (i-t) ]
\end{aligned}</script><p>单位根反演：</p>
<script type="math/tex; mode=display">
\begin{aligned}
= \sum_{i=0}^n {n\choose i}s^i {1\over 4}\sum_{j=0}^3 \omega_{4}^{j(i-t)}\\
= {1\over 4} \sum_{j=0}^3 \omega_{4}^{-jt} \sum_{i=0}^n {n\choose i}s^i w_4^{ij}
\end{aligned}</script><p>最后面的那一坨东西，由二项式定理知$(1+x)^n = \sum_{i=0}^n {n\choose i}x^i$，所以：</p>
<script type="math/tex; mode=display">
= {1\over 4} \sum_{j=0}^3 \omega_{4}^{-jt} (s\omega_4^j + 1)^n</script><p>直接算就可以了。</p>
<p><a href="https://loj.ac/submission/715070" target="_blank" rel="noopener">Code</a></p>
<h2 id="uoj450【集训队作业2018】复读机"><a href="#uoj450【集训队作业2018】复读机" class="headerlink" title="uoj450【集训队作业2018】复读机"></a>uoj450【集训队作业2018】复读机</h2><p>考虑一个复读机复读次数的生成函数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(x) = \sum_{i=0}^{\infty} {x^i\over i!} [d\mid i]
\end{aligned}</script><p>而我们要算的实际上是$n! \cdot F^k(x) [x^n]$。</p>
<p>对$F(x)$进行单位根反演：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(x) = {1\over d}\sum_{i=0}^{\infty} {x^i\over i!} \sum_{j=0}^{d-1} \omega^{ij}\\
= {1\over d}\sum_{j=0}^{d-1} \sum_{i=0}^{\infty} {x^iw^{ij}\over i!}\\
= {1\over d} \sum_{j=0}^{d-1} e^{\omega^j x}
\end{aligned}</script><p>$1\over d$是常数，我们先把它忽视掉，最后再在答案里乘上一个$1\over d^k$。</p>
<p>考虑$F^k(x)$的组合意义，相当于对于这$k$个多项式，从每一个里面选一项相乘，所有的方案得到的乘积的和。枚举$e^{\omega^jx}$被选的次数$p_j$，得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
F^k (x) = \sum_{p_0+p_1\cdots p_{d-1}=k}k!\prod_{j=0}^{d-1} {1\over p_j!}e^{p_j \omega_jx}\\
= \sum_{p_0+p_1\cdots p_{d-1}=k} e^{(\sum_{j=0}^{d-1}p_jw_j)x} \cdot k!\prod_{j=0}^{d-1} {1\over p_j!}
\end{aligned}</script><p>而</p>
<script type="math/tex; mode=display">
F^k (x) [ x^n ] = \sum_{p_0+p_1\cdots p_{d-1}=k} {(\sum_{j=0}^{d-1}p_jw_j)^n \over n!} \cdot k!\prod_{j=0}^{d-1} {1\over p_j!}</script><p>直接计算，复杂度$O(k^d \log n)$。</p>
<p><a href="http://uoj.ac/submission/376702" target="_blank" rel="noopener">Code</a></p>
<h2 id="bzoj3328-PYXFIB"><a href="#bzoj3328-PYXFIB" class="headerlink" title="bzoj3328 PYXFIB"></a>bzoj3328 PYXFIB</h2><p>设</p>
<script type="math/tex; mode=display">
\begin{aligned}
A = \begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}\\
B = \begin{bmatrix} 1\\1 \end{bmatrix}
\end{aligned}</script><p>则我们相当于要求出</p>
<script type="math/tex; mode=display">
(\sum_{i=0}^n {n\choose i} A^i [k\mid i] )B</script><p>对前面的那个括号里面的东西单位根反演，得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
{1\over k} \sum_{j=0}^{k-1} \sum_{i=0}^n {n\choose i}A^i\omega^{ij}\\
= {1\over k} \sum_{j=0}^{k-1} (\omega^j\cdot A + E)^n 
\end{aligned}</script><p>其中$E$表示单位矩阵。</p>
<p>直接矩阵快速幂计算，时间复杂度为$O(2^3 \cdot \log n \cdot k)$。</p>
<h2 id="loj3058-「HNOI2019」白兔之舞"><a href="#loj3058-「HNOI2019」白兔之舞" class="headerlink" title="loj3058 「HNOI2019」白兔之舞"></a>loj3058 「HNOI2019」白兔之舞</h2><p>设矩阵$A$是满足$A_{i,j} = w(i,j)$的$n\times n$的矩阵。</p>
<p>走$m$步的方案数为${L\choose m}T_{x,y}$，其中$T=A^m$。</p>
<p>则对于每一个$t$，我们需要求出</p>
<script type="math/tex; mode=display">
\sum_{m=0}^L {L\choose m}A^m [k\mid (t-m)]</script><p>单位根反演之后得到</p>
<script type="math/tex; mode=display">
{1\over k}\sum_{j=0}^{k-1} \omega_k^{-tj}(\omega_k^jA + E)^L</script><p>对于每一个$j$，分别算出$F_j = (\omega_k^j A+ E)^L$，设$f_j$为$F_j$的$x$行$y$列的元素，则$t$的答案就是</p>
<script type="math/tex; mode=display">
Ans_t = {1\over k}\sum_{j=0}^{k-1} f_j \omega_k^{-tj}</script><p>由于$-tj={t\choose 2}+{j\choose 2}-{t+j\choose 2}$，所以</p>
<script type="math/tex; mode=display">
Ans_t = {1\over k}\cdot \omega_k^{t\choose 2} \sum_{j=0}^{k-1} (f_j\cdot \omega_k^{j\choose 2} ) \omega_k^{-{i+j\choose 2}}</script><p>这是一个卷积的形式，用MTT优化一下就可以了。</p>
<p>总时间复杂度$O(kn^3\log L + k\log k)$。</p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望练习题</title>
    <url>/2020/01/14/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="CF963E-Circles-of-Waiting"><a href="#CF963E-Circles-of-Waiting" class="headerlink" title="CF963E Circles of Waiting"></a>CF963E Circles of Waiting</h2><p>圆内的整点形成了一个类似方阵的结构。设$f_{x,y}$为$(x,y)$期望被经过的次数。我们可以对每一个点列出一个方程：</p>
<script type="math/tex; mode=display">
f_{x,y} = {p_0} f_{x+1,y} + p_1 f_{x,y+1} +p_2 f_{x-1,y} + p_3f_{x,y-1} + [(x,y)=(0,0)]</script><p>将每一行最左侧的点设为主元，其它的点都用主元表示。从左往右考虑每一列的点：$f_{x,y}$可以用$f_{x-1,y}$的方程表示出来（因为方程中涉及到的$f_{x-1,y},f_{x-1,y-1},f_{x-1,y+1},f_{x-2,y}$在之前都已经考虑过了，只有$f_{x,y}$是未知的）。</p>
<p>这样过后，每一行最右侧的点对应的方程我们还没有用过，用这些方程一定可以解出主元的值，然后再带回去就可以得到每个点的期望被经过次数。</p>
<p>时间复杂度$O(R^3)$。</p>
<p><a href="https://codeforces.com/contest/963/submission/68692851" target="_blank" rel="noopener">Code</a></p>
<h2 id="CTSC2006-歌唱王国"><a href="#CTSC2006-歌唱王国" class="headerlink" title="CTSC2006 歌唱王国"></a>CTSC2006 歌唱王国</h2><p>题号：luogu4548, bzoj1152</p>
<p>设$f_i$为加入第$i$个字符的时候恰好结束的概率，$g_i$为加入$i$个字符之后还没有结束的概率。设$F(x) = \sum_{i=0}^\infty f_i x^i, G(x) = \sum_{i=0}^\infty g_ix^i$。</p>
<p>则有$G(x)x - F(x) = G(x) - 1$，即：$g_{i-1}-f_i = g_i$。</p>
<p>由$F(x)$的定义我们知道$F(1)=1$，即在每一轮结束的概率的和是$1$。</p>
<p>而我们要求的答案是$F’(1)$。</p>
<p>再设$H(x) = \sum_{i=j}^{m}x^{m-j} ({1\over n})^{m-j} [s_1s_2\cdots s_j\text{is a border of s}]$。</p>
<p>则</p>
<script type="math/tex; mode=display">
G(x) ({1\over n})^mx^m = F(x) H(x)</script><p>这里$F(x)$的意义相当于是枚举了，$G(x)$在末尾加上一个$s$之后，最早在什么位置出现了完整的$s$。</p>
<p>带入$x=1$得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
G(1) ({1\over n})^m = F(1) H(1)\\
G(1) = n^m H(1)
\end{aligned}</script><p>此外</p>
<script type="math/tex; mode=display">
G(x)x-F(x) = G(x)-1</script><p>两边同时求导得到</p>
<script type="math/tex; mode=display">
G(x) + G'(x)x - F'(x) = G'(x)</script><p>带入$x=1$</p>
<script type="math/tex; mode=display">
\begin{aligned}
G(1) + G'(1) - F'(1) = G'(1)\\
G(1) = F'(1)
\end{aligned}</script><p>所以答案就是$n^m H(1)$。</p>
<h2 id="PE522"><a href="#PE522" class="headerlink" title="PE522"></a><a href="https://projecteuler.net/problem=522" target="_blank" rel="noopener">PE522</a></h2><p>如果所有的连通块都是孤立的环（没有叶子），那么答案是环数。</p>
<p>否则敲定一个不为孤立的环的连通块，对于这个连通块每一个入度为$0$的点，把某个入度大于$1$的点的某一个儿子拿过来接在它的下面（接过来的部分如果还有入度为$0$的点，就重复前面的操作）。</p>
<p>如果图内存在孤立的环，就还必须在上述过程的最后一次操作之前（此时我们敲定的那个连通块内恰好只有一个叶子）对每一个孤立的环进行额外的操作：把环断成链接在叶子的下面。</p>
<p>综上所述，一张图的答案为叶子数+孤立的环数。</p>
<p>叶子数总和为：</p>
<script type="math/tex; mode=display">
n ((n-2)^{n-1} \cdot (n-1))</script><p>也就是每个点成为叶子的方案数。</p>
<p>孤立的环的数量总和为</p>
<script type="math/tex; mode=display">
\sum_{i=2}^n {n\choose i} (i-1)!(n-i-1)^{n-i}</script><p>每一个长度为$i$的环出现的方案数是$(n-i-1)^{n-i}$，而这样的环有${n\choose i} \cdot (i-1)!$个。</p>
<h2 id="CF457D-Bingo"><a href="#CF457D-Bingo" class="headerlink" title="CF457D Bingo!"></a>CF457D Bingo!</h2><p>考虑$2^s$的组合意义，也就是一个大小为$s$的集合的子集数量。所以权值的期望也就是：每一个行、列的子集在最后的矩阵中只包含了那$k$个数的概率的和。</p>
<p>假设某一个子集包含了$t$个格子，那么它只包含了那$k$个数的概率是$f_t = {P_k^t \over P_m^t}$。直接预处理阶乘来计算$f_t$无法用long double存下；推导可得$f_t = f_{t-1} \cdot {k-t+1\over m-t+1}$，由这个递推计算就可以避免上面的问题。</p>
<p>最后的答案就是</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n \sum_{j=0}^n {n\choose i}{n\choose j} f_{(i+j)n-ij}</script><p><a href="https://codeforces.com/contest/457/submission/68708656" target="_blank" rel="noopener">Code</a></p>
<h2 id="UOJ352-新年的五维几何"><a href="#UOJ352-新年的五维几何" class="headerlink" title="UOJ352 新年的五维几何"></a>UOJ352 新年的五维几何</h2><p>对于所有$l_i=r_i$的变量，考虑它们对其它变量的取值范围的影响，然后把这些变量删掉。</p>
<p>不妨将$l_i \le x_i \le r_i$看做$l_i \le x_i &lt; r_i$，两者算出来的答案是一样的。所以$x_i$的整数部分的取值范围是$[l_i,r_i)$。</p>
<p>我们首先枚举$x_i$的小数部分的大小关系，然后暴搜整数部分的合法的取值方案。由于$a_{i,j}$都是整数，所以$x_i - x_j \ge a_{i,j}$是否被满足只取决于$x_i$和$x_j$的整数部分和它们小数部分的大小关系。</p>
<p>时间复杂度$O(n!\prod_i(r_i-l_i))$。</p>
<p><a href="http://uoj.ac/submission/379410" target="_blank" rel="noopener">Code</a></p>
]]></content>
      <tags>
        <tag>专题练习</tag>
      </tags>
  </entry>
</search>
